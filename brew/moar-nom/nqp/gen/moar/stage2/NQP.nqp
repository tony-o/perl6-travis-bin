# This file automatically generated by tools/build/gen-cat.pl

# From src/vm/moar/NQP/Ops.nqp

my $ops := QAST::MASTCompiler.operations();
my $MVM_reg_int64           := 4;
my $MVM_reg_num64           := 6;
my $MVM_reg_str             := 7;
my $MVM_reg_obj             := 8;

$ops.add_hll_op('nqp', 'preinc', -> $qastcomp, $op {
    my $var := $op[0];
    unless nqp::istype($var, QAST::Var) {
        nqp::die("Pre-increment can only work on a variable");
    }
    $qastcomp.as_mast(QAST::Op.new(
        :op('bind'),
        $var,
        QAST::Op.new(
            :op('add_i'),
            $var,
            QAST::IVal.new( :value(1) )
        )));
});

$ops.add_hll_op('nqp', 'predec', -> $qastcomp, $op {
    my $var := $op[0];
    unless nqp::istype($var, QAST::Var) {
        nqp::die("Pre-decrement can only work on a variable");
    }
    $qastcomp.as_mast(QAST::Op.new(
        :op('bind'),
        $var,
        QAST::Op.new(
            :op('sub_i'),
            $var,
            QAST::IVal.new( :value(1) )
        )));
});

$ops.add_hll_op('nqp', 'postinc', -> $qastcomp, $op {
    my $var := $op[0];
    my $tmp := QAST::Op.unique('tmp');
    unless nqp::istype($var, QAST::Var) {
        nqp::die("Post-increment can only work on a variable");
    }
    $qastcomp.as_mast(QAST::Op.new(
        :op('locallifetime'),
        QAST::Stmt.new(
            :resultchild(0),
            QAST::Op.new(
                :op('bind'),
                QAST::Var.new( :name($tmp), :scope('local'), :decl('var'), :returns($var.returns) ),
                $var
            ),
            QAST::Op.new(
                :op('bind'),
                $var,
                QAST::Op.new(
                    :op('add_i'),
                    QAST::Var.new( :name($tmp), :scope('local'), :returns($var.returns)  ),
                    QAST::IVal.new( :value(1) )
                )
            )),
        $tmp));
});

$ops.add_hll_op('nqp', 'postdec', -> $qastcomp, $op {
    my $var := $op[0];
    my $tmp := QAST::Op.unique('tmp');
    unless nqp::istype($var, QAST::Var) {
        nqp::die("Post-decrement can only work on a variable");
    }
    $qastcomp.as_mast(QAST::Op.new(
        :op('locallifetime'),
        QAST::Stmt.new(
            :resultchild(0),
            QAST::Op.new(
                :op('bind'),
                QAST::Var.new( :name($tmp), :scope('local'), :decl('var') ),
                $var
            ),
            QAST::Op.new(
                :op('bind'),
                $var,
                QAST::Op.new(
                    :op('sub_i'),
                    QAST::Var.new( :name($tmp), :scope('local') ),
                    QAST::IVal.new( :value(1) )
                )
            )),
        $tmp));
});

$ops.add_hll_op('nqp', 'numify', -> $qastcomp, $op {
    $qastcomp.as_mast($op[0], :want($MVM_reg_num64))
});

$ops.add_hll_op('nqp', 'stringify', -> $qastcomp, $op {
    $qastcomp.as_mast($op[0], :want($MVM_reg_str))
});

$ops.add_hll_op('nqp', 'falsey', -> $qastcomp, $op {
    unless $op.list == 1 {
        nqp::die('falsey op requires one child');
    }
    my $val      := $qastcomp.as_mast($op[0]);
    my $regalloc := $*REGALLOC;
    if $val.result_kind == $MVM_reg_int64 {
        my $not_reg := $regalloc.fresh_register($MVM_reg_int64);
        my @ins := $val.instructions;
        push_op(@ins, 'not_i', $not_reg, $val.result_reg);
        MAST::InstructionList.new(@ins, $not_reg, $MVM_reg_int64)
    }
    elsif $val.result_kind == $MVM_reg_obj {
        my $not_reg := $regalloc.fresh_register($MVM_reg_int64);
        my $dc := $regalloc.fresh_register($MVM_reg_obj);
        my @ins := $val.instructions;
        push_op(@ins, 'decont', $dc, $val.result_reg);
        push_op(@ins, 'isfalse', $not_reg, $dc);
        $regalloc.release_register($dc, $MVM_reg_obj);
        MAST::InstructionList.new(@ins, $not_reg, $MVM_reg_int64)
    }
    elsif $val.result_kind == $MVM_reg_str {
        my $not_reg := $regalloc.fresh_register($MVM_reg_int64);
        my @ins := $val.instructions;
        push_op(@ins, 'isfalse_s', $not_reg, $val.result_reg);
        MAST::InstructionList.new(@ins, $not_reg, $MVM_reg_int64)
    }
    elsif $val.result_kind == $MVM_reg_num64 {
        my $tmp_reg := $regalloc.fresh_register($MVM_reg_num64);
        my $res_reg := $regalloc.fresh_register($MVM_reg_int64);
        my @ins := $val.instructions;
        push_op(@ins, 'const_n64', $tmp_reg, MAST::NVal.new( :value(0.0) ));
        push_op(@ins, 'eq_n', $res_reg, $val.result_reg, $tmp_reg);
        MAST::InstructionList.new(@ins, $res_reg, $MVM_reg_int64)
    }
    else {
        nqp::die("This case of nqp falsey op NYI");
    }
});

sub push_op(@dest, str $op, *@args) {
    nqp::push(@dest, MAST::Op.new_with_operand_array( :$op, @args ));
}
# From src/NQP/World.nqp

use NQPP6QRegex;
use QAST;

class NQP::World is HLL::World {
    # The stack of lexical pads, actually as QAST::Block objects. The
    # outermost frame is at the bottom, the latest frame is on top.
    has @!BLOCKS;

    # Set of code objects that need to be fixed up if dynamic compilation
    # takes place (that is, compiling parts of the program early during
    # compile time because they're needed at a BEGIN phase). Maps per-
    # compilation unit ID to a list of code objects.
    has %!code_objects_to_fix_up;

    # The types of those code objects.
    has %!code_object_types;

    # Mapping of QAST::Stmts node containing fixups, keyed by sub ID. If
    # we do dynamic compilation then we do the fixups immediately and
    # then clear this list.
    has %!code_object_fixup_list;

    # Mapping of sub IDs to SC indexes of code stubs.
    has %!code_stub_sc_idx;

    # Clear-up tasks.
    has @!clearup_tasks;

    method BUILD(*%opts) {
        @!BLOCKS := nqp::list();
        %!code_objects_to_fix_up := nqp::hash();
        %!code_object_types := nqp::hash();
        %!code_object_fixup_list := nqp::hash();
        %!code_stub_sc_idx := nqp::hash();
        @!clearup_tasks := nqp::list();

    }

    # Creates a new lexical scope and puts it on top of the stack.
    method push_lexpad($/) {
        # Create pad, link to outer and add to stack.
        my $pad := QAST::Block.new( QAST::Stmts.new(), :node($/) );
        @!BLOCKS[+@!BLOCKS] := $pad;
        $pad
    }

    # Pops a lexical scope off the stack.
    method pop_lexpad() {
        @!BLOCKS.pop()
    }

    # Gets the top lexpad.
    method cur_lexpad() {
        @!BLOCKS[+@!BLOCKS - 1]
    }

    # XXX This goes away really soon...after the multi refactor.
    method get_legacy_block_list() {
        my @x := nqp::clone(@!BLOCKS);
        @x.reverse();
        @x
    }

    # We need to load the module loader to load modules, which means we
    # can't just use ...; it; we break the circularity by using the global
    # HLL symbol stash.
    my $loader := nqp::getcurhllsym('ModuleLoader');

    # Loads the setting and emits code
    method load_setting($setting_name) {
        # Do nothing for the NULL setting.
        if $setting_name ne 'NULL' {
            # Load it immediately, so the compile time info is available.
            # Once it's loaded, set it as the outer context of the code
            # being compiled.
            my $setting := %*COMPILING<%?OPTIONS><outer_ctx>
                        := $loader.load_setting($setting_name);


            # Emit fixup or loading code.
            my $set_outer := QAST::Op.new(
                :op('forceouterctx'),
                QAST::BVal.new( :value($*UNIT) ),
                QAST::Op.new(
                    :op('callmethod'), :name('load_setting'),
                    QAST::Op.new(
                        :op('getcurhllsym'),
                        QAST::SVal.new( :value('ModuleLoader') )
                    ),
                    QAST::SVal.new( :value($setting_name) )
                ));
            if self.is_precompilation_mode() {
                self.add_load_dependency_task(:deserialize_ast(QAST::Stmts.new(
                    QAST::Op.new(
                        :op('loadbytecode'),
                        QAST::VM.new(
                            :parrot(QAST::SVal.new( :value('ModuleLoader.pbc') )),
                            :jvm(QAST::SVal.new( :value('ModuleLoader.class') )),
                            :moar(QAST::SVal.new( :value('ModuleLoader.moarvm') ))
                        )),
                    $set_outer
                )));
            }
            else {
                self.add_fixup_task(:fixup_ast($set_outer));
            }

            return nqp::ctxlexpad($setting);
        }
    }

    # Loads a module immediately, and also makes sure we load it
    # during the deserialization.
    method load_module($module_name, $cur_GLOBALish) {
        # Immediate loading.
        my $module := $loader.load_module($module_name, $cur_GLOBALish);

        # Make sure we do the loading during deserialization.
        if self.is_precompilation_mode() {
            self.add_load_dependency_task(:deserialize_ast(QAST::Stmts.new(
                QAST::Op.new(
                    :op('loadbytecode'),
                    QAST::VM.new(
                        :parrot(QAST::SVal.new( :value('ModuleLoader.pbc') )),
                        :jvm(QAST::SVal.new( :value('ModuleLoader.class') )),
                        :moar(QAST::SVal.new( :value('ModuleLoader.moarvm') ))
                    )),
                QAST::Op.new(
                   :op('callmethod'), :name('load_module'),
                   QAST::Op.new(
                        :op('getcurhllsym'),
                        QAST::SVal.new( :value('ModuleLoader') )
                    ),
                    QAST::SVal.new( :value($module_name) )
                ))));
        }

        return nqp::ctxlexpad($module);
    }

    method import($stash) {
        my $target := self.cur_lexpad();
        for $stash {
            self.install_lexical_symbol($target, $_.key, $_.value);
        }
    }

    # Installs a symbol into the package. Does so immediately, and
    # makes sure this happens on deserialization also.
    method install_package_symbol($package, @sym, $obj) {
        @sym := nqp::clone(@sym);
        my $name := ~@sym.pop();

        # Install symbol immediately.
        my $target := $package;
        for @sym {
            my $part := ~$_;
            if nqp::existskey($target.WHO, $part) {
                $target := nqp::atkey($target.WHO, $part);
            }
            else {
                my $pkgtype := nqp::existskey(%*HOW, 'package')
                    ?? nqp::atkey(%*HOW, 'package')
                    !! nqp::atkey(%*HOW, 'knowhow');
                my $pkg := $pkgtype.new_type(:name($part));
                $pkg.HOW.compose($pkg);
                $target := nqp::bindkey($target.WHO, $part, $pkg);
            }
        }
        ($target.WHO){$name} := $obj;
    }

    # Installs a lexical symbol. Takes a QAST::Block object, name and
    # the object to install.
    method install_lexical_symbol($block, str $name, $obj) {
        $block.symbol($name, :scope('lexical'), :value($obj));
        $block[0].push(QAST::Var.new(
            :scope('lexical'), :name($name), :decl('static'), :value($obj)
        ));
    }

    # Adds a fixup to install a specified QAST::Block in a package under the
    # specified name.
    method install_package_routine($package, $name, $ast_block) {
        my $fixup := QAST::Op.new(
            :op('bindkey'),
            QAST::Op.new( :op('who'), QAST::WVal.new( :value($package) ) ),
            QAST::SVal.new( :value(~$name) ),
            QAST::BVal.new( :value($ast_block) )
        );
        self.add_fixup_task(:deserialize_ast($fixup), :fixup_ast($fixup));
    }

    # Registers a code object, and gives it a dynamic compilation thunk.
    # Makes a real code object if it's a dispatcher.
    method create_code($ast, $name, $is_dispatcher, :$code_type_name = 'NQPRoutine',
            int :$onlystar = 0) {
        # See if NQPRoutine is available to wrap this up in.
        my $code_type;
        my $have_code_type := 0;
        try {
            $code_type := self.find_sym([$code_type_name]);
            $have_code_type := $*PACKAGE.HOW.name($*PACKAGE) ne $code_type_name;
        }

        # For code refs, we need a "stub" that we'll clone and use for the
        # compile-time representation. If it ever gets invoked it'll go
        # and compile the code and run it.
        # XXX Lexical environment.
        my $stub_code := sub (*@args, *%named) {
            # Do the compilation.
            $ast.unshift(self.libs());
            my $compiler := nqp::getcomp('nqp');
            my $compiled := $compiler.compile(
                QAST::CompUnit.new( :hll('nqp'), $ast ),
                :from<ast>, :compunit_ok(1), :lineposcache($*LINEPOSCACHE),
                :bootstrap(%*COMPILING<%?OPTIONS><bootstrap> ?? 1 !! 0));

            # Fix up any code objects holding stubs with the real compiled thing.
            my @allcodes := $compiler.backend.compunit_coderefs($compiled);
            my $c := nqp::elems(@allcodes);
            my $i := 0;
            while $i < $c {
                my $subid := nqp::getcodecuid(@allcodes[$i]);
                if nqp::existskey(%!code_objects_to_fix_up, $subid) {
                    # First, go over the code objects. Update the $!do, and the
                    # entry in the SC. Make sure the newly compiled code is marked
                    # as a static code ref.
                    my $static := %!code_objects_to_fix_up{$subid}.shift();
                    nqp::bindattr($static, %!code_object_types{$subid}, '$!do', @allcodes[$i]);
                    nqp::bindattr($static, %!code_object_types{$subid}, '$!clone_callback', nqp::null());
                    for %!code_objects_to_fix_up{$subid} {
                        nqp::bindattr($_, %!code_object_types{$subid}, '$!do', nqp::clone(@allcodes[$i]));
                        nqp::bindattr($_, %!code_object_types{$subid}, '$!clone_callback', nqp::null());
                    }
                    nqp::markcodestatic(@allcodes[$i]);
                    self.update_root_code_ref(%!code_stub_sc_idx{$subid}, @allcodes[$i]);

                    # Clear up the fixup statements.
                    my $fixup_stmts := %!code_object_fixup_list{$subid};
                    $fixup_stmts.shift() while +@($fixup_stmts);
                }
                $i := $i + 1;
            }

            my $mainline := $compiler.backend.compunit_mainline($compiled);
            $mainline(|@args, |%named)
        };

        # Create code object, if we'll need one.
        my $code_obj;
        if $have_code_type {
            $code_obj := nqp::create($code_type);
        }

        # See if we already have our compile-time dummy. If not, create it.
        my $fixups := QAST::Stmts.new();
        my $dummy  := $ast.ann('compile_time_dummy');
        my $code_ref_idx;
        unless nqp::defined($dummy) {
            # Create a fresh stub code, and set its name.
            $dummy := nqp::freshcoderef($stub_code);
            nqp::setcodename($dummy, $name);

            # Tag it as a static code ref and add it to the root code refs set.
            nqp::markcodestatic($dummy);
            nqp::markcodestub($dummy);
            $code_ref_idx := self.add_root_code_ref($dummy, $ast);
            %!code_stub_sc_idx{$ast.cuid()} := $code_ref_idx;
            $ast.annotate('compile_time_dummy', $dummy);

            # Things with code objects may be methods in roles or multi-dispatch
            # routines. We need to handle their cloning and maintain the fixup
            # list.
            if $have_code_type {
                %!code_object_fixup_list{$ast.cuid()} := $fixups;
                if self.is_precompilation_mode() {
                    my $cb := sub ($orig, $clone, $code_obj) {
                        %!code_objects_to_fix_up{$ast.cuid()}.push($code_obj);
                        nqp::bindattr($code_obj, $code_type, '$!clone_callback', nqp::null());
                        my $do := nqp::getattr($code_obj, $code_type, '$!do');
                        nqp::markcodestub($do);
                    }
                    nqp::bindattr($code_obj, $code_type, '$!clone_callback', $cb);
                    nqp::push(@!clearup_tasks, sub () {
                        nqp::bindattr($code_obj, $code_type, '$!clone_callback', nqp::null());
                    });
                }
                else {
                    my $cb := sub ($orig, $clone, $code_obj) {
                        # Emit fixup code.
                        self.add_object($code_obj);
                        $fixups.push(QAST::Op.new(
                            :op('setcodeobj'),
                            QAST::Op.new(
                                :op('bindattr'),
                                QAST::WVal.new( :value($code_obj) ),
                                QAST::WVal.new( :value($code_type) ),
                                QAST::SVal.new( :value('$!do') ),
                                QAST::Op.new( :op('clone'), QAST::BVal.new( :value($ast) ) )
                            ),
                            QAST::WVal.new( :value($code_obj) )
                        ));

                        # Add to dynamic compilation fixup list.
                        %!code_objects_to_fix_up{$ast.cuid()}.push($code_obj);
                    };
                    nqp::bindattr($code_obj, $code_type, '$!clone_callback', $cb);
                    nqp::push(@!clearup_tasks, sub () {
                        nqp::bindattr($code_obj, $code_type, '$!clone_callback', nqp::null());
                    });
                }
            }
        }

        # Add fixups task node; it'll get populated or cleared during the compile.
        self.add_fixup_task(:fixup_ast($fixups));

        # Provided we have the code type, now wrap what we have up in a
        # code object.
        if $have_code_type {
            # Create it now.
            nqp::bindattr($code_obj, $code_type, '$!do', $dummy);
            if $is_dispatcher {
                nqp::bindattr($code_obj, $code_type, '$!dispatchees', compilee_list());
                if $onlystar {
                    nqp::bindattr_i($code_obj, $code_type, '$!onlystar', 1);
                }
            }
            my $slot := self.add_object($code_obj);

            # Associate QAST block with code object, which will ensure it is
            # fixed up as needed.
            $ast.code_object($code_obj);

            # Add fixup of the code object and the $!do attribute.
            $fixups.push(QAST::Op.new(
                :op('bindattr'),
                QAST::WVal.new( :value($code_obj) ),
                QAST::WVal.new( :value($code_type) ),
                QAST::SVal.new( :value('$!do') ),
                QAST::BVal.new( :value($ast) )
            ));

            # Add it to the dynamic compilation fixup todo list.
            %!code_objects_to_fix_up{$ast.cuid()} := [$code_obj];
            %!code_object_types{$ast.cuid()} := $code_type;

            $code_obj
        }
        else {
            # For fixup, if we have no code body, we need to assign the method body
            # we actually compiled into the one that went into the SC.
            $fixups.push(QAST::Op.new(
                :op('replacecoderef'),
                QAST::Op.new(
                    :op('scgetcode'),
                    QAST::SVal.new( :value(self.handle()) ),
                    QAST::IVal.new( :value($code_ref_idx) )
                ),
                QAST::BVal.new( :value($ast) )
            ));
            return $dummy;
        }
    }

    # Creates a meta-object for a package, adds it to the root objects and
    # stores an event for the action. Returns the created object.
    method pkg_create_mo($how, :$name, :$repr) {
        # Create the meta-object and add to root objects.
        my %args;
        if nqp::defined($name) { %args<name> := $name; }
        if nqp::defined($repr) { %args<repr> := $repr; }
        my $mo := $how.new_type(|%args);
        self.add_object($mo);

        # Result is just the object.
        return $mo;
    }

    # Constructs a meta-attribute and adds it to a meta-object. Expects to
    # be passed the meta-attribute type object, a set of literal named
    # arguments to pass and a set of name to object mappings to pass also
    # as named arguments, but where these passed objects also live in a
    # serialization context. The type would be passed in this way.
    method pkg_add_attribute($obj, $meta_attr, %lit_args, %obj_args) {
        my $attr := $meta_attr.new(|%lit_args, |%obj_args);
        $obj.HOW.add_attribute($obj, $attr);
        $attr
    }

    # Adds a method to the meta-object.
    method pkg_add_method($obj, $meta_method_name, $name, $code) {
        $obj.HOW."$meta_method_name"($obj, $name, $code);
    }

    # Associates a signature with a code object.
    method set_routine_signature($code_obj, $types, $definednesses) {
        my $sig_type  := self.find_sym(['NQPSignature']);
        my $code_type := self.find_sym(['NQPRoutine']);
        my $sig_obj   := nqp::create($sig_type);
        nqp::bindattr($sig_obj, $sig_type, '$!types',
            compilee_list($types));
        nqp::bindattr($sig_obj, $sig_type, '$!definednesses',
            compilee_list($definednesses));
        nqp::bindattr($code_obj, $code_type, '$!signature', $sig_obj);
    }

    # This handles associating the role body with a role declaration.
    method pkg_set_body_block($obj, $body_ast) {
        # Get a code object for the body block.
        my $body_code_obj := self.create_code($body_ast, $body_ast.name, 0);

        # Set it as the body block.
        $obj.HOW.set_body_block($obj, $body_code_obj);
    }

    # Adds a parent or role to the meta-object.
    method pkg_add_parent_or_role($obj, $meta_method_name, $to_add) {
        $obj.HOW."$meta_method_name"($obj, $to_add);
    }

    method pkg_add_parrot_vtable_handler_mapping($obj, $name, $att_name) {
        $obj.HOW.add_parrot_vtable_handler_mapping($obj, $name, $att_name);
    }

    # Composes the package.
    method pkg_compose($obj) {
        $obj.HOW.compose($obj);
    }

    # Runs a block at BEGIN time.
    method run_begin_block($ast) {
        # Create a wrapper that makes all outer symbols visible.
        my $wrapper := QAST::Block.new(
            QAST::Stmts.new(),
            $ast
        );
        my %seen;
        my $i := +@!BLOCKS;
        while $i > 0 {
            $i := $i - 1;
            my %symbols := @!BLOCKS[$i].symtable();
            for %symbols {
                if !%seen{$_.key} && nqp::existskey($_.value, 'value') || nqp::existskey($_.value, 'lazy_value_from') {
                    my $value := self.force_value($_.value, $_.key, 0);
                    unless nqp::isnull(nqp::getobjsc($value)) {
                        $wrapper[0].push(QAST::Op.new(
                            :op('bind'),
                            QAST::Var.new( :name($_.key), :scope('lexical'), :decl('var') ),
                            QAST::WVal.new( :value($value) )
                        ));
                    }
                    %seen{$_.key} := 1;
                }
            }
        }

        # Compile and run it.
        my $code := self.create_code($wrapper, 'BEGIN block', 0);
        my $old_global := nqp::getcurhllsym('GLOBAL');
        nqp::bindcurhllsym('GLOBAL', $*GLOBALish);
        $code();
        nqp::bindcurhllsym('GLOBAL', $old_global);

        # Need any nested blocks inside the BEGIN block to make it into the
        # output code.
        $wrapper.shift();
        return $wrapper;
    }

    # Adds libraries that NQP code depends on.
    method libs() {
        my $libs := QAST::Stmts.new();
        if %*COMPILING<%?OPTIONS><vmlibs> {
            for nqp::split(',', %*COMPILING<%?OPTIONS><vmlibs>) {
                my @bits := nqp::split('=', $_);
                $libs.push(QAST::VM.new(
                    :moarop('loadlib'),
                    QAST::SVal.new( :value(@bits[0]) ),
                    QAST::SVal.new( :value(@bits[0]) )
                ));
                $libs.push(QAST::VM.new(
                    :moarop('loadext'),
                    QAST::SVal.new( :value(@bits[0]) ),
                    QAST::SVal.new( :value(@bits[1]) )
                ));
            }
        }
        self.add_fixup_task(:deserialize_ast($libs), :fixup_ast($libs));
        $libs
    }

    # Adds some initial tasks.
    method add_initializations() {
        self.add_load_dependency_task(:deserialize_ast(QAST::VM.new(
            :parrot(QAST::Stmts.new(
                QAST::VM.new( :pirop('nqp_dynop_setup v') ),
                QAST::VM.new( :pirop('nqp_bigint_setup v') ),
                QAST::Op.new(
                    :op('callmethod'), :name('hll_map'),
                    QAST::VM.new( :pirop('getinterp P') ),
                    QAST::VM.new( :pirop('get_class Ps'), QAST::SVal.new( :value('LexPad') ) ),
                    QAST::VM.new( :pirop('get_class Ps'), QAST::SVal.new( :value('NQPLexPad') ) )
                ))),
            :jvm(QAST::Op.new( :op('null') )),
            :moar(QAST::Op.new( :op('null') ))
        )));
    }

    # Does cleanups.
    method cleanup() {
        for @!clearup_tasks { $_() }
    }

    # Makes a list safe to cross the compilation boundary.
    sub compilee_list(@orig?) {
        my $list := nqp::create(nqp::bootarray());
        if nqp::islist(@orig) {
            for @orig {
                nqp::push($list, $_);
            }
        }
        $list
    }

    # Checks if the given name is known anywhere in the lexpad
    # and with lexical scope.
    method is_lexical(str $name) {
        self.is_scope($name, 'lexical')
    }

    # Checks if the given name is known anywhere in the lexpad
    # and with package scope.
    method is_package(str $name) {
        self.is_scope($name, 'package')
    }

    # Checks if a given name is known in the lexpad anywhere
    # with the specified scope.
    method is_scope(str $name, $wanted_scope) {
        my $i := +@!BLOCKS;
        while $i > 0 {
            $i := $i - 1;
            my %sym := @!BLOCKS[$i].symbol($name);
            if %sym {
                return %sym<scope> eq $wanted_scope;
            }
        }
        0;
    }

    # Gets the type of a lexical.
    method lexical_type(str $name) {
        my $i := +@!BLOCKS;
        while $i > 0 {
            $i := $i - 1;
            my %sym := @!BLOCKS[$i].symbol($name);
            if %sym {
                return %sym<type>;
            }
        }
        nqp::die("Lexical $name type could not be found");
    }

    # Checks if the symbol is known.
    method known_sym($/, @name) {
        my $known := 0;
        try {
            self.find_sym(@name);
            $known := 1;
        }
        $known
    }

    # Finds a symbol that has a known value at compile time from the
    # perspective of the current scope. Checks for lexicals, then if
    # that fails tries package lookup.
    method find_sym(@name) {
        # Make sure it's not an empty name.
        unless +@name { nqp::die("Cannot look up empty name"); }

        # If it's a single-part name, look through the lexical
        # scopes.
        if +@name == 1 {
            my str $final_name := ~@name[0];
            my $i := +@!BLOCKS;
            while $i > 0 {
                $i := $i - 1;
                my %sym := @!BLOCKS[$i].symbol($final_name);
                if %sym {
                    return self.force_value(%sym, $final_name, 1);
                }
            }
        }

        # If it's a multi-part name, see if the containing package
        # is a lexical somewhere. Otherwise we fall back to looking
        # in GLOBALish.
        my $result := $*GLOBALish;
        if +@name >= 2 {
            my str $first := ~@name[0];
            my int $i := +@!BLOCKS;
            while $i > 0 {
                $i := $i - 1;
                my %sym := @!BLOCKS[$i].symbol($first);
                if +%sym {
                    $result := self.force_value(%sym, $first, 1);
                    @name.shift();
                    $i := 0;
                }
            }
        }

        # Try to chase down the parts of the name.
        for @name {
            if nqp::existskey($result.WHO, ~$_) {
                $result := ($result.WHO){$_};
            }
            else {
                nqp::die("Could not locate compile-time value for symbol " ~
                    join('::', @name));
            }
        }

        $result;
    }

    method force_value(%sym, $key, int $die) {
        if nqp::existskey(%sym, 'value') {
            %sym<value>
        }
        elsif nqp::existskey(%sym, 'lazy_value_from') {
            %sym<value> := nqp::atkey(nqp::atkey(%sym, 'lazy_value_from'), $key)
        }
        else {
            $die ?? nqp::die("No compile-time value for $key") !! NQPMu
        }
    }
}
# From src/NQP/Grammar.nqp

grammar NQP::Grammar is HLL::Grammar {
    method TOP() {
        # Language braids.
        my %*LANG;
        %*LANG<Regex>         := NQP::Regex;
        %*LANG<Regex-actions> := NQP::RegexActions;
        %*LANG<MAIN>          := NQP::Grammar;
        %*LANG<MAIN-actions>  := NQP::Actions;

        # Package declarator to meta-package mapping. Note that there is
        # one universal KnowHOW from the 6model core, and an attribute
        # meta-object to go with it.
        my %*HOW;
        %*HOW<knowhow>      := nqp::knowhow();
        %*HOW<knowhow-attr> := nqp::knowhowattr();

        # Serialization context builder - keeps track of objects that
        # cross the compile-time/run-time boundary that are associated
        # with this compilation unit.
        my $file := nqp::getlexdyn('$?FILES');
        my $source_id := nqp::sha1(self.target()) ~
            (%*COMPILING<%?OPTIONS><stable-sc> ?? '' !! '-' ~ ~nqp::time_n());
        my $*W := nqp::isnull($file) ??
            NQP::World.new(:handle($source_id)) !!
            NQP::World.new(:handle($source_id), :description($file));

        my $*SCOPE        := '';
        my $*MULTINESS    := '';
        my $*PKGDECL      := '';
        my $*INVOCANT_OK  := 0;
        my $*RETURN_USED  := 0;
        my $*CONTROL_USED := 0;
        my $*IN_REGEX_ASSERTION := 0;
        my %*HANDLERS;
        self.comp_unit;
    }

    ## Lexer stuff

    token identifier { <.ident> [ <[\-']> <.ident> ]* }

    token name { <identifier> ['::'<identifier>]* }

    token deflongname {
        <identifier> <colonpair>?
    }

    token ENDSTMT {
        [
        <.unv>? $$ <.ws> <?MARKER('endstmt')>
        ]?
    }

    token ws {
        ||  <?MARKED('ws')>
        ||  <!ww>
            [ \v+
            | '#' \N*
            | ^^ <.pod_comment>
            | \h+
            ]*
            <?MARKER('ws')>
    }

    token unv {
        # :dba('horizontal whitespace')
        [
        | ^^ <?before \h* '=' [ \w | '\\'] > <.pod_comment>
        | \h* '#' \N*
        | \h+
        ]
    }

    token pod_comment {
        ^^ \h* '='
        [
        | 'begin' \h+ 'END' >>
            [ .*? \n \h* '=' 'end' \h+ 'END' » \N* || .* ]
        | 'begin' \h+ <identifier>
            [
            ||  .*? \n \h* '=' 'end' \h+ $<identifier> » \N*
            ||  <.panic: '=begin without matching =end'>
            ]
        | 'begin' » \h*
            [ $$ || '#' || <.panic: 'Unrecognized token after =begin'> ]
            [
            || .*? \n \h* '=' 'end' » \N*
            || <.panic: '=begin without matching =end'>
            ]
        | <identifier> {}
            .*? \n <?before \h* [
                '='
                [ 'cut' »
                  <.panic: 'Obsolete pod format, please use =begin/=end instead'> ]?
              | \n ]>
        |   {}
            [ \s || <.panic: 'Illegal pod directive'> ]
            \N*
        ]
    }


    ## Top-level rules

    token comp_unit {
        :my $*IN_DECL := '';

        :my $*HAS_YOU_ARE_HERE := 0;
        :my $*MAIN_SUB;
        :my $*UNIT := $*W.push_lexpad($/);

        # Create GLOBALish - the current GLOBAL view, created fresh
        # for each compilation unit so we get separate compilation.
        :my $*GLOBALish := $*W.pkg_create_mo(%*HOW<knowhow>, :name('GLOBALish'));
        {
            $*GLOBALish.HOW.compose($*GLOBALish);
            $*W.install_lexical_symbol($*UNIT, 'GLOBALish', $*GLOBALish);
        }

        # This is also the starting package.
        :my $*PACKAGE := $*GLOBALish;
        { $*W.install_lexical_symbol($*UNIT, '$?PACKAGE', $*PACKAGE); }

        # Create EXPORT::DEFAULT.
        :my $*EXPORT;
        {
            unless %*COMPILING<%?OPTIONS><setting> eq 'NULL' {
                $*EXPORT := $*W.pkg_create_mo(%*HOW<knowhow>, :name('EXPORT'));
                $*EXPORT.HOW.compose($*EXPORT);
                $*W.install_lexical_symbol($*UNIT, 'EXPORT', $*EXPORT);
                my $DEFAULT := $*W.pkg_create_mo(%*HOW<knowhow>, :name('DEFAULT'));
                $DEFAULT.HOW.compose($DEFAULT);
                ($*EXPORT.WHO)<DEFAULT> := $DEFAULT;
            }
        }

        { $*W.add_initializations(); }

        <.outerctx>

        <statementlist>
        [ $ || <.panic: 'Confused'> ]
    }

    rule statementlist {
        ''
        [
        | $
        | <?before <[\)\]\}]>>
        | [ <statement> <.eat_terminator> ]*
        ]
    }

    token label {
        <identifier> ':' <?[\s]> <.ws>
        {
            $*LABEL := ~$<identifier>;
            my $label := $*W.find_sym(['NQPLabel']).new();
            $*W.add_object($label);
            $*W.install_lexical_symbol($*W.cur_lexpad(), $*LABEL, $label);
        }
    }

    token statement($*LABEL = '') {
        <!before <[\])}]> | $ >
        [
        | <label> <statement($*LABEL)> { $*LABEL := '' if $*LABEL }
        | <statement_control>
        | <EXPR> <.ws>
            [
            || <?MARKED('endstmt')>
            || <statement_mod_cond> <statement_mod_loop>?
            || <statement_mod_loop>
            ]?
        ]
    }

    token eat_terminator {
        || ';'
        || <?MARKED('endstmt')>
        || <?terminator>
        || $
    }

    token xblock {
        <EXPR> <.ws> <pblock>
    }

    token pblock {
        | <.lambda>
            <.newpad>
            <signature> <.ws>
            <blockoid>
        | <?[{]>
            <.newpad>
            <blockoid>
        | <.panic: 'Missing block'>
    }

    token lambda { '->' | '<->' }

    token block {
        [ <?[{]> || <.panic: 'Missing block'> ]
        <.newpad>
        <blockoid>
    }

    token blockoid {
        :my %*HANDLERS;
        <.finishpad>
        [
        || '{YOU_ARE_HERE}' <you_are_here>
        || '{' ~ '}' <statementlist>
        ]
        <?ENDSTMT>
    }

    token newpad { <?> }
    token outerctx { <?> }
    token finishpad { <?> }
    token you_are_here { <?> }

    proto token terminator { <...> }

    token terminator:sym<;> { <?[;]> }
    token terminator:sym<}> { <?[}]> }

    ## Statement control

    proto rule statement_control { <...> }

    rule statement_control:sym<use> {
        <sym>\s <name>
    }

    rule statement_control:sym<if> {
        <sym>\s
        <xblock>
        [ 'elsif'\s <xblock> ]*
        [ 'else'\s <else=.pblock> ]?
    }

    rule statement_control:sym<unless> {
        <sym>\s
        <xblock>
        [ <!before 'else'> || <.panic: 'unless does not take "else", please rewrite using "if"'> ]
    }

    rule statement_control:sym<while> {
        :my $*CONTROL_USED := 0;
        $<sym>=[while|until]\s
        <xblock>
    }

    rule statement_control:sym<repeat> {
        :my $*CONTROL_USED := 0;
        <sym>\s
        [
        | $<wu>=[while|until]\s <xblock>
        | <pblock> $<wu>=[while|until]\s <EXPR>
        ]
    }

    rule statement_control:sym<for> {
        :my $*CONTROL_USED := 0;
        <sym>\s
        <xblock>
    }

    rule statement_control:sym<CATCH> { <sym>\s <block> }

    rule statement_control:sym<CONTROL> { <sym>\s <block> }

    proto token statement_prefix { <...> }
    token statement_prefix:sym<BEGIN> { <sym> <blorst> }
    token statement_prefix:sym<INIT>  { <sym> <blorst> }
    token statement_prefix:sym<try>   { <sym> <blorst> }

    token blorst {
        [
        | <?before \s> <.ws>
            [
            | <?[{]> <block>
            | <statement>
            ]
        | <.panic: "Whitespace required after keyword">
        ]
    }

    ## Statement modifiers

    proto rule statement_mod_cond { <...> }

    rule statement_mod_cond:sym<if>     { <sym> {} <cond=.EXPR> }
    rule statement_mod_cond:sym<unless> { <sym> {} <cond=.EXPR> }

    proto rule statement_mod_loop { <...> }

    rule statement_mod_loop:sym<while>     { <sym> {} <cond=.EXPR> }
    rule statement_mod_loop:sym<until>     { <sym> {} <cond=.EXPR> }
    rule statement_mod_loop:sym<for>       { <sym> {} <cond=.EXPR> }

    ## Terms

    token term:sym<fatarrow>           { <fatarrow> }
    token term:sym<colonpair>          { <colonpair> }
    token term:sym<variable>           { <variable> }
    token term:sym<package_declarator> { <package_declarator> }
    token term:sym<scope_declarator>   { <scope_declarator> }
    token term:sym<routine_declarator> { <routine_declarator> }
    token term:sym<multi_declarator>   {
        <?before 'multi'|'proto'|'only'>
        <!before 'proto' <.ws> ['regex'|'token'|'rule']>
        <multi_declarator>
    }
    token term:sym<regex_declarator>   { <regex_declarator> }
    token term:sym<statement_prefix>   { <statement_prefix> }
    token term:sym<lambda>             { <?lambda> <pblock> }
    token term:sym<last>               { <sym> [<.ws> <identifier> <?{ $*W.is_lexical(~$<identifier>) }>]? { $*CONTROL_USED := 1 } }
    token term:sym<next>               { <sym> [<.ws> <identifier> <?{ $*W.is_lexical(~$<identifier>) }>]? { $*CONTROL_USED := 1 } }
    token term:sym<redo>               { <sym> [<.ws> <identifier> <?{ $*W.is_lexical(~$<identifier>) }>]? { $*CONTROL_USED := 1 } }

    token fatarrow {
        <key=.identifier> \h* '=>' <.ws> <val=.EXPR('i=')>
    }

    token colonpair {
        ':'
        [
        | $<not>='!' <identifier>
        | <identifier> <circumfix>?
        | <circumfix>
        | <variable>
        ]
    }

    token variable {
        | <sigil> <twigil>? <desigilname=.name>
        | <sigil> <?[<]> <postcircumfix>
        | <sigil> '(' ~ ')' <semilist>
        | $<sigil>=['$'] $<desigilname>=[<[/_!¢]>]
    }

    token sigil { <[$@%&]> }

    token twigil { <[*!?]> }

    proto token package_declarator { <...> }
    token package_declarator:sym<module> {
        :my $*OUTERPACKAGE := $*PACKAGE;
        :my $*PKGDECL := 'module';
        <sym> <package_def>
    }
    token package_declarator:sym<knowhow> {
        :my $*OUTERPACKAGE := $*PACKAGE;
        :my $*PKGDECL := 'knowhow';
        <sym> <package_def>
    }
    token package_declarator:sym<class> {
        :my $*OUTERPACKAGE := $*PACKAGE;
        :my $*PKGDECL := 'class';
        <sym> <package_def>
    }
    token package_declarator:sym<grammar> {
        :my $*OUTERPACKAGE := $*PACKAGE;
        :my $*PKGDECL := 'grammar';
        <sym> <package_def>
    }
    token package_declarator:sym<role> {
        :my $*OUTERPACKAGE := $*PACKAGE;
        :my $*PKGDECL := 'role';
        <sym> <package_def>
    }
    token package_declarator:sym<native> {
        :my $*OUTERPACKAGE := $*PACKAGE;
        :my $*PKGDECL := 'native';
        <sym> <package_def>
    }
    rule package_declarator:sym<stub> {
        :my $*OUTERPACKAGE := $*PACKAGE;
        :my $*PKGDECL := 'stub';
        <sym> <name>
        'metaclass' <metaclass=.name>
        '{' '...' '}'
    }

    rule package_def {
        :my $*PACKAGE;     # The type object for this package.
        :my $OUTER := $*W.cur_lexpad();
        ''
        [
        <name>
        <.newpad>
        [ <?{ $*PKGDECL eq 'role' }> '[' ~ ']' <role_params> ]?
        [ 'is' 'repr(' <repr=.quote_EXPR> ')' ]?

        {
            # Construct meta-object for this package, adding it to the
            # serialization context for this compilation unit.
            my %args;
            %args<name> := ~$<name>;
            if $<repr> {
                %args<repr> := ~$<repr><quote_delimited><quote_atom>[0];
            }
            my $how := %*HOW{$*PKGDECL};
            my $INNER := $*W.cur_lexpad();
            $*PACKAGE := $*W.pkg_create_mo($how, |%args);

            # these need to be installed early so that they may be referenced from subs in the block
            if nqp::can($how, 'parametric') && $how.parametric($how) {
                $*W.install_lexical_symbol($INNER, '$?PACKAGE', $*PACKAGE);
                $*W.install_lexical_symbol($INNER, '$?ROLE', $*PACKAGE);
            }
            else {
                $*W.install_lexical_symbol($INNER, '$?PACKAGE', $*PACKAGE);
                $*W.install_lexical_symbol($INNER, '$?CLASS', $*PACKAGE);
            }

            # Install it in the current package or current lexpad as needed.
            if $*SCOPE eq 'our' || $*SCOPE eq '' {
                $*W.install_package_symbol($*OUTERPACKAGE, $<name><identifier>, $*PACKAGE);
                if +$<name><identifier> == 1 {
                    $*W.install_lexical_symbol($OUTER, ~$<name><identifier>[0], $*PACKAGE);
                }
            }
            elsif $*SCOPE eq 'my' {
                if +$<name><identifier> != 1 {
                    $<name>.CURSOR.panic("A my scoped package cannot have a multi-part name yet");
                }
                $*W.install_lexical_symbol($OUTER, ~$<name><identifier>[0], $*PACKAGE);
            }
            else {
                $/.CURSOR.panic("$*SCOPE scoped packages are not supported");
            }
        }

        [ $<export>=['is export'] ]?
        [ $<nativesize>=['is nativesize(' $<size>=[\d+] ')' ] ]?
        [ $<unsigned>=['is unsigned'] ]?
        [ 'is' <parent=.name> ]?
        [ 'does' <role=.name> ]*
        [
        || ';' <statementlist> [ $ || <.panic: 'Confused'> ]
        || <?[{]> <blockoid>
        || <.panic: 'Malformed package declaration'>
        ]
        ]
    }

    rule role_params {
        :my $*SCOPE   := 'my';
        :my $*IN_DECL := 'variable';
        <variable> +% ','
    }

    proto rule scope_declarator { <...> }
    rule scope_declarator:sym<my>  { <sym> <scoped('my')> }
    rule scope_declarator:sym<our> { <sym> <scoped('our')> }
    rule scope_declarator:sym<has> { <sym> <scoped('has')> }

    token scoped($*SCOPE) {
        | <declarator>
        | <multi_declarator>
        | <package_declarator>
    }

    token typename {
        <name>
        <?{ $*W.known_sym($/, $<name><identifier>) }>
    }

    token declarator {
        | <variable_declarator>
        | <routine_declarator>
    }

    rule variable_declarator {
        <typename>?
        :my $*IN_DECL := 'variable';
        <variable>
        { $*IN_DECL := 0; }
        <trait>*
        <initializer>?
    }

    token initializer {
        ':=' <.ws> [ <EXPR('f=')> || <.panic: "Malformed binding"> ]
    }

    proto rule routine_declarator { <...> }
    rule routine_declarator:sym<sub>    { <sym> <routine_def> }
    rule routine_declarator:sym<method> { <sym> <method_def> }

    rule routine_def {
        :my $*RETURN_USED := 0;
        [ $<sigil>=['&'?]<deflongname> ]?
        <.newpad>
        [ '(' ~ ')' <signature>
            || <.panic: 'Routine declaration requires a signature'> ]
        <trait>*
        [
        | <onlystar>
        | <blockoid>
        ]
    }

    rule method_def {
        :my $*RETURN_USED := 0;
        :my $*INVOCANT_OK := 1;
        [
        || '::(' <latename=variable> ')'
        || $<private>=['!'?] <deflongname>?
        ]
        <.newpad>
        [ '(' ~ ')' <signature>
            || <.panic: 'Routine declaration requires a signature'> ]
        { $*INVOCANT_OK := 0; }
        <trait>*
        [
        | <onlystar>
        | <blockoid>
        ]
    }

    token onlystar {
        <?{ $*MULTINESS eq 'proto' }>
        '{' <.ws> '*' <.ws> '}'
        <?ENDSTMT>
        <.finishpad>
    }

    proto token multi_declarator { <...> }
    token multi_declarator:sym<multi> {
        :my $*MULTINESS := 'multi';
        <sym>
        <.ws> [ <declarator> || <routine_def> || <.panic: 'Malformed multi'> ]
    }
    token multi_declarator:sym<proto> {
        :my $*MULTINESS := 'proto';
        <sym>
        <.ws> [ <declarator> || <routine_def> || <.panic: 'Malformed proto'> ]
    }
    token multi_declarator:sym<null> {
        :my $*MULTINESS := '';
        <declarator>
    }

    rule signature {
        [ <?{ $*INVOCANT_OK }> <invocant=.parameter> ':' ]?
        [ <parameter> *%% ',' ]?
    }

    token parameter {
        [ <typename> [ ':' $<definedness>=<[_DU]> ]**0..1 <.ws> ]*      # <type_constraint>
        [
        | $<quant>=['*'] <param_var>
        | [ <param_var> | <named_param> ] $<quant>=['?'|'!'|<?>]
        ]
        <.ws> <default_value>**0..1
    }

    token param_var {
        <sigil> <twigil>?
        [ <name=.identifier> | $<name>=[<[/!]>] ]
    }

    token named_param {
        ':' <param_var>
    }

    rule default_value { '=' <EXPR('i=')> }

    token trait { <trait_mod> }

    proto rule trait_mod { <...> }
    rule trait_mod:sym<is> { <sym> <longname=.deflongname><circumfix>**0..1 }

    rule regex_declarator {
        [
        | [$<proto>=[proto]] [regex|token|rule]
          [
          || '::(' <latename=variable> ')'
          || <deflongname>
          ]
          [
          || '{*}'<?ENDSTMT>
          || '{' '<...>' '}'<?ENDSTMT>
          || '{' '<*>' '}'<?ENDSTMT>
          || <.panic: "Proto regex body must be \{*\} (or <*> or <...>, which are deprecated)">
          ]
        | [$<sym>=[regex|token|rule]]
          [
          || '::(' <latename=variable> ')'
          || <deflongname>
          ]
          <.newpad>
          [ '(' ~ ')' <signature> ]**0..1
          :my %*RX;
          {
              %*RX<s>    := $<sym> eq 'rule';
              %*RX<r>    := $<sym> eq 'token' || $<sym> eq 'rule';
              %*RX<name> := $<deflongname> ?? $<deflongname>.made !! "!!LATENAME!!" ~ ~$<latename>;
              %*RX<code> := $*W.create_code($*W.cur_lexpad(), %*RX<name>, 0, :code_type_name<NQPRegex>);
          }
          '{'<p6regex=.LANG('Regex','nibbler')>'}'<?ENDSTMT>
        ]
    }

    token dotty {
        '.'
        [ <longname=deflongname>
        | <?['"]> <quote>
            [ <?[(]> || <.panic: "Quoted method name requires parenthesized arguments"> ]
        ]

        [
        | <args>
        | ':' \s <args=.arglist>
        ]**0..1
    }

    token term:sym<self> { <sym> » }

    token term:sym<identifier> {
        <deflongname> <args>
    }

    token term:sym<pir::op> {
        'pir::' $<op>=[\w+] <args>**0..1
    }

    token term:sym<pir::const> {
        'pir::const::' $<const>=[\w+]
    }

    token term:sym<nqp::op> {
        'nqp::' $<op>=[\w+] <args>**0..1
    }

    token term:sym<nqp::const> {
        'nqp::const::' $<const>=[\w+]
    }

    token term:sym<onlystar> {
        '{*}' <?ENDSTMT>
        [ <?{ $*MULTINESS eq 'proto' }> || <.panic: '{*} may only appear in proto'> ]
    }

    token term:sym<name> {
        <name> <?{ ~$<name> ne 'return' }> <args>**0..1
    }

    token args {
        | '(' <arglist> ')'
    }

    token arglist {
        <.ws>
        [
        | <EXPR('f=')>
        | <?>
        ]
    }


    token term:sym<value> { <value> }

    token value {
        | <quote>
        | <number>
    }

    token number {
        $<sign>=[<[+\-]>?]
        [ <dec_number> | <integer> ]
    }

    proto token quote { <...> }
    token quote:sym<apos> { <?[']>            <quote_EXPR: ':q'>  }
    token quote:sym<dblq> { <?["]>            <quote_EXPR: ':qq'> }
    token quote:sym<q>    { <sym> >> <![(]> <.ws> <quote_EXPR: ':q'>  }
    token quote:sym<qq>   { <sym> >> <![(]> <.ws> <quote_EXPR: ':qq'> }
    token quote:sym<Q>    { <sym> >>  <![(]> <.ws> <quote_EXPR> }
    token quote:sym<Q:PIR> { <sym> <.ws> <quote_EXPR> }
    token quote:sym</ />  {
        '/'
        <.newpad>
        :my %*RX;
        <p6regex=.LANG('Regex','nibbler')>
        '/'
    }

    token quote_escape:sym<$>   { <?[$]> <?quotemod_check('s')> <variable> }
    token quote_escape:sym<{ }> { <?[{]> <?quotemod_check('c')> <block> }
    token quote_escape:sym<esc> { \\ e <?quotemod_check('b')> }

    token circumfix:sym<( )> { '(' <.ws> <EXPR>**0..1 ')' }
    token circumfix:sym<[ ]> { '[' <.ws> <EXPR>**0..1 ']' }
    token circumfix:sym<ang> { <?[<]>  <quote_EXPR: ':q', ':w'>  }
    token circumfix:sym<« »> { <?[«]>  <quote_EXPR: ':qq', ':w'>  }
    token circumfix:sym<{ }> { <?[{]> <pblock> }

    token coloncircumfix($front) { <circumfix> }

    token semilist { <.ws> <statement> <.ws> }

    ## Operators

    INIT {
        NQP::Grammar.O(':prec<y=>, :assoc<unary>', '%methodop');
        NQP::Grammar.O(':prec<x=>, :assoc<unary>', '%autoincrement');
        NQP::Grammar.O(':prec<w=>, :assoc<left>',  '%exponentiation');
        NQP::Grammar.O(':prec<v=>, :assoc<unary>', '%symbolic_unary');
        NQP::Grammar.O(':prec<u=>, :assoc<left>',  '%multiplicative');
        NQP::Grammar.O(':prec<t=>, :assoc<left>',  '%additive');
        NQP::Grammar.O(':prec<r=>, :assoc<left>',  '%concatenation');
        NQP::Grammar.O(':prec<m=>, :assoc<non>',   '%relational');
        NQP::Grammar.O(':prec<l=>, :assoc<left>',  '%tight_and');
        NQP::Grammar.O(':prec<k=>, :assoc<left>',  '%tight_or');
        NQP::Grammar.O(':prec<j=>, :assoc<right>', '%conditional');
        NQP::Grammar.O(':prec<i=>, :assoc<right>', '%assignment');
        NQP::Grammar.O(':prec<g=>, :assoc<list>, :nextterm<nulltermish>',  '%comma');
        NQP::Grammar.O(':prec<f=>, :assoc<list>',  '%list_infix');
        NQP::Grammar.O(':prec<e=>, :assoc<unary>', '%list_prefix');
    }


    token infixish { <!infixstopper> <OPER=infix> }
    token infixstopper {
        | <?{ $*IN_REGEX_ASSERTION }> <?[>]>
        | <?lambda>
    }

    token postcircumfix:sym<[ ]> {
        '[' <.ws> <EXPR> ']'
        <O('%methodop')>
    }

    token postcircumfix:sym<{ }> {
        '{' <.ws> <EXPR> '}'
        <O('%methodop')>
    }

    token postcircumfix:sym<ang> {
        <?[<]> <quote_EXPR: ':q'>
        <O('%methodop')>
    }

    token postcircumfix:sym<( )> {
        '(' <.ws> <arglist> ')'
        <O('%methodop')>
    }

    token postfix:sym<.>  { <dotty> <O('%methodop')> }

    token prefix:sym<++>  { <sym>  <O('%autoincrement, :op<preinc>')> }
    token prefix:sym<-->  { <sym>  <O('%autoincrement, :op<predec>')> }

    token postfix:sym<++> { <sym>  <O('%autoincrement, :op<postinc>')> }
    token postfix:sym<--> { <sym>  <O('%autoincrement, :op<postdec>')> }

    token infix:sym<**>   { <sym>  <O('%exponentiation, :op<pow_n>')> }

    token prefix:sym<+>   { <sym>  <O('%symbolic_unary, :op<numify>')> }
    token prefix:sym<~>   { <sym>  <O('%symbolic_unary, :op<stringify>')> }
    token prefix:sym<->   { <sym>  <![>]> <!number> <O('%symbolic_unary, :op<neg_n>')> }
    token prefix:sym<?>   { <sym>  <O('%symbolic_unary, :op<istrue>')> }
    token prefix:sym<!>   { <sym>  <O('%symbolic_unary, :op<falsey>')> }
    token prefix:sym<|>   { <sym>  <O('%symbolic_unary')> }

    token infix:sym<*>    { <sym>  <O('%multiplicative, :op<mul_n>')> }
    token infix:sym</>    { <sym>  <O('%multiplicative, :op<div_n>')> }
    token infix:sym<%>    { <sym>  <O('%multiplicative, :op<mod_n>')> }
    token infix:sym<+&>   { <sym>  <O('%multiplicative, :op<bitand_i>')> }

    token infix:sym<+>    { <sym>  <O('%additive, :op<add_n>')> }
    token infix:sym<->    { <sym>  <O('%additive, :op<sub_n>')> }
    token infix:sym<+|>   { <sym>  <O('%additive, :op<bitor_i>')> }
    token infix:sym<+^>   { <sym>  <O('%additive, :op<bitxor_i>')> }

    token infix:sym<~>    { <sym>  <O('%concatenation , :op<concat>')> }

    token infix:sym«==»   { <sym>  <O('%relational, :op<iseq_n>')> }
    token infix:sym«!=»   { <sym>  <O('%relational, :op<isne_n>')> }
    token infix:sym«<=»   { <sym>  <O('%relational, :op<isle_n>')> }
    token infix:sym«>=»   { <sym>  <O('%relational, :op<isge_n>')> }
    token infix:sym«<»    { <sym>  <O('%relational, :op<islt_n>')> }
    token infix:sym«>»    { <sym>  <O('%relational, :op<isgt_n>')> }
    token infix:sym«eq»   { <sym>  <O('%relational, :op<iseq_s>')> }
    token infix:sym«ne»   { <sym>  <O('%relational, :op<isne_s>')> }
    token infix:sym«le»   { <sym>  <O('%relational, :op<isle_s>')> }
    token infix:sym«ge»   { <sym>  <O('%relational, :op<isge_s>')> }
    token infix:sym«lt»   { <sym>  <O('%relational, :op<islt_s>')> }
    token infix:sym«gt»   { <sym>  <O('%relational, :op<isgt_s>')> }
    token infix:sym«=:=»  { <sym>  <O('%relational, :op<eqaddr>')> }
    token infix:sym<~~>   { <sym>  <O('%relational, :reducecheck<smartmatch>')> }

    token infix:sym<&&>   { <sym>  <O('%tight_and, :op<if>')> }

    token infix:sym<||>   { <sym>  <O('%tight_or, :op<unless>')> }
    token infix:sym<//>   { <sym>  <O('%tight_or, :op<defor>')> }

    token infix:sym<?? !!> {
        '??'
        <.ws>
        <EXPR('i=')>
        '!!'
        <O('%conditional, :reducecheck<ternary>, :op<if>')>
    }

    token infix:sym<=>    {
        <sym> <.panic: 'Assignment ("=") not supported in NQP, use ":=" instead'>
    }
    token infix:sym<:=>   { <sym>  <O('%assignment, :op<bind>')> }
    token infix:sym<::=>  { <sym>  <O('%assignment, :op<bind>')> }

    token infix:sym<,>    { <sym>  <O('%comma, :op<list>')> }

    token prefix:sym<make>   { <sym> \s <O('%list_prefix')> }
    token term:sym<return> { <sym> [\s <EXPR>]? { $*RETURN_USED := 1 } }

    method smartmatch($/) {
        # swap rhs into invocant position
        my $t := $/[0]; $/[0] := $/[1]; $/[1] := $t;
    }
}

grammar NQP::Regex is QRegex::P6Regex::Grammar {
    token rxstopper {
        <[ } / ]>
    }

    token metachar:sym<:my> {
        ':' <?before 'my'> <statement=.LANG('MAIN', 'statement')> <.ws> ';'
    }

    token metachar:sym<{ }> {
        <?[{]> <codeblock>
    }

    token metachar:sym<nqpvar> {
        <?before <sigil> [\W\w | \w]> <var=.LANG('MAIN', 'variable')> <.SIGOK>
    }

    token assertion:sym<{ }> {
        <?[{]> <codeblock>
    }

    token assertion:sym<?> { '?' [ <?[>]> | <![{]> <assertion> ] }
    token assertion:sym<!> { '!' [ <?[>]> | <![{]> <assertion> ] }

    token assertion:sym<?{ }> {
        $<zw>=[ <[?!]> <?[{]> ] <codeblock>
    }

    token arglist {
        :my $*IN_REGEX_ASSERTION := 1;
        <arglist=.LANG('MAIN', 'arglist')>
    }

    token assertion:sym<name> {
        <longname=.identifier>
            [
            | <?[>]>
            | '=' <assertion>
            | ':' <arglist>
            | '(' <arglist> ')'
            | <.normspace> <nibbler>
            ]?
    }

    token assertion:sym<var> {
        <?[$@]> <var=.LANG('MAIN', 'variable')>
    }

    token codeblock {
        <block=.LANG('MAIN','pblock')>
    }

    token arg {
        <quote_EXPR=.LANG('MAIN','quote_EXPR')>
    }
}
# From src/NQP/Optimizer.nqp

use NQPP6QRegex;

class NQP::Optimizer {
    # Variable declarations and usages within a block.
    my class BlockVars {
        # Hash mapping variable names declared in the block to the QAST::Var
        # of its declaration.
        has %!decls;

        # Usages of variables in this block, or unioned in from an inlined
        # immediate block.
        has %!usages_flat;

        # Usages of variables in this block, or unioned in from a non-inlined
        # immediate block or a declaration block.
        has %!usages_inner;

        # If lowering is, for some reason, poisoned.
        has $!poisoned;

        method add_decl($var) {
            if $var.scope eq 'lexical' {
                %!decls{$var.name} := $var;
            }
        }

        method add_usage($var) {
            if $var.scope eq 'lexical' {
                my $name   := $var.name;
                my @usages := %!usages_flat{$name};
                unless @usages {
                    @usages := [];
                    %!usages_flat{$name} := @usages;
                }
                nqp::push(@usages, $var);
            }
        }

        method poison_lowering() { $!poisoned := 1; }

        method get_decls() { %!decls }

        method get_usages_flat() { %!usages_flat }

        method get_usages_inner() { %!usages_inner }

        method is_flattenable() {
            for %!decls {
                return 0 if $_.value.scope eq 'lexical';
                return 0 if $_.value.decl eq 'param';
            }
            1
        }

        method incorporate_inner($vars_info, $flattened) {
            # We'll exclude anything that the inner or flattened thing has as
            # a declaration, since those are its own.
            my %decls := $vars_info.get_decls;

            # Inner ones always go into our inners set.
            add_to_set(%!usages_inner, $vars_info.get_usages_inner, %decls);

            # Flat ones depend on if we flattened this block into ourself.
            add_to_set($flattened ?? %!usages_flat !! %!usages_inner,
                $vars_info.get_usages_flat, %decls);

            sub add_to_set(%set, %to_add, %exclude) {
                for %to_add {
                    my $name := $_.key;
                    next if nqp::existskey(%exclude, $name);
                    my @existing := %set{$name};
                    if @existing {
                        for $_.value { nqp::push(@existing, $_) }
                        #nqp::splice(@existing, $_.value, 0, 0);
                    }
                    else {
                        %set{$name} := $_.value;
                    }
                }
            }
        }

        method lexicals_to_locals() {
            return 0 if $!poisoned;
            for %!decls {
                # We're looking for lexical var or param decls.
                my $qast := $_.value;
                my str $scope := $qast.scope;
                next unless $scope eq 'lexical';
                my str $decl := $qast.decl;
                next unless $decl eq 'param' || $decl eq 'var';

                # Consider name. Can't lower if it's used by any nested blocks.
                my str $name := $_.key;
                unless nqp::existskey(%!usages_inner, $name) {
                    # Lowerable if it's a normal variable.
                    next if nqp::chars($name) < 2;
                    if $name ne 'self' && $name ne '$/' && $name ne '$_' {
                        my str $sigil := nqp::substr($name, 0, 1);
                        next unless $sigil eq '$' || $sigil eq '@' || $sigil eq '%';
                        next unless nqp::iscclass(nqp::const::CCLASS_ALPHABETIC, $name, 1);
                    }

                    # Seems good; lower it.
                    my $new_name := $qast.unique('__lowered_lex');
                    $qast.scope('local');
                    $qast.name($new_name);
                    if %!usages_flat{$name} {
                        for %!usages_flat{$name} {
                            $_.scope('local');
                            $_.name($new_name);
                        }
                    }
                }
            }
        }
    }

    has @!block_stack;
    has @!block_var_stack;
    has %!adverbs;

    method optimize($ast, *%adverbs) {
        %!adverbs := %adverbs;
        @!block_stack := [$ast[0]];
        @!block_var_stack := [BlockVars.new];
        self.visit_children($ast);
        $ast;
    }

    method visit_block($block) {
        # Push block and a new block vars tracking block.
        @!block_stack.push($block);
        @!block_var_stack.push(BlockVars.new);

        # Visit all children, which includes nested blocks.
        self.visit_children($block);

        # Methods with late-bound names poison lowering.
        if nqp::substr($block.name, 0, 12) eq '!!LATENAME!!' {
            self.poison_lowering();
        }

        # Pop the block and the vars info.
        @!block_stack.pop();
        my $vars_info := @!block_var_stack.pop();

        # Lower any declarations we can.
        $vars_info.lexicals_to_locals();

        # If the block has no lexical declarations remaining, and it was an
        # immediate block, then flatten it in.
        my int $flattened := 0;
        if $block.blocktype eq 'immediate' || $block.blocktype eq 'immediate_static' {
            if $vars_info.is_flattenable {
                my @innards := $block.list;
                $block := QAST::Stmts.new( |@innards );
                $flattened := 1;
            }
        }

        # Incorporate this block's info into outer block's info.
        @!block_var_stack[nqp::elems(@!block_var_stack) - 1].incorporate_inner($vars_info, $flattened);

        $block;
    }

    my %opt_n_i := nqp::hash('add', 1, 'sub', 1, 'mul', 1, 'mod', 1, 'neg', 1, 'abs', 1, 'iseq', 1, 'isne', 1,
                             'islt', 1, 'isle', 1, 'isgt', 1, 'isge', 1, 'cmp', 1);
    method visit_op($op) {
        # Handle op needs special handling.
        my str $opname := $op.op;
        if $opname eq 'handle' {
            return self.visit_handle($op);
        }

        # A for loop may be something we can simplify.
        if $opname eq 'for' {
            my $handled := 0;
            my $orig := $op[1].blocktype;
            if $op[1].arity == 1 && $orig eq 'immediate' {
                # Find the iteration parameter.
                my $stmts := $op[1][0];
                my int $i := 0;
                my int $n := nqp::elems($stmts);
                my $itvar;
                while $i < $n {
                    my $item := $stmts[$i];
                    if nqp::istype($item, QAST::Var) && $item.decl eq 'param' {
                        $itvar := $item;
                        last;
                    }
                    $i++;
                }

                # Provided we found it, turn it from param to decl, so it will
                # not prevent inlining. Then visit the children.
                if $itvar {
                    $itvar.decl('var');
                    self.visit_children($op);
                    if nqp::istype($op[1], QAST::Stmts) {
                        # Inlined. Replace iteration var declaration with a lookup of itself.
                        $stmts[$i] := QAST::Var.new( :name($itvar.name), :scope($itvar.scope) );

                        # Produce a while loop that iterates.
                        my $it_name := QAST::Node.unique('lowered_for_it_');
                        return QAST::Stmts.new(
                            QAST::Op.new(
                                :op('bind'),
                                QAST::Var.new( :name($it_name), :scope('local'), :decl('var') ),
                                QAST::Op.new(
                                    :op('iterator'),
                                    $op[0]
                                )
                            ),
                            QAST::Op.new(
                                :op('while'),
                                QAST::Var.new( :name($it_name), :scope('local') ),
                                QAST::Stmts.new(
                                    QAST::Op.new(
                                        :op('bind'),
                                        $itvar,
                                        QAST::Op.new(
                                            :op('shift'),
                                            QAST::Var.new( :name($it_name), :scope('local') )
                                        )),
                                    $op[1]
                                )));
                    }
                    else {
                        # Restore parameter nature of the thing; no inline happened.
                        $itvar.decl('param');
                    }
                    $handled := 1;
                }
            }
            unless $handled {
                $op[1].blocktype('declaration');
                self.visit_children($op);
                $op[1].blocktype($orig);
            }
        }
        else {
            self.visit_children($op);
        }

        # nqp::ctx and nqp::curlexpad capture the current context and so poisons lowering
        if $opname eq 'ctx' || $opname eq 'curlexpad' {
            self.poison_lowering();
        }

        # Consider numeric ops we can simplify.
        my $typeinfo := nqp::chars($opname) > 2
            ?? nqp::substr($opname, nqp::chars($opname) - 2, 2)
            !! "";
        my int $und := nqp::index($opname, '_');
        my str $asm := $und > 0 ?? nqp::substr($opname, 0, $und) !! '';
        if $typeinfo eq '_n' && nqp::existskey(%opt_n_i, $asm) {
            self.num_to_int($op, $asm);
        }

        # Calls to fixed names that are compile-time known can be simplified.
        elsif $opname eq 'call' && $op.name {
            my @sym := self.find_lex_scope_level($op.name);
            if @sym {
                if (@sym[0]<declared> || nqp::existskey(@sym[0], 'value')) && @sym[1] <= 1 {
                    # It's known at compile time and not closure-ish, so we can
                    # use a more optimal call op.
                    $op.op('callstatic');
                }
            }
            else {
                # XXX Can detect missing subs at CHECK-time by doing some kind of
                # error reporting in this branch.
            }
        }

        # Enrich various ops with int/num/str annotations.
        elsif $typeinfo eq '_i' {
            $op.returns(int);
        } elsif $typeinfo eq '_s' {
            $op.returns(str);
        }
        if $opname eq 'numify' {
            # if we can establish that the argument is a list, we are good
            # to claim it returns an int.
            if nqp::istype($op[0], QAST::Var) {
                my $sigil := nqp::substr($op[0].name, 0, 1);
                if $sigil eq '@' || $sigil eq '%' {
                    $op.returns(int)
                }
            }
        }

        $op;
    }

    method num_to_int($op, $asm) {
        sub returns_int($node) {
            if nqp::objprimspec($node.returns) == 1 {
                return 1
            }
            if nqp::istype($node, QAST::Op) {
                my $typeinfo := nqp::chars($node.op) >= 2
                                ?? nqp::substr($node.op, nqp::chars($node.op) - 2, 2)
                                !! "";
                if $typeinfo eq "_i" {
                    return 1
                } elsif $node.op eq 'chars' || $node.op eq 'ord' || $node.op eq 'elems' {
                    return 1
                }
            } elsif nqp::istype($node, QAST::IVal) {
                return 1
            } elsif nqp::istype($node, QAST::Var) && $node.scope eq 'lexical' {
                my %sym := self.find_lex($node.name);
                if nqp::existskey(%sym, 'type') && nqp::objprimspec(%sym<type>) == 1 {
                    return 1
                }
            }
            return 0;
        }

        if returns_int($op[0]) && (nqp::elems($op) == 1 || returns_int($op[1])) {
            my $newopn := $asm ~ "_i";
            $op.op($newopn);
            $op.returns(int);
        } else {
            $op.returns(num);
        }
    }

    method visit_handle($handle) {
        self.visit_children($handle, :skip_selectors);
        $handle;
    }

    method visit_var($var) {
        my str $scope := $var.scope;
        if $scope eq 'attribute' || $scope eq 'positional' || $scope eq 'associative' {
            self.visit_children($var);
        } else {
            my int $top := nqp::elems(@!block_var_stack) - 1;
            my $decl    := $var.decl;
            if $decl {
                @!block_var_stack[$top].add_decl($var);
                if $decl eq 'param' && $var.default -> $default {
                    my $stmts_def := QAST::Stmts.new( $default );
                    self.visit_children($stmts_def);
                    $var.default($stmts_def[0]);
                }
            }
            else {
                @!block_var_stack[$top].add_usage($var);
            }
        }
    }

    method visit_children($node, :$skip_selectors) {
        my int $i := 0;
        unless nqp::isstr($node) || !nqp::defined($node) {
            while $i < +@($node) {
                unless $skip_selectors && $i % 2 {
                    my $visit := $node[$i];
                    if nqp::istype($visit, QAST::Op) {
                        $node[$i] := self.visit_op($visit)
                    } elsif nqp::istype($visit, QAST::Var) {
                        self.visit_var($visit);
                    } elsif nqp::istype($visit, QAST::Block) {
                        $node[$i] := self.visit_block($visit)
                    } elsif nqp::istype($visit, QAST::Want) {
                        self.visit_children($visit, :skip_selectors)
                    } elsif nqp::istype($visit, QAST::Regex) {
                        QRegex::Optimizer.new().optimize($visit,
                            @!block_stack[+@!block_stack - 1],
                            :main_lang_optimizer(sub ($node) {
                                if nqp::istype($node, QAST::Regex) {
                                    if $node.rxtype eq 'subrule' {
                                        # Visit subrule args.
                                        if nqp::istype($node[0], QAST::Node) {
                                            self.visit_children($node[0]);
                                            return $node;
                                        }
                                    }
                                    elsif $node.rxtype eq 'qastnode' {
                                        # QAST node, and probably with statements.
                                        my $child := $node[0];
                                        if nqp::istype($child, QAST::Stmts) ||
                                                nqp::istype($child, QAST::Stmt) {
                                            self.visit_children($child);
                                            return $node;
                                        }
                                    }
                                }

                                # If we reach here, unknown. Poision.
                                self.poison_lowering();
                                return $node;
                            }),
                            |%!adverbs);
                    } else {
                        self.visit_children($visit);
                    }
                }
                $i := $i + 1;
            }
        }
    }

    method find_lex($name) {
        my int $i := +@!block_stack;
        while $i > 0 {
            $i := $i - 1;
            my %sym := @!block_stack[$i].symbol($name);
            if +%sym {
                return %sym;
            }
        }
        NQPMu;
    }

    method find_lex_scope_level($name) {
        my int $i := +@!block_stack;
        while $i > 0 {
            $i := $i - 1;
            my %sym := @!block_stack[$i].symbol($name);
            if +%sym {
                return [%sym, $i];
            }
        }
        NQPMu;
    }

    method find_sym($name) {
        my %sym := self.find_lex($name);
        if nqp::ishash(%sym) && nqp::existskey(%sym, 'value') {
            %sym<value>;
        }
        elsif nqp::ishash(%sym) && nqp::existskey(%sym, 'lazy_value_from') {
            %sym<value> := nqp::atkey(nqp::atkey(%sym, 'lazy_value_from'), $name)
        }
        else {
            nqp::die("No compile-time value for $name");
        }
    }

    method poison_lowering() {
        for @!block_var_stack {
            $_.poison_lowering();
        }
    }
}
# From src/NQP/Actions.nqp

class NQP::Actions is HLL::Actions {
    sub xblock_immediate($xblock) {
        $xblock[1] := block_immediate($xblock[1]);
        $xblock;
    }

    sub block_immediate($block) {
        $block.blocktype('immediate');
        unless $block.symtable() {
            my $stmts := QAST::Stmts.new( :node($block.node) );
            for $block.list { $stmts.push($_); }
            $block := $stmts;
        }
        $block;
    }

    sub default_for($sigil) {
        if $sigil eq '@' {
            QAST::Op.new( :op('list') )
        }
        elsif $sigil eq '%' {
            QAST::Op.new( :op('hash') )
        }
        else {
            my $default;
            try {
                $default := QAST::WVal.new( :value($*W.find_sym(['NQPMu'])) );
                CATCH { $default := QAST::Op.new( :op('null') ) }
            }
            $default
        }
    }

    sub default_value_for_prim($prim) {
        $prim == 1 ?? QAST::IVal.new( :value(0) ) !!
        $prim == 2 ?? QAST::NVal.new( :value(0.0) ) !!
                      QAST::SVal.new( :value('') )
    }

    method TOP($/) { make $<comp_unit>.made; }

    method deflongname($/) {
        make $<colonpair>
             ?? ~$<identifier> ~ ':' ~ $<colonpair>.made.named
                    ~ colonpair_str($<colonpair>.made)
             !! ~$/;
    }

    sub colonpair_str($ast) {
	my $s;
        if nqp::istype($ast, QAST::Op) {
            my @parts;
            for $ast.list { @parts.push($_.value) }
            $s := join(' ', @parts)
        } else {
            $s := $ast.value
        }
	$s ~~ /<[ < > ]>/ ?? '«' ~ $s ~ '»' !! '<' ~ $s ~ '>';
    }

    method comp_unit($/) {
        my $mainline := $<statementlist>.ast;
        my $unit     := $*W.pop_lexpad();
        $unit.name('<mainline>');

        # If our caller wants to know the mainline ctx, provide it here.
        # (CTXSAVE is inherited from HLL::Actions.) Don't do this when
        # there was an explicit {YOU_ARE_HERE}.
        unless $*HAS_YOU_ARE_HERE {
            $unit.push( self.CTXSAVE() );
        }

        # Detect if we're the main unit by if we were given any args. If so,
        # register the mainline as a module (so trying to use ourself in the
        # program will not explode). If we have a MAIN sub, call it at end of
        # mainline.
        $unit.unshift(QAST::Var.new( :scope('lexical'), :name('@ARGS'), :decl('param'), :slurpy(1) ));
        if $*MAIN_SUB {
            $mainline.push(QAST::Op.new(
                :op('if'),
                QAST::Var.new( :scope('lexical'), :name('@ARGS') ),
                QAST::Op.new(
                    :op('call'), :name('&' ~ $*MAIN_SUB.name),
                    QAST::Var.new( :scope('lexical'), :name('@ARGS'), :flat(1) )
                )
            ));
        }

        # Push mainline statements into UNIT.
        $unit.push($mainline);

        # Load the needed libraries.
        $unit.push($*W.libs());

        # Wrap everything in a QAST::CompUnit.
        my $compunit := QAST::CompUnit.new(
            :hll('nqp'),

            # Serialization related bits.
            :sc($*W.sc()),
            :code_ref_blocks($*W.code_ref_blocks()),
            :compilation_mode($*W.is_precompilation_mode()),
            :pre_deserialize($*W.load_dependency_tasks()),
            :post_deserialize($*W.fixup_tasks()),

            # If this unit is loaded as a module, we want it to automatically
            # execute the mainline code above after all other initializations
            # have occurred.
            :load(QAST::Op.new(
                :op('call'),
                QAST::BVal.new( :value($unit) )
            )),

            # If we're executed as the mainline, get the command line args
            # and pass them along.
            :main(QAST::Stmts.new(
                QAST::Op.new(
                    :op('call'),
                    QAST::BVal.new( :value($unit) ),
                    QAST::Var.new( :name('ARGS'), :scope('local'), :decl('param'), :slurpy(1), :flat(1) )
                )
            )),

            # Finally, UNIT, which in turn contains all of the other program
            # elements.
            $unit
        );

        $*W.cleanup();

        make $compunit;
    }

    method statementlist($/) {
        my $ast_list := QAST::Stmts.new( :node($/) );
        if $<statement> {
            for $<statement> {
                my $ast := $_.ast;
                my $sunk := $ast.ann('sink');
                $ast := $sunk if nqp::defined($sunk);
                if $ast.ann('bareblock') { $ast := block_immediate($ast[0]); }
                $ast := QAST::Stmts.new($ast) if nqp::istype($ast, QAST::Node);
                $ast_list.push( $ast );
            }
        }
        else {
            $ast_list.push(default_for('$'));
        }
        make $ast_list;
    }

    method statement($/, $key?) {
        my $ast;
        if $<EXPR> {
            my $mc := $<statement_mod_cond>;
            my $ml := $<statement_mod_loop>;
            $ast := $<EXPR>.ast;
            if $mc {
                $ast := QAST::Op.new($mc<cond>.ast, $ast, :op(~$mc<sym>), :node($/) );
            }
            if $ml {
                if ~$ml<sym> eq 'for' {
                    $ast := QAST::Block.new( :blocktype('immediate'),
                        QAST::Var.new( :name('$_'), :scope('lexical'), :decl('param') ),
                        $ast);
                    $ast.symbol('$_', :scope('lexical') );
                    $ast.arity(1);
                    $ast := QAST::Op.new($ml<cond>.ast, $ast, :op(~$ml<sym>), :node($/) );
                }
                else {
                    $ast := QAST::Op.new($ml<cond>.ast, $ast, :op(~$ml<sym>), :node($/) );
                }
            }
            if $ast.ann('var_initialized') {
                # Variable declared and unconditionally initialized; can strip
                # the added just-to-be-safe initialization of the lexical and
                # just have the var decl.
                my $decls := $*W.cur_lexpad()[0];
                $decls.push($decls.pop()[0]); # First child of bind node is var decl
            }
        }
        elsif $<statement> { $ast := $<statement>.ast; }
        elsif $<statement_control> { $ast := $<statement_control>.ast; }
        else { $ast := 0; }
        make $ast;
    }

    method xblock($/) {
        make QAST::Op.new( $<EXPR>.ast, $<pblock>.ast, :op('if'), :node($/) );
    }

    method pblock($/) {
        make $<blockoid>.ast;
    }

    method block($/) {
        make $<blockoid>.ast;
    }

    method blockoid($/) {
        my $BLOCK := $*W.pop_lexpad();
        if $<statementlist> {
            my $ast := $<statementlist>.ast;
            if %*HANDLERS {
                $ast := QAST::Op.new( :op('handle'), $ast );
                for %*HANDLERS {
                    $ast.push($_.key);
                    $ast.push($_.value);
                }
            }
            $BLOCK.push($ast);
            $BLOCK.node($/);
            $BLOCK.annotate('handlers', %*HANDLERS) if %*HANDLERS;
            make $BLOCK;
        }
        else {
            if $*HAS_YOU_ARE_HERE {
                $/.CURSOR.panic('{YOU_ARE_HERE} may only appear once in a setting');
            }
            $*HAS_YOU_ARE_HERE := 1;
            make $<you_are_here>.ast;
        }
    }

    method newpad($/) {
        $*W.push_lexpad($/)
    }

    method outerctx($/) {
        unless nqp::defined(%*COMPILING<%?OPTIONS><outer_ctx>) {
            # We haven't got a specified outer context already, so load a
            # setting.
            my $SETTING := $*W.load_setting(%*COMPILING<%?OPTIONS><setting> // 'NQPCORE');

            # If it exports HOWs, grab them. Also, if we're loading the
            # setting, also by default load Regex library (we can't load
            # this in the setting as Regex depends on the setting).
            unless %*COMPILING<%?OPTIONS><setting> eq 'NULL' {
                import_HOW_exports($SETTING);
                unless %*COMPILING<%?OPTIONS><no-regex-lib> {
                    if %*COMPILING<%?OPTIONS><custom-regex-lib> -> $lib {
                        $*W.load_module($lib, $*GLOBALish);
                    }
                    else {
                        $*W.load_module('NQPP6QRegex', $*GLOBALish);
                    }
                }
            }
        }
        self.SET_BLOCK_OUTER_CTX($*W.cur_lexpad());
    }

    sub import_HOW_exports($UNIT) {
        # See if we've exported any HOWs.
        if nqp::existskey($UNIT, 'EXPORTHOW') {
            for $UNIT<EXPORTHOW>.WHO {
                %*HOW{$_.key} := $_.value;
            }
        }
    }

    method you_are_here($/) {
        make self.CTXSAVE();
    }

    ## Statement control

    method statement_control:sym<use>($/) {
        my $module := $*W.load_module(~$<name>, $*GLOBALish);
        if nqp::defined($module) {
            $*W.import($module<EXPORT>.WHO<DEFAULT>.WHO)
                if nqp::existskey($module, 'EXPORT') &&
                    nqp::existskey($module<EXPORT>.WHO, 'DEFAULT');
            import_HOW_exports($module);
        }
        make QAST::Stmts.new();
    }

    method statement_control:sym<if>($/) {
        my $count := +$<xblock> - 1;
        my $ast := xblock_immediate( $<xblock>[$count].ast );
        if $<else> {
            $ast.push( block_immediate( $<else>.ast ) );
        }
        # build if/then/elsif structure
        while $count > 0 {
            $count--;
            my $else := $ast;
            $ast := xblock_immediate( $<xblock>[$count].ast );
            $ast.push($else);
        }
        make $ast;
    }

    method statement_control:sym<unless>($/) {
        my $ast := xblock_immediate( $<xblock>.ast );
        $ast.op('unless');
        $/.prune();
        make $ast;
    }

    method statement_control:sym<while>($/) {
        my $ast := xblock_immediate( $<xblock>.ast );
        $ast.op(~$<sym>);
        if $*LABEL {
            $ast.push(QAST::WVal.new( :value($*W.find_sym([$*LABEL])), :named('label') ));
        }
        elsif !$*CONTROL_USED {
            $ast.push(QAST::IVal.new( :value(1), :named('nohandler') ));
        }
        $/.prune();
        make $ast;
    }

    method statement_control:sym<repeat>($/) {
        my $op := 'repeat_' ~ ~$<wu>;
        my $ast;
        if $<xblock> {
            $ast := xblock_immediate( $<xblock>.ast );
            $ast.op($op);
        }
        else {
            $ast := QAST::Op.new( $<EXPR>.ast, block_immediate( $<pblock>.ast ),
                                   :op($op), :node($/) );
        }
        if $*LABEL {
            $ast.push(QAST::WVal.new( :value($*W.find_sym([$*LABEL])), :named('label') ));
        }
        elsif !$*CONTROL_USED {
            $ast.push(QAST::IVal.new( :value(1), :named('nohandler') ));
        }
        $/.prune();
        make $ast;
    }

    method statement_control:sym<for>($/) {
        my $ast := $<xblock>.ast;
        $ast.op('for');
        my $block := $ast[1];
        unless $block.arity {
            $block[0].push( QAST::Var.new( :name('$_'), :scope('lexical'), :decl('param') ) );
            $block.symbol('$_', :scope('lexical') );
            $block.arity(1);
        }
        $block.blocktype('immediate');
        if $*LABEL {
            $ast.push(QAST::WVal.new( :value($*W.find_sym([$*LABEL])), :named('label') ));
        }
        elsif !$*CONTROL_USED {
            $ast.push(QAST::IVal.new( :value(1), :named('nohandler') ));
        }
        $/.prune();
        make $ast;
    }

    method statement_control:sym<CATCH>($/) {
        my $block := $<block>.ast;
        set_block_handler($/, $block, 'CATCH');
        $/.prune();
        make default_for('$');
    }

    method statement_control:sym<CONTROL>($/) {
        my $block := $<block>.ast;
        set_block_handler($/, $block, 'CONTROL');
        $/.prune();
        make default_for('$');
    }

    sub set_block_handler($/, $block, $type) {
        if nqp::existskey(%*HANDLERS, $type) {
            nqp::die("Duplicate $type handler in block");
        }
        unless $block.arity {
            $block.unshift(
                QAST::Op.new( :op('bind'),
                    QAST::Var.new( :scope('lexical'), :name('$!'), :decl('var') ),
                    QAST::Var.new( :scope('lexical'), :name('$_')),
                ),
            );
            $block.unshift(QAST::Var.new( :name('$_'), :scope('lexical'), :decl('param') ));
            $block.symbol('$_', :scope('lexical') );
            $block.symbol('$!', :scope('lexical') );
            $block.arity(1);
        }
        $block.blocktype('declaration');
        %*HANDLERS{$type} := QAST::Stmts.new(
            QAST::Op.new( :op('call'),
                $block,
                QAST::Op.new( :op('exception') ),
            ),
            QAST::VM.new(
                :parrot(QAST::Op.new(
                    :op('bindkey_i'),
                    QAST::Op.new( :op('exception') ),
                    QAST::SVal.new( :value('handled') ),
                    QAST::IVal.new( :value(1) )
                )),
                :jvm(QAST::Op.new( :op('null') )),
                :moar(QAST::Op.new( :op('null') ))
            ),
            default_for('$'));
    }

	method statement_prefix:sym<BEGIN>($/) {
        make $*W.run_begin_block($<blorst>.ast);
        $/.prune();
    }

    method statement_prefix:sym<INIT>($/) {
        $*W.cur_lexpad().push($<blorst>.ast);
        make QAST::Stmts.new();
        $/.prune();
    }

    method statement_prefix:sym<try>($/) {
        my $ast := $<blorst>.ast;
        if nqp::istype($ast, QAST::Block) {
            my $handlers := $ast.ann('handlers');
            if $handlers && nqp::existskey($handlers, 'CATCH') {
                make $ast;
                return 1;
            }
            else {
                $ast.blocktype('immediate');
            }
        }
        make QAST::Op.new(
            :op('handle'),
            $ast,
            'CATCH',
            QAST::Stmts.new(
                QAST::VM.new(
                    :parrot(QAST::Op.new(
                        :op('bindkey_i'),
                        QAST::Op.new( :op('exception') ),
                        QAST::SVal.new( :value('handled') ),
                        QAST::IVal.new( :value(1) )
                    )),
                    :jvm(QAST::Op.new( :op('null') )),
                    :moar(QAST::Op.new( :op('null') ))
                ),
                default_for('$')
            ));
        $/.prune();
    }

    method blorst($/) {
        make $<block>
             ?? block_immediate($<block>.ast)
             !! $<statement>.ast;
        $/.prune();
    }

    # Statement modifiers

    method statement_mod_cond:sym<if>($/)     { make $<cond>.ast; }
    method statement_mod_cond:sym<unless>($/) { make $<cond>.ast; }

    method statement_mod_loop:sym<while>($/)  { make $<cond>.ast; }
    method statement_mod_loop:sym<until>($/)  { make $<cond>.ast; }

    ## Terms

    method term:sym<fatarrow>($/)           { make $<fatarrow>.ast; }
    method term:sym<colonpair>($/)          { make $<colonpair>.ast; }
    method term:sym<variable>($/)           { make $<variable>.ast; }
    method term:sym<package_declarator>($/) { make $<package_declarator>.ast; }
    method term:sym<scope_declarator>($/)   { make $<scope_declarator>.ast; }
    method term:sym<routine_declarator>($/) { make $<routine_declarator>.ast; }
    method term:sym<regex_declarator>($/)   { make $<regex_declarator>.ast; }
    method term:sym<statement_prefix>($/)   { make $<statement_prefix>.ast; }
    method term:sym<lambda>($/) {
        make QAST::Op.new( :op('takeclosure'), $<pblock>.ast );
    }

    method fatarrow($/) {
        my $ast := $<val>.ast;
        $ast.named( $<key>.Str );
        make $ast;
        $/.prune;
    }

    method colonpair($/) {
        if $<variable> {
            $<variable>.ast.named(~$<variable><desigilname>);
            make $<variable>.ast;
        } else {
            my $ast := $<circumfix>
                        ?? $<circumfix>.ast
                        !! QAST::IVal.new( :value( !$<not> ) );
            $ast.named( ~$<identifier> );
            make $ast;
        }
        $/.prune;
    }

    method variable($/) {
        my $ast;
        if $<postcircumfix> {
            $ast := $<postcircumfix>.ast;
            $ast.unshift(QAST::VarWithFallback.new(
                :name('$/'), :scope('lexical'), :fallback(default_for('$'))
            ));
        }
        else {
            my @name := NQP::Compiler.parse_name(~$/);
            if +@name > 1 {
                if $<twigil> {
                    $/.CURSOR.panic("Twigil not allowed on multi-part name");
                }
                $ast := lexical_package_lookup(@name, $/);
            }
            elsif $<twigil> eq '*' {
                my $global_fallback := QAST::Op.new(
                    :op('ifnull'),
                    lexical_package_lookup(['GLOBAL',  ~$<sigil> ~ $<desigilname>], $/),
                    QAST::Op.new(
                        :op('die_s'),
                        QAST::SVal.new( :value('Contextual ' ~ ~$/ ~ ' not found') )
                    ));
                $ast := QAST::VarWithFallback.new(
                    :name(~@name.pop), :scope('contextual'),
                    :fallback($global_fallback)
                );
            }
            elsif $<twigil> eq '!' {
                my $name := ~@name.pop;
                my $ch;
                if $*PKGDECL eq 'role' {
                    $ch := QAST::Var.new( :name('$?CLASS'), :scope('typevar') );
                    $ch.set_compile_time_value($*PACKAGE);
                }
                else {
                    $ch := QAST::WVal.new( :value($*PACKAGE) );
                }
                $ast := QAST::Var.new(
                    :name($name), :scope('attribute'),
                    QAST::Op.new( :op('decont'),
                        QAST::Var.new( :name('self'), :scope('lexical') ) ),
                    $ch
                );

                # Make sure the attribute exists and add type info.
                unless $*IN_DECL {
                    my $attr;
                    for $*PACKAGE.HOW.attributes($*PACKAGE, :local(1)) {
                        if $_.name eq $name {
                            $attr := $_;
                            last;
                        }
                    }
                    if nqp::defined($attr) {
                        if nqp::can($attr, 'type') {
                            $ast.returns($attr.type);
                        }
                    }
                    else {
                        $/.CURSOR.panic("Attribute '$name' not declared");
                    }
                }
            }
            elsif $<semilist> {
                my $name := ~$<sigil> eq '@' ?? 'list' !!
                            ~$<sigil> eq '%' ?? 'hash' !!
                                                'item';
                $ast := QAST::Op.new( :op('callmethod'), :name($name), $<semilist>.ast );
            }
            elsif $*W.is_package(~@name[0]) {
                $ast := lexical_package_lookup(@name, $/);
                $ast.fallback( default_for( $<sigil> ) );
            }
            else {
                my str $name := ~@name.pop;
                my int $is_lex := 0;
                if $*IN_DECL eq 'variable' || $name eq '$_' || $name eq '$/' || $name eq '$¢'
                || $name eq '$!' || $<twigil> eq '?' || ($is_lex := $*W.is_lexical($name)) {
                    $ast := QAST::Var.new( :name($name),
                        :scope($name eq '$?CLASS' ?? 'typevar' !! 'lexical') );
                    $ast.returns($*W.lexical_type($name)) if $is_lex;
                }
                else {
                    $/.CURSOR.panic("Use of undeclared variable '$name'");
                }
            }
        }
        make $ast;
    }

    method package_declarator:sym<module>($/)  { make $<package_def>.ast }
    method package_declarator:sym<knowhow>($/) { make $<package_def>.ast }
    method package_declarator:sym<class>($/)   { make $<package_def>.ast }
    method package_declarator:sym<grammar>($/) { make $<package_def>.ast }
    method package_declarator:sym<role>($/)    { make $<package_def>.ast }
    method package_declarator:sym<native>($/)  { make $<package_def>.ast }

    method package_declarator:sym<stub>($/) {
        # Construct meta-object with specified metaclass, adding it to the
        # serialization context for this compilation unit.
        my $HOW := $*W.find_sym($<metaclass><identifier>);
        my $PACKAGE := $*W.pkg_create_mo($HOW, :name(~$<name>));

        # Install it in the current package or current lexpad as needed.
        if $*SCOPE eq 'our' || $*SCOPE eq '' {
            $*W.install_package_symbol($*OUTERPACKAGE, $<name><identifier>, $PACKAGE);
            if +$<name><identifier> == 1 {
                $*W.install_lexical_symbol($*W.cur_lexpad(), ~$<name><identifier>[0], $PACKAGE);
            }
        }
        elsif $*SCOPE eq 'my' {
            if +$<name><identifier> != 1 {
                $<name>.CURSOR.panic("A my scoped package cannot have a multi-part name yet");
            }
            $*W.install_lexical_symbol($*W.cur_lexpad(), ~$<name><identifier>[0], $PACKAGE);
        }
        else {
            $/.CURSOR.panic("$*SCOPE scoped packages are not supported");
        }

        make QAST::Stmts.new();
        $/.prune;
    }

    method package_def($/) {
        # Get name and meta-object.
        my @ns := nqp::clone($<name><identifier>);
        my $name := ~@ns.pop;
        my $how := %*HOW{$*PKGDECL};

        # Get the body code.
        my $ast;
        if $<blockoid> {
            $ast := $<blockoid>.ast;
        }
        else {
            $ast := $*W.pop_lexpad();
            $ast.push($<statementlist>.ast);
        }

        # Evaluate everything in the package in-line unless this is a generic
        # type in which case it needs delayed evaluation. Normally, $?CLASS is
        # a fixed lexical, but for generic types it becomes a parameter. Also
        # for parametric types, pass along the role body block.
        if nqp::can($how, 'parametric') && $how.parametric($how) {
            $ast.blocktype('declaration_static');
            my $params := QAST::Stmts.new(
                QAST::Var.new( :name('$?CLASS'), :scope('lexical'), :decl('param') )
            );
            if $<role_params> {
                for $<role_params><variable> {
                    $params.push($_.ast);
                }
            }
            $ast.unshift($params);
            $ast.push(QAST::Op.new( :op('curlexpad') ));
            $ast.symbol('$?CLASS', :scope('lexical'));
            $*W.pkg_set_body_block($*PACKAGE, $ast);
        }
        else {
            $ast.blocktype('immediate');
        }

        # Add parent, if we have one; otherwise set default.
        if $<parent> {
            my $parent;
            my $parent_found;
            try {
                $parent := $*W.find_sym(nqp::clone($<parent><identifier>));
                $parent_found := 1;
            }
            if $parent_found {
                $*W.pkg_add_parent_or_role($*PACKAGE, "add_parent", $parent);
            }
            else {
                $/.CURSOR.panic("Could not find parent class '" ~ ~$<parent> ~ "'");
            }
        }
        elsif nqp::can($how, 'set_default_parent') {
            my $default := $*PKGDECL eq 'grammar' ?? ['NQPCursor'] !! ['NQPMu'];
            $*W.pkg_add_parent_or_role($*PACKAGE, "set_default_parent",
                $*W.find_sym($default));
        }

        # Add any done roles.
        if $<role> {
            for $<role> {
                my $role;
                my $role_found;
                try {
                    $role := $*W.find_sym(nqp::clone($_<identifier>));
                    $role_found := 1;
                }
                if $role_found {
                    $*W.pkg_add_parent_or_role($*PACKAGE, "add_role", $role);
                }
                else {
                    $/.CURSOR.panic("Could not find role '" ~ ~$_ ~ "'");
                }
            }
        }

        # Extra traits, if present.
        if $<nativesize> {
            $*PACKAGE.HOW.set_nativesize($*PACKAGE, nqp::add_i($<size>, 0));
        }
        if $<unsigned> {
            $*PACKAGE.HOW.set_unsigned($*PACKAGE, 1);
        }

        # Finally, compose.
        $*W.pkg_compose($*PACKAGE);

        # If it's a grammar, pre-compute the NFAs.
        if $*PKGDECL eq 'grammar' && nqp::can($*PACKAGE, '!precompute_nfas') {
            $*PACKAGE.'!precompute_nfas'();
        }

        # Export if needed.
        if $<export> {
            $*EXPORT.WHO<DEFAULT>.WHO{$name} := $*PACKAGE;
        }

        make $ast;
        $/.prune;
    }

    method role_params($/) {
        for $<variable> {
            my $var := $_.ast;
            $var.scope('lexical');
            $var.decl('param');
            $*W.cur_lexpad().symbol($var.name, :scope('lexical'));
        }
    }

    method scope_declarator:sym<my>($/)  { make $<scoped>.ast; $/.prune }
    method scope_declarator:sym<our>($/) { make $<scoped>.ast; $/.prune }
    method scope_declarator:sym<has>($/) { make $<scoped>.ast; $/.prune }

    method scoped($/) {
        make $<declarator>       ?? $<declarator>.ast !!
             $<multi_declarator> ?? $<multi_declarator>.ast !!
                                    $<package_declarator>.ast;
        $/.prune;
    }

    method declarator($/) {
        make $<routine_declarator>
             ?? $<routine_declarator>.ast
             !! $<variable_declarator>.ast;
    }

    method multi_declarator:sym<multi>($/) { make $<declarator> ?? $<declarator>.ast !! $<routine_def>.ast; $/.prune }
    method multi_declarator:sym<proto>($/) { make $<declarator> ?? $<declarator>.ast !! $<routine_def>.ast; $/.prune }
    method multi_declarator:sym<null>($/)  { make $<declarator>.ast; $/.prune }


    method variable_declarator($/) {
        my $ast := $<variable>.ast;
        my $sigil := $<variable><sigil>;
        my $name := $ast.name;
        my $BLOCK := $*W.cur_lexpad();
        my $*DECLARAND_ATTR;
        if $name && $BLOCK.symbol($name) {
            $/.CURSOR.panic("Redeclaration of symbol ", $name);
        }
        if $*SCOPE eq 'has' {
            # Initializer not allowed.
            if $<initializer> {
                $/.CURSOR.panic('Initiailizers not supported on has-scoped variables');
            }

            # Locate the type of meta-attribute we need.
            unless nqp::existskey(%*HOW, $*PKGDECL ~ '-attr') {
                $/.CURSOR.panic("$*PKGDECL packages do not support attributes");
            }

            # Set up arguments for meta-attribute instantiation.
            my %lit_args;
            my %obj_args;
            %lit_args<name> := $name;
            if $<typename> {
                %obj_args<type> := $*W.find_sym([~$<typename>]);
            }
            if $sigil eq '$' || $sigil eq '&' {
                if $<typename> {
                    %obj_args<default> := %obj_args<type>;
                }
                else {
                    try %obj_args<default> := $*W.find_sym(['NQPMu']);
                }
            }

            # Add it.
            $*DECLARAND_ATTR := $*W.pkg_add_attribute($*PACKAGE, %*HOW{$*PKGDECL ~ '-attr'},
                %lit_args, %obj_args);

            $ast := QAST::Stmts.new();
        }
        elsif $*SCOPE eq 'our' {
            # Depending on if this was already considered our scoped,
            # we may or may not have got a node in $var that's set up
            # right already. We build it here just to be sure.
            if $<typename> {
                $/.CURSOR.panic("Cannot put types on our-scoped variables");
            }
            $name := ~$<variable>;
            $ast := lexical_package_lookup([$name], $/);
            $BLOCK.symbol($name, :scope('package') );
            if $<initializer> {
                $ast := QAST::Op.new( :op('bind'), $ast, $<initializer>.ast );
            }
        }
        else {
            my $type;
            my $default;
            if $<typename> {
                unless $sigil eq '$' {
                    $/.CURSOR.panic("Only typed scalars are currently supported in NQP");
                }
                $type := $*W.find_sym([~$<typename>]);
                if nqp::objprimspec($type) -> $prim_spec {
                    $default := default_value_for_prim($prim_spec);
                }
                else {
                    $/.CURSOR.panic("Only native types are currently supported/checked");
                }
            }
            else {
                $default := default_for($sigil);
            }
            $BLOCK[0].push(QAST::Op.new(
                :op('bind'), :node($/),
                QAST::Var.new( :name($name), :scope('lexical'), :decl('var'), :returns($type) ),
                $default
            ));
            if $<initializer> {
                $ast := QAST::Op.new( :op('bind'), :node($/), $ast, $<initializer>.ast );
                $ast.annotate('var_initialized', 1);
            }
            $BLOCK.symbol($name, :scope('lexical'), :type($type) );
        }

        # Apply traits.
        if $<trait> {
            for $<trait> { $_.ast()($/); }
        }

        make $ast;
        $/.prune;
        $/.prune;
    }

    method initializer($/) {
        make $<EXPR>.ast;
        $/.prune;
    }

    method routine_declarator:sym<sub>($/) { make $<routine_def>.ast; $/.prune }
    method routine_declarator:sym<method>($/) { make $<method_def>.ast; $/.prune }

    method routine_def($/) {
        # If it's just got * as a body, make a multi-dispatch enterer.
        # Otherwise, need to build a sub.
        my $ast;
        my int $onlystar;
        if $<onlystar> {
            $ast := only_star_block();
            $onlystar := 1;
        }
        else {
            $ast := $<blockoid>.ast;
            if $*RETURN_USED {
                $ast[1] := wrap_return_handler($ast[1]);
            }
        }
        $ast.blocktype('declaration');
        my $block := $ast;

        if $<deflongname> {
            my $name := ~$<sigil> ~ $<deflongname>.ast;
            $ast.name($name);
            if $*SCOPE eq '' || $*SCOPE eq 'my' || $*SCOPE eq 'our' {
                if $*MULTINESS eq 'multi' {
                    # Does the current block have a proto?
                    if $*SCOPE eq 'our' { nqp::die('a multi can not be our-scoped') }
                    my $proto;
                    my %sym := $*W.cur_lexpad().symbol('&' ~ $name);
                    if %sym<proto> {
                        $proto := %sym<value>;
                    }

                    # Otherwise, no candidate holder, so add one.
                    else {
                        # Check we have a proto in scope.
                        my $found_proto;
                        for $*W.get_legacy_block_list() {
                            my %sym := $_.symbol('&' ~ $name);
                            if %sym<proto> {
                                $proto := %sym<value>;
                                $found_proto := 1;
                            }
                            elsif %sym {
                                $/.CURSOR.panic("Cannot declare a multi when an only is already in scope.");
                            }
                        }

                        # If we didn't find a proto, error for now.
                        unless $found_proto {
                            $/.CURSOR.panic("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.");
                        }

                        # Set up dispatch routine in this scope.
						nqp::die("Dispatcher derivation NYI");
                    }

                    # Create a code object and attach the signature.
                    my $code := $*W.create_code($ast, $name, 0);
                    attach_multi_signature($code, $ast);

                    # Add this candidate to the proto.
                    $proto.add_dispatchee($code);

                    # Ensure we emit the code block.
                    # XXX We'll mark it static so the code object inside the
                    # proto is captured correctly. Technically this is wrong,
                    # as the multi may be nested in another sub.
                    $ast.blocktype('declaration_static');
                    my $BLOCK := $*W.cur_lexpad();
					$BLOCK[0].push($ast);
                }
                elsif $*MULTINESS eq 'proto' {
                    # Create a candidate list holder for the dispatchees
                    # this proto will work over, and install them along
                    # with the proto.
                    if $*SCOPE eq 'our' { nqp::die('our-scoped protos not yet implemented') }
                    my $code := $*W.create_code($ast, $name, 1, :$onlystar);
                    my $BLOCK := $*W.cur_lexpad();
					$BLOCK[0].push(QAST::Op.new(
                        :op('bind'),
                        QAST::Var.new( :name('&' ~ $name), :scope('lexical'), :decl('var') ),
                        $ast
                    ));
                    $BLOCK.symbol('&' ~ $name, :scope('lexical'), :proto(1), :value($code), :declared(1) );

                    # Also stash the current lexical dispatcher and capture, for the {*}
                    # to resolve.
                    $block[0].push(QAST::Op.new(
                        :op('bind'),
                        QAST::Var.new( :name('CURRENT_DISPATCH_CAPTURE'), :scope('lexical'), :decl('var') ),
                        QAST::Op.new( :op('savecapture') )
                    ));
                    $block[0].push(QAST::Op.new(
                        :op('bind'),
                        QAST::Var.new( :name('&*CURRENT_DISPATCHER'), :scope('lexical'), :decl('var') ),
                        QAST::Op.new( :op('getcodeobj'), QAST::Op.new( :op('curcode') ) )
                    ));
                }
                else {
                    my $BLOCK := $*W.cur_lexpad();
					$BLOCK[0].push(QAST::Op.new(
                        :op('bind'),
                        QAST::Var.new( :name('&' ~ $name), :scope('lexical'), :decl('var') ),
                        $ast
                    ));
                    $BLOCK.symbol('&' ~ $name, :scope('lexical'), :declared(1));
                    if $*SCOPE eq 'our' {
                        # Need to install it at loadinit time but also re-bind
                        # it per invocation.
                        $*W.install_package_routine($*PACKAGE, $name, $ast);
                        $BLOCK[0].push(QAST::Op.new(
                            :op('bind'),
                            lexical_package_lookup([$name], $/),
                            QAST::Var.new( :name('&' ~ $name), :scope('lexical') )
                        ));

                        # Static code object needs re-capturing also, as it's
                        # our-scoped.
                        $ast.blocktype('declaration_static');

                        # Also need to make sure it gets a code object so it's
                        # in the SC.
                        $*W.create_code($ast, $name, 0);
                    }
                }
                $ast := QAST::Var.new( :name('&' ~ $name), :scope('lexical') );
            }
            else {
                $/.CURSOR.panic("$*SCOPE scoped routines are not supported yet");
            }

            # Is it the MAIN sub?
            if $name eq 'MAIN' && $*MULTINESS ne 'multi' {
                $*MAIN_SUB := $block;
            }
        }
        else {
            if $*W.is_precompilation_mode() {
                $*W.create_code($ast, '<anon>', 0)
            }
        }

        my $lex_ast := QAST::Op.new( :op('takeclosure'), $ast );
        $lex_ast.annotate('sink', $ast);
        $lex_ast.annotate('block_ast', $block);
        make $lex_ast;

        # Apply traits.
        if $<trait> {
            for $<trait> { $_.ast()($/); }
        }
        $/.prune;
    }

    method method_def($/) {
        # If it's just got * as a body, make a multi-dispatch enterer.
        # Otherwise, build method block QAST.
        my $ast;
        my int $onlystar;
        if $<onlystar> {
            $ast := only_star_block();
            $onlystar := 1;
        }
        else {
            $ast := $<blockoid>.ast;
            if $*RETURN_USED {
                $ast[1] := wrap_return_handler($ast[1]);
            }
        }
        $ast.blocktype('declaration_static');

        # Always need an invocant.
        unless $ast.ann('signature_has_invocant') {
            $ast[0].unshift(QAST::Var.new(
                :name('self'), :scope('lexical'), :decl('param'),
                :returns($*PACKAGE)
            ));
        }
        $ast.symbol('self', :scope('lexical') );

        # Install it where it should go (methods table / namespace).
        my $name := "";
        if $<deflongname> {
            $name := ~$<private> ~ ~$<deflongname>.ast;
        }
        elsif $<latename> {
            if $*PKGDECL ne 'role' {
                $/.CURSOR.panic("Late-bound method name only valid in role");
            }
            $name := "!!LATENAME!!" ~ ~$<latename>;
        }
        if $name ne "" {
            # Set name.
            $ast.name($name);

            # Insert it into the method table.
            my $meta_meth := $*MULTINESS eq 'multi' ?? 'add_multi_method' !! 'add_method';
            my $is_dispatcher := $*MULTINESS eq 'proto';
            my $code := $*W.create_code($ast, $name, $is_dispatcher, :$onlystar);
            if $*MULTINESS eq 'multi' { attach_multi_signature($code, $ast); }
            $*W.pkg_add_method($*PACKAGE, $meta_meth, $name, $code);
            $ast.annotate('code_obj', $code);

            # Install it in the package also if needed.
            if $*SCOPE eq 'our' {
                $*W.install_package_routine($*PACKAGE, $name, $ast);
            }

            # If it's a proto, also stash the current lexical dispatcher, for the {*}
            # to resolve.
            if $is_dispatcher {
                $ast[0].push(QAST::Op.new(
                    :op('bind'),
                    QAST::Var.new( :name('CURRENT_DISPATCH_CAPTURE'), :scope('lexical'), :decl('var') ),
                    QAST::Op.new( :op('savecapture') )
                ));
                $ast[0].push(QAST::Op.new(
                    :op('bind'),
                    QAST::Var.new( :name('&*CURRENT_DISPATCHER'), :scope('lexical'), :decl('var') ),
                    QAST::Op.new( :op('getcodeobj'), QAST::Op.new( :op('curcode') ) )
                ));
            }
        }

        # Install AST node in match object, then apply traits.
        my $lex_ast := QAST::Op.new( :op('takeclosure'), $ast );
        $lex_ast.annotate('sink', $ast);
        $lex_ast.annotate('block_ast', $ast);
        $lex_ast.annotate('code_obj', $ast.ann('code_obj'));
        make $lex_ast;
        if $<trait> {
            for $<trait> { $_.ast()($/); }
        }
        $/.prune;
    }

    sub only_star_block() {
        my $ast := $*W.pop_lexpad();
        $ast.push(QAST::Op.new(
            :op('invokewithcapture'),
            QAST::Op.new(
                :op('ifnull'),
                QAST::Op.new(
                    :op('multicachefind'),
                    QAST::Var.new(
                        :name('$!dispatch_cache'), :scope('attribute'),
                        QAST::Op.new( :op('getcodeobj'), QAST::Op.new( :op('curcode') ) ),
                        QAST::WVal.new( :value($*W.find_sym(['NQPRoutine'])) ),
                    ),
                    QAST::Op.new( :op('usecapture') )
                ),
                QAST::Op.new(
                    :op('callmethod'), :name('dispatch'),
                    QAST::Op.new( :op('getcodeobj'), QAST::Op.new( :op('curcode') ) ),
                    QAST::Op.new( :op('savecapture') )
                )
            ),
            QAST::Op.new( :op('usecapture') )
        ));
        $ast
    }

    sub attach_multi_signature($code_obj, $routine) {
        my $types := nqp::list();
        my $definednesses := nqp::list();
        for @($routine[0]) {
            if nqp::istype($_, QAST::Var) && $_.decl eq 'param' && !$_.named {
                $types.push($_.returns =:= NQPMu
                    ?? nqp::null()
                    !! $_.returns);
                my $defann := $_.ann('definedness');
                $definednesses.push($defann eq 'D' ?? 1 !!
                                    $defann eq 'U' ?? 2 !! 0);
            }
        }
        $*W.set_routine_signature($code_obj, $types, $definednesses);
    }

    sub wrap_return_handler($ast) {
        QAST::Op.new(
            :op<lexotic>, :name<RETURN>,
            $ast
        )
    }

    method signature($/) {
		my $BLOCK     := $*W.cur_lexpad();
        my $BLOCKINIT := $BLOCK[0];
        if $<invocant> {
            my $inv := $<invocant>.ast;
            $BLOCKINIT.push($inv);
            $BLOCKINIT.push(QAST::Op.new(
                :op('bind'),
                QAST::Var.new( :name('self'), :scope('lexical'), :decl('var') ),
                QAST::Var.new( :scope('lexical'), :name($inv.name) )
            ));
            $BLOCK.annotate('signature_has_invocant', 1);
        }
        if $<parameter> {
            for $<parameter> { $BLOCKINIT.push($_.ast); }
        }
        $/.prune;
    }

    method parameter($/) {
        my $quant := $<quant>;
        my $ast;
        if $<named_param> {
            $ast := $<named_param>.ast;
            if $quant ne '!' {
                $ast.default( default_for($<named_param><param_var><sigil>) );
            }
        }
        else {
            $ast := $<param_var>.ast;
            if $quant eq '*' {
                $ast.slurpy(1);
                $ast.named( $<param_var><sigil> eq '%' );
            }
            elsif $quant eq '?' {
                $ast.default( default_for($<param_var><sigil>) );
            }
        }
        if $<default_value> {
            if $quant eq '*' {
                $/.CURSOR.panic("Can't put default on slurpy parameter");
            }
            if $quant eq '!' {
                $/.CURSOR.panic("Can't put default on required parameter");
            }
            $ast.default( $<default_value>[0]<EXPR>.ast );
        }
        unless $ast.default { $*W.cur_lexpad().arity( +$*W.cur_lexpad().arity + 1 ); }

        # Set the type of the parameter.
        if $<typename> {
            my $type := $<typename>[0].ast.value;
            $ast.returns($type);
            if nqp::objprimspec($type) -> $prim {
                $*W.cur_lexpad().symbol($ast.name, :type($type));
                if $ast.default && !$<default_value> {
                    $ast.default(default_value_for_prim($prim));
                }
            }
        }

        # Set definedness flag (XXX want a better way to do this).
        if $<definedness> {
            $ast.annotate('definedness', ~$<definedness>[0]);
        }

        make $ast;
        $/.prune();
    }

    method param_var($/) {
        my $name := ~$/;
        my $ast :=  QAST::Var.new( :name($name), :scope('lexical'),
                                    :decl('param'), :node($/) );
        $*W.cur_lexpad().symbol($name, :scope('lexical') );
        make $ast;
    }

    method named_param($/) {
        my $ast := $<param_var>.ast;
        $ast.named( ~$<param_var><name> );
        make $ast;
    }

    method typename($/) {
        # Try to locate the symbol. We'll emit a lookup via the SC so
        # the scope we emit code to do the symbol lookup in won't matter,
        # and so we can complain about non-existent type names.
        my @name := HLL::Compiler.parse_name(~$/);
        my $found := 0;
        try {
            my $sym := $*W.find_sym(@name);
            make QAST::WVal.new( :value($sym) );
            $found := 1;
        }
        unless $found {
            $/.CURSOR.panic("Use of undeclared type '" ~ ~$/ ~ "'");
        }
        $/.prune;
    }

    method trait($/) {
        make $<trait_mod>.ast;
        $/.prune;
    }

    method trait_mod:sym<is>($/) {
        if $<longname> eq 'parrot_vtable' {
            # XXX This should be in Parrot-specific module and need a pragma.
            my $c_ast := $<circumfix>[0].ast;
            $/.CURSOR.panic("Trait 'parrot_vtable' requires constant scalar argument")
                unless $c_ast ~~ QAST::SVal;
            my $name := $c_ast.value;
            my $package := $*PACKAGE;
            my $is_dispatcher := $*SCOPE eq 'proto';
            make -> $match {
                $*W.pkg_add_method($package, 'add_parrot_vtable_mapping', $name,
                    $match.ast.ann('code_obj') //
                        $*W.create_code($match.ast.ann('block_ast'), $name, $is_dispatcher));
            };
        }
        elsif $<longname> eq 'parrot_vtable_handler' {
            # XXX This should be in Parrot-specific module and need a pragma.
            my $c_ast := $<circumfix>[0].ast;
            $/.CURSOR.panic("Trait 'parrot_vtable_handler' requires constant scalar argument")
                unless $c_ast ~~ QAST::SVal;
            my $name := $c_ast.value;
            my $package := $*PACKAGE;
            make -> $match {
                $*W.pkg_add_parrot_vtable_handler_mapping($package, $name, ~$match<variable>);
            };
        }
        elsif $<longname> eq 'positional_delegate' {
            make -> $m { $*DECLARAND_ATTR.set_positional_delegate(1) };
        }
        elsif $<longname> eq 'associative_delegate' {
            make -> $m { $*DECLARAND_ATTR.set_associative_delegate(1) };
        }
        elsif $<longname> eq 'export' {
            make -> $match {
                my $ast  := $match.ast;
                my $name := $ast.ann('block_ast').name;
                $*EXPORT.WHO<DEFAULT>.WHO{'&' ~ $name} := $ast.ann('code_obj') //
                    $*W.create_code($ast.ann('block_ast'), $name, 0);
            };
        }
        else {
            $/.CURSOR.panic("Trait '$<longname>' not implemented");
        }
        $/.prune;
    }

    method regex_declarator($/, $key?) {
        my $name;
        if $<deflongname> {
            $name := ~$<deflongname>.ast;
        }
        else {
            if $*PKGDECL ne 'role' {
                $/.CURSOR.panic("Late-bound method name only valid in role");
            }
            $name := "!!LATENAME!!" ~ ~$<latename>;
        }
        my $ast;
        if $<proto> {
            $ast := QAST::Block.new(
                    :name($name),
                    QAST::Op.new(
                        QAST::Var.new( :name('self'), :scope('local'), :decl('param') ),
                        QAST::SVal.new( :value($name) ),
                        :name('!protoregex'),
                        :op('callmethod')
                    ),
                    :blocktype('declaration_static'),
                    :node($/)
                );
                $*W.pkg_add_method($*PACKAGE, 'add_method', $name,
                    $*W.create_code($ast, $name, 0, :code_type_name<NQPRegex>));
        }
        else {
            my $block := $*W.pop_lexpad();
            $block[0].unshift(QAST::Var.new(:name<self>, :scope<lexical>, :decl<param>));
            $block[0].push(QAST::Op.new(
                :op('bind'),
                QAST::Var.new(:name<self>, :scope<local>, :decl<var> ),
                QAST::Var.new( :name<self>, :scope('lexical') )));
            $block[0].push(QAST::Var.new(:name<$¢>, :scope<lexical>, :decl<var>));
            $block[0].push(QAST::Var.new(:name<$/>, :scope<lexical>, :decl<var>));
            $block.symbol('$¢', :scope<lexical>);
            $block.symbol('$/', :scope<lexical>);
            my $code  := %*RX<code>;
            my $regex := %*LANG<Regex-actions>.qbuildsub($<p6regex>.ast, $block,
                code_obj => $code, cursor_type => $*W.find_sym(['NQPCursor']));
            $regex.name($name);

            if $*PKGDECL && nqp::can($*PACKAGE.HOW, 'add_method') {
                # Add the actual method, marking it as a static declaration
                # since it's reachable through the method table.
                $block.blocktype('declaration_static');
                $*W.pkg_add_method($*PACKAGE, 'add_method', $name, $code);
            }

            # If this appears in a role, its NFA may depend on generic args.
            # If it does, we store the generic version of it.
            if $*PKGDECL eq 'role' {
                my $gen_nfa := QRegex::NFA.new();
                $gen_nfa.addnode($<p6regex>.ast, :vars_as_generic);
                if $gen_nfa.generic {
                    $code.SET_GENERIC_NFA($gen_nfa);
                }
            }

            # In sink context, we don't need the Regex::Regex object.
            $ast := QAST::Op.new(
                :op<callmethod>, :name<new>,
                lexical_package_lookup(['NQPRegexMethod'], $/),
                $regex);
            $ast.annotate('sink', $regex);
        }
        make $ast;
    }


    method dotty($/) {
        my $ast := $<args> ?? $<args>[0].ast !! QAST::Op.new( :node($/) );
        if $<quote> {
            $ast.unshift($<quote>.ast);
            $ast.op('callmethod');
        }
        elsif $<longname> eq 'HOW' {
            $ast.op('how');
        }
        elsif $<longname> eq 'WHAT' {
            $ast.op('what');
        }
        elsif $<longname> eq 'WHO' {
            $ast.op('who');
        }
        elsif $<longname> eq 'REPR' {
            $ast.op('reprname');
        }
        else {
            $ast.name(~$<longname>);
            $ast.op('callmethod');
        }
        make $ast;
        $/.prune;
    }

    ## Terms

    method term:sym<self>($/) {
        make QAST::Op.new( :op('decont'),
            QAST::Var.new( :name('self'), :scope('lexical') ) );
    }

    method term:sym<identifier>($/) {
        my $ast := $<args>.ast;
        $ast.name('&' ~ ~$<deflongname>);
        make $ast;
        $/.prune;
    }

    method term:sym<name>($/) {
        # See if it's a lexical symbol (known in any outer scope).
        my $var;
        if $*W.is_lexical(~$<name>) {
            unless $<args> {
                try {
                    my $sym := $*W.find_sym([~$<name>]);
                    unless nqp::isnull(nqp::getobjsc($sym)) {
                        $var := QAST::WVal.new( :value($sym) );
                    }
                }
            }
            unless $var {
                $var := QAST::Var.new( :name(~$<name>), :scope('lexical') );
            }
        }
        else {
            my @ns := nqp::clone($<name><identifier>);
            unless $<args> {
                try {
                    my $sym := $*W.find_sym(@ns);
                    unless nqp::isnull(nqp::getobjsc($sym)) {
                        $var := QAST::WVal.new( :value($sym) );
                    }
                }
            }
            unless $var {
                $var := lexical_package_lookup(@ns, $/);
            }
        }

        # If it's a call, add the arguments.
        my $ast := $var;
        if $<args> {
            $ast := $<args>[0].ast;
            $ast.unshift($var);
        }
        make $ast;
        $/.prune;
    }

    method term:sym<pir::op>($/) {
        my @args := $<args> ?? $<args>[0].ast.list !! [];
        my $pirop := ~$<op>;
        $pirop := join(' ', nqp::split('__', $pirop));
        make QAST::VM.new( :pirop($pirop), :node($/), |@args );
        $/.prune;
    }

    method term:sym<pir::const>($/) {
        make QAST::VM.new( :pirconst(~$<const>) );
        $/.prune;
    }

    method term:sym<nqp::op>($/) {
        my $op    := ~$<op>;
        my @args  := $<args> ?? $<args>[0].ast.list !! [];
        my $ast  := QAST::Op.new( :op($op), |@args, :node($/) );
        make $ast;
        $/.prune;
    }

    method term:sym<nqp::const>($/) {
        make QAST::Op.new( :op('const'), :name(~$<const>) );
        $/.prune;
    }

    method term:sym<onlystar>($/) {
        my $dc_name := QAST::Node.unique('dispatch_cap');
        my $stmts := QAST::Stmts.new(
            QAST::Op.new(
                :op('bind'),
                QAST::Var.new( :name($dc_name), :scope('local'), :decl('var') ),
                QAST::Var.new( :name('CURRENT_DISPATCH_CAPTURE'), :scope('lexical') )
            ),
            QAST::Op.new(
                :op('invokewithcapture'),
                QAST::Op.new(
                    :op('ifnull'),
                    QAST::Op.new(
                        :op('multicachefind'),
                        QAST::Var.new(
                            :name('$!dispatch_cache'), :scope('attribute'),
                            QAST::Var.new( :name('&*CURRENT_DISPATCHER'), :scope('lexical') ),
                            QAST::WVal.new( :value($*W.find_sym(['NQPRoutine'])) ),
                        ),
                        QAST::Var.new( :name($dc_name), :scope('local') )
                    ),
                    QAST::Op.new(
                        :op('callmethod'), :name('dispatch'),
                        QAST::Var.new( :name('&*CURRENT_DISPATCHER'), :scope('lexical') ),
                        QAST::Var.new( :name($dc_name), :scope('local') )
                    )
                ),
                QAST::Var.new( :name($dc_name), :scope('local') )
            ));
        make QAST::Op.new( :op('locallifetime'), $stmts, $dc_name );
        $/.prune;
    }

    method args($/) { make $<arglist>.ast; }

    method arglist($/) {
        my $ast := QAST::Op.new( :op('call'), :node($/) );
        if $<EXPR> {
            my $expr := $<EXPR>.ast;
            if nqp::istype($expr, QAST::Op) && $expr.name eq '&infix:<,>' && !$expr.named {
                for $expr.list { $ast.push($_); }
            }
            else { $ast.push($expr); }
        }
        my $i := 0;
        my $n := +$ast.list;
        while $i < $n {
            if nqp::istype($ast[$i], QAST::Op) && $ast[$i].name eq '&prefix:<|>' {
                $ast[$i] := $ast[$i][0];
                $ast[$i].flat(1);
                $ast[$i].named(1) if nqp::istype($ast[$i], QAST::Var)
                    && nqp::substr($ast[$i].name, 0, 1) eq '%';
            }
            $i++;
        }
        make $ast;
    }

    method term:sym<multi_declarator>($/) { make $<multi_declarator>.ast; $/.prune; }

    method term:sym<value>($/) { make $<value>.ast; $/.prune; }

    method circumfix:sym<( )>($/) {
        make $<EXPR>
             ?? $<EXPR>[0].ast
             !! QAST::Op.new( :op('list'), :node($/) );
        $/.prune;
    }

    method circumfix:sym<[ ]>($/) {
        my $ast;
        if $<EXPR> {
            $ast := $<EXPR>[0].ast;
            unless nqp::istype($ast, QAST::Op) && $ast.name eq '&infix:<,>' {
                $ast := QAST::Op.new( $ast, :op('list') );
            }
        }
        else {
            $ast := QAST::Op.new( :op('list') );
        }
        $ast.name('&circumfix:<[ ]>');
        make $ast;
        $/.prune;
    }

    method circumfix:sym<ang>($/) { make $<quote_EXPR>.ast; $/.prune }
    method circumfix:sym<« »>($/) { make $<quote_EXPR>.ast; $/.prune }

    method circumfix:sym<{ }>($/) {
        if +$<pblock><blockoid><statementlist><statement> > 0 {
            my $ast := QAST::Op.new( :op('takeclosure'), $<pblock>.ast );
            $ast.annotate('bareblock', 1);
            make $ast;
        }
        elsif $<pblock><blockoid><you_are_here> {
            make $<pblock>.ast;
        }
        else {
            make default_for('%');
        }
        $/.prune;
    }

    method coloncircumfix($/) {
        make $<circumfix>.ast
    }

    method semilist($/) { make $<statement>.ast; $/.prune; }

    method postcircumfix:sym<[ ]>($/) {
        make QAST::VarWithFallback.new( :scope('positional'), $<EXPR>.ast, :fallback(default_for('$')) );
    }

    method postcircumfix:sym<{ }>($/) {
        make QAST::VarWithFallback.new( :scope('associative'), $<EXPR>.ast, :fallback(default_for('$')) );
    }

    method postcircumfix:sym<ang>($/) {
        make QAST::VarWithFallback.new( :scope('associative'), $<quote_EXPR>.ast, :fallback(default_for('$')) );
    }

    method postcircumfix:sym<( )>($/) {
        make $<arglist>.ast;
    }

    method value($/) {
        make $<quote> ?? $<quote>.ast !! $<number>.ast;
        $/.prune;
    }

    method number($/) {
        my $value := $<dec_number> ?? $<dec_number>.ast !! $<integer>.ast;
        if ~$<sign> eq '-' { $value := -$value; }
        make $<dec_number> ??
            QAST::NVal.new( :value($value) ) !!
            QAST::IVal.new( :value($value) );
        $/.prune;
    }

    method quote:sym<apos>($/) { make $<quote_EXPR>.ast; }
    method quote:sym<dblq>($/) { make $<quote_EXPR>.ast; }
    method quote:sym<qq>($/)   { make $<quote_EXPR>.ast; }
    method quote:sym<q>($/)    { make $<quote_EXPR>.ast; }
    method quote:sym<Q>($/)    { make $<quote_EXPR>.ast; }
    method quote:sym<Q:PIR>($/) {
        make QAST::VM.new( :pir( $<quote_EXPR>.ast.value ), :node($/) );
    }

    method quote:sym</ />($/) {
        my $block := $*W.pop_lexpad();
        $block[0].push(QAST::Var.new(:name<self>, :scope<lexical>, :decl<param>));
        $block[0].push(QAST::Op.new(
            :op('bind'),
            QAST::Var.new(:name<self>, :scope<local>, :decl('var') ),
            QAST::Var.new( :name<self>, :scope('lexical') )));
        $block[0].push(QAST::Var.new(:name<$¢>, :scope<lexical>, :decl('var')));
        $block[0].push(QAST::Var.new(:name<$/>, :scope<lexical>, :decl('var')));
        $block.symbol('$¢', :scope<lexical>);
        $block.symbol('$/', :scope<lexical>);

        my $regex := %*LANG<Regex-actions>.qbuildsub($<p6regex>.ast, $block);
        my $ast := QAST::Op.new(
            :op<callmethod>, :name<new>,
            lexical_package_lookup(['NQPRegex'], $/),
            $regex);

        # In sink context, we don't need the Regex::Regex object.
        $ast.annotate('sink', $regex);
        make $ast;
    }

    method quote_escape:sym<$>($/) { make $<variable>.ast; }
    method quote_escape:sym<{ }>($/) {
        make QAST::Op.new(
            :op('stringify'), block_immediate($<block>.ast), :node($/)
        );
    }
    method quote_escape:sym<esc>($/) { make "\c[27]"; }

    ## Operators

    method postfix:sym<.>($/) { make $<dotty>.ast; }

    method term:sym<return>($/) {
        make QAST::Op.new( :op('call'), :name('RETURN'),
            $<EXPR> ?? $<EXPR>.ast !!  QAST::WVal.new( :value($*W.find_sym(['NQPMu'])) ));
    }

    method prefix:sym<make>($/) {
        make QAST::Op.new(
                 QAST::Var.new( :name('$/'), :scope('lexical') ),
                 :op('callmethod'),
                 :name('make'),
                 :node($/)
        );
    }

    method term:sym<next>($/) {
        my $ast := QAST::Op.new( :op('control'), :name('next') );

        if $<identifier> {
            $ast.push(QAST::WVal.new( :value($*W.find_sym([$<identifier>])), :named('label') ));
        }

        make $ast
    }
    method term:sym<last>($/) {
        my $ast := QAST::Op.new( :op('control'), :name('last') );

        if $<identifier> {
            $ast.push(QAST::WVal.new( :value($*W.find_sym([$<identifier>])), :named('label') ));
        }

        make $ast
    }
    method term:sym<redo>($/) {
        my $ast := QAST::Op.new( :op('control'), :name('redo') );

        if $<identifier> {
            $ast.push(QAST::WVal.new( :value($*W.find_sym([$<identifier>])), :named('label') ));
        }

        make $ast
    }

    method infix:sym<~~>($/) {
        make QAST::Op.new( :op<callmethod>, :name<ACCEPTS>, :node($/) );
    }

    # Takes a multi-part name that we know is in a package and generates
    # QAST to look it up using NQP package semantics.
    sub lexical_package_lookup(@name, $/) {
        # Catch empty names and die helpfully.
        if +@name == 0 { $/.CURSOR.panic("Cannot compile empty name"); }

        # The final lookup will always be just a keyed access to a
        # symbol table.
        my $final_name := @name.pop();
        my $lookup := QAST::VarWithFallback.new(
            :scope('associative'),
            QAST::SVal.new( :value(~$final_name) )
        );

        # If there's no explicit qualification, then look it up in the
        # current package, and fall back to looking in GLOBAL.
        if +@name == 0 {
            $lookup.unshift(QAST::Op.new(
                :op('who'),
                QAST::Var.new( :name('$?PACKAGE'), :scope('lexical') )
            ));
            $lookup.fallback(QAST::Op.new(
                :op('ifnull'),
                QAST::Op.new(
                    :op('atkey'),
                    QAST::Op.new(
                        :op('who'),
                        QAST::WVal.new( :value($*GLOBALish) )
                    ),
                    QAST::SVal.new( :value(~$final_name) )
                ),
                default_for(nqp::substr(~$final_name, 0, 1))));
        }

        # Otherwise, see if the first part of the name is lexically
        # known. If not, it's in GLOBAL. Also, if first part is GLOBAL
        # then strip it off.
        else {
            my $path;
            if $*W.is_lexical(~@name[0]) {
                try {
                    my $first := @name.shift();
                    $path := QAST::WVal.new( :value($*W.find_sym([$first])) );
                    CATCH {
                        $path := QAST::Var.new( :name($first), :scope('lexical') );
                    }
                }
            }
            else {
                $path := QAST::WVal.new( :value($*GLOBALish) );
            }
            if @name[0] eq 'GLOBAL' {
                @name.shift();
            }
            for @name {
                my $path_temp := QAST::Node.unique('pkg_lookup_tmp');
                $path := QAST::Stmts.new(
                    QAST::Op.new(
                        :op('bind'),
                        QAST::Var.new( :name($path_temp), :scope('local'), :decl('var') ),
                        $path
                    ),
                    QAST::Op.new(
                        :op('if'),
                        QAST::Op.new(
                            :op('existskey'),
                            QAST::Op.new( :op('who'), QAST::Var.new( :name($path_temp), :scope('local') ) ),
                            QAST::SVal.new( :value(~$_) )
                        ),
                        QAST::Op.new(
                            :op('atkey'),
                            QAST::Op.new( :op('who'), QAST::Var.new( :name($path_temp), :scope('local') ) ),
                            QAST::SVal.new( :value(~$_) )
                        ),
                        default_for('$')
                    ));
                $path := QAST::Op.new( :op('locallifetime'), $path, $path_temp );
            }
            $lookup.unshift(QAST::Op.new(:op('who'), $path));
            my $sigil := nqp::substr(~$final_name, 0, 1);
            if $sigil eq '@' || $sigil eq '%' {
                my $viv_temp := QAST::Node.unique('pkg_viv_tmp');
                $lookup[0] := QAST::Op.new(
                    :op('bind'),
                    QAST::Var.new( :name($viv_temp), :scope('local'), :decl('var') ),
                    $lookup[0]);
                $lookup.fallback(QAST::Op.new(
                    :op('bindkey'),
                    QAST::Var.new( :name($viv_temp), :scope('local') ),
                    $lookup[1],
                    default_for($sigil)
                ));
            }
            else {
                $lookup.fallback(default_for($sigil));
            }
        }

        return $lookup;
    }
}

class NQP::RegexActions is QRegex::P6Regex::Actions {

    method metachar:sym<:my>($/) {
        my $ast := $<statement>.ast;
        make QAST::Regex.new( $ast,
                              :rxtype('qastnode'), :subtype('declarative'), :node($/) );
    }

    method metachar:sym<{ }>($/) {
        make QAST::Regex.new( $<codeblock>.ast,
                              :rxtype<qastnode>, :node($/) );
    }

    method metachar:sym<nqpvar>($/) {
        make QAST::Regex.new( QAST::NodeList.new(
                                  QAST::SVal.new( :value('!INTERPOLATE') ),
                                  $<var>.ast,
                                  QAST::IVal.new( :value($*SEQ ?? 1 !! 0) ) ),
                              :rxtype<subrule>, :subtype<method>, :node($/));
    }

    method assertion:sym<{ }>($/) {
        make QAST::Regex.new( QAST::NodeList.new(
                                  QAST::SVal.new( :value('!INTERPOLATE_REGEX') ),
                                  $<codeblock>.ast),
                              :rxtype<subrule>, :subtype<method>, :node($/));
    }

    method assertion:sym<?{ }>($/) {
        make QAST::Regex.new( $<codeblock>.ast,
                              :subtype<zerowidth>, :negate( $<zw> eq '!' ),
                              :rxtype<qastnode>, :node($/) );
    }

    method assertion:sym<var>($/) {
        make QAST::Regex.new( QAST::NodeList.new(
                                  QAST::SVal.new( :value('!INTERPOLATE_REGEX') ),
                                  $<var>.ast),
                              :rxtype<subrule>, :subtype<method>, :node($/));
    }

    method codeblock($/) {
        my $block := $<block>.ast;
        $block.blocktype('immediate');
        my $ast :=
            QAST::Stmts.new(
                QAST::Op.new(
                    :op('bind'),
                    QAST::Var.new( :name('$/'), :scope('lexical') ),
                    QAST::Op.new(
                        QAST::Var.new( :name('$¢'), :scope('lexical') ),
                        :name('MATCH'),
                        :op('callmethod')
                    )
                ),
                $block
            );
        make $ast;
    }

    method assertion:sym<name>($/) {
        my $name := ~$<longname>;
        my $qast;
        if $<assertion> {
            $qast := $<assertion>.ast;
            if $qast.rxtype eq 'subrule' {
                self.subrule_alias($qast, $name);
            }
            else {
                $qast := QAST::Regex.new( $qast, :name($name),
                                          :rxtype<subcapture>, :node($/) );
            }
        }
        elsif $name eq 'sym' {
            my str $fullrxname := %*RX<name>;
            my str $rxname := "";
            my int $loc := nqp::index($fullrxname, ':sym');
            if $loc >= 0 {
                $rxname := nqp::substr($fullrxname, $loc + 5 );
                $rxname := nqp::substr( $rxname, 0, nqp::chars($rxname) - 1);
            }
            else {
                $loc := nqp::index($fullrxname, ':');
                my $angleloc := nqp::index($fullrxname, '<', $loc);
                $angleloc := nqp::index($fullrxname, '«', $loc) if $angleloc < 0;
                $rxname := nqp::substr($fullrxname, $loc + 1, $angleloc - $loc - 1) unless $loc < 0;
            }
            if $loc >= 0 {
                $qast := QAST::Regex.new(:name('sym'), :rxtype<subcapture>, :node($/),
                    QAST::Regex.new(:rxtype<literal>, $rxname, :node($/)));
            }
            else {
                self.panic("<sym> only valid in multiregexes");
            }
        }
        else {
            $qast := QAST::Regex.new(:rxtype<subrule>, :subtype<capture>,
                                     :node($/), :name($name),
                                     QAST::NodeList.new( QAST::SVal.new( :value($name) ) ) );
            if $<arglist> {
                for $<arglist>.ast.list { $qast[0].push( $_ ) }
            }
            elsif $<nibbler> {
                if $name eq 'after' {
                    my int $litlen := self.offset_ast($<nibbler>.ast);
                    if $litlen >= 0 {
                        $qast[0][0].value('before');
                        $qast[0].push(self.qbuildsub($<nibbler>.ast, :anon(1), :addself(1)));
                        $qast[0].push(QAST::IVal.new( :value($litlen) ));  # optional offset to before
                    }
                    else {
                        $qast[0].push(self.qbuildsub(self.flip_ast($<nibbler>.ast), :anon(1), :addself(1)));
                    }
                }
                else {
                    $qast[0].push(self.qbuildsub($<nibbler>.ast, :anon(1), :addself(1)));
                }
            }
        }
        make $qast;
    }

    method arglist($/) { make $<arglist>.ast }

    method arg($/) {
        make $<quote_EXPR>.ast;
    }

    method create_regex_code_object($block) {
        my $code := $*W.create_code($block, '', 0, :code_type_name<NQPRegex>);
        if nqp::existskey(%*RX, 'code') {
            %*RX<code>.ADD_NESTED_CODE($code);
        }
        $code
    }

    method store_regex_nfa($code_obj, $block, $nfa) {
        $code_obj.SET_NFA($nfa.save);
    }

    method store_regex_caps($code_obj, $block, %caps) {
        $code_obj.SET_CAPS(%caps);
    }

    method store_regex_alt_nfa($code_obj, $block, $key, @alternatives) {
        my @saved;
        for @alternatives {
            @saved.push($_.save(:non_empty));
        }
        $code_obj.SET_ALT_NFA($key, @saved);
    }
}
# From src/NQP/Compiler.nqp

use QRegex;

class NQP::Compiler is HLL::Compiler {
    method optimize($ast, *%adverbs) {
        %adverbs<optimize> eq 'off'
            ?? $ast
            !! NQP::Optimizer.new.optimize($ast, |%adverbs)
    }
}

# Create and configure compiler object.
my $nqpcomp := NQP::Compiler.new();
$nqpcomp.language('nqp');
$nqpcomp.parsegrammar(NQP::Grammar);
$nqpcomp.parseactions(NQP::Actions);
hll-config($nqpcomp.config);

$nqpcomp.addstage('optimize', :after<ast>);

# Add extra command line options.
my @clo := $nqpcomp.commandline_options();
@clo.push('parsetrace');
@clo.push('setting=s');
@clo.push('setting-path=s');
@clo.push('custom-regex-lib=s');
@clo.push('module-path=s');
@clo.push('no-regex-lib');
@clo.push('stable-sc');
@clo.push('optimize=s');
@clo.push('vmlibs=s');
@clo.push('bootstrap');

# XXX FIX ME
sub MAIN(@ARGS) {
    # Enter the compiler.
    $nqpcomp.command_line(@ARGS, :encoding('utf8'), :transcode('ascii iso-8859-1'));

    # Uncomment below to dump cursor usage logging (also need to uncomment two lines
    # in src/QRegex/Cursor.nqp, in !cursor_start_cur and !cursor_start_all).
    #ParseShared.log_dump();

    # Close event logging
    $nqpcomp.nqpevent();
}
# From gen/moar/stage2/nqp-config.nqp

sub hll-config($config) {
    $config<version>    := '2016.03';
    $config<build-date> := '2016-03-23T19:35:19Z';
}

# vim: set ft=perl6 nomodifiable :
