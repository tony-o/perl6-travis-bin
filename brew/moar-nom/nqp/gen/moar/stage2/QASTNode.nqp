# This file automatically generated by tools/build/gen-cat.pl

# From src/QAST/CompileTimeValue.nqp

# Composed or mixed in to any node that also has a compile-time known value.
role QAST::CompileTimeValue {
    has $!compile_time_value;
    
    method has_compile_time_value() {
        1
    }
    
    method compile_time_value() {
        $!compile_time_value
    }
    
    method set_compile_time_value($value) {
        $!compile_time_value := $value
    }
}
# From src/QAST/SpecialArg.nqp

my class NO_VALUE { }

role QAST::SpecialArg {
    has $!named;
    has int $!flat;
    
    method named($value = NO_VALUE) {
        $!named := $value unless $value =:= NO_VALUE;
        $!named
    }

    method flat($value = NO_VALUE) {
        $!flat := $value unless $value =:= NO_VALUE;
        $!flat
    }

    method dump_extra_node_info() {
        my $parent := self.HOW.parents(self, :local(1))[0];
        my $info := $parent.HOW.method_table($parent)<dump_extra_node_info>(self);

        $info := nqp::chars($info) ?? $info ~ " " !! "";

        if $!flat {
            $info ~ ":flat" ~ ($!named ?? " :named" !! "");
        } else {
            $info ~ ($!named ?? ":named<$!named>" !! "");
        }
    }
}
# From src/QAST/Children.nqp

role QAST::Children {
    has @!children is positional_delegate;

    method list()          { @!children }
    method pop()           { nqp::pop(@!children) }
    method push($value)    { nqp::push(@!children, $value) }
    method shift()         { nqp::shift(@!children) }
    method unshift($value) { nqp::unshift(@!children, $value) }

    method shallow_clone() {
        my $clone := nqp::clone(self);
        $clone.set_children(nqp::clone(@!children));
        $clone
    }

    method set_children(@children) {
        @!children := @children;
    }

    method dump_node_list(int $indent, @onto, @node_list) {
        for @node_list {
            if nqp::istype($_, QAST::Node) {
                nqp::push(@onto, $_.dump($indent));
            }
            else {
                nqp::push(@onto, nqp::x(' ', $indent));
                nqp::push(@onto, '- ');
                nqp::push(@onto, nqp::istype($_, NQPMu) ?? '(NQPMu)' !! ~$_);
                nqp::push(@onto, "\n");
            }
        }
	CATCH { nqp::push(@onto, "Oops!!! {nqp::getmessage($_)}\n") }
    }

    method extra_children() {
        [];
    }

    method dump_children(int $indent, @onto) {
        my $extra := 0;
        for self.extra_children -> $tag, $nodes {
            if $nodes {
                nqp::push(@onto, nqp::x(' ', $indent));
                nqp::push(@onto, "[" ~ $tag ~ "]");
                nqp::push(@onto, "\n");
                self.dump_node_list($indent+2, @onto, nqp::islist($nodes) ?? $nodes !! [$nodes]);
            }
            $extra := $extra + nqp::elems($nodes);
        }

        if $extra && @!children {
            nqp::push(@onto, nqp::x(' ', $indent) ~ "[children]\n");
            self.dump_node_list($indent+2, @onto, @!children);
        } else {
            self.dump_node_list($indent, @onto, @!children);
        }
    }
}
# From src/QAST/Node.nqp

class QAST::Node {
    has %!annotations;
    has $!node;
    has $!returns;
    has int $!flags;

    method new(*@children, *%options) {
        nqp::die('Can not instantiate QAST::Node; please use a subclass');
    }

    method set(%options) {
        my $it := nqp::iterator(%options);
        while $it {
            my $cur := nqp::shift($it);
            nqp::findmethod(self, nqp::iterkey_s($cur))(self, nqp::iterval($cur))
        }
        self
    }

    method list() { [] }

    method node($value = NO_VALUE) {
        $!node := $value unless $value =:= NO_VALUE;
        $!node := NQPMu if nqp::isnull($value);
        $!node
    }

    method returns($value = NO_VALUE) {
        $!returns := $value unless $value =:= NO_VALUE;
        $!returns
    }
    
    method named($value = NO_VALUE) {
        if $value =:= NO_VALUE {
            NQPMu
        }
        else {
            self.HOW.mixin(self, QAST::SpecialArg);
            self.named($value);
        }
    }

    method flat($value = NO_VALUE) {
        if $value =:= NO_VALUE {
            0
        }
        else {
            self.HOW.mixin(self, QAST::SpecialArg);
            self.flat($value);
        }
    }
    
    method setflag($bit)   { $!flags := nqp::bitor_i($!flags, $bit) }
    method clearflag($bit) { $!flags := nqp::bitand_i($!flags, nqp::bitneg_i($bit)) }
    method isflag($bit)    { nqp::istrue(nqp::bitand_i($!flags, $bit)) }

    method wanted ($value = NO_VALUE) { $value =:= NO_VALUE ?? self.isflag(0x1) !! $value ?? self.setflag(0x1) !! self.clearflag(0x1) }
    method sunk   ($value = NO_VALUE) { $value =:= NO_VALUE ?? self.isflag(0x2) !! $value ?? self.setflag(0x2) !! self.clearflag(0x2) }
    method nosink ($value = NO_VALUE) { $value =:= NO_VALUE ?? self.isflag(0x4) !! $value ?? self.setflag(0x4) !! self.clearflag(0x4) }
    method sinkok ($value = NO_VALUE) { $value =:= NO_VALUE ?? self.isflag(0x8) !! $value ?? self.setflag(0x8) !! self.clearflag(0x8) }
    method final  ($value = NO_VALUE) { $value =:= NO_VALUE ?? self.isflag(0x10) !! $value ?? self.setflag(0x10) !! self.clearflag(0x10) }
    method okifnil($value = NO_VALUE) { $value =:= NO_VALUE ?? self.isflag(0x20) !! $value ?? self.setflag(0x20) !! self.clearflag(0x20) }

    method dump_flags() {
	my @flags;
	if $!flags {
	    nqp::push(@flags, 'wanted')  if self.wanted;
	    nqp::push(@flags, 'sunk')    if self.sunk;
	    nqp::push(@flags, 'nosink')  if self.nosink;
	    nqp::push(@flags, 'sinkok')  if self.sinkok;
	    nqp::push(@flags, 'final')   if self.final;
	    nqp::push(@flags, 'okifnil') if self.okifnil;
	}
	@flags ?? '<' ~ nqp::join(' ',@flags) ~ '>' !! '';
    }

    method has_compile_time_value() {
        0
    }
    
    method set_compile_time_value($value) {
        self.HOW.mixin(self, QAST::CompileTimeValue);
        self.set_compile_time_value($value);
    }

    method annotate(str $key, $value) {
        %!annotations := nqp::hash() unless nqp::ishash(%!annotations);
        %!annotations{$key} := $value;
    }

    method ann(str $key) {
        nqp::ishash(%!annotations)
            ?? %!annotations{$key}
            !! NQPMu
    }

    method has_ann(str $key) {
        nqp::ishash(%!annotations) && nqp::existskey(%!annotations, $key)
    }

    method clear_annotations() {
        %!annotations := nqp::null();
    }

    my %uniques;
    method unique($prefix) {
        my $id := nqp::existskey(%uniques, $prefix) ??
            (%uniques{$prefix} := %uniques{$prefix} + 1) !!
            (%uniques{$prefix} := 1);
        $prefix ~ '_' ~ $id
    }
    
    method shallow_clone() {
        nqp::clone(self)
    }
    
    method count_inline_placeholder_usages(@usages) {
        nqp::die(self.HOW.name(self) ~ " does not support inlining");
    }

    method substitute_inline_placeholders(@fillers) {
        nqp::die(self.HOW.name(self) ~ " does not support inlining");
    }

    method evaluate_unquotes(@unquotes) {
        nqp::die(self.HOW.name(self) ~ " does not support evaluating unquotes");
    }

    method dump(int $indent = 0) {
        my @chunks := [
            nqp::x(' ', $indent), '- ', self.HOW.name(self),
        ];
        my $extra := self.dump_extra_node_info();
        if nqp::chars($extra) {
            nqp::push(@chunks, "($extra)");
        }
	nqp::push(@chunks, ' ');
	nqp::push(@chunks, self.dump_annotations);
        if (self.node) {
            nqp::push(@chunks, ' ');
            my $escaped_node := nqp::escape(self.node);
            nqp::push(@chunks, nqp::substr($escaped_node, 0, 50));
            if (nqp::chars($escaped_node) > 50) {
                nqp::push(@chunks, "...");
            }
        }
        nqp::push(@chunks, "\n");
        self.dump_children($indent + 2, @chunks);
        return join('', @chunks);
    }

    method dump_annotations() {
	my @anns;
	nqp::push(@anns, self.dump_flags);

        if nqp::ishash(%!annotations) {
	    for %!annotations {
		my $k := $_.key;
		my $v := $_.value;
		try {
		    if nqp::isconcrete($v) {
			if $k eq 'IN_DECL' || $k eq 'BY' {
			    nqp::push(@anns, ':' ~ $k ~ '<' ~ $v ~ '>');
			}
			else {   # dunno how to introspect
			    nqp::push(@anns, ':' ~ $k ~ '<?>');
			}
		    }
		}
	    }
	}
	nqp::join(' ',@anns);
    }

    method dump_children(int $indent, @onto) { }

    method dump_extra_node_info() { '' }
}
# From src/QAST/NodeList.nqp

class QAST::NodeList is QAST::Node does QAST::Children {
    method new(*@children, *%options) {
        my $node := nqp::create(self);
        nqp::bindattr_i($node, QAST::Node, '$!flags', 0);
        nqp::bindattr($node, QAST::NodeList, '@!children', @children);
        $node.set(%options) if %options;
        $node
    }
}
# From src/QAST/Regex.nqp

role QAST::RegexCursorType {
    has $!cursor_type;
    method has_cursor_type() { 1 }
    method cursor_type($value = NO_VALUE) {
        $!cursor_type := $value unless $value =:= NO_VALUE;
        $!cursor_type
    }

    method dump_extra_node_info() {
        my $info := QAST::Regex.HOW.method_table(QAST::Regex)<dump_extra_node_info>(self);
        $info ~ " :cursor_type({$!cursor_type.HOW.name($!cursor_type)})"
    }
}

class QAST::Regex is QAST::Node does QAST::Children {
    has $!name;
    has str $!rxtype;
    has str $!subtype;
    has str $!backtrack;
    has int $!negate;
    has int $!min;
    has int $!max;
    
    method new(str :$rxtype, str :$subtype, *@children, *%options) {
        my $node := nqp::create(self);
        nqp::bindattr_i($node, QAST::Node, '$!flags', 0);
        nqp::bindattr($node, QAST::Regex, '@!children', @children);
        nqp::bindattr_s($node, QAST::Regex, '$!rxtype', $rxtype);
        nqp::bindattr_s($node, QAST::Regex, '$!subtype', $subtype);
        $node.set(%options) if %options;
        $node
    }

    method name($value = NO_VALUE)      { $!name := $value unless $value =:= NO_VALUE; $!name }
    method rxtype($value = NO_VALUE)    {
        $!rxtype := $value unless $value =:= NO_VALUE;
        !nqp::isnull_s($!rxtype) ?? $!rxtype !! ""
    }
    method subtype($value = NO_VALUE)   {
        $!subtype := $value unless $value =:= NO_VALUE;
        !nqp::isnull_s($!subtype) ?? $!subtype !! "" 
    }
    method backtrack($value = NO_VALUE) {
        $!backtrack := $value unless $value =:= NO_VALUE;
        !nqp::isnull_s($!backtrack) ?? $!backtrack !! ""
    }
    method negate($value = NO_VALUE)    { $!negate := $value unless $value =:= NO_VALUE; $!negate }
    method min($value = NO_VALUE)       { $!min := $value unless $value =:= NO_VALUE; $!min }
    method max($value = NO_VALUE)       { $!max := $value unless $value =:= NO_VALUE; $!max }
    
    method dump_extra_node_info() {
        ":rxtype($!rxtype)" ~ (!nqp::isnull_s($!subtype) ?? " :subtype($!subtype)" !! "") ~ ($!negate ?? ' (negated)' !! '') ~ (nqp::defined($!name) ?? " :name($!name)" !! '')
    }
    
    method has_cursor_type() { 0 }
    method cursor_type($type) {
        self.HOW.mixin(self, QAST::RegexCursorType);
        self.cursor_type($type);
    }
}

# From src/QAST/IVal.nqp

class QAST::IVal is QAST::Node {
    has int $!value;

    method new(:$value, *%options) {
        my $node := nqp::create(self);
        nqp::bindattr_i($node, QAST::Node, '$!flags', 0);
        nqp::bindattr_i($node, QAST::IVal, '$!value', $value);
        nqp::bindattr($node, QAST::Node, '$!returns', int);
        $node.set(%options) if %options;
        $node
    }

    method value($value = NO_VALUE) { $!value := $value unless $value =:= NO_VALUE; $!value }

    method count_inline_placeholder_usages(@usages) { }

    method substitute_inline_placeholders(@fillers) {
        self
    }

    method evaluate_unquotes(@unquotes) {
        self
    }
    method dump_extra_node_info() { ~$!value }
}
# From src/QAST/NVal.nqp

class QAST::NVal is QAST::Node {
    has num $!value;

    method new(:$value, *%options) {
        my $node := nqp::create(self);
        nqp::bindattr_i($node, QAST::Node, '$!flags', 0);
        nqp::bindattr_n($node, QAST::NVal, '$!value', $value);
        nqp::bindattr($node, QAST::Node, '$!returns', num);
        $node.set(%options) if %options;
        $node
    }

    method value($value = NO_VALUE) { $!value := $value unless $value =:= NO_VALUE; $!value }

    method count_inline_placeholder_usages(@usages) { }

    method substitute_inline_placeholders(@fillers) {
        self
    }

    method evaluate_unquotes(@unquotes) {
        self
    }

    method dump_extra_node_info() { ~$!value }
}
# From src/QAST/SVal.nqp

class QAST::SVal is QAST::Node {
    has str $!value;

    method new(:$value, *%options) {
        my $node := nqp::create(self);
        nqp::bindattr_i($node, QAST::Node, '$!flags', 0);
        nqp::bindattr_s($node, QAST::SVal, '$!value', $value);
        nqp::bindattr($node, QAST::Node, '$!returns', str);
        $node.set(%options) if %options;
        $node
    }

    method value($value = NO_VALUE) { $!value := $value unless $value =:= NO_VALUE; $!value }
    
    method count_inline_placeholder_usages(@usages) { }

    method substitute_inline_placeholders(@fillers) {
        self
    }

    method evaluate_unquotes(@unquotes) {
        self
    }
    method dump_extra_node_info() {
        nqp::escape($!value);
    }
}
# From src/QAST/BVal.nqp

class QAST::BVal is QAST::Node {
    has $!value;

    method new(:$value, *%options) {
        my $node := nqp::create(self);
        nqp::bindattr_i($node, QAST::Node, '$!flags', 0);
        nqp::bindattr($node, QAST::BVal, '$!value', $value);
        $node.set(%options) if %options;
        $node
    }

    method value($value = NO_VALUE) { $!value := $value unless $value =:= NO_VALUE; $!value }

    method evaluate_unquotes(@unquotes) {
        self
    }

    method dump_extra_node_info() { ~$!value.cuid }
}
# From src/QAST/WVal.nqp

class QAST::WVal is QAST::Node does QAST::CompileTimeValue {
    method new(:$value, *%options) {
        my $node := nqp::create(self);
        nqp::bindattr_i($node, QAST::Node, '$!flags', 0);
        nqp::bindattr($node, QAST::WVal, '$!compile_time_value', $value);
        $node.set(%options) if %options;
        $node
    }

    method value($value = NO_VALUE) {
        $value =:= NO_VALUE
            ?? self.compile_time_value()
            !! self.set_compile_time_value($value)
    }

    method count_inline_placeholder_usages(@usages) { }

    method substitute_inline_placeholders(@fillers) {
        self
    }

    method evaluate_unquotes(@unquotes) {
        self
    }

    method dump_extra_node_info() {
	CATCH { return "?" } 
        my $v := self.compile_time_value();
        $v.HOW.name($v);
    }
}
# From src/QAST/Want.nqp

class QAST::Want is QAST::Node does QAST::Children {
    method new(*@children, *%options) {
        my $node := nqp::create(self);
        nqp::bindattr_i($node, QAST::Node, '$!flags', 0);
        nqp::bindattr($node, QAST::Want, '@!children', @children);
        $node.set(%options) if %options;
        $node
    }

    method has_compile_time_value() {
        nqp::istype(self[0], QAST::Node)
            ?? self[0].has_compile_time_value()
            !! 0
    }
    
    method compile_time_value() {
        self[0].compile_time_value()
    }

    method count_inline_placeholder_usages(@usages) {
        my int $i := 0;
        my int $elems := +@(self);
        while $i < $elems {
            self[$i].count_inline_placeholder_usages(@usages);
            $i := $i + 2;
        }
    }

    method substitute_inline_placeholders(@fillers) {
        my $result := self.shallow_clone();
        my int $i := 0;
        my int $elems := +@(self);
        while $i < $elems {
            $result[$i] := self[$i].substitute_inline_placeholders(@fillers);
            $i := $i + 2;
        }
        $result
    }

    method evaluate_unquotes(@unquotes) {
        my $result := self.shallow_clone();
        my $i := 0;
        my $elems := +@(self);
        while $i < $elems {
            $result[$i] := self[$i].evaluate_unquotes(@unquotes);
            $i := $i + 2;
        }
        $result
    }
}
# From src/QAST/Var.nqp

class QAST::Var is QAST::Node does QAST::Children {
    has str $!name;
    has str $!scope;
    has str $!decl;
    has int $!slurpy;
    has $!default_or_value;

    method new(:$name, str :$scope, str :$decl, *@children, *%options) {
        my $node := nqp::create(self);
        nqp::bindattr_i($node, QAST::Node, '$!flags', 0);
        nqp::bindattr($node, QAST::Var, '@!children', @children);
        nqp::bindattr_s($node, QAST::Var, '$!name', $name);
        nqp::bindattr_s($node, QAST::Var, '$!scope', $scope);
        nqp::bindattr_s($node, QAST::Var, '$!decl', $decl);
        $node.set(%options) if %options;
        $node
    }
    
    method name($value = NO_VALUE) {
        $!name := $value unless $value =:= NO_VALUE;
        !nqp::isnull_s($!name) ?? $!name !! ""
    }
    method scope($value = NO_VALUE) {
        $!scope := $value unless $value =:= NO_VALUE;
        !nqp::isnull_s($!scope) ?? $!scope !! ""
    }
    method decl($value = NO_VALUE) {
        $!decl := $value unless $value =:= NO_VALUE;
        !nqp::isnull_s($!decl) ?? $!decl !! ""
    }
    method slurpy($value = NO_VALUE)  { $!slurpy := $value unless $value =:= NO_VALUE; $!slurpy }
    method default($value = NO_VALUE) { $!default_or_value := $value unless $value =:= NO_VALUE; $!default_or_value }
    method value($value = NO_VALUE)   { $!default_or_value := $value unless $value =:= NO_VALUE; $!default_or_value }

    method count_inline_placeholder_usages(@usages) { }

    method substitute_inline_placeholders(@fillers) {
        self
    }

    method evaluate_unquotes(@unquotes) {
        self
    }

    method dump_extra_node_info() {
        my $info := nqp::isnull_s($!name) ?? $!scope !! "$!scope $!name";
        nqp::chars($!decl) ?? "$info :decl($!decl)" !! $info
    }

    method extra_children() {
        nqp::defined($!default_or_value) ?? [$!decl eq 'param' ?? 'default' !! 'value', [$!default_or_value]] !! [];
    }
}
# From src/QAST/VarWithFallback.nqp

class QAST::VarWithFallback is QAST::Var {
    has $!fallback;
    method fallback($value = NO_VALUE) { $!fallback := $value unless $value =:= NO_VALUE; $!fallback }

    method extra_children() {
        $!fallback ?? ['fallback', [$!fallback]] !! [];
    }
}
# From src/QAST/ParamTypeCheck.nqp

class QAST::ParamTypeCheck is QAST::Node does QAST::Children {
    method new(*@children, *%options) {
        my $node := nqp::create(self);
        nqp::bindattr_i($node, QAST::Node, '$!flags', 0);
        nqp::bindattr($node, QAST::ParamTypeCheck, '@!children', @children);
        $node.set(%options) if %options;
        $node
    }
}
# From src/QAST/Op.nqp

class QAST::Op is QAST::Node does QAST::Children {
    has str $!name;
    has str $!op;
    has str $!childorder;
    has int $!arity;

    method new(str :$name, str :$op, *@children, *%options) {
        my $node := nqp::create(self);
        nqp::bindattr_i($node, QAST::Node, '$!flags', 0);
        nqp::bindattr($node, QAST::Op, '@!children', @children);
        nqp::bindattr_s($node, QAST::Op, '$!name', $name);
        nqp::bindattr_s($node, QAST::Op, '$!op', $op);
        $node.set(%options) if %options;
        $node
    }

    method name($value = NO_VALUE) {
        $!name := $value unless $value =:= NO_VALUE;
        nqp::isnull_s($!name) ?? "" !! $!name
    }
    method op($value = NO_VALUE) {
        $!op := $value unless $value =:= NO_VALUE;
        nqp::isnull_s($!op) ?? "" !! $!op
    }
    method childorder($value = NO_VALUE) {
        $!childorder := $value unless $value =:= NO_VALUE;
        nqp::isnull_s($!childorder) ?? "" !! $!childorder
    }
    method arity($value = NO_VALUE)      { $!arity := $value unless $value =:= NO_VALUE; $!arity }

    method count_inline_placeholder_usages(@usages) {
        my int $i := 0;
        my int $elems := +@(self);
        while $i < $elems {
            self[$i].count_inline_placeholder_usages(@usages);
            $i++;
        }
    }

    method substitute_inline_placeholders(@fillers) {
        my $result := self.shallow_clone();
        my int $i := 0;
        my int $elems := +@(self);
        while $i < $elems {
            $result[$i] := self[$i].substitute_inline_placeholders(@fillers)
                unless nqp::isstr(self[$i]);
            $i++;
        }
        $result
    }

    method evaluate_unquotes(@unquotes) {
        my $result := self.shallow_clone();
        my $i := 0;
        my $elems := +@(self);
        while $i < $elems {
            $result[$i] := self[$i].evaluate_unquotes(@unquotes)
                unless nqp::isstr(self[$i]);
            $i := $i + 1;
        }
        $result
    }

    method dump_extra_node_info() {
        !nqp::isnull_s($!name) && nqp::chars($!name)
            ?? "$!op $!name"
            !! $!op;
    }
}
# From src/QAST/VM.nqp

class QAST::VM is QAST::Node does QAST::Children {
    has %!alternatives;
    
    method new(*@children, *%alternatives) {
        my $obj := nqp::create(self);
        nqp::bindattr_i($obj, QAST::Node, '$!flags', 0);
        nqp::bindattr($obj, QAST::VM, '@!children', @children);
        nqp::bindattr($obj, QAST::VM, '%!alternatives', %alternatives);
        $obj
    }
    
    method supports($option) {  
        nqp::existskey(%!alternatives, $option)
    }
    
    method alternative($option) {
        nqp::atkey(%!alternatives, $option)
    }

    method dump_children(int $indent, @onto) {
        for %!alternatives {
            nqp::push(@onto, nqp::x(' ', $indent));
            nqp::push(@onto, '[');
            nqp::push(@onto, $_.key);
            nqp::push(@onto, "]\n");

            if nqp::istype($_.value, QAST::Node) {
                nqp::push(@onto, $_.value.dump($indent+2));
            }
            else {
                nqp::push(@onto, nqp::x(' ', $indent+2));
                nqp::push(@onto, '- ');
                if $_.key eq 'loadlibs' {
                    nqp::push(@onto, nqp::join(' ',$_.value));
                }
                else {
                    nqp::push(@onto, ~$_.value);
                }
                nqp::push(@onto, "\n");
            }
        }
    }
}
# From src/QAST/Stmts.nqp

class QAST::Stmts is QAST::Node does QAST::Children {
    has $!resultchild;

    method new(*@children, *%options) {
        my $node := nqp::create(self);
        nqp::bindattr_i($node, QAST::Node, '$!flags', 0);
        nqp::bindattr($node, QAST::Stmts, '@!children', @children);
        $node.set(%options) if %options;
        $node
    }

    method resultchild($value = NO_VALUE) { $!resultchild := $value unless $value =:= NO_VALUE; $!resultchild }
    
    method count_inline_placeholder_usages(@usages) {
        my int $i := 0;
        my int $elems := +@(self);
        while $i < $elems {
            self[$i].count_inline_placeholder_usages(@usages);
            $i++;
        }
    }

    method substitute_inline_placeholders(@fillers) {
        my $result := self.shallow_clone();
        my $i := 0;
        my $elems := +@(self);
        while $i < $elems {
            $result[$i] := self[$i].substitute_inline_placeholders(@fillers);
            $i := $i + 1;
        }
        $result
    }

    method evaluate_unquotes(@unquotes) {
        my $result := self.shallow_clone();
        my $i := 0;
        my $elems := +@(self);
        while $i < $elems {
            $result[$i] := self[$i].evaluate_unquotes(@unquotes);
            $i := $i + 1;
        }
        $result
    }

    method dump_extra_node_info() {
        nqp::defined($!resultchild) ?? ":resultchild($!resultchild))" !! ''
    }
}
# From src/QAST/Stmt.nqp

class QAST::Stmt is QAST::Node does QAST::Children {
    has $!resultchild;

    method new(*@children, *%options) {
        my $node := nqp::create(self);
        nqp::bindattr_i($node, QAST::Node, '$!flags', 0);
        nqp::bindattr($node, QAST::Stmt, '@!children', @children);
        $node.set(%options) if %options;
        $node
    }

    method resultchild($value = NO_VALUE) { $!resultchild := $value unless $value =:= NO_VALUE; $!resultchild }

    method count_inline_placeholder_usages(@usages) {
        my int $i := 0;
        my int $elems := +@(self);
        while $i < $elems {
            self[$i].count_inline_placeholder_usages(@usages);
            $i++;
        }
    }

    method substitute_inline_placeholders(@fillers) {
        my $result := self.shallow_clone();
        my int $i := 0;
        my int $elems := +@(self);
        while $i < $elems {
            $result[$i] := self[$i].substitute_inline_placeholders(@fillers);
            $i++;
        }
        $result
    }

    method evaluate_unquotes(@unquotes) {
        my $result := self.shallow_clone();
        my $i := 0;
        my $elems := +@(self);
        while $i < $elems {
            $result[$i] := self[$i].evaluate_unquotes(@unquotes);
            $i := $i + 1;
        }
        $result
    }
    
    method dump_extra_node_info() {
        nqp::defined($!resultchild) ?? ":resultchild($!resultchild))" !! ''
    }
}
# From src/QAST/Block.nqp

class QAST::Block is QAST::Node does QAST::Children {
    has str $!name;
    has str $!blocktype;
    has int $!custom_args;
    has int $!has_exit_handler;
    has int $!is_thunk;
    has str $!cuid;
    has int $!arity;
    has $!code_object;
    has %!symbol;

    method new(str :$name, str :$blocktype, *@children, *%options) {
        my $node := nqp::create(self);
        nqp::bindattr_i($node, QAST::Node, '$!flags', 0);
        nqp::bindattr($node, QAST::Block, '@!children', @children);
        nqp::bindattr_s($node, QAST::Block, '$!name', $name);
        nqp::bindattr_s($node, QAST::Block, '$!blocktype', $blocktype);
        $node.set(%options) if %options;
        $node
    }
    
    method name($value = NO_VALUE) {
        $!name := $value unless $value =:= NO_VALUE;
        nqp::isnull_s($!name) ?? "" !! $!name
    }
    method blocktype($value = NO_VALUE) {
        $!blocktype := $value unless $value =:= NO_VALUE;
        nqp::isnull_s($!blocktype) ?? "" !! $!blocktype
    }
    method custom_args($value = NO_VALUE)      { $!custom_args := $value unless $value =:= NO_VALUE; $!custom_args }
    method has_exit_handler($value = NO_VALUE) { $!has_exit_handler := $value unless $value =:= NO_VALUE; $!has_exit_handler }
    method is_thunk($value = NO_VALUE)         { $!is_thunk := $value unless $value =:= NO_VALUE; $!is_thunk }
    method arity($value = NO_VALUE)            { $!arity := $value unless $value =:= NO_VALUE; $!arity }

    method code_object($value = NO_VALUE) {
        $!code_object := $value unless $value =:= NO_VALUE;
        $!code_object
    }

    my $cur_cuid := 0;
    method cuid($value = NO_VALUE) {
        if !($value =:= NO_VALUE) {
            # Set ID if we are provided one.
            $!cuid := $value;
        }
        elsif $!cuid {
            # If we already have an ID, return it.
            $!cuid
        }
        else {
            # Otherwise, generate one.
            $cur_cuid := $cur_cuid + 1;
            $!cuid := ~$cur_cuid;
        }
    }

    my %NOSYMS := nqp::hash();
    method symbol(str $name, *%attrs) {
        %!symbol := nqp::hash() if nqp::isnull(%!symbol);
        if %attrs {
            my %syms := %!symbol{$name};
            if nqp::ishash(%syms) && nqp::elems(%syms) {
                for %attrs {
                    %syms{$_.key} := $_.value;
                }
            }
            else {
                %!symbol{$name} := %syms := %attrs;
            }
            %syms
        }
        else {
            nqp::ifnull(nqp::atkey(%!symbol, $name), %NOSYMS)
        }
    }
    
    method symtable() {
        %!symbol := nqp::hash() if nqp::isnull(%!symbol);
        %!symbol
    }

    method evaluate_unquotes(@unquotes) {
        my $result := self.shallow_clone();
        my $i := 0;
        my $elems := +@(self);
        while $i < $elems {
            $result[$i] := self[$i].evaluate_unquotes(@unquotes);
            $i := $i + 1;
        }
        $result
    }

    method dump_extra_node_info() {
        nqp::chars(self.blocktype) ?? ":blocktype($!blocktype)" !! "";
    }
}
# From src/QAST/Unquote.nqp

class QAST::Unquote is QAST::Node {
    has int $!position;

    method new(int :$position, *%options) {
        my $node := nqp::create(self);
        nqp::bindattr_i($node, QAST::Node, '$!flags', 0);
        nqp::bindattr_i($node, QAST::Unquote, '$!position', $position);
        $node.set(%options) if %options;
        $node
    }

    method position(*@value) {
        @value ?? ($!position := @value[0]) !! $!position
    }

    method evaluate_unquotes(@unquotes) {
        @unquotes[$!position];
    }
}
# From src/QAST/CompUnit.nqp

class QAST::CompUnit is QAST::Node does QAST::Children {
    # The serialization context for the compilation unit.
    has $!sc;
    
    # Code reference block list for the serialization context.
    has $!code_ref_blocks;
    
    # Are we in compilation mode?
    has int $!compilation_mode;
    
    # Tasks we should run prior to deserialization (or, in the non-precompiled
    # case, just before everything else in this compilation unit).
    has @!pre_deserialize;

    # Tasks we should run after deserialization (or, in the non-precompiled
    # case, right after the pre-deserialize tasks).
    has @!post_deserialize;
    
    # Call to the repossession conflict resolution mechanism, to be invoked
    # on deserialization.
    has $!repo_conflict_resolver;
    
    # The HLL name.
    has $!hll;
    
    # What to run at the point the compilation unit is loaded.
    has $!load;
    
    # What to run if this is the main entry point.
    has $!main;

    has $!is_nested;

    method new(*@children, *%options) {
        my $node := nqp::create(self);
        nqp::bindattr_i($node, QAST::Node, '$!flags', 0);
        nqp::bindattr($node, QAST::CompUnit, '@!children', @children);
        $node.set(%options) if %options;
        $node
    }
    
    method sc($value = NO_VALUE)       { $!sc := $value unless $value =:= NO_VALUE; $!sc }
    method hll($value = NO_VALUE)      { $!hll := $value unless $value =:= NO_VALUE; $!hll }
    method load($value = NO_VALUE)     { $!load := $value unless $value =:= NO_VALUE; $!load }
    method main($value = NO_VALUE)     { $!main := $value unless $value =:= NO_VALUE; $!main }
    
    method compilation_mode($value = NO_VALUE) {
        $!compilation_mode := $value unless $value =:= NO_VALUE; $!compilation_mode
    }
    method pre_deserialize($value = NO_VALUE) {
        @!pre_deserialize := $value unless $value =:= NO_VALUE;
        nqp::isnull(@!pre_deserialize) ?? [] !! @!pre_deserialize
    }
    method post_deserialize($value = NO_VALUE) {
        @!post_deserialize := $value unless $value =:= NO_VALUE;
        nqp::isnull(@!post_deserialize) ?? [] !! @!post_deserialize
    }
    method repo_conflict_resolver($value = NO_VALUE) {
        $value =:= NO_VALUE ?? $!repo_conflict_resolver !! ($!repo_conflict_resolver := $value)
    }
    method code_ref_blocks($value = NO_VALUE) {
        $!code_ref_blocks := $value unless $value =:= NO_VALUE; $!code_ref_blocks
    }
    method is_nested($value = NO_VALUE) {
        $!is_nested := $value unless $value =:= NO_VALUE; $!is_nested
    }

    method extra_children() {
        [
            'pre_deserialize', self.pre_deserialize,
            'post_deserialize', self.post_deserialize,
            'main', self.main ?? [self.main] !! [],
            'load', self.load ?? [self.load] !! [],
        ];
    }
}
# From src/QAST/InlinePlaceholder.nqp

# This indicates a place in a QAST tree that has been stashed for later
# inlining where one of the arguments to the inlined routine was used.
class QAST::InlinePlaceholder is QAST::Node {
    has int $!position;

    method new(:$position, *%options) {
        my $node := nqp::create(self);
        nqp::bindattr_i($node, QAST::Node, '$!flags', 0);
        nqp::bindattr_i($node, QAST::InlinePlaceholder, '$!position', $position);
        $node.set(%options) if %options;
        $node
    }

    method position(*@value) {
        @value ?? ($!position := @value[0]) !! $!position
    }

    method count_inline_placeholder_usages(@usages) {
        @usages[$!position]++;
    }

    method substitute_inline_placeholders(@fillers) {
        if $!position < +@fillers {
            my $result := @fillers[$!position];
            if self.named || self.flat {
                $result := $result.shallow_clone();
                if self.named -> $name {
                    $result.named($name);
                }
                if self.flat {
                    $result.flat(1);
                }
            }
            $result
        }
        else {
            nqp::die("Inline placeholder index out of range")
        }
    }
}

# vim: set ft=perl6 nomodifiable :
