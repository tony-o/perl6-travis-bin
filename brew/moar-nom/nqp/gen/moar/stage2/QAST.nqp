# This file automatically generated by tools/build/gen-cat.pl

# From src/vm/moar/QAST/QASTRegexCompilerMAST.nqp

use QASTNode;
use NQPHLL;
use MASTNodes;
use MASTOps;
use QRegex;

my $MVM_reg_void            := 0; # not really a register; just a result/return kind marker
my $MVM_reg_int8            := 1;
my $MVM_reg_int16           := 2;
my $MVM_reg_int32           := 3;
my $MVM_reg_int64           := 4;
my $MVM_reg_num32           := 5;
my $MVM_reg_num64           := 6;
my $MVM_reg_str             := 7;
my $MVM_reg_obj             := 8;
my $MVM_reg_uint8           := 17;
my $MVM_reg_uint16          := 18;
my $MVM_reg_uint32          := 19;
my $MVM_reg_uint64          := 20;

class QAST::MASTRegexCompiler {
    # The compiler we're working against.
    has $!qastcomp;

    # The current register allocator.
    has $!regalloc;

    # Cursor type, if any.
    has $!cursor_type;

    # Registers used.
    has %!reg;

    # Jump table.
    has @!rxjumps;

    method new(:$qastcomp!, :$regalloc!) {
        my $obj := nqp::create(self);
        $obj.BUILD($qastcomp, $regalloc);
        $obj
    }

    method BUILD($qastcomp, $regalloc) {
        $!qastcomp    := $qastcomp;
        $!regalloc    := $regalloc;
        $!cursor_type := NQPMu;
    }

    method unique($str?) {
        $!qastcomp.unique($str)
    }

    method as_mast($node, :$want) {
        # Build the list of (unique) registers we need
        my $tgt      := $!regalloc.fresh_s();
        my $pos      := $!regalloc.fresh_i();
        my $off      := $!regalloc.fresh_i();
        my $eos      := $!regalloc.fresh_i();
        my $rep      := $!regalloc.fresh_i();
        my $cur      := $!regalloc.fresh_o();
        my $curclass := $!regalloc.fresh_o();
        my $bstack   := $!regalloc.fresh_o();
        my $cstack   := $!regalloc.fresh_o();
        my $negone   := $!regalloc.fresh_i();
        my $zero     := $!regalloc.fresh_i();
        my $one      := $!regalloc.fresh_i();
        my $two      := $!regalloc.fresh_i();
        my $three    := $!regalloc.fresh_i();
        my $four     := $!regalloc.fresh_i();
        my $P11      := $!regalloc.fresh_o();
        my $method   := $!regalloc.fresh_o();
        my $tmp      := $!regalloc.fresh_o();

        # cclass_const
        my $cclass_word     := $!regalloc.fresh_i();
        my $cclass_newline  := $!regalloc.fresh_i();

        # create our labels
        my $startlabel   := label();
        my $donelabel    := label();
        my $restartlabel := label();
        my $faillabel    := label();
        my $jumplabel    := label();
        my $cutlabel     := label();
        my $cstacklabel  := label();

        my $self := $*BLOCK.local('self');

        my %!reg := nqp::hash(
            'tgt',      $tgt,
            'pos',      $pos,
            'off',      $off,
            'eos',      $eos,
            'rep',      $rep,
            'cur',      $cur,
            'curclass', $curclass,
            'bstack',   $bstack,
            'cstack',   $cstack,
            'negone',   $negone,
            'zero',     $zero,
            'one',      $one,
            'two',      $two,
            'three',    $three,
            'four',     $four,
            'P11',      $P11,
            'fail',     $faillabel,
            'jump',     $jumplabel,
            'method',   $method,
            'self',     $self,
            'cclass_word'   , $cclass_word,
            'cclass_newline', $cclass_newline
            );

        @!rxjumps := nqp::list($donelabel);

        my $shared := $!regalloc.fresh_o();
        my $sharedclass := $!regalloc.fresh_o();
        my $i19 := $!regalloc.fresh_i(); # yes, I know, inheriting the name from ancestor method
        my $i0 := $!regalloc.fresh_i();

        my @ins := [
            op('const_i64', $negone, ival(-1)),
            op('const_i64', $zero, ival(0)),
            op('const_i64', $one, ival(1)),
            op('const_i64', $two, ival(2)),
            op('const_i64', $three, ival(3)),
            op('const_i64', $four, ival(4)),
            op('const_i64', $cclass_word, ival(nqp::const::CCLASS_WORD)),
            op('const_i64', $cclass_newline, ival(nqp::const::CCLASS_NEWLINE)),
            op('findmeth', $method, $self, sval('!cursor_start')),
            call($method, [ $Arg::obj ], :result($cur), $self )
        ];

        my int $has_cursor_type := $node.has_cursor_type();
        if $has_cursor_type {
            $!cursor_type := $node.cursor_type();
            my $wval := $!qastcomp.as_mast(QAST::WVal.new( :value($!cursor_type) ));
            merge_ins(@ins, $wval.instructions);
            merge_ins(@ins, [
                op('set', $curclass, $wval.result_reg),
                op('getattr_o', $shared, $self, $curclass, sval('$!shared'),
                    ival(nqp::hintfor($!cursor_type, '$!shared')))
            ]);
            $!regalloc.release_register($wval.result_reg, $MVM_reg_obj);
        }
        else {
            merge_ins(@ins, [
                op('findmeth', $shared, $self, sval('!shared')),
                call($shared, [ $Arg::obj ], :result($shared), $self ),
                op('getwhat', $sharedclass, $shared),
                op('getattr_o', $curclass, $shared, $sharedclass, sval('$!CUR_CLASS'), ival(-1))
            ]);
        }
        
        merge_ins(@ins, [
            op('getattr_s', $tgt, $shared, $sharedclass, sval('$!target'),
                ival(nqp::hintfor(ParseShared, '$!target'))),
            op('flattenropes', $tgt),
            op('getattr_i', $pos, $cur, $curclass, sval('$!from'),
                ival(nqp::hintfor($!cursor_type, '$!from'))),
            op('getattr_o', $bstack, $cur, $curclass, sval('$!bstack'),
                ival(nqp::hintfor($!cursor_type, '$!bstack'))),
            op('getattr_o', $tmp, $self, $curclass, sval('$!restart'),
                ival(nqp::hintfor($!cursor_type, '$!restart'))),
            op('isconcrete', $i19, $tmp),
            op('bindlex', $*BLOCK.resolve_lexical('$¢'), $cur),
            op('chars', $eos, $tgt),
            op('eq_i', $i0, $one, $i19),
            op('if_i', $i0, $restartlabel),
            op('gt_i', $i0, $pos, $eos),
            op('if_i', $i0, $faillabel)
        ]);
        $!regalloc.release_register($i0, $MVM_reg_int64);
        $!regalloc.release_register($i19, $MVM_reg_int64);

        merge_ins(@ins, self.regex_mast($node));

        $i0 := $!regalloc.fresh_i();
        $i19 := $!regalloc.fresh_i();
        my $i18 := $!regalloc.fresh_i();
        merge_ins(@ins, [
            $restartlabel,
            op('getattr_o', $cstack, $cur, $curclass, sval('$!cstack'),
                ival(nqp::hintfor($!cursor_type, '$!cstack'))),
            $faillabel,
            op('isnull', $i0, $bstack),
            op('if_i', $i0, $donelabel),
            op('elems', $i0, $bstack),
            op('gt_i', $i0, $i0, $zero),
            op('unless_i', $i0, $donelabel),
            op('pop_i', $i19, $bstack),
            op('islist', $i0, $cstack),
            op('unless_i', $i0, $cstacklabel),
            op('elems', $i0, $cstack),
            op('gt_i', $i0, $i0, $zero),
            op('unless_i', $i0, $cstacklabel),
            op('dec_i', $i19),
            op('atpos_o', $P11, $cstack, $i19),
            $cstacklabel,
            op('pop_i', $rep, $bstack),
            op('pop_i', $pos, $bstack),
            op('pop_i', $i19, $bstack),
            op('lt_i', $i0, $pos, $negone),
            op('if_i', $i0, $donelabel),
            op('lt_i', $i0, $pos, $zero),
            op('if_i', $i0, $faillabel),
            op('eq_i', $i0, $i19, $zero),
            op('if_i', $i0, $faillabel),
            # backtrack the cursor stack
            op('isnull', $i0, $cstack),
            op('if_i', $i0, $jumplabel),
            op('unless_o', $cstack, $jumplabel),
            op('elems', $i18, $bstack),
            op('le_i', $i0, $i18, $zero),
            op('if_i', $i0, $cutlabel),
            op('dec_i', $i18),
            op('atpos_i', $i18, $bstack, $i18),
            $cutlabel,
            op('setelemspos', $cstack, $i18),
            $jumplabel,
            op('jumplist', ival(+@!rxjumps), $i19)
        ]);
        nqp::push(@ins, op('goto', $_)) for @!rxjumps;
        merge_ins(@ins, [
            $donelabel,
            op('findmeth', $method, $cur, sval('!cursor_fail')),
            call($method, [ $Arg::obj ], $cur), # don't pass a :result so it's void
        ]);

        MAST::InstructionList.new(@ins, $cur, $MVM_reg_obj)
    }

    method alt($node) {
        unless $node.name {
            return self.altseq($node);
        }

        # See if we can stash the labels array in an SC or if we'll have
        # to actually emit code for it.
        my @label_ins   := nqp::list();
        my @label_arr   := nqp::list_i();
        my int $have_sc := 0;
        if $!qastcomp.sc -> $sc {
            # Add labels array to SC.
            my $obj_idx := nqp::scobjcount($sc);
            nqp::setobjsc(@label_arr, $sc);
            nqp::scsetobj($sc, $obj_idx, @label_arr);

            # Emit wval instruction to look it up.
            my $sc_idx := $!qastcomp.mast_compunit.sc_idx($sc);
            nqp::push(@label_ins, op(
                $obj_idx < 32768 ?? 'wval' !! 'wval_wide',
                %!reg<P11>,
                MAST::IVal.new( :value($sc_idx) ),
                MAST::IVal.new( :value($obj_idx) )
            ));
            $have_sc := 1;
        }
        else {
            nqp::push(@label_ins, op('bootintarray', %!reg<P11>));
            nqp::push(@label_ins, op('create', %!reg<P11>, %!reg<P11>));
        }

        # Calculate all the branches to try, which populates the bstack
        # with the options. Then immediately fail to start iterating it.
        my $endlabel_index := self.rxjump();
        my $endlabel := @!rxjumps[$endlabel_index];
        my @ins := nqp::list();
        self.regex_mark(@ins, $endlabel_index, %!reg<negone>, %!reg<zero>);
        nqp::push(@ins, op('findmeth', %!reg<method>, %!reg<cur>, sval('!alt')));
        my $name := $!regalloc.fresh_s();
        nqp::push(@ins, op('const_s', $name, sval($node.name)));
        nqp::push(@ins, call(%!reg<method>, [ $Arg::obj, $Arg::int, $Arg::str, $Arg::obj ],
            %!reg<cur>, %!reg<pos>, $name, %!reg<P11>));
        $!regalloc.release_register($name, $MVM_reg_str);
        nqp::push(@ins, op('goto', %!reg<fail>));

        # Emit all the possible alternatives
        my $altcount := 0;
        my $iter     := nqp::iterator($node.list);
        my $itmp     := $!regalloc.fresh_i();
        while $iter {
            my $altlabel_index := self.rxjump();
            my $altlabel := @!rxjumps[$altlabel_index];
            my @amast    := self.regex_mast(nqp::shift($iter));
            nqp::push(@ins, $altlabel);
            merge_ins(@ins, @amast);
            nqp::push(@ins, op('goto', $endlabel));
            if $have_sc {
                nqp::push_i(@label_arr, $altlabel_index);
            }
            else {
                nqp::push(@label_ins, op('const_i64', $itmp, ival($altlabel_index)));
                nqp::push(@label_ins, op('push_i', %!reg<P11>, $itmp));
            }
            $altcount++;
        }
        $!regalloc.release_register($itmp, $MVM_reg_int64);
        nqp::push(@ins, $endlabel);
        self.regex_commit(@ins, $endlabel_index) if $node.backtrack eq 'r';
        merge_ins(@label_ins, @ins);
        @label_ins # so the label array creation or lookup happens first
    }

    method altseq($node) {
        my @ins := nqp::list();
        my $altcount := 0;
        my $iter := nqp::iterator($node.list);
        my $endlabel_index := self.rxjump();
        my $endlabel := @!rxjumps[$endlabel_index];
        my $altlabel_index := self.rxjump();
        my $altlabel := @!rxjumps[$altlabel_index];
        my @amast    := self.regex_mast(nqp::shift($iter));
        while $iter {
            nqp::push(@ins, $altlabel);
            $altcount++;
            $altlabel_index := self.rxjump();
            $altlabel := @!rxjumps[$altlabel_index];
            self.regex_mark(@ins, $altlabel_index, %!reg<pos>, %!reg<zero>);
            merge_ins(@ins, @amast);
            nqp::push(@ins, op('goto', $endlabel));
            @amast := self.regex_mast(nqp::shift($iter));
        }
        nqp::push(@ins, $altlabel);
        merge_ins(@ins, @amast);
        nqp::push(@ins, $endlabel);
        @ins
    }

    method anchor($node) {
        my @ins := nqp::list();
        my $subtype := $node.subtype;
        my $donelabel := label();
        my $i11 := $!regalloc.fresh_i();
        my $pos := %!reg<pos>;
        my $fail := %!reg<fail>;
        if $subtype eq 'bos' {
            nqp::push(@ins, op('ne_i', $i11, $pos, %!reg<zero>));
            nqp::push(@ins, op('if_i', $i11, $fail));
        }
        elsif $subtype eq 'eos' {
            nqp::push(@ins, op('lt_i', $i11, $pos, %!reg<eos>));
            nqp::push(@ins, op('if_i', $i11, $fail));
        }
        elsif $subtype eq 'lwb' {
            merge_ins(@ins, [
                op('ge_i', $i11, $pos, %!reg<eos>),
                op('if_i', $i11, $fail),
                op('iscclass', $i11, %!reg<cclass_word>, %!reg<tgt>, $pos),
                op('unless_i', $i11, %!reg<fail>),
                op('sub_i', $i11, %!reg<pos>, %!reg<one>),
                op('iscclass', $i11, %!reg<cclass_word>, %!reg<tgt>, $i11),
                op('if_i', $i11, $fail)
            ]);
        }
        elsif $subtype eq 'rwb' {
            merge_ins(@ins, [
                op('le_i', $i11, $pos, %!reg<zero>),
                op('if_i', $i11, $fail),
                op('iscclass', $i11, %!reg<cclass_word>, %!reg<tgt>, $pos),
                op('if_i', $i11, %!reg<fail>),
                op('sub_i', $i11, %!reg<pos>, %!reg<one>),
                op('iscclass', $i11, %!reg<cclass_word>, %!reg<tgt>, $i11),
                op('unless_i', $i11, $fail)
            ]);
        }
        elsif $subtype eq 'bol' {
            merge_ins(@ins, [
                op('eq_i', $i11, %!reg<pos>, %!reg<zero>),
                op('if_i', $i11, $donelabel),
                op('ge_i', $i11, $pos, %!reg<eos>),
                op('if_i', $i11, $fail),
                op('sub_i', $i11, %!reg<pos>, %!reg<one>),
                op('iscclass', $i11, %!reg<cclass_newline>, %!reg<tgt>, $i11),
                op('unless_i', $i11, $fail),
                $donelabel
            ]);
        }
        elsif $subtype eq 'eol' {
            merge_ins(@ins, [
                op('iscclass', $i11, %!reg<cclass_newline>, %!reg<tgt>, %!reg<pos>),
                op('if_i', $i11, $donelabel),
                op('ne_i', $i11, %!reg<pos>, %!reg<eos>),
                op('if_i', $i11, $fail),
                op('eq_i', $i11, %!reg<pos>, %!reg<zero>),
                op('if_i', $i11, $donelabel),
                op('sub_i', $i11, %!reg<pos>, %!reg<one>),
                op('iscclass', $i11, %!reg<cclass_newline>, %!reg<tgt>, $i11),
                op('if_i', $i11, $fail),
                $donelabel
            ]);
        }
        elsif $subtype eq 'fail' {
            nqp::push(@ins, op('goto', $fail));
        }
        elsif $subtype eq 'pass' || $subtype eq '' {
            # Nothing to do.
        } elsif $subtype eq 'zerowidth' {
            # Nothing to do either. This gets generated for <???>, for example
        }
        else {
            nqp::die("Unknown anchor subtype $subtype");
        }
        $!regalloc.release_register($i11, $MVM_reg_int64);
        @ins
    }

    my %cclass_code;
    INIT {
        %cclass_code<.>  := nqp::const::CCLASS_ANY;
        %cclass_code<d>  := nqp::const::CCLASS_NUMERIC;
        %cclass_code<s>  := nqp::const::CCLASS_WHITESPACE;
        %cclass_code<w>  := nqp::const::CCLASS_WORD;
        %cclass_code<n>  := nqp::const::CCLASS_NEWLINE;
    }

    method cclass($node) {
        my $subtype := $node.name;
        my $cclass := %cclass_code{ $subtype };
        self.panic("Unrecognized subtype '$subtype' in QAST::Regex cclass")
            unless $cclass;

        my @ins := nqp::list();
        my $i0 := $!regalloc.fresh_i();
        nqp::push(@ins, op('ge_i', $i0, %!reg<pos>, %!reg<eos>));
        nqp::push(@ins, op('if_i', $i0, %!reg<fail>));

        if $cclass != nqp::const::CCLASS_ANY {
            my $testop := $node.negate ?? 'if_i' !! 'unless_i';
            nqp::push(@ins, op('const_i64', $i0, ival($cclass)));
            nqp::push(@ins, op('iscclass', $i0, $i0, %!reg<tgt>, %!reg<pos>));
            nqp::push(@ins, op($testop, $i0, %!reg<fail>));
        }

        nqp::push(@ins, op('inc_i', %!reg<pos>)) unless $node.subtype eq 'zerowidth';
        $!regalloc.release_register($i0, $MVM_reg_int64);
        @ins
    }

    method concat($node) {
        my @ins := nqp::list();
        merge_ins(@ins, self.regex_mast($_)) for $node.list;
        @ins
    }

    method goal($node) {
        self.regex_mast(QAST::Regex.new(
            :rxtype<concat>,
            $node[1],
            QAST::Regex.new( :rxtype<altseq>, $node[0], $node[2] )
        ))
    }

    method conj($node) { self.conjseq($node) }

    method conjseq($node) {
        my $conjlabel_index := self.rxjump();
        my $conjlabel := @!rxjumps[$conjlabel_index];
        my $firstlabel := label();
        my $iter := nqp::iterator($node.list);
        my @ins := [
            op('goto', $firstlabel),
            $conjlabel,
            op('goto', %!reg<fail>),
            # call the first child
            $firstlabel
        ];
        # make a mark that holds our starting position in the pos slot
        self.regex_mark(@ins, $conjlabel_index, %!reg<pos>, %!reg<zero>);
        merge_ins(@ins, self.regex_mast(nqp::shift($iter)));
        # use previous mark to make one with pos=start, rep=end
        my $i11 := $!regalloc.fresh_i();
        my $i12 := $!regalloc.fresh_i();
        self.regex_peek(@ins, $conjlabel_index, $i11);
        self.regex_mark(@ins, $conjlabel_index, $i11, %!reg<pos>);

        while $iter {
            nqp::push(@ins, op('set', %!reg<pos>, $i11));
            merge_ins(@ins, self.regex_mast(nqp::shift($iter)));
            self.regex_peek(@ins, $conjlabel_index, $i11, $i12);
            nqp::push(@ins, op('ne_i', $i12, %!reg<pos>, $i12));
            nqp::push(@ins, op('if_i', $i12, %!reg<fail>));
        }
        nqp::push(@ins, op('set', %!reg<pos>, $i11)) if $node.subtype eq 'zerowidth';
        $!regalloc.release_register($i11, $MVM_reg_int64);
        $!regalloc.release_register($i12, $MVM_reg_int64);
        @ins
    }

    method enumcharlist($node) {
        my @ins;
        my $op := $node.negate ?? 'indexnat' !! 'indexat';
	my $i0 := $!regalloc.fresh_i();
	my $donelabel := label();
	# The indexat and indexnat opcodes assume <+[]>/<-[]> semantics, and don't return true at EOS,
	# so we compensate here by checking for EOS explicitly in the negative case, and succeeding.
	# (If instead we fix indexnat, we'd have to put the EOS check on the non-zerowidth branches,
	# but that makes the compiler loop for some reason, hence this approach.)
	if $node.subtype eq 'zerowidth' && $node.negate {
            merge_ins(@ins, [
		op('ge_i', $i0, %!reg<pos>, %!reg<eos>),
		op('if_i', $i0, $donelabel),
	    ]);
	}
        if $node.subtype eq 'ignoremark' || $node.subtype eq 'ignorecase+ignoremark' {
            my $s0 := $!regalloc.fresh_s();
            merge_ins(@ins, [
                op('ordbaseat', $i0, %!reg<tgt>, %!reg<pos>),
                op('chr', $s0, $i0),
                op($op, $s0, %!reg<zero>, sval($node[0]), %!reg<fail>),
            ]);
        }
        else {
            nqp::push(@ins, op($op, %!reg<tgt>, %!reg<pos>, sval($node[0]), %!reg<fail>));
        }
	nqp::push(@ins, op('inc_i', %!reg<pos>))
	    unless $node.subtype eq 'zerowidth';
	nqp::push(@ins, $donelabel) if $donelabel;
        @ins
    }

    method charrange($node) {
        my @ins;
        my $i0    := $!regalloc.fresh_i();
        my $i1    := $!regalloc.fresh_i();
        my $lower := $!regalloc.fresh_i();
        my $upper := $!regalloc.fresh_i();
        merge_ins(@ins, [
            op('ge_i', $i0, %!reg<pos>, %!reg<eos>),
            op('if_i', $i0, %!reg<fail>),
            op('const_i64', $lower, ival($node[1].value)),
            op('const_i64', $upper, ival($node[2].value)),
        ]);
        if $node[0] eq 'ignorecase+ignoremark' {
            my $succeed := label();
            my $s0      := $!regalloc.fresh_s();
            my $s1      := $!regalloc.fresh_s();
            my $i2      := $!regalloc.fresh_i();
            my $goal    := $node.negate ?? %!reg<fail> !! $succeed;
            merge_ins(@ins, [
                op('substr_s', $s0, %!reg<tgt>, %!reg<pos>, %!reg<one>),
                op('lc', $s1, $s0),
                op('ordbaseat', $i0, $s1, %!reg<zero>),
                op('ge_i', $i1, $i0, $lower),
                op('le_i', $i2, $i0, $upper),
                op('band_i', $i1, $i1, $i2),
                op('if_i', $i1, $goal),
                op('uc', $s1, $s0),
                op('ordbaseat', $i0, $s1, %!reg<zero>),
                op('ge_i', $i1, $i0, $lower),
                op('le_i', $i2, $i0, $upper),
                op('band_i', $i1, $i1, $i2),
                op('if_i', $i1, $goal),
            ]);
            $!regalloc.release_register($s0, $MVM_reg_str);
            $!regalloc.release_register($s1, $MVM_reg_str);
            $!regalloc.release_register($i2, $MVM_reg_int64);
            unless $node.negate {
                nqp::push(@ins, op('goto', %!reg<fail>));
                nqp::push(@ins, $succeed);
            }
        }
        elsif $node[0] eq 'ignorecase' {
            my $succeed := label();
            my $s0      := $!regalloc.fresh_s();
            my $s1      := $!regalloc.fresh_s();
            my $i2      := $!regalloc.fresh_i();
            my $goal    := $node.negate ?? %!reg<fail> !! $succeed;
            merge_ins(@ins, [
                op('substr_s', $s0, %!reg<tgt>, %!reg<pos>, %!reg<one>),
                op('lc', $s1, $s0),
                op('ordfirst', $i0, $s1),
                op('ge_i', $i1, $i0, $lower),
                op('le_i', $i2, $i0, $upper),
                op('band_i', $i1, $i1, $i2),
                op('if_i', $i1, $goal),
                op('uc', $s1, $s0),
                op('ordfirst', $i0, $s1),
                op('ge_i', $i1, $i0, $lower),
                op('le_i', $i2, $i0, $upper),
                op('band_i', $i1, $i1, $i2),
                op('if_i', $i1, $goal),
            ]);
            $!regalloc.release_register($s0, $MVM_reg_str);
            $!regalloc.release_register($s1, $MVM_reg_str);
            $!regalloc.release_register($i2, $MVM_reg_int64);
            unless $node.negate {
                nqp::push(@ins, op('goto', %!reg<fail>));
                nqp::push(@ins, $succeed);
            }
        }
        elsif $node[0] eq 'ignoremark' {
            my $succeed := label();
            my $goal := $node.negate ?? $succeed !! %!reg<fail>;
            merge_ins(@ins, [
                op('ordbaseat', $i0, %!reg<tgt>, %!reg<pos>),
                op('gt_i', $i1, $i0, $upper),
                op('if_i', $i1, $goal),
                op('lt_i', $i1, $i0, $lower),
                op('if_i', $i1, $goal),
            ]);
            if $node.negate {
                nqp::push(@ins, op('goto', %!reg<fail>));
                nqp::push(@ins, $succeed);
            }
        }
        else {
            my $succeed := label();
            my $goal    := $node.negate ?? $succeed !! %!reg<fail>;
            merge_ins(@ins, [
                op('ordat', $i0, %!reg<tgt>, %!reg<pos>),
                op('gt_i', $i1, $i0, $upper),
                op('if_i', $i1, $goal),
                op('lt_i', $i1, $i0, $lower),
                op('if_i', $i1, $goal),
            ]);
            if $node.negate {
                nqp::push(@ins, op('goto', %!reg<fail>));
                nqp::push(@ins, $succeed);
            }
        }
        nqp::push(@ins, op('inc_i', %!reg<pos>)) unless $node.subtype eq 'zerowidth';
        $!regalloc.release_register($i0,    $MVM_reg_int64);
        $!regalloc.release_register($i1,    $MVM_reg_int64);
        $!regalloc.release_register($lower, $MVM_reg_int64);
        $!regalloc.release_register($upper, $MVM_reg_int64);
        @ins
    }

    method literal($node) {
        my $litconst := $node[0];
        my $s0 := $!regalloc.fresh_s();
        my $i0 := $!regalloc.fresh_i();
        my @ins;
        if $node.negate {
            # Need explicit check we're not going beyond the string end in the
            # negated case, to avoid false positive.
            nqp::push(@ins, op('const_i64', $i0, ival(nqp::chars($litconst))));
            nqp::push(@ins, op('add_i', $i0, %!reg<pos>, $i0));
            nqp::push(@ins, op('gt_i', $i0, $i0, %!reg<eos>));
            nqp::push(@ins, op('if_i', $i0, %!reg<fail>));
        }
        # XXX create some regex prologue system so these const assignments
        # can happen only once at the beginning of a regex. hash of string constants
        # to the registers to which they are assigned.
        # XXX or make a specialized eqat_sc op that takes a constant string.
        # also, consider making the op branch directly from the comparison
        # instead of storing an integer to a temporary register
        if $node.subtype eq 'ignorecase+ignoremark' {
            my $op := $node.negate ?? 'indexnat' !! 'indexat';
            my $c  := nqp::chr(nqp::ordbaseat($litconst, 0));
            merge_ins(@ins, [
                op('ge_i', $i0, %!reg<pos>, %!reg<eos>),
                op('if_i', $i0, %!reg<fail>),
                op('ordbaseat', $i0, %!reg<tgt>, %!reg<pos>),
                op('chr', $s0, $i0),
                op($op, $s0, %!reg<zero>, sval(nqp::lc($c) ~ nqp::uc($c)), %!reg<fail>),
            ]);
        }
        else {
            my $eq_op := $node.subtype eq 'ignorecase' ?? 'eqatic_s' !!
                         $node.subtype eq 'ignoremark' ?? 'eqatim_s' !! 'eqat_s';
            my $cmpop := $node.negate ?? 'if_i' !! 'unless_i';
            nqp::push(@ins, op('const_s', $s0, sval($litconst)));
            nqp::push(@ins, op($eq_op, $i0, %!reg<tgt>, $s0, %!reg<pos>));
            nqp::push(@ins, op($cmpop, $i0, %!reg<fail>));
        }
        unless $node.subtype eq 'zerowidth' {
            nqp::push(@ins, op('const_i64', $i0, ival(nqp::chars($litconst))));
            nqp::push(@ins, op('add_i', %!reg<pos>, %!reg<pos>, $i0));
        }
        $!regalloc.release_register($s0, $MVM_reg_str);
        $!regalloc.release_register($i0, $MVM_reg_int64);
        @ins
    }

    method pass($node) {
        my @ins := nqp::list();
        my @args := [%!reg<cur>, %!reg<pos>];
        my @flags := [$Arg::obj, $Arg::int];
        my $op;
        my $meth := $!regalloc.fresh_o();
        nqp::push(@ins, op('findmeth', $meth, %!reg<cur>, sval('!cursor_pass')));
        if $node.name {
            my $sname := $!regalloc.fresh_s();
            nqp::push(@ins, op('const_s', $sname, sval($node.name)));
            nqp::push(@args, $sname);
            nqp::push(@flags, $Arg::str);
        }
        elsif +@($node) == 1 {
            my $name := $!qastcomp.as_mast($node[0], :want($MVM_reg_str));
            merge_ins(@ins, $name.instructions);
            nqp::push(@args, $name.result_reg);
            nqp::push(@flags, $Arg::str);
        }
        if $node.backtrack ne 'r' {
            nqp::push(@args, sval('backtrack'));
            nqp::push(@args, %!reg<one>);
            nqp::push(@flags, $Arg::named +| $Arg::int);
        }
        nqp::push(@ins, call($meth, @flags, :result($meth), |@args));
        $!regalloc.release_register($meth, $MVM_reg_obj);
        nqp::push(@ins, op('return_o', %!reg<cur>));
        @ins
    }

    sub resolve_condition_op($kind, $negated) {
        return $negated ??
            $kind == $MVM_reg_int64 ?? 'unless_i' !!
            $kind == $MVM_reg_num64 ?? 'unless_n' !!
            $kind == $MVM_reg_str   ?? 'unless_s' !!
            $kind == $MVM_reg_obj   ?? 'unless_o' !!
            ''
         !! $kind == $MVM_reg_int64 ?? 'if_i' !!
            $kind == $MVM_reg_num64 ?? 'if_n' !!
            $kind == $MVM_reg_str   ?? 'if_s' !!
            $kind == $MVM_reg_obj   ?? 'if_o' !!
            ''
    }

    method qastnode($node) {
        my @ins := [
            op('bindattr_i', %!reg<cur>, %!reg<curclass>, sval('$!pos'), %!reg<pos>, ival(-1)),
            op('bindlex', $*BLOCK.resolve_lexical('$¢'), %!reg<cur>)
        ];
        my $cmast := $!qastcomp.as_mast($node[0]);
        merge_ins(@ins, $cmast.instructions);
        $!regalloc.release_register($cmast.result_reg, $cmast.result_kind);
        my $cndop := resolve_condition_op($cmast.result_kind, !$node.negate);
        if $node.subtype eq 'zerowidth' && $cndop ne '' {
            nqp::push(@ins, op('decont', $cmast.result_reg, $cmast.result_reg))
                if $cmast.result_kind == $MVM_reg_obj;
            nqp::push(@ins, op($cndop, $cmast.result_reg, %!reg<fail>));
        }
        @ins
    }

    method dynquant($node) {
        my @ins := nqp::list();

        my $backtrack  := $node.backtrack || 'g';
        my $sep        := $node[2];
        my $looplabel_index := self.rxjump();
        my $looplabel  := @!rxjumps[$looplabel_index];
        my $donelabel_index := self.rxjump();
        my $donelabel  := @!rxjumps[$donelabel_index];
        my $skip0label := label();
        my $skip1label := label();
        my $skip2label := label();
        my $skip3label := label();
        my $skip4label := label();
        my $skip5label := label();
        my $skip6label := label();
        my $skip7label := label();
        my $skip8label := label();
        my $needrep    := $!regalloc.fresh_i();
        my $needmark   := $!regalloc.fresh_i();
        my $rep        := %!reg<rep>;
        my $pos        := %!reg<pos>;
        my $ireg       := $!regalloc.fresh_i();

        my $minmax     := $node[1];
        my $min_reg    := $!regalloc.fresh_i();
        my $max_reg    := $!regalloc.fresh_i();

        my $minmax_mast := $!qastcomp.as_mast($minmax, :want($MVM_reg_obj));
        my $res_reg     := $minmax_mast.result_reg;
        merge_ins(@ins, $minmax_mast.instructions);
        merge_ins(@ins, [
            op('atpos_i', $min_reg, $res_reg, %!reg<zero>),
            op('atpos_i', $max_reg, $res_reg, %!reg<one>),
        ]);

        # return if $min == 0 && $max == 0;
        merge_ins(@ins, [
            op('if_i', $min_reg, $skip8label),
            op('unless_i', $max_reg, $skip7label),
            $skip8label
        ]);

        # $needrep := $min > 1 || $max > 1;
        merge_ins(@ins, [
            op('gt_i', $needrep, $min_reg, %!reg<one>),
            op('if_i', $needrep, $skip0label),
            op('gt_i', $needrep, $max_reg, %!reg<one>),
            $skip0label
        ]);

        # $needmark := $needrep || $backtrack eq 'r';
        if $backtrack eq 'r' {
            nqp::push(@ins, op('set', $needmark, %!reg<one>));
        }
        else {
            nqp::push(@ins, op('set', $needmark, $needrep));
        }

        if $backtrack eq 'f' {
            my $seplabel := label();
            nqp::push(@ins, op('set', $rep, %!reg<zero>));

            nqp::push(@ins, op('ge_i', $ireg, $min_reg, %!reg<one>)); # if $min < 1 {
            nqp::push(@ins, op('if_i', $ireg, $skip1label));
            self.regex_mark(@ins, $looplabel_index, $pos, $rep);
            nqp::push(@ins, op('goto', $donelabel));
            nqp::push(@ins, $skip1label);                             # }

            nqp::push(@ins, op('goto', $seplabel)) if $sep;
            nqp::push(@ins, $looplabel);
            nqp::push(@ins, op('set', $ireg, $rep));
            if $sep {
                merge_ins(@ins, self.regex_mast($sep));
                nqp::push(@ins, $seplabel);
            }
            merge_ins(@ins, self.regex_mast($node[0]));
            merge_ins(@ins, [
                op('set', $rep, $ireg),
                op('inc_i', $rep),

                op('le_i', $ireg, $min_reg, %!reg<one>), # if $min > 1 {
                op('if_i', $ireg, $skip2label),
                op('lt_i', $ireg, $rep, $min_reg),
                op('if_i', $ireg, $looplabel),
                $skip2label,                             # }

                op('le_i', $ireg, $max_reg, %!reg<one>), # if $max > 1 {
                op('if_i', $ireg, $skip3label),
                op('ge_i', $ireg, $rep, $max_reg),
                op('if_i', $ireg, $donelabel),
                $skip3label,                             # }

                op('eq_i', $ireg, $max_reg, %!reg<one>), # unless $max == 1 {
                op('if_i', $ireg, $skip4label),
            ]);
            self.regex_mark(@ins, $looplabel_index, $pos, $rep);
            nqp::push(@ins, $skip4label);                # }

            nqp::push(@ins, $donelabel);
        }
        else {
            nqp::push(@ins, op('if_i', $min_reg, $skip1label));     # if $min == 0 {
            self.regex_mark(@ins, $donelabel_index, $pos, %!reg<zero>);
            nqp::push(@ins, $skip1label);                           # }

            nqp::push(@ins, op('unless_i', $min_reg, $skip2label)); # elsif $needmark {
            nqp::push(@ins, op('unless_i', $needmark, $skip2label));
            self.regex_mark(@ins, $donelabel_index, %!reg<negone>, %!reg<zero>);
            nqp::push(@ins, $skip2label);                           # }

            nqp::push(@ins, $looplabel);
            merge_ins(@ins, self.regex_mast($node[0]));

            nqp::push(@ins, op('unless_i', $needmark, $skip3label)); # if $needmark {
            self.regex_peek(@ins, $donelabel_index, MAST::Local.new(:index(-1)), $rep);
            self.regex_commit(@ins, $donelabel_index) if $backtrack eq 'r';
            merge_ins(@ins, [
                op('inc_i', $rep),

                op('le_i', $ireg, $max_reg, %!reg<one>), # if $max > 1 {
                op('if_i', $ireg, $skip4label),
                op('ge_i', $ireg, $rep, $max_reg),
                op('if_i', $ireg, $donelabel),
                $skip4label,                             # }
                $skip3label,                                        # }

                op('eq_i', $ireg, $max_reg, %!reg<one>), # unless $max == 1 {
                op('if_i', $ireg, $skip5label),
            ]);
            self.regex_mark(@ins, $donelabel_index, $pos, $rep);
            merge_ins(@ins, self.regex_mast($sep)) if $sep;
            merge_ins(@ins, [
                op('goto', $looplabel),
                $skip5label,                             # }
                $donelabel,

                op('le_i', $ireg, $min_reg, %!reg<one>), # if $min > 1 {
                op('if_i', $ireg, $skip6label),
                op('lt_i', $ireg, $rep, $min_reg),
                op('if_i', $ireg, %!reg<fail>),
                $skip6label,                             # }
            ]);
        }
        nqp::push(@ins, $skip7label);
        @ins
    }

    method quant($node) {
        my @ins := nqp::list();
        my $min := $node.min;
        my $max := $node.max;

        if $min == 0 && $max == 0 {
            # Nothing to do, and nothing to backtrack into.
            return @ins;
        }

        my $backtrack := $node.backtrack || 'g';
        my $sep       := $node[1];
        my $looplabel_index := self.rxjump();
        my $looplabel := @!rxjumps[$looplabel_index];
        my $donelabel_index := self.rxjump();
        my $donelabel := @!rxjumps[$donelabel_index];
        my $needrep   := $min > 1 || $max > 1;
        my $needmark  := $needrep || $backtrack eq 'r';
        my $rep       := %!reg<rep>;
        my $pos       := %!reg<pos>;
        my $ireg      := $!regalloc.fresh_register($MVM_reg_int64, 1); # Must be regex-unique

        if $backtrack eq 'f' {
            my $seplabel := label();
            nqp::push(@ins, op('set', $rep, %!reg<zero>));
            if $min < 1 {
                self.regex_mark(@ins, $looplabel_index, $pos, $rep);
                nqp::push(@ins, op('goto', $donelabel));
            }
            nqp::push(@ins, op('goto', $seplabel)) if $sep;
            nqp::push(@ins, $looplabel);
            nqp::push(@ins, op('set', $ireg, $rep));
            if $sep {
                merge_ins(@ins, self.regex_mast($sep));
                nqp::push(@ins, $seplabel);
            }
            merge_ins(@ins, self.regex_mast($node[0]));
            nqp::push(@ins, op('set', $rep, $ireg));
            nqp::push(@ins, op('inc_i', $rep));
            if $min > 1 {
                my $minreg := $!regalloc.fresh_i();
                nqp::push(@ins, op('const_i64', $minreg, ival($min)));
                nqp::push(@ins, op('lt_i', $ireg, $rep, $minreg));
                nqp::push(@ins, op('if_i', $ireg, $looplabel));
                $!regalloc.release_register($minreg, $MVM_reg_int64);
            }
            if $max > 1 {
                my $maxreg := $!regalloc.fresh_i();
                nqp::push(@ins, op('const_i64', $maxreg, ival($max)));
                nqp::push(@ins, op('ge_i', $ireg, $rep, $maxreg));
                nqp::push(@ins, op('if_i', $ireg, $donelabel));
                $!regalloc.release_register($maxreg, $MVM_reg_int64);
            }
            self.regex_mark(@ins, $looplabel_index, $pos, $rep) if $max != 1;
            nqp::push(@ins, $donelabel);
        }
        else {
            if $min == 0 { self.regex_mark(@ins, $donelabel_index, $pos, %!reg<zero>); }
            elsif $needmark { self.regex_mark(@ins, $donelabel_index, %!reg<negone>, %!reg<zero>); }
            nqp::push(@ins, $looplabel);
            merge_ins(@ins, self.regex_mast($node[0]));
            if $needmark {
                self.regex_peek(@ins, $donelabel_index, MAST::Local.new(:index(-1)), $rep);
                self.regex_commit(@ins, $donelabel_index) if $backtrack eq 'r';
                nqp::push(@ins, op('inc_i', $rep));
                if $max > 1 {
                    my $maxreg := $!regalloc.fresh_i();
                    nqp::push(@ins, op('const_i64', $maxreg, ival($max)));
                    nqp::push(@ins, op('ge_i', $ireg, $rep, $maxreg));
                    nqp::push(@ins, op('if_i', $ireg, $donelabel));
                    $!regalloc.release_register($maxreg, $MVM_reg_int64);
                }
            }
            unless $max == 1 {
                self.regex_mark(@ins, $donelabel_index, $pos, $rep);
                merge_ins(@ins, self.regex_mast($sep)) if $sep;
                nqp::push(@ins, op('goto', $looplabel));
            }
            nqp::push(@ins, $donelabel);
            if $min > 1 {
                my $minreg := $!regalloc.fresh_i();
                nqp::push(@ins, op('const_i64', $minreg, ival($min)));
                nqp::push(@ins, op('lt_i', $ireg, $rep, $minreg));
                nqp::push(@ins, op('if_i', $ireg, %!reg<fail>));
                $!regalloc.release_register($minreg, $MVM_reg_int64);
            }
        }
        @ins
    }

    method scan($node) {
        my $looplabel_index := self.rxjump();
        my $looplabel := @!rxjumps[$looplabel_index];
        my $scanlabel := label();
        my $donelabel := label();
        my $ireg0 := $!regalloc.fresh_i();
        my @ins := [
            op('getattr_i', $ireg0, %!reg<self>, %!reg<curclass>, sval('$!from'),
                ival(nqp::hintfor($!cursor_type, '$!from'))),
            op('ne_i', $ireg0, $ireg0, %!reg<negone>),
            op('if_i', $ireg0, $donelabel),
            op('goto', $scanlabel),
            $looplabel,
            op('inc_i', %!reg<pos>),
        ];
        if $node.list && $node.subtype ne 'ignorecase' && $node.subtype ne 'ignoremark' && $node.subtype ne 'ignorecase+ignoremark' {
            my $lit := $!regalloc.fresh_s();
            nqp::push(@ins, op('const_s', $lit, sval($node[0])));
            nqp::push(@ins, op('index_s', %!reg<pos>, %!reg<tgt>, $lit, %!reg<pos>));
            nqp::push(@ins, op('eq_i', $ireg0, %!reg<pos>, %!reg<negone>));
            $!regalloc.release_register($lit, $MVM_reg_str);
        }
        else {
            nqp::push(@ins, op('gt_i', $ireg0, %!reg<pos>, %!reg<eos>));
        }
        nqp::push(@ins, op('if_i', $ireg0, %!reg<fail>));
        nqp::push(@ins, op('bindattr_i', %!reg<cur>, %!reg<curclass>, sval('$!from'), %!reg<pos>, ival(-1)));
        nqp::push(@ins, $scanlabel);
        self.regex_mark(@ins, $looplabel_index, %!reg<pos>, %!reg<zero>);
        nqp::push(@ins, $donelabel);
        @ins
    }

    method subcapture($node) {
        my @ins := nqp::list();
        my $donelabel := label();
        my $faillabel_index := self.rxjump();
        my $faillabel := @!rxjumps[$faillabel_index];
        my $i11 := $!regalloc.fresh_i();
        my $p11 := $!regalloc.fresh_o();
        my $s11 := $!regalloc.fresh_s();
        self.regex_mark(@ins, $faillabel_index, %!reg<pos>, %!reg<zero>);
        merge_ins(@ins, self.regex_mast($node[0]));
        self.regex_peek(@ins, $faillabel_index, $i11);
        merge_ins(@ins, [
            op('bindattr_i', %!reg<cur>, %!reg<curclass>, sval('$!pos'),
                %!reg<pos>, ival(-1)),
            op('findmeth', %!reg<method>, %!reg<cur>, sval('!cursor_start_subcapture')),
            call(%!reg<method>, [$Arg::obj, $Arg::int], %!reg<cur>, $i11, :result($p11)),
            op('findmeth', %!reg<method>, $p11, sval('!cursor_pass')),
            call(%!reg<method>, [$Arg::obj, $Arg::int], $p11, %!reg<pos>),
            op('findmeth', %!reg<method>, %!reg<cur>, sval('!cursor_capture')),
            op('const_s', $s11, sval($node.name)),
            call(%!reg<method>, [$Arg::obj, $Arg::obj, $Arg::str],
                %!reg<cur>, $p11, $s11, :result(%!reg<cstack>)),
            op('goto', $donelabel),
            $faillabel,
            op('goto', %!reg<fail>),
            $donelabel
        ]);
        $!regalloc.release_register($i11, $MVM_reg_int64);
        $!regalloc.release_register($p11, $MVM_reg_obj);
        $!regalloc.release_register($s11, $MVM_reg_str);
        @ins
    }

    my @kind_to_args := [0,
        $Arg::int,  # $MVM_reg_int8            := 1;
        $Arg::int,  # $MVM_reg_int16           := 2;
        $Arg::int,  # $MVM_reg_int32           := 3;
        $Arg::int,  # $MVM_reg_int64           := 4;
        $Arg::num,  # $MVM_reg_num32           := 5;
        $Arg::num,  # $MVM_reg_num64           := 6;
        $Arg::str,  # $MVM_reg_str             := 7;
        $Arg::obj   # $MVM_reg_obj             := 8;
    ];

     method children($node) {
        my @masts := nqp::list();
        my @results := nqp::list();
        my @result_kinds := nqp::list();
        my @flags := nqp::list();
        for @($node) {
            my $mast := $!qastcomp.as_mast($_);
            merge_ins(@masts, $mast.instructions);
            my $kind := $mast.result_kind;
            my $flag := @kind_to_args[$kind];
            if $_.flat {
                $flag := $flag +| ($_.named ?? $Arg::flatnamed !! $Arg::flat);
            }
            elsif $_.named {
                nqp::push(@results, MAST::SVal.new( value => $_.named ));
                nqp::push(@result_kinds, NQPMu);
                $flag := $flag +| $Arg::named;
            }
            nqp::push(@results, $mast.result_reg);
            nqp::push(@result_kinds, $kind);
            nqp::push(@flags, $flag);
        }
        [@masts, @results, @result_kinds, @flags]
    }

    method subrule($node) {
        my @ins      := nqp::list();
        my $subtype  := $node.subtype;
        my $testop   := $node.negate ?? 'ge_i' !! 'lt_i';
        my $captured := 0;

        my @arg_info := self.children($node[0]);
        my @args := @arg_info[1];
        my @kinds := @arg_info[2];
        my @flags := @arg_info[3];

        my $submast := nqp::shift(@args);
        my $submast_kind := nqp::shift(@kinds);
        $!regalloc.release_register($submast, $submast_kind);

        my $i := 0;
        for @kinds {
            $!regalloc.release_register(@args[$i], $_)
                if nqp::isconcrete($_);
            $i++;
        }

        @flags[0] := $Arg::obj;

        my $p11 := %!reg<P11>;
        my $i11 := $!regalloc.fresh_i();

        merge_ins(@ins, @arg_info[0]);
        merge_ins(@ins, [
            op('bindattr_i', %!reg<cur>, %!reg<curclass>, sval('$!pos'),
                %!reg<pos>, ival(-1))
        ]);
        if nqp::istype($node[0][0], QAST::SVal) {
            # Method call.
            merge_ins(@ins, [
                op('findmeth', %!reg<method>, %!reg<cur>, sval($node[0][0].value)),
                call(%!reg<method>, @flags, %!reg<cur>, |@args, :result($p11))
            ]);
        }
        else {
            # Normal invocation (probably positional capture).
            merge_ins(@ins, [
                call($submast, @flags, %!reg<cur>, |@args, :result($p11))
            ]);
        }
        merge_ins(@ins, [
            op('getattr_i', $i11, $p11, %!reg<curclass>, sval('$!pos'),
                ival(nqp::hintfor($!cursor_type, '$!pos'))),
            op($testop, $i11, $i11, %!reg<zero>),
            op('if_i', $i11, %!reg<fail>)
        ]);

        if $subtype ne 'zerowidth' {
            my $passlabel_index := self.rxjump();
            my $passlabel := @!rxjumps[$passlabel_index];
            if $node.backtrack eq 'r' {
                unless $subtype eq 'method' {
                    self.regex_mark(@ins, $passlabel_index, %!reg<negone>, %!reg<zero>);
                }
                nqp::push(@ins, $passlabel);
            }
            else {
                my $backlabel_index := self.rxjump();
                my $backlabel := @!rxjumps[$backlabel_index];
                merge_ins(@ins, [
                    op('goto', $passlabel),
                    $backlabel,
                    # %!reg<P11> ($p11 here) is magically set just before the jump at the backtracker
                    op('findmeth', %!reg<method>, $p11, sval('!cursor_next')),
                    call(%!reg<method>, [$Arg::obj], $p11, :result($p11)),
                    op('getattr_i', $i11, $p11, %!reg<curclass>, sval('$!pos'),
                        ival(nqp::hintfor($!cursor_type, '$!pos'))),
                    op($testop, $i11, $i11, %!reg<zero>),
                    op('if_i', $i11, %!reg<fail>),
                    $passlabel
                ]);

                if $subtype eq 'capture' {
                    my $sname := $!regalloc.fresh_s();
                    nqp::push(@ins, op('findmeth', %!reg<method>, %!reg<cur>,
                        sval('!cursor_capture')));
                    nqp::push(@ins, op('const_s', $sname, sval($node.name)));
                    nqp::push(@ins, call(%!reg<method>, [$Arg::obj, $Arg::obj, $Arg::str],
                        %!reg<cur>, $p11, $sname, :result(%!reg<cstack>)));
                    $!regalloc.release_register($sname, $MVM_reg_str);
                    $captured := 1;

                    # Record a mark on the bstack saying how many captures we
                    # had before pushing this one, so we can remove it upon
                    # backtracking (otherwise we end up keeping backtracked
                    # over subrule captures around).
                    my $bstack := %!reg<bstack>;
                    merge_ins(@ins, [
                        op('const_i64', $i11, ival($backlabel_index)),
                        op('push_i', $bstack, $i11),
                        op('push_i', $bstack, %!reg<negone>),
                        op('push_i', $bstack, %!reg<negone>),
                        op('elems', $i11, %!reg<cstack>),
                        op('dec_i', $i11),
                        op('push_i', $bstack, $i11)
                    ]);
                }
                else {
                    nqp::push(@ins, op('findmeth', %!reg<method>, %!reg<cur>,
                        sval('!cursor_push_cstack')));
                    nqp::push(@ins, call(%!reg<method>, [$Arg::obj, $Arg::obj],
                        %!reg<cur>, $p11, :result(%!reg<cstack>)));
                }

                my $bstack := %!reg<bstack>;
                merge_ins(@ins, [
                    op('const_i64', $i11, ival($backlabel_index)),
                    op('push_i', $bstack, $i11),
                    op('push_i', $bstack, %!reg<zero>),
                    op('push_i', $bstack, %!reg<pos>),
                    op('elems', $i11, %!reg<cstack>),
                    op('push_i', $bstack, $i11)
                ]);
            }
        }

        if !$captured && $subtype eq 'capture' {
            my $sname := $!regalloc.fresh_s();
            nqp::push(@ins, op('findmeth', %!reg<method>, %!reg<cur>,
                sval('!cursor_capture')));
            nqp::push(@ins, op('const_s', $sname, sval($node.name)));
            nqp::push(@ins, call(%!reg<method>, [$Arg::obj, $Arg::obj, $Arg::str],
                %!reg<cur>, $p11, $sname, :result(%!reg<cstack>)));
            $!regalloc.release_register($sname, $MVM_reg_str);
        }

        nqp::push(@ins, op('getattr_i', %!reg<pos>, $p11, %!reg<curclass>,
            sval('$!pos'), ival(nqp::hintfor($!cursor_type, '$!pos'))))
                unless $subtype eq 'zerowidth';

        $!regalloc.release_register($i11, $MVM_reg_int64);

        @ins
    }

    method regex_mark(@ins, $label_index, $pos, $rep) {
        my $bstack := %!reg<bstack>;
        my $mark := $!regalloc.fresh_i();
        my $elems := $!regalloc.fresh_i();
        my $caps := $!regalloc.fresh_i();
        my $haselemslabel := label();
        my $haselemsendlabel := label();
        merge_ins(@ins, [
            op('const_i64', $mark, ival($label_index)),
            op('elems', $elems, $bstack),
            op('gt_i', $caps, $elems, %!reg<zero>),
            op('if_i', $caps, $haselemslabel),
            op('set', $caps, %!reg<zero>),
            op('goto', $haselemsendlabel),
            $haselemslabel,
            op('dec_i', $elems),
            op('atpos_i', $caps, $bstack, $elems),
            $haselemsendlabel,
            op('push_i', $bstack, $mark),
            op('push_i', $bstack, $pos),
            op('push_i', $bstack, $rep),
            op('push_i', $bstack, $caps)
        ]);
        $!regalloc.release_register($mark, $MVM_reg_int64);
        $!regalloc.release_register($elems, $MVM_reg_int64);
        $!regalloc.release_register($caps, $MVM_reg_int64);
    }

    method regex_peek(@ins, $label_index, *@regs) {
        my $bstack := %!reg<bstack>;
        my $mark := $!regalloc.fresh_i();
        my $ptr := $!regalloc.fresh_i();
        my $i0 := $!regalloc.fresh_i();
        my $haselemsendlabel := label();
        my $backupendlabel := label();
        merge_ins(@ins, [
            op('const_i64', $mark, ival($label_index)),
            op('elems', $ptr, $bstack),
            $haselemsendlabel,
            op('lt_i', $i0, $ptr, %!reg<zero>),
            op('if_i', $i0, $backupendlabel),
            op('atpos_i', $i0, $bstack, $ptr),
            op('eq_i', $i0, $i0, $mark),
            op('if_i', $i0, $backupendlabel),
            op('sub_i', $ptr, $ptr, %!reg<four>),
            op('goto', $haselemsendlabel),
            $backupendlabel
        ]);
        for @regs {
            nqp::push(@ins, op('inc_i', $ptr));
            nqp::push(@ins, op('atpos_i', $_, $bstack, $ptr)) if $_.index != -1;
        }
        $!regalloc.release_register($mark, $MVM_reg_int64);
        $!regalloc.release_register($ptr, $MVM_reg_int64);
        $!regalloc.release_register($i0, $MVM_reg_int64);
    }

    method regex_commit(@ins, $label_index) {
        my $bstack := %!reg<bstack>;
        my $mark := $!regalloc.fresh_i();
        my $ptr := $!regalloc.fresh_i();
        my $caps := $!regalloc.fresh_i();
        my $i0 := $!regalloc.fresh_i();
        my $haselemslabel := label();
        my $haselemsendlabel := label();
        my $backupendlabel := label();
        my $nocapslabel := label();
        my $makemarklabel := label();
        merge_ins(@ins, [
            op('const_i64', $mark, ival($label_index)),
            op('elems', $ptr, $bstack),
            op('gt_i', $caps, $ptr, %!reg<zero>),
            op('if_i', $caps, $haselemslabel),
            op('set', $caps, %!reg<zero>),
            op('goto', $haselemsendlabel),
            $haselemslabel,
            op('dec_i', $ptr),
            op('atpos_i', $caps, $bstack, $ptr),
            op('inc_i', $ptr),
            $haselemsendlabel,
            op('lt_i', $i0, $ptr, %!reg<zero>),
            op('if_i', $i0, $backupendlabel),
            op('atpos_i', $i0, $bstack, $ptr),
            op('eq_i', $i0, $i0, $mark),
            op('if_i', $i0, $backupendlabel),
            op('sub_i', $ptr, $ptr, %!reg<four>),
            op('goto', $haselemsendlabel),
            $backupendlabel,
            op('setelemspos', $bstack, $ptr),
            op('lt_i', $i0, $caps, %!reg<one>),
            op('if_i', $i0, $nocapslabel),
            op('lt_i', $i0, $ptr, %!reg<one>),
            op('if_i', $i0, $makemarklabel),
            op('sub_i', $ptr, $ptr, %!reg<three>),
            op('atpos_i', $i0, $bstack, $ptr),
            op('ge_i', $i0, $i0, %!reg<zero>),
            op('if_i', $i0, $makemarklabel),
            op('add_i', $ptr, $ptr, %!reg<two>),
            op('bindpos_i', $bstack, $ptr, $caps),
            op('inc_i', $ptr),
            op('goto', $nocapslabel),
            $makemarklabel,
            op('push_i', $bstack, %!reg<zero>),
            op('push_i', $bstack, %!reg<negone>),
            op('push_i', $bstack, %!reg<zero>),
            op('push_i', $bstack, $caps),
            $nocapslabel
        ]);
        $!regalloc.release_register($mark, $MVM_reg_int64);
        $!regalloc.release_register($ptr, $MVM_reg_int64);
        $!regalloc.release_register($caps, $MVM_reg_int64);
        $!regalloc.release_register($i0, $MVM_reg_int64);
    }

    method regex_mast($node) {
        unless $node ~~ QAST::Regex {
            my $mast := $!qastcomp.as_mast($node);
            $!regalloc.release_register($mast.result_reg, $mast.result_kind);
            return $mast.instructions;
        }
        my $rxtype := $node.rxtype() || 'concat';
        self."$rxtype"($node) # expects to return an nqp::list of instructions
    }

    method uniprop($node) {
        my $pname   := $!regalloc.fresh_s();
        my $pcode   := $!regalloc.fresh_i();
        my $pvcode  := $!regalloc.fresh_i();
        my $pprop   := $!regalloc.fresh_s();
        my $i0      := $!regalloc.fresh_i();
        my $testop  := $node.negate ?? 'if_i' !! 'unless_i';
        my $succeed := label();
        my $prop    := ~$node[0];
        my @ins     := [
            op('ge_i', $i0, %!reg<pos>, %!reg<eos>),
            op('if_i', $i0, %!reg<fail>),
        ];
        if +@($node) == 1 {
            my $hasvalcode := label();
            my $endblock   := label();
            if $prop eq 'name' || $prop eq 'Name' {
                my $s0 := $!regalloc.fresh_s();
                merge_ins(@ins, [
                    op('ordat', $i0, %!reg<tgt>, %!reg<pos>),
                    op('getuniname', $s0, $i0),
                    op('const_i64', $i0, %!reg<zero>),
                    op('unless_s', $s0, $endblock),
                    op('ordfirst', $i0, $s0),
                    op('const_i64', $pcode, ival(60)), # not a property code but the ord of '<'
                    op('ne_i', $i0, $i0, $pcode),
                    $endblock,
                    op('if_i', $i0, $succeed),
                ]);
            }
            elsif $prop ~~ /^ [ In<[A..Z]> | in<[a..z]> ]/ { # "InArabic" is a lookup of Block Arabic
                merge_ins(@ins, [
                    op('const_s', $pname, sval(nqp::substr($prop,2))),
                    op('uniisblock', $i0, %!reg<tgt>, %!reg<pos>, $pname),
                    op('if_i', $i0, $succeed),
                    op('const_s', $pprop, sval('Block')),
                    op('unipropcode', $pcode, $pprop),
                    op('unless_i', $pcode, $endblock),
                    op('unipvalcode', $pvcode, $pcode, $pname),
                    op('if_i', $pvcode, $hasvalcode),
                    $endblock,
                ]);
            }
            merge_ins(@ins, [
                op('const_s', $pname, sval($node[0])),
                op('unipropcode', $pcode, $pname),
                op('unipvalcode', $pvcode, $pcode, $pname),
                #~ op($testop, $pvcode, %!reg<fail>), # XXX I am sure we should fail here
                $hasvalcode,
                op('hasuniprop', $i0, %!reg<tgt>, %!reg<pos>, $pcode, $pvcode),
                $succeed,
                op($testop, $i0, %!reg<fail>),
            ]);
        }
        elsif $prop eq 'name' || $prop eq 'Name' {
            my $smrtmtch_mast := $!qastcomp.as_mast($node[1], :want($MVM_reg_obj));
            my $s0            := $!regalloc.fresh_s();
            merge_ins(@ins, $smrtmtch_mast.instructions);
            merge_ins(@ins, [
                op('ordat', $i0, %!reg<tgt>, %!reg<pos>),
                op('getuniname', $s0, $i0),
                op('findmeth', %!reg<method>, %!reg<cur>, sval('!DELEGATE_ACCEPTS')),
                call(%!reg<method>, [$Arg::obj, $Arg::obj, $Arg::str], :result($i0),
                    %!reg<cur>, $smrtmtch_mast.result_reg, $s0),
                op($testop, $i0, %!reg<fail>),
            ]);
        }
        else {
            my $smrtmtch_mast := $!qastcomp.as_mast($node[1], :want($MVM_reg_obj));
            my $s0            := $!regalloc.fresh_s();
            my $tryintprop    := label();
            my $tryboolprop   := label();
            merge_ins(@ins, $smrtmtch_mast.instructions);
            merge_ins(@ins, [
                op('const_s', $pname, sval($prop)),
                op('unipropcode', $pcode, $pname),
                op('unipvalcode', $pvcode, $pcode, $pname),
                op('ordat', $i0, %!reg<tgt>, %!reg<pos>),

                op('getuniprop_str', $s0, $i0, $pcode),
                op('unless_s', $s0, $tryintprop),
                op('findmeth', %!reg<method>, %!reg<cur>, sval('!DELEGATE_ACCEPTS')),
                call(%!reg<method>, [$Arg::obj, $Arg::obj, $Arg::str], :result($i0),
                    %!reg<cur>, $smrtmtch_mast.result_reg, $s0),
                op('goto', $succeed),

                $tryintprop,
                op('getuniprop_int', $i0, $i0, $pcode),
                op('findmeth', %!reg<method>, %!reg<cur>, sval('!DELEGATE_ACCEPTS')),
                call(%!reg<method>, [$Arg::obj, $Arg::obj, $Arg::int], :result($i0),
                    %!reg<cur>, $smrtmtch_mast.result_reg, $i0),

                $succeed,
                op($testop, $i0, %!reg<fail>),
            ]);
        }
        nqp::push(@ins, op('inc_i', %!reg<pos>)) unless $node.subtype eq 'zerowidth';
        @ins
    }

    method ws($node) { self.subrule($node) }

    method dba($node) {
        my @flags := [$Arg::obj, $Arg::int, $Arg::str];
        my $sname := $!regalloc.fresh_s();
        my @ins := [
            op('const_s', $sname, sval($node.name)),
            op('findmeth', %!reg<method>, %!reg<cur>, sval('!dba')),
            call(%!reg<method>, @flags, %!reg<cur>, %!reg<pos>, $sname)
        ];
        $!regalloc.release_register($sname, $MVM_reg_str);
        @ins
    }

    method rxjump() {
        my $index := +@!rxjumps;
        @!rxjumps[$index] := MAST::Label.new();
        $index
    }

    sub merge_ins(@dest, @src) {
        nqp::splice(@dest, @src, +@dest, 0);
    }

    sub op(str $op, *@args) {
        MAST::Op.new_with_operand_array( :$op, @args );
    }

    sub call($target, @flags, :$result?, *@args) {
        nqp::defined($result) ??
        MAST::Call.new(
            :target($target), :result($result), :flags(@flags), |@args
        ) !!
        MAST::Call.new(
            :target($target), :flags(@flags), |@args
        )
    }

    sub label()    { MAST::Label.new() }
    sub ival($val) { MAST::IVal.new( :value($val) ) }
    sub nval($val) { MAST::NVal.new( :value($val) ) }
    sub sval($val) { MAST::SVal.new( :value($val) ) }
}
# From src/vm/moar/QAST/QASTOperationsMAST.nqp

my $MVM_operand_literal     := 0;
my $MVM_operand_read_reg    := 1;
my $MVM_operand_write_reg   := 2;
my $MVM_operand_read_lex    := 3;
my $MVM_operand_write_lex   := 4;
my $MVM_operand_rw_mask     := 7;

my $MVM_operand_int8        := ($MVM_reg_int8 * 8);
my $MVM_operand_int16       := ($MVM_reg_int16 * 8);
my $MVM_operand_int32       := ($MVM_reg_int32 * 8);
my $MVM_operand_int64       := ($MVM_reg_int64 * 8);
my $MVM_operand_num32       := ($MVM_reg_num32 * 8);
my $MVM_operand_num64       := ($MVM_reg_num64 * 8);
my $MVM_operand_str         := ($MVM_reg_str * 8);
my $MVM_operand_obj         := ($MVM_reg_obj * 8);
my $MVM_operand_ins         := (9 * 8);
my $MVM_operand_type_var    := (10 * 8);
my $MVM_operand_lex_outer   := (11 * 8);
my $MVM_operand_coderef     := (12 * 8);
my $MVM_operand_callsite    := (13 * 8);
my $MVM_operand_type_mask   := (31 * 8);
my $MVM_operand_uint8       := ($MVM_reg_uint8 * 8);
my $MVM_operand_uint16      := ($MVM_reg_uint16 * 8);
my $MVM_operand_uint32      := ($MVM_reg_uint32 * 8);
my $MVM_operand_uint64      := ($MVM_reg_uint64 * 8);

# This is used as a return value from all of the various compilation routines.
# It groups together a set of instructions along with a result register and a
# result kind.  It also tracks the source filename and line number.
class MAST::InstructionList {
    has @!instructions;
    has $!result_reg;
    has int $!result_kind;
    has str $!filename;
    has int $!lineno;

    method new(@instructions, $result_reg, $result_kind, str :$filename = '<anon>', int :$lineno = 0) {
        my $obj := nqp::create(self);
        nqp::bindattr($obj, MAST::InstructionList, '@!instructions', @instructions);
        nqp::bindattr($obj, MAST::InstructionList, '$!result_reg', $result_reg);
        nqp::bindattr_i($obj, MAST::InstructionList, '$!result_kind', $result_kind);
        nqp::bindattr_s($obj, MAST::InstructionList, '$!filename', $filename);
        nqp::bindattr_i($obj, MAST::InstructionList, '$!lineno', $lineno);
        $obj
    }

    method instructions() { @!instructions }
    method result_reg()   { $!result_reg }
    method result_kind()  { $!result_kind }
    method filename()     { $!filename }
    method lineno()       { $!lineno }

    method append(MAST::InstructionList $other) {
        push_ilist(@!instructions, $other);
        $!result_reg := $other.result_reg;
        $!result_kind := $other.result_kind;
    }
}

# Marker object for void.
class MAST::VOID { }

class QAST::MASTOperations {

    # Maps operations to code that will handle them. Hash of code.
    my %core_ops;

    # Maps HLL-specific operations to code that will handle them.
    # Hash of hash of code.
    my %hll_ops;

    # Mapping of how to box/unbox by HLL.
    my %hll_box;
    my %hll_unbox;

    # What we know about inlinability.
    my %core_inlinability;
    my %hll_inlinability;

    # What we know about op native results types.
    my %core_result_type;
    my %hll_result_type;

    # Compiles an operation to MAST.
    method compile_op($qastcomp, $hll, $op) {
        my str $name := $op.op;
        my $mapper;
        if $hll {
            my %ops := %hll_ops{$hll};
            $mapper := %ops{$name} if %ops;
        }
        $mapper := %core_ops{$name} unless $mapper;
        $mapper
            ?? $mapper($qastcomp, $op)
            !! nqp::die("No registered operation handler for '$name'");
    }

    my @kind_names := ['VOID','int8','int16','int32','int','num32','num','str','obj'];
    my @kind_types := [0,1,1,1,1,2,2,3,4];

    my @core_operands_offsets := MAST::Ops.WHO<@offsets>;
    my @core_operands_counts  := MAST::Ops.WHO<@counts>;
    my @core_operands_values  := MAST::Ops.WHO<@values>;
    my %core_op_codes         := MAST::Ops.WHO<%codes>;
    method compile_mastop($qastcomp, $op, @args, @deconts, :$returnarg = -1, :$want) {
        # Resolve as either core op or ext op.
        my int $num_operands;
        my int $operands_offset;
        my int $is_extop;
        my @operands_values;
        if nqp::existskey(%core_op_codes, $op) {
            my int $op_num   := %core_op_codes{$op};
            $num_operands    := nqp::atpos_i(@core_operands_counts, $op_num);
            $operands_offset := nqp::atpos_i(@core_operands_offsets, $op_num);
            @operands_values := @core_operands_values;
            $is_extop := 0;
        }
        elsif MAST::ExtOpRegistry.extop_known($op) {
            @operands_values := MAST::ExtOpRegistry.extop_signature($op);
            $num_operands    := nqp::elems(@operands_values);
            $operands_offset := 0;
            $is_extop := 1;
        }
        else {
            nqp::die("MoarVM op '$op' is unknown as a core or extension op");
        }
        
        my $num_args := +@args;
        my $operand_num := 0;
        my $result_kind := $MVM_reg_void;
        my $result_reg := MAST::VOID;
        my $needs_write := 0;
        my $type_var_kind := 0;
        my $regalloc := $*REGALLOC;

        my @arg_regs;
        my @all_ins;
        my @release_regs;
        my @release_kinds;

        # if the op has operands, and the first operand is a write register,
        # and the number of args provided is one less than the number of operands needed,
        # mark that we need to generate a result register at the end, and
        # advance to the second operand.
        if ($num_operands
                && (nqp::atpos_i(@operands_values, $operands_offset) +& $MVM_operand_rw_mask) == $MVM_operand_write_reg
                    # allow the QASTree to define its own write register
                && $num_args == $num_operands - 1) {
            $needs_write := 1;
            $operand_num++;
        }

        if ($num_args != $num_operands - $operand_num) {
            nqp::die("Arg count $num_args doesn't equal required operand count "~($num_operands - $operand_num)~" for op '$op'");
        }

        if ($op eq 'return') {
            $*BLOCK.return_kind($MVM_reg_void);
        }

        my $arg_num := 0;
        # Compile provided args.
        for @args {
            my $operand := nqp::atpos_i(@operands_values, $operands_offset + $operand_num++);
            my $operand_kind := ($operand +& $MVM_operand_type_mask);
            my $constant_operand := !($operand +& $MVM_operand_rw_mask);
            my $arg := $operand_kind == $MVM_operand_type_var
                ?? $qastcomp.as_mast($_)
                !! $qastcomp.as_mast($_, :want($operand_kind/8));
            my $arg_kind := $arg.result_kind;

            if $arg_num == 0 && nqp::substr($op, 0, 7) eq 'return_' {
                $*BLOCK.return_kind($arg.result_kind);
            }

            # args cannot be void
            if $arg_kind == $MVM_reg_void {
                nqp::die("Cannot use a void register as an argument to op '$op'");
            }

            if ($operand_kind == $MVM_operand_type_var) {
                # handle ops that have type-variables as operands
                if ($type_var_kind) {
                    # if we've already seen a type-var
                    if ($arg_kind != $type_var_kind) {
                        # the arg types must match
                        nqp::die("variable-type op requires same-typed args");
                    }
                }
                else {
                    # set this variable-type op's typecode
                    $type_var_kind := $arg_kind;
                }
            } # allow nums and ints to be bigger than their destination width
            elsif (@kind_types[$arg_kind] != @kind_types[$operand_kind/8]) {
                $qastcomp.coerce($arg, $operand_kind/8);
                $arg_kind := $operand_kind/8;
                # the arg typecode left shifted 3 must match the operand typecode
            #    nqp::die("arg type {@kind_names[$arg_kind]} does not match operand type {@kind_names[$operand_kind/8]} to op '$op'");
            }

            # if this is the write register, get the result reg and type from it
            if ($operand +& $MVM_operand_rw_mask) == $MVM_operand_write_reg
                || ($operand +& $MVM_operand_rw_mask) == $MVM_operand_write_lex
                || $returnarg != -1 && $returnarg == $arg_num {
                $result_reg := $arg.result_reg;
                $result_kind := $arg_kind;
            }
            # otherwise it's a read register, so it can be released if it's an
            # intermediate value
            else {
                # if it's not a write register, queue it to be released it to the allocator
                nqp::push(@release_regs, $arg.result_reg);
                nqp::push(@release_kinds, $arg_kind);
            }

            # put the arg exression's generation code in the instruction list
            nqp::splice(@all_ins, $arg.instructions, +@all_ins, 0)
                unless $constant_operand;
            if @deconts[$arg_num] {
                my $dc_reg := $regalloc.fresh_register($MVM_reg_obj);
                nqp::push(@all_ins, MAST::Op.new( :op('decont'), $dc_reg, $arg.result_reg ));
                nqp::push(@arg_regs, $dc_reg);
                nqp::push(@release_regs, $dc_reg);
                nqp::push(@release_kinds, $MVM_reg_obj);
            }
            else {
                nqp::push(@arg_regs, $constant_operand
                    ?? $qastcomp.as_mast_constant($_)
                    !! $arg.result_reg);
            }

            $arg_num++;
        }

        # release the registers to the allocator. See comment there.
        my $release_i := 0;
        $regalloc.release_register($_, @release_kinds[$release_i++]) for @release_regs;

        # unshift in a generated write register arg if it needs one
        if ($needs_write) {
            # do this after the args to possibly reuse a register,
            # and so we know the type of result register for ops with type_var operands.

            $result_kind := (nqp::atpos_i(@operands_values, $operands_offset) +& $MVM_operand_type_mask) / 8;

            # fixup the variable typecode if there is one
            if ($type_var_kind && $result_kind == $MVM_operand_type_var / 8) {
                $result_kind := $type_var_kind;
            }

            $result_reg := $regalloc.fresh_register($result_kind);

            nqp::unshift(@arg_regs, $result_reg);
        }

        # Add operation node.
        nqp::push(@all_ins, $is_extop
            ?? MAST::ExtOp.new_with_operand_array( :op($op), :cu($qastcomp.mast_compunit), @arg_regs )
            !! MAST::Op.new_with_operand_array( :op($op), @arg_regs ));

        # Build instruction list.
        nqp::defined($want)
            ?? $qastcomp.coerce(MAST::InstructionList.new(@all_ins, $result_reg, $result_kind), $want)
            !! MAST::InstructionList.new(@all_ins, $result_reg, $result_kind);
    }

    # Adds a core op handler.
    method add_core_op(str $op, $handler, :$inlinable = 1) {
        %core_ops{$op} := $handler;
        self.set_core_op_inlinability($op, $inlinable);
    }

    # Adds a HLL op handler.
    method add_hll_op(str $hll, str $op, $handler, :$inlinable = 1) {
        %hll_ops{$hll} := {} unless %hll_ops{$hll};
        %hll_ops{$hll}{$op} := $handler;
        self.set_hll_op_inlinability($hll, $op, $inlinable);
    }

    # Sets op inlinability at a core level.
    method set_core_op_inlinability(str $op, $inlinable) {
        %core_inlinability{$op} := $inlinable;
    }

    # Sets op inlinability at a HLL level. (Can override at HLL level whether
    # or not the HLL overrides the op itself.)
    method set_hll_op_inlinability(str $hll, str $op, $inlinable) {
        %hll_inlinability{$hll} := {} unless nqp::existskey(%hll_inlinability, $hll);
        %hll_inlinability{$hll}{$op} := $inlinable;
    }

    # Checks if an op is considered inlinable.
    method is_inlinable(str $hll, str $op) {
        if nqp::existskey(%hll_inlinability, $hll) {
            if nqp::existskey(%hll_inlinability{$hll}, $op) {
                return %hll_inlinability{$hll}{$op};
            }
        }
        return %core_inlinability{$op} // 0;
    }

    # Adds a core op that maps to a Moar op.
    method add_core_moarop_mapping(str $op, str $moarop, $ret = -1, :$mapper?, :$decont, :$inlinable = 1) {
        my $moarop_mapper := $mapper
            ?? $mapper(self, $moarop, $ret)
            !! self.moarop_mapper($moarop, $ret, $decont);
        %core_ops{$op} := -> $qastcomp, $op {
            $moarop_mapper($qastcomp, $op.op, $op.list)
        };
        self.set_core_op_inlinability($op, $inlinable);
        self.set_core_op_result_type($op, moarop_return_type($moarop));
    }

    # Adds a HLL op that maps to a Moar op.
    method add_hll_moarop_mapping(str $hll, str $op, str $moarop, $ret = -1, :$mapper?, :$decont, :$inlinable = 1) {
        my $moarop_mapper := $mapper
            ?? $mapper(self, $moarop, $ret)
            !! self.moarop_mapper($moarop, $ret, $decont);
        %hll_ops{$hll} := {} unless %hll_ops{$hll};
        %hll_ops{$hll}{$op} := -> $qastcomp, $op {
            $moarop_mapper($qastcomp, $op.op, $op.list)
        };
        self.set_hll_op_inlinability($hll, $op, $inlinable);
        self.set_hll_op_result_type($hll, $op, moarop_return_type($moarop));
    }

    # Returns a mapper closure for turning an operation into a Moar op.
    # $ret is the 0-based index of which arg to use as the result when
    # the moarop is void.
    method moarop_mapper(str $moarop, $ret, $decont_in) {
        # do a little checking of input values

        my $self := self;

        if $ret != -1 {
            my int $num_operands;
            my int $operands_offset;
            my @operands_values;
            if nqp::existskey(%core_op_codes, $moarop) {
                my int $op_num   := %core_op_codes{$moarop};
                $num_operands    := nqp::atpos_i(@core_operands_counts, $op_num);
                $operands_offset := nqp::atpos_i(@core_operands_offsets, $op_num);
                @operands_values := @core_operands_values;
            }
            elsif MAST::ExtOpRegistry.extop_known($moarop) {
                @operands_values := MAST::ExtOpRegistry.extop_signature($moarop);
                $num_operands    := nqp::elems(@operands_values);
                $operands_offset := 0;
            }
            else {
                nqp::die("MoarVM op '$moarop' is unknown as a core or extension op");
            }
            nqp::die("moarop $moarop return arg index out of range")
                if $ret < -1 || $ret >= $num_operands;
            nqp::die("moarop $moarop is not void")
                if $num_operands && (nqp::atpos_i(@operands_values, $operands_offset) +& $MVM_operand_rw_mask) ==
                    $MVM_operand_write_reg;
        }
        
        my @deconts;
        if nqp::islist($decont_in) {
            for $decont_in { @deconts[$_] := 1; }
        }
        elsif nqp::defined($decont_in) {
            @deconts[$decont_in] := 1;
        }

        -> $qastcomp, $op_name, @op_args {
            $self.compile_mastop($qastcomp, $moarop, @op_args, @deconts, :returnarg($ret))
        }
    }

    # Gets the return type of a MoarVM op, if any.
    sub moarop_return_type(str $moarop) {
        if nqp::existskey(%core_op_codes, $moarop) {
            my int $op_num       := %core_op_codes{$moarop};
            my int $num_operands := nqp::atpos_i(@core_operands_counts, $op_num);
            if $num_operands {
                my int $operands_offset := nqp::atpos_i(@core_operands_offsets, $op_num);
                my int $ret_sig         := nqp::atpos_i(@core_operands_values, $operands_offset);
                if ($ret_sig +& $MVM_operand_rw_mask) == $MVM_operand_write_reg {
                    return nqp::bitshiftr_i($ret_sig, 3);
                }
            }
        }
        elsif MAST::ExtOpRegistry.extop_known($moarop) {
            my @operands_values := MAST::ExtOpRegistry.extop_signature($moarop);
            if @operands_values {
                my int $ret_sig := nqp::atpos_i(@operands_values, 0);
                if ($ret_sig +& $MVM_operand_rw_mask) == $MVM_operand_write_reg {
                    return nqp::bitshiftr_i($ret_sig, 3);
                }
            }
        }
        else {
            nqp::die("MoarVM op '$moarop' is unknown as a core or extension op");
        }
        0
    }

    # Sets op native result type at a core level.
    method set_core_op_result_type(str $op, $type) {
        if $type == $MVM_reg_int64 {
            %core_result_type{$op} := int;
        }
        elsif $type == $MVM_reg_num64 {
            %core_result_type{$op} := num;
        }
        elsif $type == $MVM_reg_str {
            %core_result_type{$op} := str;
        }
    }
    
    # Sets op inlinability at a HLL level. (Can override at HLL level whether
    # or not the HLL overrides the op itself.)
    method set_hll_op_result_type(str $hll, str $op, $type) {
        %hll_result_type{$hll} := {} unless nqp::existskey(%hll_result_type, $hll);
        if $type == $MVM_reg_int64 {
            %hll_result_type{$hll}{$op} := int;
        }
        elsif $type == $MVM_reg_num64 {
            %hll_result_type{$hll}{$op} := num;
        }
        elsif $type == $MVM_reg_str {
            %hll_result_type{$hll}{$op} := str;
        }
    }

    # Sets returns on an op node if we it has a native result type.
    method attach_result_type(str $hll, $node) {
        my $op := $node.op;
        if nqp::existskey(%hll_result_type, $hll) {
            if nqp::existskey(%hll_result_type{$hll}, $op) {
                $node.returns(%hll_result_type{$hll}{$op});
                return 1;
            }
        }
        if nqp::existskey(%core_result_type, $op) {
            $node.returns(%core_result_type{$op});
        }
    }

    # Adds a HLL box handler.
    method add_hll_box(str $hll, $type, $handler) {
        unless $type == $MVM_reg_int64 || $type == $MVM_reg_num64 || $type == $MVM_reg_str ||
                $type == $MVM_reg_uint64 || $type == $MVM_reg_void {
            nqp::die("Unknown box type '$type'");
        }
        %hll_box{$hll} := {} unless nqp::existskey(%hll_box, $hll);
        %hll_box{$hll}{$type} := $handler;
    }

    # Adds a HLL unbox handler.
    method add_hll_unbox(str $hll, $type, $handler) {
        unless $type == $MVM_reg_int64 || $type == $MVM_reg_num64 ||
                $type == $MVM_reg_str || $type == $MVM_reg_uint64 {
            nqp::die("Unknown unbox type '$type'");
        }
        %hll_unbox{$hll} := {} unless nqp::existskey(%hll_unbox, $hll);
        %hll_unbox{$hll}{$type} := $handler;
    }

    # Generates instructions to box the result in reg.
    method box($qastcomp, str $hll, $type, $reg) {
        (%hll_box{$hll}{$type} // %hll_box{''}{$type})($qastcomp, $reg)
    }

    # Generates instructions to unbox the result in reg.
    method unbox($qastcomp, str $hll, $type, $reg) {
        (%hll_unbox{$hll}{$type} // %hll_unbox{''}{$type})($qastcomp, $reg)
    }
}

# Set of sequential statements
QAST::MASTOperations.add_core_op('stmts', -> $qastcomp, $op {
    $qastcomp.as_mast(QAST::Stmts.new( |@($op) ))
});

my sub pre-size-array($qastcomp, $instructionlist, $array_reg, $size) {
    my $int_reg := $*REGALLOC.fresh_i();
    push_op($instructionlist.instructions, 'const_i64', $int_reg, MAST::IVal.new( :value($size) ));
    push_op($instructionlist.instructions, 'setelemspos', $array_reg, $int_reg);
    # reset the number of elements to 0 so that we don't push to the end
    # since our lists don't shrink by themselves (or by setting elems), we'll
    # end up with enough storage to hold all elements exactly
    push_op($instructionlist.instructions, 'const_i64', $int_reg, MAST::IVal.new( :value(0) ));
    push_op($instructionlist.instructions, 'setelemspos', $array_reg, $int_reg);
    $*REGALLOC.release_register($int_reg, $MVM_reg_int64);
}

# Data structures
QAST::MASTOperations.add_core_op('list', -> $qastcomp, $op {
    # Just desugar to create the empty list.
    my $regalloc := $*REGALLOC;
    my $arr := $qastcomp.as_mast(QAST::Op.new(
        :op('create'),
        QAST::Op.new( :op('hlllist') )
    ));
    if +$op.list {
        my $arr_reg := $arr.result_reg;
        pre-size-array($qastcomp, $arr, $arr_reg, +$op.list);
        # Push things to the list.
        for $op.list {
            my $item := $qastcomp.as_mast($_, :want($MVM_reg_obj));
            my $item_reg := $item.result_reg;
            $arr.append($item);
            push_op($arr.instructions, 'push_o', $arr_reg, $item_reg);
            $regalloc.release_register($item_reg, $MVM_reg_obj);
        }
        my $ensure_return_register := MAST::InstructionList.new(nqp::list(), $arr_reg, $MVM_reg_obj);
        $arr.append($ensure_return_register);
    }
    $arr
});
QAST::MASTOperations.add_core_op('list_i', -> $qastcomp, $op {
    # Just desugar to create the empty list.
    my $regalloc := $*REGALLOC;
    my $arr := $qastcomp.as_mast(QAST::Op.new(
        :op('create'),
        QAST::Op.new( :op('bootintarray') )
    ));
    if +$op.list {
        my $arr_reg := $arr.result_reg;
        pre-size-array($qastcomp, $arr, $arr_reg, +$op.list);
        # Push things to the list.
        for $op.list {
            my $item := $qastcomp.as_mast($_, :want($MVM_reg_int64));
            my $item_reg := $item.result_reg;
            $arr.append($item);
            push_op($arr.instructions, 'push_i', $arr_reg, $item_reg);
            $regalloc.release_register($item_reg, $MVM_reg_int64);
        }
        my $ensure_return_register := MAST::InstructionList.new(nqp::list(), $arr_reg, $MVM_reg_obj);
        $arr.append($ensure_return_register);
    }
    $arr
});
QAST::MASTOperations.add_core_op('list_n', -> $qastcomp, $op {
    # Just desugar to create the empty list.
    my $regalloc := $*REGALLOC;
    my $arr := $qastcomp.as_mast(QAST::Op.new(
        :op('create'),
        QAST::Op.new( :op('bootnumarray') )
    ));
    if +$op.list {
        my $arr_reg := $arr.result_reg;
        pre-size-array($qastcomp, $arr, $arr_reg, +$op.list);
        # Push things to the list.
        for $op.list {
            my $item := $qastcomp.as_mast($_, :want($MVM_reg_num64));
            my $item_reg := $item.result_reg;
            $arr.append($item);
            push_op($arr.instructions, 'push_n', $arr_reg, $item_reg);
            $regalloc.release_register($item_reg, $MVM_reg_num64);
        }
        my $ensure_return_register := MAST::InstructionList.new(nqp::list(), $arr_reg, $MVM_reg_obj);
        $arr.append($ensure_return_register);
    }
    $arr
});
QAST::MASTOperations.add_core_op('list_s', -> $qastcomp, $op {
    # Just desugar to create the empty list.
    my $regalloc := $*REGALLOC;
    my $arr := $qastcomp.as_mast(QAST::Op.new(
        :op('create'),
        QAST::Op.new( :op('bootstrarray') )
    ));
    if +$op.list {
        my $arr_reg := $arr.result_reg;
        pre-size-array($qastcomp, $arr, $arr_reg, +$op.list);
        # Push things to the list.
        for $op.list {
            my $item := $qastcomp.as_mast($_, :want($MVM_reg_str));
            my $item_reg := $item.result_reg;
            $arr.append($item);
            push_op($arr.instructions, 'push_s', $arr_reg, $item_reg);
            $regalloc.release_register($item_reg, $MVM_reg_str);
        }
        my $ensure_return_register := MAST::InstructionList.new(nqp::list(), $arr_reg, $MVM_reg_obj);
        $arr.append($ensure_return_register);
    }
    $arr
});
QAST::MASTOperations.add_core_op('list_b', -> $qastcomp, $op {
    # Just desugar to create the empty list.
    my $regalloc := $*REGALLOC;
    my $arr := $qastcomp.as_mast(QAST::Op.new(
        :op('create'),
        QAST::Op.new( :op('bootarray') )
    ));
    if +$op.list {
        my $arr_reg := $arr.result_reg;
        pre-size-array($qastcomp, $arr, $arr_reg, +$op.list);
        # Push things to the list.
        my $item_reg := $regalloc.fresh_register($MVM_reg_obj);
        for $op.list {
            nqp::die("list_b must have a list of blocks")
                unless nqp::istype($_, QAST::Block);
            my $cuid  := $_.cuid();
            my $frame := $qastcomp.mast_frames{$cuid};
            push_op($arr.instructions, 'getcode', $item_reg, $frame);
            push_op($arr.instructions, 'push_o', $arr_reg, $item_reg);
        }
        $regalloc.release_register($item_reg, $MVM_reg_obj);
        my $ensure_return_register := MAST::InstructionList.new(nqp::list(), $arr_reg, $MVM_reg_obj);
        $arr.append($ensure_return_register);
    }
    $arr
});
QAST::MASTOperations.add_core_op('qlist', -> $qastcomp, $op {
    $qastcomp.as_mast(QAST::Op.new( :op('list'), |@($op) ))
});
QAST::MASTOperations.add_core_op('hash', -> $qastcomp, $op {
    # Just desugar to create the empty hash.
    my $regalloc := $*REGALLOC;
    my $hash := $qastcomp.as_mast(QAST::Op.new(
        :op('create'),
        QAST::Op.new( :op('hllhash') )
    ));
    if +$op.list {
        my $hash_reg := $hash.result_reg;
        for $op.list -> $key, $val {
            my $key_mast := $qastcomp.as_mast($key, :want($MVM_reg_str));
            my $val_mast := $qastcomp.as_mast($val, :want($MVM_reg_obj));
            my $key_reg := $key_mast.result_reg;
            my $val_reg := $val_mast.result_reg;
            $hash.append($key_mast);
            $hash.append($val_mast);
            push_op($hash.instructions, 'bindkey_o', $hash_reg, $key_reg, $val_reg);
            $regalloc.release_register($key_reg, $MVM_reg_str);
            $regalloc.release_register($val_reg, $MVM_reg_obj);
        }
        my $ensure_return_register := MAST::InstructionList.new(nqp::list(), $hash_reg, $MVM_reg_obj);
        $hash.append($ensure_return_register);
    }
    $hash
});

# Chaining.
QAST::MASTOperations.add_core_op('chain', -> $qastcomp, $op {
    # First, we build up the list of nodes in the chain
    my @clist;
    my $cqast := $op;
    while $cqast ~~ QAST::Op && $cqast.op eq 'chain' {
        nqp::push(@clist, $cqast);
        $cqast := $cqast[0];
    }

    my @ops;
    my $regalloc := $*REGALLOC;
    my $res_reg  := $regalloc.fresh_register($MVM_reg_obj);
    my $endlabel := MAST::Label.new();

    $cqast := nqp::pop(@clist);
    my $aqast := $cqast[0];
    my $acomp := $qastcomp.as_mast($aqast, :want($MVM_reg_obj));
    push_ilist(@ops, $acomp);

    my $more := 1;
    while $more {
        my $bqast := $cqast[1];
        my $bcomp := $qastcomp.as_mast($bqast, :want($MVM_reg_obj));
        push_ilist(@ops, $bcomp);

        my $callee := $qastcomp.as_mast(
            QAST::Var.new( :name($cqast.name), :scope('lexical') ),
            :want($MVM_reg_obj));
        push_ilist(@ops, $callee);
        nqp::push(@ops, MAST::Call.new(
            :target($callee.result_reg),
            :flags([$Arg::obj, $Arg::obj]),
            :result($res_reg),
            $acomp.result_reg, $bcomp.result_reg
        ));

        $regalloc.release_register($callee.result_reg, $MVM_reg_obj);
        $regalloc.release_register($acomp.result_reg, $MVM_reg_obj);

        if @clist {
            push_op(@ops, 'unless_o', $res_reg, $endlabel);
            $cqast := nqp::pop(@clist);
            $acomp := $bcomp;
        }
        else {
            $more := 0;
        }
    }

    nqp::push(@ops, $endlabel);
    MAST::InstructionList.new(@ops, $res_reg, $MVM_reg_obj)
});

# Conditionals.
sub needs_cond_passed($n) {
    nqp::istype($n, QAST::Block) && $n.arity > 0 &&
        ($n.blocktype eq 'immediate' || $n.blocktype eq 'immediate_static')
}
for <if unless with without> -> $op_name {
    QAST::MASTOperations.add_core_op($op_name, -> $qastcomp, $op {
        # Check operand count.
        my $operands := +$op.list;
        nqp::die("Operation '$op_name' needs either 2 or 3 operands")
            if $operands < 2 || $operands > 3;

        # Create labels.
        my $if_id    := $qastcomp.unique($op_name);
        my $else_lbl := MAST::Label.new();
        my $end_lbl  := MAST::Label.new();

        # Compile each of the children, handling any that want the conditional
        # value to be passed.
        my $is_void := nqp::defined($*WANT) && $*WANT == $MVM_reg_void;
        my $wanted  := $is_void ?? $MVM_reg_void !! NQPMu;
        my @comp_ops;
        my $is_withy := $op_name eq 'with' || $op_name eq 'without';
        my $cond_temp_lbl := $is_withy || needs_cond_passed($op[1]) || needs_cond_passed($op[2])
            ?? $qastcomp.unique('__im_cond_')
            !! '';
        if $cond_temp_lbl {
            if $is_withy {
                @comp_ops[0] := $qastcomp.as_mast(QAST::Op.new(
                    :op('bind'),
                    QAST::Var.new( :name($cond_temp_lbl), :scope('local'), :decl('var') ),
                    $op[0]), :want($MVM_reg_obj));
            } else {
                @comp_ops[0] := $qastcomp.as_mast(QAST::Op.new(
                    :op('bind'),
                    QAST::Var.new( :name($cond_temp_lbl), :scope('local'), :decl('var') ),
                    $op[0]));
            }
        } else {
            @comp_ops[0] := $qastcomp.as_mast($op[0]);
        }
        if needs_cond_passed($op[1]) {
            my $orig_type := $op[1].blocktype;
            $op[1].blocktype('declaration');
            @comp_ops[1] := $qastcomp.as_mast(QAST::Op.new(
                :op('call'),
                $op[1],
                QAST::Var.new( :name($cond_temp_lbl), :scope('local') )),
                :want($wanted));
            $op[1].blocktype($orig_type);
        }
        else {
            @comp_ops[1] := $qastcomp.as_mast($op[1], :want($wanted));
        }
        if needs_cond_passed($op[2]) {
            my $orig_type := $op[2].blocktype;
            $op[2].blocktype('declaration');
            @comp_ops[2] := $qastcomp.as_mast(QAST::Op.new(
                :op('call'),
                $op[2],
                QAST::Var.new( :name($cond_temp_lbl), :scope('local') )),
                :want($wanted));
            $op[2].blocktype($orig_type);
        }
        elsif $op[2] {
            @comp_ops[2] := $qastcomp.as_mast($op[2], :want($wanted));
        }

        if (@comp_ops[0].result_kind == $MVM_reg_void) {
            nqp::die("operation '$op_name' condition cannot be void");
        }

        my $res_kind;
        my $res_reg;
        my $regalloc := $*REGALLOC;
        if $is_void {
            $res_reg := MAST::VOID;
        }
        else {
            $res_kind := $operands == 3
                ?? (@comp_ops[1].result_kind == @comp_ops[2].result_kind
                && @comp_ops[1].result_kind != $MVM_reg_void
                    ?? @comp_ops[1].result_kind
                    !! $MVM_reg_obj)
                !! (@comp_ops[0].result_kind == @comp_ops[1].result_kind
                    ?? @comp_ops[0].result_kind
                    !! $MVM_reg_obj);
            $res_reg := $regalloc.fresh_register($res_kind);
        }

        my @ins;

        # Evaluate the condition first; store result if needed.
        push_ilist(@ins, @comp_ops[0]);
        if $operands == 2 && !$is_void {
            my $il := MAST::InstructionList.new(@ins, @comp_ops[0].result_reg, @comp_ops[0].result_kind);
            $qastcomp.coerce($il, $res_kind);
            push_op(@ins, 'set', $res_reg, $il.result_reg);
        }

        # Emit the jump.
        if @comp_ops[0].result_kind == $MVM_reg_obj {
            my $decont_reg := $regalloc.fresh_register($MVM_reg_obj);
            push_op(@ins, 'decont', $decont_reg, @comp_ops[0].result_reg);
            if $is_withy {
                my $method_reg := $regalloc.fresh_register($MVM_reg_obj);
                push_op(@ins, 'findmeth', $method_reg, $decont_reg, MAST::SVal.new( :value('defined')));
                nqp::push(@ins,
                   MAST::Call.new( :target($method_reg), :result($decont_reg), :flags([$Arg::obj]), $decont_reg));
                $regalloc.release_register($method_reg, $MVM_reg_obj);
            }
            push_op(@ins,
                resolve_condition_op(@comp_ops[0].result_kind, $op_name eq 'if' || $op_name eq 'with'),
                $decont_reg,
                ($operands == 3 ?? $else_lbl !! $end_lbl)
            );
            $regalloc.release_register($decont_reg, $MVM_reg_obj);
        }
        else {
            push_op(@ins,
                resolve_condition_op(@comp_ops[0].result_kind, $op_name eq 'if'),
                @comp_ops[0].result_reg,
                ($operands == 3 ?? $else_lbl !! $end_lbl)
            );
        }

        # Emit the then, stash the result
        push_ilist(@ins, @comp_ops[1]);
        if (!$is_void && @comp_ops[1].result_kind != $res_kind) {
            my $coercion := $qastcomp.coercion(@comp_ops[1],
                (nqp::defined($*WANT) ?? $*WANT !! $MVM_reg_obj));
            push_ilist(@ins, $coercion);
            $regalloc.release_register($res_reg, $res_kind);
            $res_reg := $regalloc.fresh_register($coercion.result_kind);
            push_op(@ins, 'set', $res_reg, $coercion.result_reg);
            $res_kind := $coercion.result_kind;
        }
        elsif !$is_void {
            push_op(@ins, 'set', $res_reg, @comp_ops[1].result_reg);
        }
        $regalloc.release_register(@comp_ops[1].result_reg, @comp_ops[1].result_kind);

        # Handle else branch (coercion of condition result if 2-arg).
        push_op(@ins, 'goto', $end_lbl);
        nqp::push(@ins, $else_lbl);
        if $operands == 3 {
            push_ilist(@ins, @comp_ops[2]);
            if !$is_void {
                if @comp_ops[2].result_kind != $res_kind {
                    my $coercion := $qastcomp.coercion(@comp_ops[2], $res_kind);
                    push_ilist(@ins, $coercion);
                    push_op(@ins, 'set', $res_reg, $coercion.result_reg);
                }
                else {
                    push_op(@ins, 'set', $res_reg, @comp_ops[2].result_reg);
                }
            }
            $regalloc.release_register(@comp_ops[2].result_reg, @comp_ops[2].result_kind);
        }
        else {
            if !$is_void && @comp_ops[0].result_kind != $res_kind {
                my $coercion := $qastcomp.coercion(@comp_ops[0], $res_kind);
                push_ilist(@ins, $coercion);
                push_op(@ins, 'set', $res_reg, $coercion.result_reg);
            }
        }
        $regalloc.release_register(@comp_ops[0].result_reg, @comp_ops[0].result_kind);
        nqp::push(@ins, $end_lbl);

        MAST::InstructionList.new(@ins, $res_reg, $res_kind)
    });
}

QAST::MASTOperations.add_core_op('defor', -> $qastcomp, $op {
    if +$op.list != 2 {
        nqp::die("Operation 'defor' needs 2 operands");
    }

    # Compile the expression.
    my $regalloc := $*REGALLOC;
    my $res_reg := $regalloc.fresh_o();
    my $expr := $qastcomp.as_mast($op[0], :want($MVM_reg_obj));

    # Emit defined check.
    my $def_reg := $regalloc.fresh_i();
    my $lbl := MAST::Label.new();
    push_op($expr.instructions, 'set', $res_reg, $expr.result_reg);
    push_op($expr.instructions, 'isconcrete', $def_reg, $res_reg);
    push_op($expr.instructions, 'if_i', $def_reg, $lbl);
    $regalloc.release_register($def_reg, $MVM_reg_int64);

    # Emit "then" part.
    my $then := $qastcomp.as_mast($op[1], :want($MVM_reg_obj));
    $regalloc.release_register($expr.result_reg, $MVM_reg_obj);
    $expr.append($then);
    push_op($expr.instructions, 'set', $res_reg, $then.result_reg);
    nqp::push($expr.instructions, $lbl);
    $regalloc.release_register($then.result_reg, $MVM_reg_obj);
    my $newer := MAST::InstructionList.new(nqp::list(), $res_reg, $MVM_reg_obj);
    $expr.append($newer);

    $expr
});

QAST::MASTOperations.add_core_op('xor', -> $qastcomp, $op {
    my @ops;
    my $res_kind   := $MVM_reg_obj;
    my $res_reg    := $*REGALLOC.fresh_o();
    my $t          := $*REGALLOC.fresh_i();
    my $u          := $*REGALLOC.fresh_i();
    my $d          := $*REGALLOC.fresh_o();
    my $falselabel := MAST::Label.new();
    my $endlabel   := MAST::Label.new();

    my @comp_ops;
    my $f_ast;
    for $op.list {
        if $_.named eq 'false' {
            $f_ast := $qastcomp.as_mast($_, :want($MVM_reg_obj));
        }
        else {
            nqp::push(@comp_ops, $qastcomp.as_mast($_, :want($MVM_reg_obj)));
        }
    }

    my $apost := nqp::shift(@comp_ops);
    push_ilist(@ops, $apost);
    push_op(@ops, 'set', $res_reg, $apost.result_reg);
    push_op(@ops, 'decont', $d, $apost.result_reg);
    push_op(@ops, 'istrue', $t, $d);
    $*REGALLOC.release_register($apost.result_reg, $MVM_reg_obj);

    my $have_middle_child := 1;
    my $bpost;
    while $have_middle_child {
        $bpost := nqp::shift(@comp_ops);
        push_ilist(@ops, $bpost);
        push_op(@ops, 'decont', $d, $bpost.result_reg);
        push_op(@ops, 'istrue', $u, $d);

        my $jumplabel := MAST::Label.new();
        push_op(@ops, 'unless_i', $t, $jumplabel);
        push_op(@ops, 'unless_i', $u, $jumplabel);
        push_op(@ops, 'goto', $falselabel);
        nqp::push(@ops, $jumplabel);

        if @comp_ops {
            my $truelabel := MAST::Label.new();
            push_op(@ops, 'if_i', $t, $truelabel);
            push_op(@ops, 'set', $res_reg, $bpost.result_reg);
            $*REGALLOC.release_register($bpost.result_reg, $MVM_reg_obj);
            push_op(@ops, 'set', $t, $u);
            nqp::push(@ops, $truelabel);
        }
        else {
            $have_middle_child := 0;
        }
    }
    $*REGALLOC.release_register($u, $MVM_reg_int64);

    push_op(@ops, 'if_i', $t, $endlabel);
    $*REGALLOC.release_register($t, $MVM_reg_int64);
    push_op(@ops, 'set', $res_reg, $bpost.result_reg);
    $*REGALLOC.release_register($bpost.result_reg, $MVM_reg_obj);
    push_op(@ops, 'goto', $endlabel);
    nqp::push(@ops, $falselabel);

    if $f_ast {
        push_ilist(@ops, $f_ast);
        push_op(@ops, 'set', $res_reg, $f_ast.result_reg);
        $*REGALLOC.release_register($f_ast.result_reg, $MVM_reg_obj);
    }
    else {
        push_op(@ops, 'null', $res_reg);
    }

    nqp::push(@ops, $endlabel);

    $*REGALLOC.release_register($d, $MVM_reg_obj);

    MAST::InstructionList.new(@ops, $res_reg, $res_kind)
});

QAST::MASTOperations.add_core_op('ifnull', -> $qastcomp, $op {
    if +$op.list != 2 {
        nqp::die("The 'ifnull' op expects two children");
    }

    # Compile the expression.
    my $regalloc := $*REGALLOC;
    my $res_reg := $regalloc.fresh_o();
    my $expr := $qastcomp.as_mast($op[0], :want($MVM_reg_obj));

    # Emit null check.
    my $lbl := MAST::Label.new();
    push_op($expr.instructions, 'set', $res_reg, $expr.result_reg);
    push_op($expr.instructions, 'ifnonnull', $expr.result_reg, $lbl);

    # Emit "then" part.
    my $then := $qastcomp.as_mast($op[1], :want($MVM_reg_obj));
    $regalloc.release_register($expr.result_reg, $MVM_reg_obj);
    $expr.append($then);
    push_op($expr.instructions, 'set', $res_reg, $then.result_reg);
    nqp::push($expr.instructions, $lbl);
    $regalloc.release_register($then.result_reg, $MVM_reg_obj);
    my $newer := MAST::InstructionList.new(nqp::list(), $res_reg, $MVM_reg_obj);
    $expr.append($newer);

    $expr
});

# Loops.
for ('', 'repeat_') -> $repness {
    for <while until> -> $op_name {
        QAST::MASTOperations.add_core_op("$repness$op_name", -> $qastcomp, $op {
            # Create labels.
            my $while_id := $qastcomp.unique($op_name);
            my $test_lbl := MAST::Label.new();
            my $next_lbl := MAST::Label.new();
            my $redo_lbl := MAST::Label.new();
            my $done_lbl := MAST::Label.new();

            # Pick out applicable children; detect no handler case and munge
            # immediate arg case.
            my @children;
            my $handler := 1;
            my $orig_type;
            my $label_wval;
            my $cond_temp;
            for $op.list {
                if $_.named eq 'nohandler' { $handler := 0; }
                elsif $_.named eq 'label' { $label_wval := $_; }
                else { nqp::push(@children, $_) }
            }
            if needs_cond_passed(@children[1]) {
                $cond_temp := $qastcomp.unique('__im_cond_');
                @children[0] := QAST::Op.new(
                    :op('bind'),
                    QAST::Var.new( :name($cond_temp), :scope('local'), :decl('var') ),
                    @children[0]);
                $orig_type := @children[1].blocktype;
                @children[1].blocktype('declaration');
                @children[1] := QAST::Op.new(
                    :op('call'),
                    @children[1],
                    QAST::Var.new( :name($cond_temp), :scope('local') ));
            }

            # Compile each of the children.
            my @comp_ops;
            my @comp_types;
            my $regalloc := $*REGALLOC;
            for @children {
                my $comp := nqp::elems(@comp_ops) == 0
                    ?? $qastcomp.as_mast($_)
                    !! $qastcomp.as_mast($_, :want($MVM_reg_void));
                @comp_ops.push($comp);
                @comp_types.push($comp.result_kind);
            }

            my $res_kind := $MVM_reg_obj;
            my $res_reg;

            if nqp::defined($*WANT) && $*WANT == $MVM_reg_void {
                $res_kind := $MVM_reg_void;
                $res_reg := MAST::VOID;
            } else {
                $res_reg := $regalloc.fresh_register($res_kind);
            }

            if $orig_type {
                @children[1][0].blocktype($orig_type);
            }

            # Check operand count.
            my $operands := +@comp_ops;
            nqp::die("Operation '$repness$op_name' needs 2 or 3 operands")
                if $operands != 2 && $operands != 3;

            # Test the condition and jump to the loop end if it's
            # not met.
            my @loop_il;

            # Generate a lousy return value for our while loop.
            unless $res_reg =:= MAST::VOID {
                push_op(@loop_il, 'null', $res_reg);
            }

            if $repness {
                # It's a repeat_ variant, need to go straight into the
                # loop body unconditionally.
                if $cond_temp {
                    push_op(@loop_il, 'null', $*BLOCK.local($cond_temp));
                }
                push_op(@loop_il, 'goto', $redo_lbl);
            }
            nqp::push(@loop_il, $test_lbl);
            push_ilist(@loop_il, @comp_ops[0]);
            if @comp_ops[0].result_kind == $MVM_reg_obj {
                my $decont_reg := $regalloc.fresh_register($MVM_reg_obj);
                push_op(@loop_il, 'decont', $decont_reg, @comp_ops[0].result_reg);
                push_op(@loop_il,
                    resolve_condition_op(@comp_ops[0].result_kind, $op_name eq 'while'),
                    $decont_reg,
                    $done_lbl
                );
                $regalloc.release_register($decont_reg, $MVM_reg_obj);
            }
            else {
                push_op(@loop_il,
                    resolve_condition_op(@comp_ops[0].result_kind, $op_name eq 'while'),
                    @comp_ops[0].result_reg,
                    $done_lbl
                );
            }

            # Emit the loop body; stash the result.
            my $body := $qastcomp.coerce(@comp_ops[1], $res_kind);
            nqp::push(@loop_il, $redo_lbl);
            push_op(@loop_il, 'osrpoint');
            push_ilist(@loop_il, $body);

            # If there's a third child, evaluate it as part of the
            # "next".
            if $operands == 3 {
                nqp::push(@loop_il, $next_lbl);
                push_ilist(@loop_il, @comp_ops[2]);
            }

            # Emit the iteration jump.
            push_op(@loop_il, 'goto', $test_lbl);

            # Emit postlude, with exception handlers if needed. Note that we
            # don't actually need to emit a bunch of handlers; since a handler
            # scope will happily throw control to a label of our choosing, we
            # just have the goto label be the place the control exception
            # needs to send control to.
            if $handler {
                my $lablocal;
                my $redo_mask := $HandlerCategory::redo;
                my $next_mask := $HandlerCategory::next;
                my $last_mask := $HandlerCategory::last;
                my $il        := nqp::list();
                if $label_wval {
                    $redo_mask  := $redo_mask + $HandlerCategory::labeled;
                    $next_mask  := $next_mask + $HandlerCategory::labeled;
                    $last_mask  := $last_mask + $HandlerCategory::labeled;
                    my $labmast := $qastcomp.as_mast($label_wval, :want($MVM_reg_obj)); #nqp::where($label.value);
                    my $labreg  := $labmast.result_reg;
                    $lablocal   := MAST::Local.new(:index($*MAST_FRAME.add_local(NQPMu)));
                    push_ilist($il, $labmast);
                    push_op($il, 'set', $lablocal, $labreg);
                    $regalloc.release_register($labreg, $MVM_reg_obj);
                }
                my @redo_il := [MAST::HandlerScope.new(
                    :instructions(@loop_il),
                    :category_mask($redo_mask),
                    :action($HandlerAction::unwind_and_goto),
                    :goto($redo_lbl),
                    :label($lablocal)
                )];
                my @next_il := [MAST::HandlerScope.new(
                    :instructions(@redo_il),
                    :category_mask($next_mask),
                    :action($HandlerAction::unwind_and_goto),
                    :goto($operands == 3 ?? $next_lbl !! $test_lbl),
                    :label($lablocal)
                )];
                nqp::push($il, MAST::HandlerScope.new(
                    :instructions(@next_il),
                    :category_mask($last_mask),
                    :action($HandlerAction::unwind_and_goto),
                    :goto($done_lbl),
                    :label($lablocal)
                ));
                nqp::push($il, $done_lbl);
                MAST::InstructionList.new($il, $res_reg, $res_kind)
            }
            else {
                nqp::push(@loop_il, $done_lbl);
                MAST::InstructionList.new(@loop_il, $res_reg, $res_kind)
            }
        });
    }
}

QAST::MASTOperations.add_core_op('for', -> $qastcomp, $op {
    my $handler := 1;
    my @operands;
    my $label_wval;
    for $op.list {
        if $_.named eq 'nohandler' { $handler := 0; }
        elsif $_.named eq 'label' { $label_wval := $_; }
        else { @operands.push($_) }
    }

    if +@operands != 2 {
        nqp::die("Operation 'for' needs 2 operands");
    }
    unless nqp::istype(@operands[1], QAST::Block) {
        nqp::die("Operation 'for' expects a block as its second operand");
    }
    if @operands[1].blocktype eq 'immediate' {
        @operands[1].blocktype('declaration');
    }
    elsif @operands[1].blocktype eq 'immediate_static' {
        @operands[1].blocktype('declaration_static');
    }

    # Evaluate the thing we'll iterate over, get the iterator and
    # store it in a temporary.
    my $regalloc := $*REGALLOC;
    my $il := [];
    my $list_il := $qastcomp.as_mast(@operands[0], :want($MVM_reg_obj));
    push_ilist($il, $list_il);
    my $iter_tmp := $regalloc.fresh_o();
    push_op($il, 'iter', $iter_tmp, $list_il.result_reg);

    # Do similar for the block.
    my $block_res := $qastcomp.as_mast(@operands[1], :want($MVM_reg_obj));
    push_ilist($il, $block_res);

    # Some labels we'll need.
    my $for_id := $qastcomp.unique('for');
    my $lbl_next := MAST::Label.new();
    my $lbl_redo := MAST::Label.new();
    my $lbl_done := MAST::Label.new();

    # Emit loop test.
    my $loop_il := ();
    nqp::push($loop_il, $lbl_next);
    push_op($loop_il, 'unless_o', $iter_tmp, $lbl_done);
    $loop_il := MAST::InstructionList.new($loop_il, MAST::VOID, $MVM_reg_void);

    # Fetch values into temporaries (on the stack ain't enough in case
    # of redo).
    my $val_il := ();
    my @val_temps;
    my @arg_flags;
    my $arity := @operands[1].arity || 1;
    while $arity > 0 {
        my $tmp := $regalloc.fresh_o();
        push_op($val_il, 'shift_o', $tmp, $iter_tmp);
        nqp::push(@val_temps, $tmp);
        nqp::push(@arg_flags, $Arg::obj);
        $arity := $arity - 1;
    }
    nqp::push($val_il, $lbl_redo);
    push_op($val_il, 'osrpoint');
    $val_il := MAST::InstructionList.new($val_il, MAST::VOID, $MVM_reg_void);

    # Now do block invocation.
    my $inv_il := MAST::Call.new(
        :target($block_res.result_reg),
        :flags(@arg_flags),
        |@val_temps
    );
    $inv_il := MAST::InstructionList.new([$inv_il], MAST::VOID, $MVM_reg_void);
    push_ilist($val_il.instructions, $inv_il);

    # Emit next.
    push_ilist($loop_il.instructions, $val_il);
    push_op($loop_il.instructions, 'goto', $lbl_next );

    # Emit postlude, wrapping in handlers if needed.
    if $handler {
        my $lablocal;
        my $redo_mask := $HandlerCategory::redo;
        my $next_mask := $HandlerCategory::next;
        my $last_mask := $HandlerCategory::last;
        if $label_wval {
            $redo_mask  := $redo_mask + $HandlerCategory::labeled;
            $next_mask  := $next_mask + $HandlerCategory::labeled;
            $last_mask  := $last_mask + $HandlerCategory::labeled;
            my $labmast := $qastcomp.as_mast($label_wval, :want($MVM_reg_obj));
            my $labreg  := $labmast.result_reg;
            $lablocal   := MAST::Local.new(:index($*MAST_FRAME.add_local(NQPMu)));
            push_ilist($il, $labmast);
            push_op($il, 'set', $lablocal, $labreg);
            $regalloc.release_register($labreg, $MVM_reg_obj);
        }
        my @ins_wrap := $loop_il.instructions;
        @ins_wrap := [MAST::HandlerScope.new(
            :instructions(@ins_wrap),
            :category_mask($redo_mask),
            :action($HandlerAction::unwind_and_goto),
            :goto($lbl_redo),
            :label($lablocal)
        )];
        @ins_wrap := [MAST::HandlerScope.new(
            :instructions(@ins_wrap),
            :category_mask($next_mask),
            :action($HandlerAction::unwind_and_goto),
            :goto($lbl_next),
            :label($lablocal)
        )];
        nqp::push($il, MAST::HandlerScope.new(
            :instructions(@ins_wrap),
            :category_mask($last_mask),
            :action($HandlerAction::unwind_and_goto),
            :goto($lbl_done),
            :label($lablocal)
        ));
    }
    else {
        push_ilist($il, $loop_il);
    }
    nqp::push($il, $lbl_done);

    # Result; probably void, though evaluate to the input list if we must
    # give a value.
    $regalloc.release_register($block_res.result_reg, $block_res.result_kind);
    for @val_temps { $regalloc.release_register($_, $MVM_reg_obj) }
    $regalloc.release_register($inv_il.result_reg, $inv_il.result_kind);
    if $*WANT == $MVM_reg_void {
        $regalloc.release_register($list_il.result_reg, $list_il.result_kind);
        MAST::InstructionList.new($il, MAST::VOID, $MVM_reg_void)
    }
    else {
        MAST::InstructionList.new($il, $list_il.result_reg, $list_il.result_kind)
    }
});

# Calling
my @kind_to_args := [0,
    $Arg::int,  # $MVM_reg_int8            := 1;
    $Arg::int,  # $MVM_reg_int16           := 2;
    $Arg::int,  # $MVM_reg_int32           := 3;
    $Arg::int,  # $MVM_reg_int64           := 4;
    $Arg::num,  # $MVM_reg_num32           := 5;
    $Arg::num,  # $MVM_reg_num64           := 6;
    $Arg::str,  # $MVM_reg_str             := 7;
    $Arg::obj   # $MVM_reg_obj             := 8;
];

sub handle_arg($arg, $qastcomp, @ins, @arg_regs, @arg_flags, @arg_kinds) {
    # generate the code for the arg expression
    my $arg_mast := $qastcomp.as_mast($arg);
    my int $arg_mast_kind := $arg_mast.result_kind;
    if $arg_mast_kind == $MVM_reg_num32 {
        $arg_mast := $qastcomp.coerce($arg_mast, $MVM_reg_num64);
    }
    elsif $arg_mast_kind == $MVM_reg_int32 || $arg_mast_kind == $MVM_reg_int16 ||
            $arg_mast_kind == $MVM_reg_int8 || $arg_mast_kind == $MVM_reg_uint64 ||
            $arg_mast_kind == $MVM_reg_uint32 || $arg_mast_kind == $MVM_reg_uint16 ||
            $arg_mast_kind == $MVM_reg_uint8 {
        $arg_mast := $qastcomp.coerce($arg_mast, $MVM_reg_int64);
    }

    nqp::die("arg expression cannot be void")
        if $arg_mast.result_kind == $MVM_reg_void;

    nqp::die("arg code did not result in a MAST::Local")
        unless $arg_mast.result_reg && $arg_mast.result_reg ~~ MAST::Local;

    nqp::push(@arg_kinds, $arg_mast.result_kind);

    # append the code to the main instruction list
    push_ilist(@ins, $arg_mast);

    # build up the typeflag
    my $result_typeflag := @kind_to_args[$arg_mast.result_kind];
    if nqp::can($arg, 'flat') && $arg.flat {
        if $arg.named {
            $result_typeflag := $result_typeflag +| $Arg::flatnamed;
        }
        else {
            $result_typeflag := $result_typeflag +| $Arg::flat;
        }
    }
    elsif nqp::can($arg, 'named') && $arg.named -> $name {
        # add in the extra arg for the name
        nqp::push(@arg_regs, MAST::SVal.new( value => $name ));

        $result_typeflag := $result_typeflag +| $Arg::named;
    }

    # stash the result register and result typeflag
    nqp::push(@arg_regs, $arg_mast.result_reg);
    nqp::push(@arg_flags, $result_typeflag);
}

sub arrange_args(@in) {
    my @named := ();
    my @posit := ();
    for @in {
        nqp::push((nqp::can($_, 'named') && $_.named ?? @named !! @posit), $_);
    }
    for @named { nqp::push(@posit, $_) }
    @posit
}

my $call_gen := sub ($qastcomp, $op) {
    # Work out what callee is.
    my $callee;
    my @args := $op.list;
    if $op.name {
        $callee := $qastcomp.as_mast($op.op eq 'callstatic'
            ?? QAST::VM.new( :moarop('getlexstatic_o'), QAST::SVal.new( :value($op.name) ) )
            !! QAST::Var.new( :name($op.name), :scope('lexical') ));
    }
    elsif +@args {
        @args := nqp::clone(@args);
        $callee := $qastcomp.as_mast(@args.shift());
    }
    else {
        nqp::die("No name for call and empty children list");
    }
    @args := arrange_args(@args);

    nqp::die("callee expression must be an object")
        unless $callee.result_kind == $MVM_reg_obj;

    nqp::die("callee code did not result in a MAST::Local")
        unless $callee.result_reg && $callee.result_reg ~~ MAST::Local;

    # main instruction list
    my @ins := nqp::list();
    # the result MAST::Locals of the arg expressions
    my @arg_regs := nqp::list();
    # the result kind codes of the arg expressions
    my @arg_kinds := nqp::list();
    # the args' flags in the protocol the MAST compiler expects
    my @arg_flags := nqp::list();

    # Append the code to evaluate the callee expression
    push_ilist(@ins, $callee);

    # Process arguments.
    for @args {
        handle_arg($_, $qastcomp, @ins, @arg_regs, @arg_flags, @arg_kinds);
    }

    # Decontainerize the callee.
    my $regalloc := $*REGALLOC;
    my $decont_reg := $regalloc.fresh_register($MVM_reg_obj);
    push_op(@ins, 'decont', $decont_reg, $callee.result_reg);

    # Release the callee's result register and the decont register.
    $regalloc.release_register($callee.result_reg, $MVM_reg_obj);
    $regalloc.release_register($decont_reg, $MVM_reg_obj);

    # Release each arg's result register
    my $arg_num := 0;
    for @arg_regs -> $reg {
        if $reg ~~ MAST::Local {
            $regalloc.release_register($reg, @arg_kinds[$arg_num]);
            $arg_num++;
        }
    }

    # Figure out result register type
    my $res_kind := $qastcomp.type_to_register_kind($op.returns);

    # and allocate a register for it. Probably reuse an arg's or the callee's.
    my $res_reg := $regalloc.fresh_register($res_kind);

    # Generate call.
    nqp::push(@ins, MAST::Call.new(
        :target($decont_reg),
        :flags(@arg_flags),
        |@arg_regs,
        :result($res_reg)
    ));

    MAST::InstructionList.new(@ins, $res_reg, $res_kind)
};
QAST::MASTOperations.add_core_op('call', $call_gen, :!inlinable);
QAST::MASTOperations.add_core_op('callstatic', $call_gen, :!inlinable);

QAST::MASTOperations.add_core_op('callmethod', -> $qastcomp, $op {
    my @args := nqp::clone($op.list);
    if +@args == 0 {
        nqp::die('Method call node requires at least one child');
    }
    my $invocant := $qastcomp.as_mast(@args.shift(), :want($MVM_reg_obj));
    my $methodname_expr;
    if $op.name {
        # great!
    }
    elsif +@args >= 1 {
        $methodname_expr := @args.shift();
    }
    else {
        nqp::die("Method call must either supply a name or have a child node that evaluates to the name");
    }
    @args := arrange_args(@args);

    nqp::die("invocant expression must be an object")
        unless $invocant.result_kind == $MVM_reg_obj;

    nqp::die("invocant code did not result in a MAST::Local")
        unless $invocant.result_reg && $invocant.result_reg ~~ MAST::Local;

    # main instruction list
    my @ins := [];
    # the result MAST::Locals of the arg expressions
    my @arg_regs := [$invocant.result_reg];
    # the result kind codes of the arg expressions
    my @arg_kinds := [$MVM_reg_obj];
    # the args' flags in the protocol the MAST compiler expects
    my @arg_flags := [$Arg::obj];

    # evaluate the invocant expression
    push_ilist(@ins, $invocant);

    # Process arguments.
    for @args {
        handle_arg($_, $qastcomp, @ins, @arg_regs, @arg_flags, @arg_kinds);
    }

    # generate and emit findmethod code
    my $regalloc   := $*REGALLOC;
    my $callee_reg := $regalloc.fresh_o();

    # This will hold the 3rd argument to findmeth(_s) - the method name
    # either a MAST::SVal or an $MVM_reg_str
    my $method_name;
    if $op.name {
        $method_name := MAST::SVal.new( :value($op.name) );
    }
    else {
        my $method_name_ilist := $qastcomp.as_mast($methodname_expr, :want($MVM_reg_str));
        push_ilist(@ins, $method_name_ilist);
        $method_name := $method_name_ilist.result_reg;
    }

    # push the op that finds the method based on either the provided name
    # or the provided name-producing expression.
    my $decont_inv_reg := $regalloc.fresh_o();
    push_op(@ins, 'decont', $decont_inv_reg, $invocant.result_reg);
    push_op(@ins, ($op.name ?? 'findmeth' !! 'findmeth_s'),
        $callee_reg, $decont_inv_reg, $method_name);
    $regalloc.release_register($decont_inv_reg, $MVM_reg_obj);

    # release the method name register if we used one
    $regalloc.release_register($method_name, $MVM_reg_str) unless $op.name;

    # release the callee register
    $regalloc.release_register($callee_reg, $MVM_reg_obj);

    # Release the invocant's and each arg's result registers
    my $arg_num := 0;
    for @arg_regs -> $reg {
        if $reg ~~ MAST::Local {
            $regalloc.release_register($reg, @arg_kinds[$arg_num]);
            $arg_num++;
        }
    }

    # Figure out expected result register type
    my $res_kind := $qastcomp.type_to_register_kind($op.returns);

    # and allocate a register for it. Probably reuse an arg's or the invocant's.
    my $res_reg := $regalloc.fresh_register($res_kind);

    # Generate call.
    nqp::push(@ins, MAST::Call.new(
        :target($callee_reg),
        :result($res_reg),
        :flags(@arg_flags),
        |@arg_regs
    ));

    MAST::InstructionList.new(@ins, $res_reg, $res_kind)
});

QAST::MASTOperations.add_core_op('lexotic', :!inlinable, -> $qastcomp, $op {
    my $lex_label := MAST::Label.new();
    my $end_label := MAST::Label.new();

    # Create new lexotic and install it lexically.
    my @ins;
    my $lex_tmp := $*REGALLOC.fresh_register($MVM_reg_obj);
    $*BLOCK.add_lexical(QAST::Var.new( :name($op.name), :scope('lexical'), :decl('var') ));
    push_op(@ins, 'newlexotic', $lex_tmp, $lex_label);
    push_op(@ins, 'bindlex', $*BLOCK.lexical($op.name), $lex_tmp);

    # Emit the body, and go to the end of the lexotic code; the body's result
    # is what we want.
    my $*WANT := $MVM_reg_obj;
    my $body  := $qastcomp.compile_all_the_stmts($op.list);
    nqp::push(@ins, MAST::HandlerScope.new(
        :instructions($body.instructions),
        :category_mask($HandlerCategory::return),
        :action($HandlerAction::unwind_and_goto),
        :goto($lex_label)
    ));
    push_op(@ins, 'goto', $end_label);

    # Finally, emit the lexotic handler.
    nqp::push(@ins, $lex_label);
    push_op(@ins, 'lexoticresult', $body.result_reg, $lex_tmp);
    nqp::push(@ins, $end_label);

    $*REGALLOC.release_register($lex_tmp, $MVM_reg_obj);

    MAST::InstructionList.new(@ins, $body.result_reg, $MVM_reg_obj)
});

# Binding
QAST::MASTOperations.add_core_op('bind', -> $qastcomp, $op {
    # Sanity checks.
    my @children := $op.list;
    if +@children != 2 {
        nqp::die("A 'bind' op must have exactly two children");
    }
    unless nqp::istype(@children[0], QAST::Var) {
        nqp::die("First child of a 'bind' op must be a QAST::Var");
    }

    # Set the QAST of the think we're to bind, then delegate to
    # the compilation of the QAST::Var to handle the rest.
    my $*BINDVAL := @children[1];
    $qastcomp.as_mast(@children[0])
});

# Exception handling/munging.
QAST::MASTOperations.add_core_moarop_mapping('die', 'die');
QAST::MASTOperations.add_core_moarop_mapping('die_s', 'die');
QAST::MASTOperations.add_core_moarop_mapping('exception', 'exception');
QAST::MASTOperations.add_core_moarop_mapping('getextype', 'getexcategory');
QAST::MASTOperations.add_core_moarop_mapping('setextype', 'bindexcategory', 1);
QAST::MASTOperations.add_core_moarop_mapping('getpayload', 'getexpayload');
QAST::MASTOperations.add_core_moarop_mapping('setpayload', 'bindexpayload', 1);
QAST::MASTOperations.add_core_moarop_mapping('getmessage', 'getexmessage');
QAST::MASTOperations.add_core_moarop_mapping('setmessage', 'bindexmessage', 1);
QAST::MASTOperations.add_core_moarop_mapping('newexception', 'newexception');
QAST::MASTOperations.add_core_moarop_mapping('backtracestrings', 'backtracestrings');
QAST::MASTOperations.add_core_moarop_mapping('backtrace', 'backtrace');
QAST::MASTOperations.add_core_moarop_mapping('throw', 'throwdyn');
QAST::MASTOperations.add_core_moarop_mapping('rethrow', 'rethrow');
QAST::MASTOperations.add_core_moarop_mapping('resume', 'resume');

my %handler_names := nqp::hash(
    'CATCH',   $HandlerCategory::catch,
    'CONTROL', $HandlerCategory::control,
    'NEXT',    $HandlerCategory::next,
    'LAST',    $HandlerCategory::last,
    'REDO',    $HandlerCategory::redo,
    'TAKE',    $HandlerCategory::take,
    'WARN',    $HandlerCategory::warn,
    'PROCEED', $HandlerCategory::proceed,
    'SUCCEED', $HandlerCategory::succeed,
    'AWAIT',   $HandlerCategory::await,
    'EMIT',    $HandlerCategory::emit,
    'DONE',    $HandlerCategory::done,
);
QAST::MASTOperations.add_core_op('handle', :!inlinable, sub ($qastcomp, $op) {
    my @children := nqp::clone($op.list());
    if @children == 0 {
        nqp::die("The 'handle' op requires at least one child");
    }

    # If there's exactly one child, then there's nothing protecting
    # it; just compile it and we're done.
    my $protected := @children.shift();
    unless @children {
        return $qastcomp.as_mast($protected);
    }

    # Otherwise, we need to generate and install a handler block, which will
    # decide that to do by category.
    my $regalloc := $*REGALLOC;
    my $il := nqp::list();
    my $mask := 0;
    my $hblock := QAST::Block.new(
        QAST::Op.new(
            :op('bind'),
            QAST::Var.new( :name('__category__'), :scope('local'), :decl('var') ),
            QAST::Op.new(
                :op('getextype'),
                QAST::Op.new( :op('exception') )
            )));
    my $push_target := $hblock;
    my $lablocal;
    for @children -> $type, $handler {
        if $type eq 'LABELED' {
            $mask       := $HandlerCategory::labeled;
            my $labmast := $qastcomp.as_mast($handler, :want($MVM_reg_obj));
            my $labreg  := $labmast.result_reg;
            $lablocal   := MAST::Local.new(:index($*MAST_FRAME.add_local(NQPMu)));
            push_ilist($il, $labmast);
            push_op($il, 'set', $lablocal, $labreg);
            $regalloc.release_register($labreg, $MVM_reg_obj);
        }
        else {
            # Get the category mask.
            unless nqp::existskey(%handler_names, $type) {
                nqp::die("Invalid handler type '$type'");
            }
            my $cat_mask := $type eq 'CONTROL' ?? 0xEFFE !! %handler_names{$type};

            # Chain in this handler.
            my $check := QAST::Op.new(
                    :op('if'),
                    QAST::Op.new(
                        :op('bitand_i'),
                        QAST::Var.new( :name('__category__'), :scope('local') ),
                        QAST::IVal.new( :value($cat_mask) )
                    ),
                    $handler
                );
            # Push this check as the 3rd arg to op 'if' in case this is not the first iteration.
            $push_target.push($check);
            $push_target := $check;

            # Add to mask.
            $mask := nqp::bitor_i($mask, $cat_mask);
        }
    }

    # Add a local and store the handler block into it.
    my $hblocal := MAST::Local.new(:index($*MAST_FRAME.add_local(NQPMu)));
    my $hbmast  := $qastcomp.as_mast($hblock, :want($MVM_reg_obj));
    push_ilist($il, $hbmast);
    push_op($il, 'set', $hblocal, $hbmast.result_reg);
    $regalloc.release_register($hbmast.result_reg, $MVM_reg_obj);

    # Wrap instructions to try up in a handler and evaluate to the result
    # of the protected code of the exception handler.
    my $protil := $qastcomp.as_mast($protected, :want($MVM_reg_obj));
    my $uwlbl  := MAST::Label.new();
    my $endlbl := MAST::Label.new();
    push_op($protil.instructions, 'goto', $endlbl);
    nqp::push($il, MAST::HandlerScope.new(
        :instructions($protil.instructions), :goto($uwlbl), :block($hblocal),
        :category_mask($mask), :action($HandlerAction::invoke_and_we'll_see),
        :label($lablocal)));
    nqp::push($il, $uwlbl);
    push_op($il, 'takehandlerresult', $protil.result_reg);
    nqp::push($il, $endlbl);

    MAST::InstructionList.new($il, $protil.result_reg, $MVM_reg_obj)
});

# Control exception throwing.
my %control_map := nqp::hash(
    'next', $HandlerCategory::next,
    'last', $HandlerCategory::last,
    'redo', $HandlerCategory::redo
);
QAST::MASTOperations.add_core_op('control', -> $qastcomp, $op {
    my $regalloc := $*REGALLOC;
    my $name := $op.name;
    my $label;
    for $op.list {
        $label := $_ if $_.named eq 'label';
    }

    if nqp::existskey(%control_map, $name) {
        if $label {
            # Create an exception object, and attach the label to its payload.
            my $res := $regalloc.fresh_register($MVM_reg_obj);
            my $ex  := $regalloc.fresh_register($MVM_reg_obj);
            my $lbl := $qastcomp.as_mast($label, :want($MVM_reg_obj));
            my $cat := $regalloc.fresh_register($MVM_reg_int64);
            my $il  := MAST::InstructionList.new(nqp::list(), $res, $MVM_reg_obj);
            $il.append($lbl);
            push_op($il.instructions, 'newexception',   $ex);
            push_op($il.instructions, 'bindexpayload',  $ex,  $lbl.result_reg );
            push_op($il.instructions, 'const_i64',      $cat,
                MAST::IVal.new( :value(%control_map{$name} + $HandlerCategory::labeled) ) );
            push_op($il.instructions, 'bindexcategory', $ex,  $cat );
            push_op($il.instructions, 'throwdyn',       $res, $ex);
            $il
        }
        else {
            my $il := nqp::list();
            my $res := $regalloc.fresh_register($MVM_reg_obj);
            push_op($il, 'throwcatdyn', $res,
                MAST::IVal.new( :value(%control_map{$name}) ));
            MAST::InstructionList.new($il, $res, $MVM_reg_obj)
        }
    }
    else {
        nqp::die("Unknown control exception type '$name'");
    }
});

# Default ways to box/unbox (for no particular HLL).
QAST::MASTOperations.add_hll_unbox('', $MVM_reg_int64, -> $qastcomp, $reg {
    my $regalloc := $*REGALLOC;
    my $il := nqp::list();
    my $a := $regalloc.fresh_register($MVM_reg_num64);
    my $b := $regalloc.fresh_register($MVM_reg_int64);
    $regalloc.release_register($reg, $MVM_reg_obj);
    my $dc := $regalloc.fresh_register($MVM_reg_obj);
    push_op($il, 'decont', $dc, $reg);
    push_op($il, 'smrt_numify', $a, $dc);
    push_op($il, 'coerce_ni', $b, $a);
    $regalloc.release_register($a, $MVM_reg_num64);
    $regalloc.release_register($dc, $MVM_reg_obj);
    MAST::InstructionList.new($il, $b, $MVM_reg_int64)
});
QAST::MASTOperations.add_hll_unbox('', $MVM_reg_num64, -> $qastcomp, $reg {
    my $regalloc := $*REGALLOC;
    my $il := nqp::list();
    my $res_reg := $regalloc.fresh_register($MVM_reg_num64);
    $regalloc.release_register($reg, $MVM_reg_obj);
    my $dc := $regalloc.fresh_register($MVM_reg_obj);
    push_op($il, 'decont', $dc, $reg);
    push_op($il, 'smrt_numify', $res_reg, $dc);
    $regalloc.release_register($dc, $MVM_reg_obj);
    MAST::InstructionList.new($il, $res_reg, $MVM_reg_num64)
});
QAST::MASTOperations.add_hll_unbox('', $MVM_reg_str, -> $qastcomp, $reg {
    my $regalloc := $*REGALLOC;
    my $il := nqp::list();
    my $res_reg := $regalloc.fresh_register($MVM_reg_str);
    $regalloc.release_register($reg, $MVM_reg_obj);
    my $dc := $regalloc.fresh_register($MVM_reg_obj);
    push_op($il, 'decont', $dc, $reg);
    push_op($il, 'smrt_strify', $res_reg, $dc);
    $regalloc.release_register($dc, $MVM_reg_obj);
    MAST::InstructionList.new($il, $res_reg, $MVM_reg_str)
});
QAST::MASTOperations.add_hll_unbox('', $MVM_reg_uint64, -> $qastcomp, $reg {
    my $regalloc := $*REGALLOC;
    my $il := nqp::list();
    my $a := $regalloc.fresh_register($MVM_reg_num64);
    my $b := $regalloc.fresh_register($MVM_reg_uint64);
    $regalloc.release_register($reg, $MVM_reg_obj);
    my $dc := $regalloc.fresh_register($MVM_reg_obj);
    push_op($il, 'decont', $dc, $reg);
    push_op($il, 'smrt_numify', $a, $dc);
    push_op($il, 'coerce_nu', $b, $a);
    $regalloc.release_register($a, $MVM_reg_num64);
    $regalloc.release_register($dc, $MVM_reg_obj);
    MAST::InstructionList.new($il, $b, $MVM_reg_int64)
});
sub boxer($kind, $type_op, $op) {
    -> $qastcomp, $reg {
        my $regalloc := $*REGALLOC;
        my $il := nqp::list();
        my $res_reg := $regalloc.fresh_register($MVM_reg_obj);
        push_op($il, $type_op, $res_reg);
        push_op($il, $op, $res_reg, $reg, $res_reg);
        $regalloc.release_register($reg, $kind);
        MAST::InstructionList.new($il, $res_reg, $MVM_reg_obj)
    }
}
QAST::MASTOperations.add_hll_box('', $MVM_reg_int64, boxer($MVM_reg_int64, 'hllboxtype_i', 'box_i'));
QAST::MASTOperations.add_hll_box('', $MVM_reg_num64, boxer($MVM_reg_num64, 'hllboxtype_n', 'box_n'));
QAST::MASTOperations.add_hll_box('', $MVM_reg_str, boxer($MVM_reg_str, 'hllboxtype_s', 'box_s'));
QAST::MASTOperations.add_hll_box('', $MVM_reg_uint64, boxer($MVM_reg_uint64, 'hllboxtype_i', 'box_u'));
QAST::MASTOperations.add_hll_box('', $MVM_reg_void, -> $qastcomp, $reg {
    my $il := nqp::list();
    my $res_reg := $*REGALLOC.fresh_register($MVM_reg_obj);
    push_op($il, 'null', $res_reg);
    MAST::InstructionList.new($il, $res_reg, $MVM_reg_obj)
});

# Context introspection
QAST::MASTOperations.add_core_moarop_mapping('ctx', 'ctx', :!inlinable);
QAST::MASTOperations.add_core_moarop_mapping('ctxouter', 'ctxouter', :!inlinable);
QAST::MASTOperations.add_core_moarop_mapping('ctxcaller', 'ctxcaller', :!inlinable);
QAST::MASTOperations.add_core_moarop_mapping('ctxcode', 'ctxcode', :!inlinable);
QAST::MASTOperations.add_core_moarop_mapping('ctxouterskipthunks', 'ctxouterskipthunks', :!inlinable);
QAST::MASTOperations.add_core_moarop_mapping('ctxcallerskipthunks', 'ctxcallerskipthunks', :!inlinable);
QAST::MASTOperations.add_core_moarop_mapping('curcode', 'curcode', :!inlinable);
QAST::MASTOperations.add_core_moarop_mapping('callercode', 'callercode', :!inlinable);
QAST::MASTOperations.add_core_moarop_mapping('ctxlexpad', 'ctxlexpad', :!inlinable);
QAST::MASTOperations.add_core_moarop_mapping('curlexpad', 'ctx', :!inlinable);
QAST::MASTOperations.add_core_moarop_mapping('lexprimspec', 'lexprimspec');

# Argument capture processing, for writing things like multi-dispatchers in
# high level languages.
QAST::MASTOperations.add_core_moarop_mapping('usecapture', 'usecapture', :!inlinable);
QAST::MASTOperations.add_core_moarop_mapping('savecapture', 'savecapture', :!inlinable);
QAST::MASTOperations.add_core_moarop_mapping('captureposelems', 'captureposelems');
QAST::MASTOperations.add_core_moarop_mapping('captureposarg', 'captureposarg');
QAST::MASTOperations.add_core_moarop_mapping('captureposarg_i', 'captureposarg_i');
QAST::MASTOperations.add_core_moarop_mapping('captureposarg_n', 'captureposarg_n');
QAST::MASTOperations.add_core_moarop_mapping('captureposarg_s', 'captureposarg_s');
QAST::MASTOperations.add_core_moarop_mapping('captureposprimspec', 'captureposprimspec');
QAST::MASTOperations.add_core_moarop_mapping('captureexistsnamed', 'captureexistsnamed');
QAST::MASTOperations.add_core_moarop_mapping('capturehasnameds', 'capturehasnameds');
QAST::MASTOperations.add_core_moarop_mapping('capturenamedshash', 'capturenamedshash');
QAST::MASTOperations.add_core_moarop_mapping('objprimspec', 'objprimspec');
QAST::MASTOperations.add_core_moarop_mapping('objprimbits', 'objprimbits');
QAST::MASTOperations.add_core_moarop_mapping('objprimunsigned', 'objprimunsigned');

# Multiple dispatch related.
QAST::MASTOperations.add_core_moarop_mapping('invokewithcapture', 'invokewithcapture');
QAST::MASTOperations.add_core_moarop_mapping('multicacheadd', 'multicacheadd');
QAST::MASTOperations.add_core_moarop_mapping('multicachefind', 'multicachefind');

# Constant mapping.
my %const_map := nqp::hash(
    'CCLASS_ANY',           65535,
    'CCLASS_UPPERCASE',     1,
    'CCLASS_LOWERCASE',     2,
    'CCLASS_ALPHABETIC',    4,
    'CCLASS_NUMERIC',       8,
    'CCLASS_HEXADECIMAL',   16,
    'CCLASS_WHITESPACE',    32,
    'CCLASS_PRINTING',      64,
    'CCLASS_BLANK',         256,
    'CCLASS_CONTROL',       512,
    'CCLASS_PUNCTUATION',   1024,
    'CCLASS_ALPHANUMERIC',  2048,
    'CCLASS_NEWLINE',       4096,
    'CCLASS_WORD',          8192,

    'HLL_ROLE_NONE',        0,
    'HLL_ROLE_INT',         1,
    'HLL_ROLE_NUM',         2,
    'HLL_ROLE_STR',         3,
    'HLL_ROLE_ARRAY',       4,
    'HLL_ROLE_HASH',        5,
    'HLL_ROLE_CODE',        6,

    'CONTROL_NEXT',         4,
    'CONTROL_REDO',         8,
    'CONTROL_LAST',         16,
    'CONTROL_TAKE',         128,
    'CONTROL_WARN',         256,
    'CONTROL_SUCCEED',      512,
    'CONTROL_PROCEED',      1024,
    'CONTROL_LABELED',      4096,
    'CONTROL_AWAIT',        8192,
    'CONTROL_EMIT',         16384,
    'CONTROL_DONE',         32768,

    'STAT_EXISTS',             0,
    'STAT_FILESIZE',           1,
    'STAT_ISDIR',              2,
    'STAT_ISREG',              3,
    'STAT_ISDEV',              4,
    'STAT_CREATETIME',         5,
    'STAT_ACCESSTIME',         6,
    'STAT_MODIFYTIME',         7,
    'STAT_CHANGETIME',         8,
    'STAT_BACKUPTIME',         9,
    'STAT_UID',                10,
    'STAT_GID',                11,
    'STAT_ISLNK',              12,
    'STAT_PLATFORM_DEV',       -1,
    'STAT_PLATFORM_INODE',     -2,
    'STAT_PLATFORM_MODE',      -3,
    'STAT_PLATFORM_NLINKS',    -4,
    'STAT_PLATFORM_DEVTYPE',   -5,
    'STAT_PLATFORM_BLOCKSIZE', -6,
    'STAT_PLATFORM_BLOCKS',    -7,

    'PIPE_INHERIT_IN',          1,
    'PIPE_IGNORE_IN',           2,
    'PIPE_CAPTURE_IN',          4,
    'PIPE_INHERIT_OUT',         8,
    'PIPE_IGNORE_OUT',          16,
    'PIPE_CAPTURE_OUT',         32,
    'PIPE_INHERIT_ERR',         64,
    'PIPE_IGNORE_ERR',          128,
    'PIPE_CAPTURE_ERR',         256,

    'SIG_HUP',                  1,
    'SIG_INT',                  2,
    'SIG_QUIT',                 3,
    'SIG_ILL',                  4,
    'SIG_TRAP',                 5,
    'SIG_ABRT',                 6,
    'SIG_EMT',                  7,
    'SIG_FPE',                  8,
    'SIG_KILL',                 9,
    'SIG_BUS',                  10,
    'SIG_SEGV',                 11,
    'SIG_SYS',                  12,
    'SIG_PIPE',                 13,
    'SIG_ALRM',                 14,
    'SIG_TERM',                 15,
    'SIG_URG',                  16,
    'SIG_STOP',                 17,
    'SIG_TSTP',                 18,
    'SIG_CONT',                 19,
    'SIG_CHLD',                 20,
    'SIG_TTIN',                 21,
    'SIG_TTOU',                 22,
    'SIG_IO',                   23,
    'SIG_XCPU',                 24,
    'SIG_XFSZ',                 25,
    'SIG_VTALRM',               26,
    'SIG_PROF',                 27,
    'SIG_WINCH',                28,
    'SIG_INFO',                 29,
    'SIG_USR1',                 30,
    'SIG_USR2',                 31,
    'SIG_THR',                  32,
    'SIG_STKFLT',               116,
    'SIG_PWR',                  130,
    'SIG_BREAK',                221,

    'C_TYPE_CHAR',              -1,
    'C_TYPE_SHORT',             -2,
    'C_TYPE_INT',               -3,
    'C_TYPE_LONG',              -4,
    'C_TYPE_LONGLONG',          -5,
    'C_TYPE_SIZE_T',            -6,
    'C_TYPE_BOOL',              -7,
    'C_TYPE_FLOAT',             -1,
    'C_TYPE_DOUBLE',            -2,
    'C_TYPE_LONGDOUBLE',        -3,

    'NORMALIZE_NONE',            0,
    'NORMALIZE_NFC',             1,
    'NORMALIZE_NFD',             2,
    'NORMALIZE_NFKC',            3,
    'NORMALIZE_NFKD',            4,
);
QAST::MASTOperations.add_core_op('const', -> $qastcomp, $op {
    if nqp::existskey(%const_map, $op.name) {
        $qastcomp.as_mast(QAST::IVal.new( :value(%const_map{$op.name}) ))
    }
    else {
        nqp::die("Unknown constant '" ~ $op.name ~ "'");
    }
});

# Default way to do positional and associative lookups.
QAST::MASTOperations.add_core_moarop_mapping('positional_get', 'atpos_o');
QAST::MASTOperations.add_core_moarop_mapping('positional_bind', 'bindpos_o', 2);
QAST::MASTOperations.add_core_moarop_mapping('associative_get', 'atkey_o');
QAST::MASTOperations.add_core_moarop_mapping('associative_bind', 'bindkey_o', 2);

# I/O opcodes
QAST::MASTOperations.add_core_moarop_mapping('say', 'say', 0);
QAST::MASTOperations.add_core_moarop_mapping('print', 'print', 0);
QAST::MASTOperations.add_core_moarop_mapping('stat', 'stat');
QAST::MASTOperations.add_core_moarop_mapping('stat_time', 'stat_time');
QAST::MASTOperations.add_core_moarop_mapping('lstat', 'lstat');
QAST::MASTOperations.add_core_moarop_mapping('lstat_time', 'lstat_time');
QAST::MASTOperations.add_core_moarop_mapping('open', 'open_fh');
QAST::MASTOperations.add_core_moarop_mapping('filereadable', 'filereadable');
QAST::MASTOperations.add_core_moarop_mapping('filewritable', 'filewritable');
QAST::MASTOperations.add_core_moarop_mapping('fileexecutable', 'fileexecutable');
QAST::MASTOperations.add_core_op('fileislink', -> $qastcomp, $op {
    $qastcomp.as_mast( QAST::Op.new( :op('stat'), $op[0], QAST::IVal.new( :value(12) )) )
});
QAST::MASTOperations.add_core_moarop_mapping('flushfh', 'sync_fh');
QAST::MASTOperations.add_core_moarop_mapping('getstdin', 'getstdin');
QAST::MASTOperations.add_core_moarop_mapping('getstdout', 'getstdout');
QAST::MASTOperations.add_core_moarop_mapping('getstderr', 'getstderr');
QAST::MASTOperations.add_core_moarop_mapping('setencoding', 'setencoding', 1);
QAST::MASTOperations.add_core_moarop_mapping('tellfh', 'tell_fh');
QAST::MASTOperations.add_core_moarop_mapping('seekfh', 'seek_fh');
QAST::MASTOperations.add_core_moarop_mapping('lockfh', 'lock_fh');
QAST::MASTOperations.add_core_moarop_mapping('unlockfh', 'unlock_fh');
QAST::MASTOperations.add_core_moarop_mapping('readfh', 'read_fhb', 1);
QAST::MASTOperations.add_core_moarop_mapping('writefh', 'write_fhb', 1);
QAST::MASTOperations.add_core_moarop_mapping('printfh', 'write_fhs');
QAST::MASTOperations.add_core_moarop_mapping('sayfh', 'say_fhs');
QAST::MASTOperations.add_core_moarop_mapping('readlinefh', 'readline_fh');
QAST::MASTOperations.add_core_moarop_mapping('readlinechompfh', 'readlinechomp_fh');
QAST::MASTOperations.add_core_moarop_mapping('readallfh', 'readall_fh');
QAST::MASTOperations.add_core_op('getcfh', -> $qastcomp, $op {
    $qastcomp.as_mast( QAST::VM.new( :moarop('read_fhs'), $op[0], QAST::IVal.new( :value(1) )) )
});
QAST::MASTOperations.add_core_moarop_mapping('eoffh', 'eof_fh');
QAST::MASTOperations.add_core_moarop_mapping('closefh', 'close_fh', 0);
QAST::MASTOperations.add_core_moarop_mapping('closefh_i', 'close_fhi');
QAST::MASTOperations.add_core_moarop_mapping('isttyfh', 'istty_fh');
QAST::MASTOperations.add_core_moarop_mapping('filenofh', 'fileno_fh');
QAST::MASTOperations.add_core_moarop_mapping('socket', 'socket');
QAST::MASTOperations.add_core_moarop_mapping('connect', 'connect_sk', 0);
QAST::MASTOperations.add_core_moarop_mapping('bindsock', 'bind_sk', 0);
QAST::MASTOperations.add_core_moarop_mapping('accept', 'accept_sk');
QAST::MASTOperations.add_core_moarop_mapping('readcharsfh', 'read_fhs');
QAST::MASTOperations.add_core_moarop_mapping('setinputlinesep', 'setinputlinesep_fh', 0);
QAST::MASTOperations.add_core_moarop_mapping('setinputlineseps', 'setinputlineseps_fh', 0);

QAST::MASTOperations.add_core_moarop_mapping('chmod', 'chmod_f', 0);
QAST::MASTOperations.add_core_moarop_mapping('unlink', 'delete_f', 0);
QAST::MASTOperations.add_core_moarop_mapping('rmdir', 'rmdir', 0);
QAST::MASTOperations.add_core_moarop_mapping('cwd', 'cwd');
QAST::MASTOperations.add_core_moarop_mapping('chdir', 'chdir', 0);
QAST::MASTOperations.add_core_moarop_mapping('mkdir', 'mkdir', 0);
QAST::MASTOperations.add_core_moarop_mapping('rename', 'rename_f', 0);
QAST::MASTOperations.add_core_moarop_mapping('copy', 'copy_f', 0);
QAST::MASTOperations.add_core_moarop_mapping('symlink', 'symlink');
QAST::MASTOperations.add_core_moarop_mapping('readlink', 'readlink');
QAST::MASTOperations.add_core_moarop_mapping('link', 'link');
QAST::MASTOperations.add_core_moarop_mapping('opendir', 'open_dir');
QAST::MASTOperations.add_core_moarop_mapping('nextfiledir', 'read_dir');
QAST::MASTOperations.add_core_moarop_mapping('closedir', 'close_dir');
QAST::MASTOperations.add_core_op('sprintf', -> $qastcomp, $op {
    my @operands := $op.list;
    $qastcomp.as_mast(
        QAST::Op.new(
            :op('call'),
            :returns(str),
            QAST::Op.new(
                :op('gethllsym'),
                QAST::SVal.new( :value('nqp') ),
                QAST::SVal.new( :value('sprintf') )
            ),
            |@operands )
    );
});
QAST::MASTOperations.add_core_op('sprintfdirectives', -> $qastcomp, $op {
    my @operands := $op.list;
    $qastcomp.as_mast(
        QAST::Op.new(
            :op('call'),
            :returns(int),
            QAST::Op.new(
                :op('gethllsym'),
                QAST::SVal.new( :value('nqp') ),
                QAST::SVal.new( :value('sprintfdirectives') )
            ),
            |@operands )
    );
});
QAST::MASTOperations.add_core_op('sprintfaddargumenthandler', -> $qastcomp, $op {
    my @operands := $op.list;
    $qastcomp.as_mast(
        QAST::Op.new(
            :op('call'),
            :returns(str),
            QAST::Op.new(
                :op('gethllsym'),
                QAST::SVal.new( :value('nqp') ),
                QAST::SVal.new( :value('sprintfaddargumenthandler') )
            ),
            |@operands )
    );
});

# terms
QAST::MASTOperations.add_core_moarop_mapping('time_i', 'time_i');
QAST::MASTOperations.add_core_moarop_mapping('time_n', 'time_n');

# Arithmetic ops
QAST::MASTOperations.add_core_moarop_mapping('add_i', 'add_i');
QAST::MASTOperations.add_core_moarop_mapping('add_I', 'add_I');
QAST::MASTOperations.add_core_moarop_mapping('add_n', 'add_n');
QAST::MASTOperations.add_core_moarop_mapping('sub_i', 'sub_i');
QAST::MASTOperations.add_core_moarop_mapping('sub_I', 'sub_I');
QAST::MASTOperations.add_core_moarop_mapping('sub_n', 'sub_n');
QAST::MASTOperations.add_core_moarop_mapping('mul_i', 'mul_i');
QAST::MASTOperations.add_core_moarop_mapping('mul_I', 'mul_I');
QAST::MASTOperations.add_core_moarop_mapping('mul_n', 'mul_n');
QAST::MASTOperations.add_core_moarop_mapping('div_i', 'div_i');
QAST::MASTOperations.add_core_moarop_mapping('div_I', 'div_I');
QAST::MASTOperations.add_core_moarop_mapping('div_In', 'div_In');
QAST::MASTOperations.add_core_moarop_mapping('div_n', 'div_n');
QAST::MASTOperations.add_core_moarop_mapping('mod_i', 'mod_i');
QAST::MASTOperations.add_core_moarop_mapping('mod_I', 'mod_I');
QAST::MASTOperations.add_core_moarop_mapping('expmod_I', 'expmod_I');
QAST::MASTOperations.add_core_moarop_mapping('mod_n', 'mod_n');
QAST::MASTOperations.add_core_moarop_mapping('neg_i', 'neg_i');
QAST::MASTOperations.add_core_moarop_mapping('neg_I', 'neg_I');
QAST::MASTOperations.add_core_moarop_mapping('neg_n', 'neg_n');
QAST::MASTOperations.add_core_moarop_mapping('pow_i', 'pow_i');
QAST::MASTOperations.add_core_moarop_mapping('pow_I', 'pow_I');
QAST::MASTOperations.add_core_moarop_mapping('pow_n', 'pow_n');
QAST::MASTOperations.add_core_moarop_mapping('abs_i', 'abs_i');
QAST::MASTOperations.add_core_moarop_mapping('abs_I', 'abs_I');
QAST::MASTOperations.add_core_moarop_mapping('abs_n', 'abs_n');
QAST::MASTOperations.add_core_moarop_mapping('ceil_n', 'ceil_n');
QAST::MASTOperations.add_core_moarop_mapping('floor_n', 'floor_n');
QAST::MASTOperations.add_core_moarop_mapping('sqrt_n', 'sqrt_n');
QAST::MASTOperations.add_core_moarop_mapping('base_I', 'base_I');
QAST::MASTOperations.add_core_moarop_mapping('isbig_I', 'isbig_I');
QAST::MASTOperations.add_core_moarop_mapping('radix', 'radix');
QAST::MASTOperations.add_core_moarop_mapping('radix_I', 'radix_I');
QAST::MASTOperations.add_core_moarop_mapping('log_n', 'log_n');
QAST::MASTOperations.add_core_moarop_mapping('exp_n', 'exp_n');
QAST::MASTOperations.add_core_moarop_mapping('isnanorinf', 'isnanorinf');
QAST::MASTOperations.add_core_moarop_mapping('inf', 'inf');
QAST::MASTOperations.add_core_moarop_mapping('neginf', 'neginf');
QAST::MASTOperations.add_core_moarop_mapping('nan', 'nan');
QAST::MASTOperations.add_core_moarop_mapping('isprime_I', 'isprime_I');
QAST::MASTOperations.add_core_moarop_mapping('rand_I', 'rand_I');

# bigint <-> string/num conversions
QAST::MASTOperations.add_core_moarop_mapping('tostr_I', 'coerce_Is');
QAST::MASTOperations.add_core_moarop_mapping('fromstr_I', 'coerce_sI');
QAST::MASTOperations.add_core_moarop_mapping('tonum_I', 'coerce_In');
QAST::MASTOperations.add_core_moarop_mapping('fromnum_I', 'coerce_nI');

# trig opcodes
QAST::MASTOperations.add_core_moarop_mapping('sin_n', 'sin_n');
QAST::MASTOperations.add_core_moarop_mapping('asin_n', 'asin_n');
QAST::MASTOperations.add_core_moarop_mapping('cos_n', 'cos_n');
QAST::MASTOperations.add_core_moarop_mapping('acos_n', 'acos_n');
QAST::MASTOperations.add_core_moarop_mapping('tan_n', 'tan_n');
QAST::MASTOperations.add_core_moarop_mapping('atan_n', 'atan_n');
QAST::MASTOperations.add_core_moarop_mapping('atan2_n', 'atan2_n');
QAST::MASTOperations.add_core_moarop_mapping('sec_n', 'sec_n');
QAST::MASTOperations.add_core_moarop_mapping('asec_n', 'asec_n');
QAST::MASTOperations.add_core_moarop_mapping('asin_n', 'asin_n');
QAST::MASTOperations.add_core_moarop_mapping('sinh_n', 'sinh_n');
QAST::MASTOperations.add_core_moarop_mapping('cosh_n', 'cosh_n');
QAST::MASTOperations.add_core_moarop_mapping('tanh_n', 'tanh_n');
QAST::MASTOperations.add_core_moarop_mapping('sech_n', 'sech_n');

# esoteric math opcodes
QAST::MASTOperations.add_core_moarop_mapping('gcd_i', 'gcd_i');
QAST::MASTOperations.add_core_moarop_mapping('gcd_I', 'gcd_I');
QAST::MASTOperations.add_core_moarop_mapping('lcm_i', 'lcm_i');
QAST::MASTOperations.add_core_moarop_mapping('lcm_I', 'lcm_I');

# string opcodes
QAST::MASTOperations.add_core_moarop_mapping('chars', 'chars');
QAST::MASTOperations.add_core_moarop_mapping('uc', 'uc');
QAST::MASTOperations.add_core_moarop_mapping('lc', 'lc');
QAST::MASTOperations.add_core_moarop_mapping('tc', 'tc');
QAST::MASTOperations.add_core_moarop_mapping('fc', 'fc');
QAST::MASTOperations.add_core_moarop_mapping('x', 'repeat_s');
QAST::MASTOperations.add_core_moarop_mapping('iscclass', 'iscclass');
QAST::MASTOperations.add_core_moarop_mapping('findcclass', 'findcclass');
QAST::MASTOperations.add_core_moarop_mapping('findnotcclass', 'findnotcclass');
QAST::MASTOperations.add_core_moarop_mapping('escape', 'escape');
QAST::MASTOperations.add_core_moarop_mapping('replace', 'replace');
QAST::MASTOperations.add_core_moarop_mapping('flip', 'flip');
QAST::MASTOperations.add_core_moarop_mapping('concat', 'concat_s');
QAST::MASTOperations.add_core_moarop_mapping('join', 'join');
QAST::MASTOperations.add_core_moarop_mapping('split', 'split');
QAST::MASTOperations.add_core_moarop_mapping('chr', 'chr');
QAST::MASTOperations.add_core_moarop_mapping('ordfirst', 'ordfirst');
QAST::MASTOperations.add_core_moarop_mapping('ordat', 'ordat');
QAST::MASTOperations.add_core_moarop_mapping('ordbaseat', 'ordbaseat');
QAST::MASTOperations.add_core_moarop_mapping('indexfrom', 'index_s');
QAST::MASTOperations.add_core_moarop_mapping('rindexfrom', 'rindexfrom');
QAST::MASTOperations.add_core_moarop_mapping('substr_s', 'substr_s');
QAST::MASTOperations.add_core_moarop_mapping('codepointfromname', 'getcpbyname');
QAST::MASTOperations.add_core_moarop_mapping('encode', 'encode');
QAST::MASTOperations.add_core_moarop_mapping('encoderep', 'encoderep');
QAST::MASTOperations.add_core_moarop_mapping('decode', 'decode');
QAST::MASTOperations.add_core_moarop_mapping('decodetocodes', 'decodetocodes', 3);
QAST::MASTOperations.add_core_moarop_mapping('encodefromcodes', 'encodefromcodes', 2);
QAST::MASTOperations.add_core_moarop_mapping('encodenorm', 'encodenorm', 3);
QAST::MASTOperations.add_core_moarop_mapping('normalizecodes', 'normalizecodes', 2);
QAST::MASTOperations.add_core_moarop_mapping('strfromcodes', 'strfromcodes');
QAST::MASTOperations.add_core_moarop_mapping('strtocodes', 'strtocodes', 2);

QAST::MASTOperations.add_core_op('tclc', -> $qastcomp, $op {
    my @operands := $op.list;
    unless +@operands == 1 {
        nqp::die('tclc op requires one argument');
    }
    $qastcomp.as_mast(
            QAST::Op.new( :op('concat'),
                QAST::Op.new( :op('tc'),
                    QAST::Op.new( :op('substr'),
                        @operands[0], QAST::IVal.new( :value(0) ), QAST::IVal.new( :value(1) ))),
                QAST::Op.new( :op('lc'),
                    QAST::Op.new( :op('substr'),
                        @operands[0], QAST::IVal.new( :value(1) ))),
        ));
});

QAST::MASTOperations.add_core_moarop_mapping('eqat', 'eqat_s');

QAST::MASTOperations.add_core_op('substr', -> $qastcomp, $op {
    my @operands := $op.list;
    if +@operands == 2 { nqp::push(@operands, QAST::IVal.new( :value(-1) )) }
    $qastcomp.as_mast(QAST::Op.new( :op('substr_s'), |@operands ));
});

QAST::MASTOperations.add_core_op('ord',  -> $qastcomp, $op {
    my @operands := $op.list;
    $qastcomp.as_mast(+@operands == 1
        ?? QAST::Op.new( :op('ordfirst'), |@operands )
        !! QAST::Op.new( :op('ordat'), |@operands ));
});

QAST::MASTOperations.add_core_op('index',  -> $qastcomp, $op {
    my @operands := $op.list;
    $qastcomp.as_mast(+@operands == 2
        ?? QAST::Op.new( :op('indexfrom'), |@operands, QAST::IVal.new( :value(0)) )
        !! QAST::Op.new( :op('indexfrom'), |@operands ));
});

QAST::MASTOperations.add_core_op('rindex',  -> $qastcomp, $op {
    my @operands := $op.list;
    $qastcomp.as_mast(+@operands == 2
        ?? QAST::Op.new( :op('rindexfrom'), |@operands, QAST::IVal.new( :value(-1) ) )
        !! QAST::Op.new( :op('rindexfrom'), |@operands ));
});

# unicode properties
QAST::MASTOperations.add_core_moarop_mapping('unipropcode', 'unipropcode');
QAST::MASTOperations.add_core_moarop_mapping('unipvalcode', 'unipvalcode');
QAST::MASTOperations.add_core_moarop_mapping('getuniname', 'getuniname');
QAST::MASTOperations.add_core_moarop_mapping('getuniprop_str', 'getuniprop_str');
QAST::MASTOperations.add_core_moarop_mapping('getuniprop_bool', 'getuniprop_bool');
QAST::MASTOperations.add_core_moarop_mapping('getuniprop_int', 'getuniprop_int');
QAST::MASTOperations.add_core_moarop_mapping('matchuniprop', 'matchuniprop');

# serialization context opcodes
QAST::MASTOperations.add_core_moarop_mapping('sha1', 'sha1');
QAST::MASTOperations.add_core_moarop_mapping('createsc', 'createsc');
QAST::MASTOperations.add_core_moarop_mapping('scsetobj', 'scsetobj', 2);
QAST::MASTOperations.add_core_moarop_mapping('scsetcode', 'scsetcode', 2);
QAST::MASTOperations.add_core_moarop_mapping('scgetobj', 'scgetobj');
QAST::MASTOperations.add_core_moarop_mapping('scgethandle', 'scgethandle');
QAST::MASTOperations.add_core_moarop_mapping('scgetdesc', 'scgetdesc');
QAST::MASTOperations.add_core_moarop_mapping('scgetobjidx', 'scgetobjidx');
QAST::MASTOperations.add_core_moarop_mapping('scsetdesc', 'scsetdesc', 1);
QAST::MASTOperations.add_core_moarop_mapping('scobjcount', 'scobjcount');
QAST::MASTOperations.add_core_moarop_mapping('setobjsc', 'setobjsc', 0);
QAST::MASTOperations.add_core_moarop_mapping('getobjsc', 'getobjsc');
QAST::MASTOperations.add_core_moarop_mapping('serialize', 'serialize');
QAST::MASTOperations.add_core_moarop_mapping('deserialize', 'deserialize', 0);
QAST::MASTOperations.add_core_moarop_mapping('scwbdisable', 'scwbdisable');
QAST::MASTOperations.add_core_moarop_mapping('scwbenable', 'scwbenable');
QAST::MASTOperations.add_core_moarop_mapping('pushcompsc', 'pushcompsc', 0);
QAST::MASTOperations.add_core_moarop_mapping('popcompsc', 'popcompsc');
QAST::MASTOperations.add_core_moarop_mapping('neverrepossess', 'neverrepossess', 0);
QAST::MASTOperations.add_core_moarop_mapping('scdisclaim', 'scdisclaim', 0);

# bitwise opcodes
QAST::MASTOperations.add_core_moarop_mapping('bitor_i', 'bor_i');
QAST::MASTOperations.add_core_moarop_mapping('bitxor_i', 'bxor_i');
QAST::MASTOperations.add_core_moarop_mapping('bitand_i', 'band_i');
QAST::MASTOperations.add_core_moarop_mapping('bitshiftl_i', 'blshift_i');
QAST::MASTOperations.add_core_moarop_mapping('bitshiftr_i', 'brshift_i');
QAST::MASTOperations.add_core_moarop_mapping('bitneg_i', 'bnot_i');

QAST::MASTOperations.add_core_moarop_mapping('bitor_I', 'bor_I');
QAST::MASTOperations.add_core_moarop_mapping('bitxor_I', 'bxor_I');
QAST::MASTOperations.add_core_moarop_mapping('bitand_I', 'band_I');
QAST::MASTOperations.add_core_moarop_mapping('bitneg_I', 'bnot_I');
QAST::MASTOperations.add_core_moarop_mapping('bitshiftl_I', 'blshift_I');
QAST::MASTOperations.add_core_moarop_mapping('bitshiftr_I', 'brshift_I');

# string bitwise ops
QAST::MASTOperations.add_core_moarop_mapping('bitor_s', 'bitor_s');
QAST::MASTOperations.add_core_moarop_mapping('bitxor_s', 'bitxor_s');
QAST::MASTOperations.add_core_moarop_mapping('bitand_s', 'bitand_s');

# relational opcodes
QAST::MASTOperations.add_core_moarop_mapping('cmp_i', 'cmp_i');
QAST::MASTOperations.add_core_moarop_mapping('iseq_i', 'eq_i');
QAST::MASTOperations.add_core_moarop_mapping('isne_i', 'ne_i');
QAST::MASTOperations.add_core_moarop_mapping('islt_i', 'lt_i');
QAST::MASTOperations.add_core_moarop_mapping('isle_i', 'le_i');
QAST::MASTOperations.add_core_moarop_mapping('isgt_i', 'gt_i');
QAST::MASTOperations.add_core_moarop_mapping('isge_i', 'ge_i');

QAST::MASTOperations.add_core_moarop_mapping('cmp_n', 'cmp_n');
QAST::MASTOperations.add_core_moarop_mapping('not_i', 'not_i');
QAST::MASTOperations.add_core_moarop_mapping('iseq_n', 'eq_n');
QAST::MASTOperations.add_core_moarop_mapping('isne_n', 'ne_n');
QAST::MASTOperations.add_core_moarop_mapping('islt_n', 'lt_n');
QAST::MASTOperations.add_core_moarop_mapping('isle_n', 'le_n');
QAST::MASTOperations.add_core_moarop_mapping('isgt_n', 'gt_n');
QAST::MASTOperations.add_core_moarop_mapping('isge_n', 'ge_n');

QAST::MASTOperations.add_core_moarop_mapping('cmp_s', 'cmp_s');
QAST::MASTOperations.add_core_moarop_mapping('iseq_s', 'eq_s');
QAST::MASTOperations.add_core_moarop_mapping('isne_s', 'ne_s');
QAST::MASTOperations.add_core_moarop_mapping('islt_s', 'lt_s');
QAST::MASTOperations.add_core_moarop_mapping('isle_s', 'le_s');
QAST::MASTOperations.add_core_moarop_mapping('isgt_s', 'gt_s');
QAST::MASTOperations.add_core_moarop_mapping('isge_s', 'ge_s');

QAST::MASTOperations.add_core_moarop_mapping('bool_I', 'bool_I');
QAST::MASTOperations.add_core_moarop_mapping('cmp_I', 'cmp_I');
QAST::MASTOperations.add_core_moarop_mapping('iseq_I', 'eq_I');
QAST::MASTOperations.add_core_moarop_mapping('isne_I', 'ne_I');
QAST::MASTOperations.add_core_moarop_mapping('islt_I', 'lt_I');
QAST::MASTOperations.add_core_moarop_mapping('isle_I', 'le_I');
QAST::MASTOperations.add_core_moarop_mapping('isgt_I', 'gt_I');
QAST::MASTOperations.add_core_moarop_mapping('isge_I', 'ge_I');

# aggregate opcodes
QAST::MASTOperations.add_core_moarop_mapping('atpos', 'atpos_o');
QAST::MASTOperations.add_core_moarop_mapping('atpos_i', 'atpos_i');
QAST::MASTOperations.add_core_moarop_mapping('atpos_n', 'atpos_n');
QAST::MASTOperations.add_core_moarop_mapping('atpos_s', 'atpos_s');
QAST::MASTOperations.add_core_moarop_mapping('atposref_i', 'atposref_i');
QAST::MASTOperations.add_core_moarop_mapping('atposref_n', 'atposref_n');
QAST::MASTOperations.add_core_moarop_mapping('atposref_s', 'atposref_s');
QAST::MASTOperations.add_core_moarop_mapping('atpos2d', 'atpos2d_o');
QAST::MASTOperations.add_core_moarop_mapping('atpos2d_i', 'atpos2d_i');
QAST::MASTOperations.add_core_moarop_mapping('atpos2d_n', 'atpos2d_n');
QAST::MASTOperations.add_core_moarop_mapping('atpos2d_s', 'atpos2d_s');
QAST::MASTOperations.add_core_moarop_mapping('atpos3d', 'atpos3d_o');
QAST::MASTOperations.add_core_moarop_mapping('atpos3d_i', 'atpos3d_i');
QAST::MASTOperations.add_core_moarop_mapping('atpos3d_n', 'atpos3d_n');
QAST::MASTOperations.add_core_moarop_mapping('atpos3d_s', 'atpos3d_s');
QAST::MASTOperations.add_core_moarop_mapping('atposnd', 'atposnd_o');
QAST::MASTOperations.add_core_moarop_mapping('atposnd_i', 'atposnd_i');
QAST::MASTOperations.add_core_moarop_mapping('atposnd_n', 'atposnd_n');
QAST::MASTOperations.add_core_moarop_mapping('atposnd_s', 'atposnd_s');
QAST::MASTOperations.add_core_moarop_mapping('multidimref_i', 'multidimref_i');
QAST::MASTOperations.add_core_moarop_mapping('multidimref_n', 'multidimref_n');
QAST::MASTOperations.add_core_moarop_mapping('multidimref_s', 'multidimref_s');
QAST::MASTOperations.add_core_moarop_mapping('atkey', 'atkey_o');
QAST::MASTOperations.add_core_moarop_mapping('atkey_i', 'atkey_i');
QAST::MASTOperations.add_core_moarop_mapping('atkey_n', 'atkey_n');
QAST::MASTOperations.add_core_moarop_mapping('atkey_s', 'atkey_s');
QAST::MASTOperations.add_core_moarop_mapping('bindpos', 'bindpos_o', 2);
QAST::MASTOperations.add_core_moarop_mapping('bindpos_i', 'bindpos_i', 2);
QAST::MASTOperations.add_core_moarop_mapping('bindpos_n', 'bindpos_n', 2);
QAST::MASTOperations.add_core_moarop_mapping('bindpos_s', 'bindpos_s', 2);

QAST::MASTOperations.add_core_moarop_mapping('bindpos2d', 'bindpos2d_o', 3);
QAST::MASTOperations.add_core_moarop_mapping('bindpos2d_i', 'bindpos2d_i', 3);
QAST::MASTOperations.add_core_moarop_mapping('bindpos2d_n', 'bindpos2d_n', 3);
QAST::MASTOperations.add_core_moarop_mapping('bindpos2d_s', 'bindpos2d_s', 3);
QAST::MASTOperations.add_core_moarop_mapping('bindpos3d', 'bindpos3d_o', 4);
QAST::MASTOperations.add_core_moarop_mapping('bindpos3d_i', 'bindpos3d_i', 4);
QAST::MASTOperations.add_core_moarop_mapping('bindpos3d_n', 'bindpos3d_n', 4);
QAST::MASTOperations.add_core_moarop_mapping('bindpos3d_s', 'bindpos3d_s', 4);
QAST::MASTOperations.add_core_moarop_mapping('bindposnd', 'bindposnd_o', 2);
QAST::MASTOperations.add_core_moarop_mapping('bindposnd_i', 'bindposnd_i', 2);
QAST::MASTOperations.add_core_moarop_mapping('bindposnd_n', 'bindposnd_n', 2);
QAST::MASTOperations.add_core_moarop_mapping('bindposnd_s', 'bindposnd_s', 2);
QAST::MASTOperations.add_core_moarop_mapping('bindkey', 'bindkey_o', 2);
QAST::MASTOperations.add_core_moarop_mapping('bindkey_i', 'bindkey_i', 2);
QAST::MASTOperations.add_core_moarop_mapping('bindkey_n', 'bindkey_n', 2);
QAST::MASTOperations.add_core_moarop_mapping('bindkey_s', 'bindkey_s', 2);
QAST::MASTOperations.add_core_moarop_mapping('existskey', 'existskey');
QAST::MASTOperations.add_core_moarop_mapping('deletekey', 'deletekey');
QAST::MASTOperations.add_core_moarop_mapping('elems', 'elems');
QAST::MASTOperations.add_core_moarop_mapping('setelems', 'setelemspos', 0);
QAST::MASTOperations.add_core_moarop_mapping('dimensions', 'dimensions');
QAST::MASTOperations.add_core_moarop_mapping('setdimensions', 'setdimensions', 0);
QAST::MASTOperations.add_core_moarop_mapping('numdimensions', 'numdimensions');
QAST::MASTOperations.add_core_moarop_mapping('existspos', 'existspos');
QAST::MASTOperations.add_core_moarop_mapping('push', 'push_o', 1);
QAST::MASTOperations.add_core_moarop_mapping('push_i', 'push_i', 1);
QAST::MASTOperations.add_core_moarop_mapping('push_n', 'push_n', 1);
QAST::MASTOperations.add_core_moarop_mapping('push_s', 'push_s', 1);
QAST::MASTOperations.add_core_moarop_mapping('pop', 'pop_o');
QAST::MASTOperations.add_core_moarop_mapping('pop_i', 'pop_i');
QAST::MASTOperations.add_core_moarop_mapping('pop_n', 'pop_n');
QAST::MASTOperations.add_core_moarop_mapping('pop_s', 'pop_s');
QAST::MASTOperations.add_core_moarop_mapping('unshift', 'unshift_o', 1);
QAST::MASTOperations.add_core_moarop_mapping('unshift_i', 'unshift_i', 1);
QAST::MASTOperations.add_core_moarop_mapping('unshift_n', 'unshift_n', 1);
QAST::MASTOperations.add_core_moarop_mapping('unshift_s', 'unshift_s', 1);
QAST::MASTOperations.add_core_moarop_mapping('shift', 'shift_o');
QAST::MASTOperations.add_core_moarop_mapping('shift_i', 'shift_i');
QAST::MASTOperations.add_core_moarop_mapping('shift_n', 'shift_n');
QAST::MASTOperations.add_core_moarop_mapping('shift_s', 'shift_s');
QAST::MASTOperations.add_core_moarop_mapping('splice', 'splice', 0);
QAST::MASTOperations.add_core_moarop_mapping('isint', 'isint', :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('isnum', 'isnum', :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('isstr', 'isstr', :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('islist', 'islist', :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('ishash', 'ishash', :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('iterator', 'iter');
QAST::MASTOperations.add_core_moarop_mapping('iterkey_s', 'iterkey_s');
QAST::MASTOperations.add_core_moarop_mapping('iterval', 'iterval');

# object opcodes
QAST::MASTOperations.add_core_op('null', -> $qastcomp, $op {
    my $want := $*WANT;
    if nqp::isconcrete($want) && $want == $MVM_reg_void {
        MAST::InstructionList.new(nqp::list(), MAST::VOID, $MVM_reg_void);
    }
    else {
        my $il := nqp::list();
        my $res_reg := $*REGALLOC.fresh_register($MVM_reg_obj);
        push_op($il, 'null', $res_reg);
        MAST::InstructionList.new($il, $res_reg, $MVM_reg_obj)
    }
});
QAST::MASTOperations.add_core_moarop_mapping('null_s', 'null_s');
QAST::MASTOperations.add_core_moarop_mapping('what', 'getwhat', :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('how', 'gethow', :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('who', 'getwho', :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('where', 'getwhere', :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('objectid', 'objectid', :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('findmethod', 'findmeth_s', :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('setwho', 'setwho');
QAST::MASTOperations.add_core_moarop_mapping('rebless', 'rebless', :decont(0, 1));
QAST::MASTOperations.add_core_moarop_mapping('knowhow', 'knowhow');
QAST::MASTOperations.add_core_moarop_mapping('knowhowattr', 'knowhowattr');
QAST::MASTOperations.add_core_moarop_mapping('bootint', 'bootint');
QAST::MASTOperations.add_core_moarop_mapping('bootnum', 'bootnum');
QAST::MASTOperations.add_core_moarop_mapping('bootstr', 'bootstr');
QAST::MASTOperations.add_core_moarop_mapping('bootarray', 'bootarray');
QAST::MASTOperations.add_core_moarop_mapping('bootintarray', 'bootintarray');
QAST::MASTOperations.add_core_moarop_mapping('bootnumarray', 'bootnumarray');
QAST::MASTOperations.add_core_moarop_mapping('bootstrarray', 'bootstrarray');
QAST::MASTOperations.add_core_moarop_mapping('boothash', 'boothash');
QAST::MASTOperations.add_core_moarop_mapping('hlllist', 'hlllist');
QAST::MASTOperations.add_core_moarop_mapping('hllhash', 'hllhash');
QAST::MASTOperations.add_core_moarop_mapping('create', 'create');
QAST::MASTOperations.add_core_moarop_mapping('clone', 'clone', :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('isconcrete', 'isconcrete', :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('iscont', 'iscont');
QAST::MASTOperations.add_core_moarop_mapping('iscont_i', 'iscont_i');
QAST::MASTOperations.add_core_moarop_mapping('iscont_n', 'iscont_n');
QAST::MASTOperations.add_core_moarop_mapping('iscont_s', 'iscont_s');
QAST::MASTOperations.add_core_moarop_mapping('isrwcont', 'isrwcont');
QAST::MASTOperations.add_core_moarop_mapping('decont', 'decont');
QAST::MASTOperations.add_core_moarop_mapping('decont_i', 'decont_i');
QAST::MASTOperations.add_core_moarop_mapping('decont_n', 'decont_n');
QAST::MASTOperations.add_core_moarop_mapping('decont_s', 'decont_s');
QAST::MASTOperations.add_core_moarop_mapping('isnull', 'isnull');
QAST::MASTOperations.add_core_moarop_mapping('isnull_s', 'isnull_s');
QAST::MASTOperations.add_core_moarop_mapping('istrue', 'istrue', :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('isfalse', 'isfalse', :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('istype', 'istype', :decont(0, 1));
QAST::MASTOperations.add_core_moarop_mapping('eqaddr', 'eqaddr');
QAST::MASTOperations.add_core_moarop_mapping('attrinited', 'attrinited', :decont(1));

sub add_bindattr_op($nqpop, $hintedop, $namedop, $want) {
    QAST::MASTOperations.add_core_op($nqpop, -> $qastcomp, $op {
        my $regalloc := $*REGALLOC;
        my $val_mast := $qastcomp.as_mast( :$want, $op[3] );
        my $obj_mast := $qastcomp.as_mast( :want($MVM_reg_obj), $op[0] );
        my $type_mast := $qastcomp.as_mast( :want($MVM_reg_obj), $op[1] );
        my int $hint := -1;
        my @ins;
        push_ilist(@ins, $val_mast);
        push_ilist(@ins, $obj_mast);
        push_ilist(@ins, $type_mast);
        push_op(@ins, 'decont', $type_mast.result_reg, $type_mast.result_reg);
        if nqp::istype($op[2], QAST::SVal) {
            if nqp::istype($op[1], QAST::WVal) {
                $hint := nqp::hintfor($op[1].value, $op[2].value);
            }
            push_op(@ins, $hintedop, $obj_mast.result_reg, $type_mast.result_reg,
                MAST::SVal.new( :value($op[2].value) ),
                $val_mast.result_reg, MAST::IVal.new( :value($hint) ));
        } else {
            my $name_mast := $qastcomp.as_mast( :want($MVM_reg_str), $op[2] );
            push_ilist(@ins, $name_mast);
            push_op(@ins, $namedop, $obj_mast.result_reg, $type_mast.result_reg,
                $name_mast.result_reg, $val_mast.result_reg);
            $regalloc.release_register($name_mast.result_reg, $MVM_reg_str);
        }
        $regalloc.release_register($obj_mast.result_reg, $MVM_reg_obj);
        $regalloc.release_register($type_mast.result_reg, $MVM_reg_obj);
        MAST::InstructionList.new(@ins, $val_mast.result_reg, $want)
    })
}

add_bindattr_op('bindattr',   'bindattr_o', 'bindattrs_o', $MVM_reg_obj);
add_bindattr_op('bindattr_i', 'bindattr_i', 'bindattrs_i', $MVM_reg_int64);
add_bindattr_op('bindattr_n', 'bindattr_n', 'bindattrs_n', $MVM_reg_num64);
add_bindattr_op('bindattr_s', 'bindattr_s', 'bindattrs_s', $MVM_reg_str);

sub add_getattr_op($nqpop, $hintedop, $namedop, $want) {
    QAST::MASTOperations.add_core_op($nqpop, -> $qastcomp, $op {
        my $regalloc := $*REGALLOC;
        my $obj_mast := $qastcomp.as_mast( :want($MVM_reg_obj), $op[0] );
        my $type_mast := $qastcomp.as_mast( :want($MVM_reg_obj), $op[1] );
        my int $hint := -1;
        my @ins;
        push_ilist(@ins, $obj_mast);
        push_ilist(@ins, $type_mast);
        my $res_reg := $regalloc.fresh_register($want);
        push_op(@ins, 'decont', $type_mast.result_reg, $type_mast.result_reg);
        if nqp::istype($op[2], QAST::SVal) {
            if nqp::istype($op[1], QAST::WVal) {
                $hint := nqp::hintfor($op[1].value, $op[2].value);
            }
            push_op(@ins, $hintedop, $res_reg, $obj_mast.result_reg, $type_mast.result_reg,
                MAST::SVal.new( :value($op[2].value) ), MAST::IVal.new( :value($hint) ));
        } else {
            my $name_mast := $qastcomp.as_mast( :want($MVM_reg_str), $op[2] );
            push_ilist(@ins, $name_mast);
            push_op(@ins, $namedop, $res_reg, $obj_mast.result_reg, $type_mast.result_reg,
                $name_mast.result_reg);
            $regalloc.release_register($name_mast.result_reg, $MVM_reg_str);
        }
        $regalloc.release_register($obj_mast.result_reg, $MVM_reg_obj);
        $regalloc.release_register($type_mast.result_reg, $MVM_reg_obj);
        MAST::InstructionList.new(@ins, $res_reg, $want)
    })
}

add_getattr_op('getattr',   'getattr_o', 'getattrs_o', $MVM_reg_obj);
add_getattr_op('getattr_i', 'getattr_i', 'getattrs_i', $MVM_reg_int64);
add_getattr_op('getattr_n', 'getattr_n', 'getattrs_n', $MVM_reg_num64);
add_getattr_op('getattr_s', 'getattr_s', 'getattrs_s', $MVM_reg_str);

add_getattr_op('getattrref_i', 'getattrref_i', 'getattrsref_i', $MVM_reg_obj);
add_getattr_op('getattrref_n', 'getattrref_n', 'getattrsref_n', $MVM_reg_obj);
add_getattr_op('getattrref_s', 'getattrref_s', 'getattrsref_s', $MVM_reg_obj);

QAST::MASTOperations.add_core_moarop_mapping('hintfor', 'hintfor');
QAST::MASTOperations.add_core_moarop_mapping('unbox_i', 'unbox_i', :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('unbox_n', 'unbox_n', :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('unbox_s', 'unbox_s', :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('unbox_u', 'unbox_u', :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('box_i', 'box_i');
QAST::MASTOperations.add_core_moarop_mapping('box_n', 'box_n');
QAST::MASTOperations.add_core_moarop_mapping('box_s', 'box_s');
QAST::MASTOperations.add_core_moarop_mapping('box_u', 'box_u');
QAST::MASTOperations.add_core_moarop_mapping('can', 'can_s', :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('reprname', 'reprname', :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('newtype', 'newtype', :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('composetype', 'composetype');
QAST::MASTOperations.add_core_moarop_mapping('setboolspec', 'setboolspec', 0, :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('setmethcache', 'setmethcache', 0, :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('setmethcacheauth', 'setmethcacheauth', 0, :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('settypecache', 'settypecache', 0, :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('settypecheckmode', 'settypecheckmode', 0, :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('settypefinalize', 'settypefinalize', 0, :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('isinvokable', 'isinvokable');
QAST::MASTOperations.add_core_moarop_mapping('setinvokespec', 'setinvokespec', 0, :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('setmultispec', 'setmultispec', 0, :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('setcontspec', 'setcontspec', 0, :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('assign', 'assign', 0, :decont(1));

sub try_get_bind_scope($var) {
    if nqp::istype($var, QAST::Var) {
        my str $scope := $var.scope;
        if $scope eq 'attributeref' {
            return 'attribute';
        }
        elsif $scope eq 'lexicalref' {
            # Make sure we've got the lexical itself in scope to bind to.
            my $lex;
            my $lexref;
            my $outer := 0;
            my $block := $*BLOCK;
            my $name  := $var.name;
            while nqp::istype($block, BlockInfo) {
                last if $block.qast.ann('DYN_COMP_WRAPPER');
                $lex := $block.lexical($name);
                last if $lex;
                last if $block.lexicalref($name);
                $block := $block.outer;
                $outer++;
            }
            if $lex {
                return 'lexical';
            }
        }
    }
    ''
}
sub add_native_assign_op($op_name, $kind) {
    QAST::MASTOperations.add_core_op($op_name, -> $qastcomp, $op {
        my @operands := $op.list;
        unless +@operands == 2 {
            nqp::die($op ~ ' op requires two arguments');
        }
        my $target := @operands[0];
        if try_get_bind_scope($target) -> $bind_scope {
            # Can lower it to a bind instead.
            $op.op('bind');
            $target.scope($bind_scope);
            $qastcomp.as_mast($op)
        }
        else {
            # Really need to emit an assign.
            my $regalloc := $*REGALLOC;
            my $target_mast := $qastcomp.as_mast( :want($MVM_reg_obj), $op[0] );
            my $value_mast  := $qastcomp.as_mast( :want($kind), $op[1] );
            my @ins;
            push_ilist(@ins, $target_mast);
            push_ilist(@ins, $value_mast);
            push_op(@ins, $op_name, $target_mast.result_reg, $value_mast.result_reg);
            $regalloc.release_register($value_mast.result_reg, $kind);
            MAST::InstructionList.new(@ins, $target_mast.result_reg, $MVM_reg_obj)
        }
    })
}
add_native_assign_op('assign_i', $MVM_reg_int64);
add_native_assign_op('assign_n', $MVM_reg_num64);
add_native_assign_op('assign_s', $MVM_reg_str);

QAST::MASTOperations.add_core_moarop_mapping('assignunchecked', 'assignunchecked', 0, :decont(1));
QAST::MASTOperations.add_core_moarop_mapping('setparameterizer', 'setparameterizer', 0, :decont(0, 1));
QAST::MASTOperations.add_core_moarop_mapping('parameterizetype', 'parameterizetype', :decont(0, 1));
QAST::MASTOperations.add_core_moarop_mapping('typeparameterized', 'typeparameterized', :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('typeparameters', 'typeparameters', :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('typeparameterat', 'typeparameterat', :decont(0));

# defined - overridden by HLL, but by default same as .DEFINITE.
QAST::MASTOperations.add_core_moarop_mapping('defined', 'isconcrete', :decont(0));

# lexical related opcodes
QAST::MASTOperations.add_core_moarop_mapping('getlex', 'getlex_no');
QAST::MASTOperations.add_core_moarop_mapping('getlex_i', 'getlex_ni');
QAST::MASTOperations.add_core_moarop_mapping('getlex_n', 'getlex_nn');
QAST::MASTOperations.add_core_moarop_mapping('getlex_s', 'getlex_ns');
QAST::MASTOperations.add_core_moarop_mapping('getlexref_i', 'getlexref_ni');
QAST::MASTOperations.add_core_moarop_mapping('getlexref_n', 'getlexref_nn');
QAST::MASTOperations.add_core_moarop_mapping('getlexref_s', 'getlexref_ns');
QAST::MASTOperations.add_core_moarop_mapping('bindlex', 'bindlex_no', 1);
QAST::MASTOperations.add_core_moarop_mapping('bindlex_i', 'bindlex_ni', 1);
QAST::MASTOperations.add_core_moarop_mapping('bindlex_n', 'bindlex_nn', 1);
QAST::MASTOperations.add_core_moarop_mapping('bindlex_s', 'bindlex_ns', 1);
QAST::MASTOperations.add_core_moarop_mapping('getlexdyn', 'getdynlex');
QAST::MASTOperations.add_core_moarop_mapping('bindlexdyn', 'binddynlex');
QAST::MASTOperations.add_core_moarop_mapping('getlexouter', 'getlexouter');
QAST::MASTOperations.add_core_moarop_mapping('getlexrel', 'getlexrel');
QAST::MASTOperations.add_core_moarop_mapping('getlexreldyn', 'getlexreldyn');
QAST::MASTOperations.add_core_moarop_mapping('getlexrelcaller', 'getlexrelcaller');
QAST::MASTOperations.add_core_moarop_mapping('getlexcaller', 'getlexcaller');
QAST::MASTOperations.add_core_op('locallifetime', -> $qastcomp, $op {
    # TODO: take advantage of this info for code-gen, if possible.
    $qastcomp.as_mast($op[0], :want($*WANT))
});

# code object related opcodes
# XXX explicit takeclosure will go away under new model; for now, no-op it.
QAST::MASTOperations.add_core_op('takeclosure', -> $qastcomp, $op {
    unless +@($op) == 1 {
        nqp::die('takeclosure op requires one argument');
    }
    $qastcomp.as_mast($op[0])
});
QAST::MASTOperations.add_core_moarop_mapping('getcodeobj', 'getcodeobj');
QAST::MASTOperations.add_core_moarop_mapping('setcodeobj', 'setcodeobj', 0);
QAST::MASTOperations.add_core_moarop_mapping('getcodename', 'getcodename');
QAST::MASTOperations.add_core_moarop_mapping('setcodename', 'setcodename', 0);
QAST::MASTOperations.add_core_moarop_mapping('forceouterctx', 'forceouterctx', 0);
QAST::MASTOperations.add_core_moarop_mapping('setdispatcher', 'setdispatcher', 0);
QAST::MASTOperations.add_core_op('takedispatcher', -> $qastcomp, $op {
    my $regalloc := $*REGALLOC;
    unless nqp::istype($op[0], QAST::SVal) {
        nqp::die("takedispatcher must have a single QAST::SVal child");
    }
    my @ops;
    my $disp_reg   := $regalloc.fresh_register($MVM_reg_obj);
    my $isnull_reg := $regalloc.fresh_register($MVM_reg_int64);
    my $done_lbl   := MAST::Label.new();
    push_op(@ops, 'takedispatcher', $disp_reg);
    push_op(@ops, 'isnull', $isnull_reg, $disp_reg);
    push_op(@ops, 'if_i', $isnull_reg, $done_lbl);
    if $*BLOCK.lexical($op[0].value) -> $lex {
        push_op(@ops, 'bindlex', $lex, $disp_reg);
    }
    nqp::push(@ops, $done_lbl);
    $regalloc.release_register($disp_reg, $MVM_reg_obj);
    $regalloc.release_register($isnull_reg, $MVM_reg_int64);
    MAST::InstructionList.new(@ops, $MVM_reg_void, MAST::VOID)
});
QAST::MASTOperations.add_core_moarop_mapping('cleardispatcher', 'takedispatcher');
QAST::MASTOperations.add_core_moarop_mapping('freshcoderef', 'freshcoderef');
QAST::MASTOperations.add_core_moarop_mapping('iscoderef', 'iscoderef');
QAST::MASTOperations.add_core_moarop_mapping('markcodestatic', 'markcodestatic');
QAST::MASTOperations.add_core_moarop_mapping('markcodestub', 'markcodestub');
QAST::MASTOperations.add_core_moarop_mapping('getstaticcode', 'getstaticcode');
QAST::MASTOperations.add_core_moarop_mapping('getcodecuid', 'getcodecuid');

# language/compiler ops
QAST::MASTOperations.add_core_moarop_mapping('getcomp', 'getcomp');
QAST::MASTOperations.add_core_moarop_mapping('bindcomp', 'bindcomp');
QAST::MASTOperations.add_core_moarop_mapping('gethllsym', 'gethllsym');
QAST::MASTOperations.add_core_moarop_mapping('bindhllsym', 'bindhllsym', 2);
QAST::MASTOperations.add_core_moarop_mapping('getcurhllsym', 'getcurhllsym');
QAST::MASTOperations.add_core_moarop_mapping('bindcurhllsym', 'bindcurhllsym');
QAST::MASTOperations.add_core_moarop_mapping('sethllconfig', 'sethllconfig');
QAST::MASTOperations.add_core_moarop_mapping('loadbytecode', 'loadbytecode');
QAST::MASTOperations.add_core_moarop_mapping('settypehll', 'settypehll', 0);
QAST::MASTOperations.add_core_moarop_mapping('settypehllrole', 'settypehllrole', 0);
QAST::MASTOperations.add_core_moarop_mapping('usecompileehllconfig', 'usecompileehllconfig');
QAST::MASTOperations.add_core_moarop_mapping('usecompilerhllconfig', 'usecompilerhllconfig');
QAST::MASTOperations.add_core_moarop_mapping('hllize', 'hllize');
QAST::MASTOperations.add_core_moarop_mapping('hllizefor', 'hllizefor');

QAST::MASTOperations.add_core_moarop_mapping('setdebugtypename', 'setdebugtypename', 0);

# regex engine related opcodes
QAST::MASTOperations.add_core_moarop_mapping('nfafromstatelist', 'nfafromstatelist');
QAST::MASTOperations.add_core_moarop_mapping('nfarunproto', 'nfarunproto');
QAST::MASTOperations.add_core_moarop_mapping('nfarunalt', 'nfarunalt', 0);

# native call ops
QAST::MASTOperations.add_core_moarop_mapping('initnativecall', 'no_op');
QAST::MASTOperations.add_core_moarop_mapping('buildnativecall', 'nativecallbuild', 0);
QAST::MASTOperations.add_core_moarop_mapping('nativecall', 'nativecallinvoke');
QAST::MASTOperations.add_core_op('nativecall', -> $qastcomp, $op {
    proto decont_all(@args) {
        my int $i := 0;
        my int $n := nqp::elems(@args);
        my $obj;
        while $i < $n {
            $obj := nqp::atpos(@args, $i);
            unless nqp::iscont_i($obj) || nqp::iscont_n($obj) || nqp::iscont_s($obj) {
                nqp::bindpos(@args, $i, nqp::can($obj, 'cstr')
                    ?? nqp::decont($obj.cstr())
                    !! nqp::decont($obj));
            }
            $i++;
        }
        @args
    }
    $qastcomp.as_mast(QAST::VM.new(
        :moarop('nativecallinvoke'),
        $op[0], $op[1],
        QAST::Op.new(
            :op('call'),
            QAST::WVal.new( :value(nqp::getcodeobj(&decont_all)) ),
            $op[2]
        )));
});
QAST::MASTOperations.add_core_moarop_mapping('nativecallrefresh', 'nativecallrefresh', 0, :decont(0));
QAST::MASTOperations.add_core_moarop_mapping('nativecallcast', 'nativecallcast');
QAST::MASTOperations.add_core_moarop_mapping('nativecallglobal', 'nativecallglobal');
QAST::MASTOperations.add_core_moarop_mapping('nativecallsizeof', 'nativecallsizeof', :decont(0));

QAST::MASTOperations.add_core_moarop_mapping('getcodelocation', 'getcodelocation', :decont(0));

# process related opcodes
QAST::MASTOperations.add_core_moarop_mapping('exit', 'exit', 0);
QAST::MASTOperations.add_core_moarop_mapping('sleep', 'sleep', 0);
QAST::MASTOperations.add_core_moarop_mapping('getenvhash', 'getenvhash');
QAST::MASTOperations.add_core_moarop_mapping('getpid', 'getpid');
QAST::MASTOperations.add_core_moarop_mapping('shell', 'shell');
QAST::MASTOperations.add_core_moarop_mapping('spawn', 'spawn');
QAST::MASTOperations.add_core_moarop_mapping('gethostname', 'gethostname');
QAST::MASTOperations.add_core_moarop_mapping('syncpipe', 'syncpipe');
QAST::MASTOperations.add_core_moarop_mapping('rand_i', 'rand_i');
QAST::MASTOperations.add_core_moarop_mapping('rand_n', 'randscale_n');
QAST::MASTOperations.add_core_moarop_mapping('srand', 'srand', 0);
QAST::MASTOperations.add_core_moarop_mapping('execname', 'execname');

# thread related opcodes
QAST::MASTOperations.add_core_moarop_mapping('newthread', 'newthread');
QAST::MASTOperations.add_core_moarop_mapping('threadrun', 'threadrun', 0);
QAST::MASTOperations.add_core_moarop_mapping('threadjoin', 'threadjoin', 0);
QAST::MASTOperations.add_core_moarop_mapping('threadid', 'threadid');
QAST::MASTOperations.add_core_moarop_mapping('threadyield', 'threadyield');
QAST::MASTOperations.add_core_moarop_mapping('currentthread', 'currentthread');
QAST::MASTOperations.add_core_moarop_mapping('lock', 'lock', 0);
QAST::MASTOperations.add_core_moarop_mapping('unlock', 'unlock', 0);
QAST::MASTOperations.add_core_moarop_mapping('getlockcondvar', 'getlockcondvar');
QAST::MASTOperations.add_core_moarop_mapping('condwait', 'condwait', 0);
QAST::MASTOperations.add_core_moarop_mapping('condsignalone', 'condsignalone', 0);
QAST::MASTOperations.add_core_moarop_mapping('condsignalall', 'condsignalall', 0);
QAST::MASTOperations.add_core_moarop_mapping('semacquire', 'semacquire');
QAST::MASTOperations.add_core_moarop_mapping('semtryacquire', 'semtryacquire');
QAST::MASTOperations.add_core_moarop_mapping('semrelease', 'semrelease');
QAST::MASTOperations.add_core_moarop_mapping('queuepoll', 'queuepoll');

# asynchrony related ops
QAST::MASTOperations.add_core_moarop_mapping('timer', 'timer');
QAST::MASTOperations.add_core_moarop_mapping('cancel', 'cancel', 0);
QAST::MASTOperations.add_core_moarop_mapping('signal', 'signal');
QAST::MASTOperations.add_core_moarop_mapping('watchfile', 'watchfile');
QAST::MASTOperations.add_core_moarop_mapping('asyncconnect', 'asyncconnect');
QAST::MASTOperations.add_core_moarop_mapping('asynclisten', 'asynclisten');
QAST::MASTOperations.add_core_moarop_mapping('asyncudp', 'asyncudp');
QAST::MASTOperations.add_core_moarop_mapping('asyncwritestr', 'asyncwritestr');
QAST::MASTOperations.add_core_moarop_mapping('asyncwritebytes', 'asyncwritebytes');
QAST::MASTOperations.add_core_moarop_mapping('asyncwritestrto', 'asyncwritestrto');
QAST::MASTOperations.add_core_moarop_mapping('asyncwritebytesto', 'asyncwritebytesto');
QAST::MASTOperations.add_core_moarop_mapping('asyncreadchars', 'asyncreadchars');
QAST::MASTOperations.add_core_moarop_mapping('asyncreadbytes', 'asyncreadbytes');
QAST::MASTOperations.add_core_moarop_mapping('spawnprocasync', 'spawnprocasync');
QAST::MASTOperations.add_core_moarop_mapping('killprocasync', 'killprocasync', 1);

# MoarVM-specific compilation ops
QAST::MASTOperations.add_core_moarop_mapping('masttofile', 'masttofile', 2);
QAST::MASTOperations.add_core_moarop_mapping('masttocu', 'masttocu');
QAST::MASTOperations.add_core_moarop_mapping('iscompunit', 'iscompunit');
QAST::MASTOperations.add_core_moarop_mapping('compunitmainline', 'compunitmainline');
QAST::MASTOperations.add_core_moarop_mapping('compunitcodes', 'compunitcodes');
QAST::MASTOperations.add_core_moarop_mapping('backendconfig', 'backendconfig');

# MoarVM-specific (though matching NQP JVM API) continuation ops.
QAST::MASTOperations.add_core_moarop_mapping('continuationclone', 'continuationclone');
QAST::MASTOperations.add_core_moarop_mapping('continuationreset', 'continuationreset');
QAST::MASTOperations.add_core_moarop_mapping('continuationcontrol', 'continuationcontrol');
QAST::MASTOperations.add_core_moarop_mapping('continuationinvoke', 'continuationinvoke');

# MoarVM-specific profiling ops.
QAST::MASTOperations.add_core_moarop_mapping('mvmstartprofile', 'startprofile', 0);
QAST::MASTOperations.add_core_moarop_mapping('mvmendprofile', 'endprofile');

# MoarVM-specific GC ops
QAST::MASTOperations.add_core_moarop_mapping('force_gc', 'force_gc');

sub resolve_condition_op($kind, $negated) {
    return $negated ??
        $kind == $MVM_reg_int64 ?? 'unless_i' !!
        $kind == $MVM_reg_num64 ?? 'unless_n' !!
        $kind == $MVM_reg_str   ?? 'unless_s0' !!
        $kind == $MVM_reg_obj   ?? 'unless_o' !!
        nqp::die("unhandled kind $kind")
     !! $kind == $MVM_reg_int64 ?? 'if_i' !!
        $kind == $MVM_reg_num64 ?? 'if_n' !!
        $kind == $MVM_reg_str   ?? 'if_s0' !!
        $kind == $MVM_reg_obj   ?? 'if_o' !!
        nqp::die("unhandled kind $kind")
}

sub push_op(@dest, str $op, *@args) {
    nqp::push(@dest, MAST::Op.new_with_operand_array( :$op, @args ));
}

sub push_ilist(@dest, $src) is export {
    nqp::splice(@dest, $src.instructions, +@dest, 0);
}

# vim: ft=perl6 expandtab sw=4
# From src/vm/moar/QAST/QASTCompilerMAST.nqp

# Per-compilation instance of the MAST compiler, holding state and driving the
# compilation.

my class MASTCompilerInstance {
    # The HLL that we're compiling.
    has $!hll;

    # The MAST compilation unit we're compiling it into.
    has $!mast_compunit;

    # MAST frames lookup hash.
    has %!mast_frames;

    # The filename we're compiling.
    has $!file;

    # The serialization context of the code we're compiling, if we have one.
    has $!sc;

    # The most recent op we tried to compile, for error reporting.
    has $!last_op;

    # This uses a very simple scheme. Write registers are assumed
    # to be write-once, read-once.  Therefore, if a QAST control
    # structure wants to reuse the intermediate result of an
    # expression, it must `set` the result to other registers before
    # using the result as an arg to another op.
    my class RegAlloc {
        has $!frame;
        has @!objs;
        has @!int64s;
        has @!int32s;
        has @!int16s;
        has @!int8s;
        has @!num64s;
        has @!num32s;
        has @!strs;
        has @!uint64s;
        has @!uint32s;
        has @!uint16s;
        has @!uint8s;
        has %!released_indexes;

        method new($frame) {
            my $obj := nqp::create(self);
            nqp::bindattr($obj, RegAlloc, '$!frame', $frame);
            nqp::bindattr($obj, RegAlloc, '@!objs', []);
            nqp::bindattr($obj, RegAlloc, '@!int64s', []);
            nqp::bindattr($obj, RegAlloc, '@!int32s', []);
            nqp::bindattr($obj, RegAlloc, '@!int16s', []);
            nqp::bindattr($obj, RegAlloc, '@!int8s', []);
            nqp::bindattr($obj, RegAlloc, '@!num64s', []);
            nqp::bindattr($obj, RegAlloc, '@!num32s', []);
            nqp::bindattr($obj, RegAlloc, '@!strs', []);
            nqp::bindattr($obj, RegAlloc, '@!uint64s', []);
            nqp::bindattr($obj, RegAlloc, '@!uint32s', []);
            nqp::bindattr($obj, RegAlloc, '@!uint16s', []);
            nqp::bindattr($obj, RegAlloc, '@!uint8s', []);
            nqp::bindattr($obj, RegAlloc, '%!released_indexes', {});
            $obj
        }

        method fresh_i() { self.fresh_register($MVM_reg_int64) }
        method fresh_n() { self.fresh_register($MVM_reg_num64) }
        method fresh_s() { self.fresh_register($MVM_reg_str) }
        method fresh_o() { self.fresh_register($MVM_reg_obj) }

        # QAST::Vars need entirely new MAST::Locals all to themselves,
        # so a Local can't be a non-Var for the first half of a block and
        # then a Var the second half, but then control returns to the first half
        method fresh_register($kind, $new = 0) {
            my @arr; my $type;
            # set $new to 1 here if you suspect a problem with the allocator,
            # or if you suspect a register is being double-released somewhere.
            # $new := 1;
               if $kind == $MVM_reg_int64  { @arr := @!int64s; $type := int }
            elsif $kind == $MVM_reg_num64  { @arr := @!num64s; $type := num }
            elsif $kind == $MVM_reg_str    { @arr := @!strs; $type := str }
            elsif $kind == $MVM_reg_obj    { @arr := @!objs; $type := NQPMu }
            elsif $kind == $MVM_reg_int32  { @arr := @!int32s; $type := int32 }
            elsif $kind == $MVM_reg_int16  { @arr := @!int16s; $type := int16 }
            elsif $kind == $MVM_reg_int8   { @arr := @!int8s; $type := int8 }
            elsif $kind == $MVM_reg_num32  { @arr := @!num32s; $type := num32 }
            elsif $kind == $MVM_reg_uint64 { @arr := @!uint64s; $type := uint64 }
            elsif $kind == $MVM_reg_uint32 { @arr := @!uint32s; $type := uint32 }
            elsif $kind == $MVM_reg_uint16 { @arr := @!uint16s; $type := uint16 }
            elsif $kind == $MVM_reg_uint8  { @arr := @!uint8s; $type := uint8 }
            else { nqp::die("unhandled reg kind $kind") }

            my $reg;
            if nqp::elems(@arr) && !$new {
                $reg := nqp::pop(@arr);
                nqp::deletekey(%!released_indexes, $reg.index);
            }
            else {
                $reg := MAST::Local.new(:index($!frame.add_local($type)));
            }
            $reg
        }

        method release_i($reg) { self.release_register($reg, $MVM_reg_int64) }
        method release_n($reg) { self.release_register($reg, $MVM_reg_num64) }
        method release_s($reg) { self.release_register($reg, $MVM_reg_str) }
        method release_o($reg) { self.release_register($reg, $MVM_reg_obj) }

        method release_register($reg, $kind, $force = 0) {
            return 1 if $kind == $MVM_reg_void || !$force && $*BLOCK.is_var($reg)
                || nqp::existskey(%!released_indexes, $reg.index);
            %!released_indexes{$reg.index} := 1;
            return nqp::push(@!int64s, $reg) if $kind == $MVM_reg_int64;
            return nqp::push(@!num64s, $reg) if $kind == $MVM_reg_num64;
            return nqp::push(@!strs, $reg) if $kind == $MVM_reg_str;
            return nqp::push(@!objs, $reg) if $kind == $MVM_reg_obj;
            return nqp::push(@!int32s, $reg) if $kind == $MVM_reg_int32;
            return nqp::push(@!int16s, $reg) if $kind == $MVM_reg_int16;
            return nqp::push(@!int8s, $reg) if $kind == $MVM_reg_int8;
            return nqp::push(@!num32s, $reg) if $kind == $MVM_reg_num32;
            return nqp::push(@!uint64s, $reg) if $kind == $MVM_reg_uint64;
            return nqp::push(@!uint32s, $reg) if $kind == $MVM_reg_uint32;
            return nqp::push(@!uint16s, $reg) if $kind == $MVM_reg_uint16;
            return nqp::push(@!uint8s, $reg) if $kind == $MVM_reg_uint8;
            nqp::die("unhandled reg kind $kind");
        }
    }

    # Holds information about the QAST::Block we're currently compiling.
    my class BlockInfo {
        has $!qast;                 # The QAST::Block
        has $!outer;                # Outer block's BlockInfo
        has %!local_names_by_index; # Locals' names by their indexes
        has %!locals;               # Mapping of local names to locals
        has %!local_kinds;          # Mapping of local registers to kinds
        has %!localrefs;            # Mapping of localref names to locals
        has %!localref_kinds;       # Mapping of localref registers to kinds
        has %!lexicals;             # Mapping of lexical names to lexicals
        has %!lexical_kinds;        # Mapping of lexical names to kinds
        has %!lexical_params;       # Mapping of lexical param names to their initial result reg
        has %!lexicalrefs;          # Mapping of lexical reference names to lexicals
        has %!lexicalref_kinds;     # Mapping of lexical reference names to kinds
        has int $!param_idx;        # Current lexical parameter index
        has $!compiler;             # The QAST::MASTCompiler
        has @!params;               # List of QAST::Var param nodes
        has $!return_kind;          # Kind of return, tracked while emitting
        has @!captured_inners;      # List of CUIDs of blocks we statically capture
        has %!cloned_inners;        # Mapping of CUIDs of blocks we clone to register with the clone
        has @!contvar_locals;       # Locals with a contvar that needs allocating.

        method new($qast, $outer, $compiler) {
            my $obj := nqp::create(self);
            $obj.BUILD($qast, $outer, $compiler);
            $obj
        }

        method BUILD($qast, $outer, $compiler) {
            $!qast := $qast;
            $!outer := $outer;
            $!compiler := $compiler;
            %!local_names_by_index := nqp::hash();
            %!locals := nqp::hash();
            %!local_kinds := nqp::hash();
            %!localrefs := nqp::hash();
            %!localref_kinds := nqp::hash();
            %!lexicals := nqp::hash();
            %!lexical_kinds := nqp::hash();
            %!lexical_params := nqp::hash();
            %!lexicalrefs := nqp::hash();
            %!lexicalref_kinds := nqp::hash();
            @!params := nqp::list();
            @!captured_inners := nqp::list();
            %!cloned_inners := nqp::hash();
            @!contvar_locals := nqp::list();
        }

        method add_param($var) {
            @!params[+@!params] := $var;
            if $var.scope eq 'local' {
                self.register_local($var);
            }
            else {
                my $res_kind := self.add_lexical($var);
                my $res_reg := $*REGALLOC.fresh_register($res_kind);
                %!lexical_params{$var.name} := $res_reg;
                [$res_kind, $res_reg]
            }
        }

        method add_lexical($var, :$is_static, :$is_cont, :$is_state) {
            my $mf    := $*MAST_FRAME;
            my $type  := $var.returns;
            my $kind  := $!compiler.type_to_register_kind($type);
            my $index := $mf.add_lexical($type, $var.name);
            self.register_lexical($var.name, $index, $kind);
            if $is_static || $is_cont || $is_state {
                my int $flags := $is_static ?? 0 !!
                                 $is_cont   ?? 1 !! 2;
                my $val       := $var.value;
                my $sc        := nqp::getobjsc($val);
                if nqp::isnull($sc) {
                    nqp::die("Object of type " ~ $val.HOW.name($val) ~
                        " in QAST::Var value, but not in SC");
                }
                my int $idx    := nqp::scgetobjidx($sc, $val);
                my int $sc_idx := $!compiler.mast_compunit.sc_idx($sc);
                $mf.add_static_lex_value($index, $flags, $sc_idx, $idx);
            }
            $kind;
        }

        method register_lexical(str $name, $index, $kind) {
            if nqp::existskey(%!lexicals, $name) || nqp::existskey(%!lexicalrefs, $name) {
                nqp::die("Lexical '$name' already declared");
            }
            my $lex := MAST::Lexical.new( :index($index), :frames_out(0) );
            %!lexicals{$name} := $lex;
            %!lexical_kinds{$name} := $kind;
            $lex;
        }

        method add_lexicalref($var) {
            my $mf   := $*MAST_FRAME;
            my $type := $var.returns;
            my $kind := $!compiler.type_to_register_kind($type);
            unless nqp::objprimspec($type) {
                nqp::die("lexicalref declaration must have a native type");
            }
            my $index := $mf.add_lexical(NQPMu, $var.name);
            self.register_lexicalref($var.name, $index, $kind);
            $MVM_reg_obj
        }

        method register_lexicalref(str $name, $index, $kind) {
            if nqp::existskey(%!lexicals, $name) || nqp::existskey(%!lexicalrefs, $name) {
                nqp::die("Lexical '$name' already declared");
            }
            my $lex := MAST::Lexical.new( :index($index), :frames_out(0) );
            %!lexicalrefs{$name} := $lex;
            %!lexicalref_kinds{$name} := $kind;
            $lex;
        }

        method register_local($var, :$is_cont) {
            my $name := $var.name;
            my $temporary := ?$*INSTMT;
            if nqp::existskey(%!locals, $name) || nqp::existskey(%!localrefs, $name) ||
                    $temporary && nqp::existskey(%*STMTTEMPS, $name) {
                nqp::die("Local (or localref) '$name' already declared");
            }
            my $kind := $!compiler.type_to_register_kind($var.returns);
            %!local_kinds{$name} := $kind;
            # pass a 1 meaning get a Totally New MAST::Local
            my $local := $*REGALLOC.fresh_register($kind, !$temporary);
            %!locals{$name} := $local;
            %!local_names_by_index{$local.index} := $name;
            if $temporary {
                %*STMTTEMPS{$name} := $local;
            }
            if $is_cont {
                nqp::push(@!contvar_locals, $var);
            }
            $local;
        }

        method register_localref($var) {
            my $name := $var.name;
            my $temporary := ?$*INSTMT;
            if nqp::existskey(%!localrefs, $name) || nqp::existskey(%!locals, $name) ||
                    $temporary && nqp::existskey(%*STMTTEMPS, $name) {
                nqp::die("Localref (or local) '$name' already declared");
            }
            my $kind := $!compiler.type_to_register_kind($var.returns);
            %!localref_kinds{$name} := $kind;
            # pass a 1 meaning get a Totally New MAST::Local
            my $localref := $*REGALLOC.fresh_register($MVM_reg_obj, !$temporary);
            %!localrefs{$name} := $localref;
            %!local_names_by_index{$localref.index} := $name;
            if $temporary {
                %*STMTTEMPS{$name} := $localref;
            }
            $localref;
        }

        # returns whether a MAST::Local is a variable in this block
        method is_var($local) {
            nqp::existskey(%!local_names_by_index, $local.index)
        }

        method return_kind(*@value) {
            if @value {
                nqp::die("inconsistent immediate block return type")
                    if ($!qast.blocktype eq 'immediate' || $!qast.blocktype eq 'immediate_static') &&
                        nqp::defined($!return_kind) && @value[0] != $!return_kind;
                $!return_kind := @value[0];
            }
            $!return_kind
        }

        method release_temp($name) {
            my $local := %!locals{$name};
            my $index := $local.index();
            my $kind := %!local_kinds{$name};
            $*REGALLOC.release_register($local, $kind, 1);
            nqp::deletekey(%!local_names_by_index, $index);
            nqp::deletekey(%!locals, $name);
            nqp::deletekey(%!local_kinds, $name);
        }

        method qast() { $!qast }
        method outer() { $!outer }
        method lexical($name) { %!lexicals{$name} }
        method lexicals() { %!lexicals }
        method lexicalref($name) { %!lexicalrefs{$name} }
        method lexicalrefs() { %!lexicalrefs }
        method local($name) { %!locals{$name} }
        method local_kind($name) { %!local_kinds{$name} }
        method localref($name) { %!localrefs{$name} }
        method localref_kind($name) { %!localref_kinds{$name} }
        method lexical_kind($name) { %!lexical_kinds{$name} }
        method lexical_kinds() { %!lexical_kinds }
        method lexicalref_kind($name) { %!lexicalref_kinds{$name} }
        method lexicalref_kinds() { %!lexicalref_kinds }
        method params() { @!params }
        method lexical_param($name) { %!lexical_params{$name} }

        method resolve_lexical($name) {
            my $block := self;
            my $out := 0;
            while $block {
                my $lex := ($block.lexicals()){$name};
                return MAST::Lexical.new( :index($lex.index), :frames_out($out) ) if $lex;
                $out++;
                $block := $block.outer;
            }
            nqp::die("could not resolve lexical $name");
        }
        
        method capture_inner($block) {
            nqp::push(@!captured_inners, $block.cuid)
        }
        method clone_inner($block) {
            my $cuid    := $block.cuid;
            my $already := %!cloned_inners{$cuid};
            if $already {
                $already
            }
            else {
                my $reg  := $*REGALLOC.fresh_register($MVM_reg_obj, 1);
                %!cloned_inners{$cuid} := $reg;
                %!local_names_by_index{$reg.index} := $cuid;
                $reg
            }
        }
        method captured_inners() { @!captured_inners }
        method cloned_inners() { %!cloned_inners }

        method contvar_locals() { @!contvar_locals }
    }

    method source_for_node($node) {
        my $source := $node.node
                        ?? ~ nqp::escape($node.node.Str)
                        !! '';
        if nqp::chars($source) > 103 {
            $source := nqp::substr($source, 0, 100) ~ '...';
        }
        if nqp::chars($source) {
            $source := qq[ (source text: "$source")];
        }
        $source;
    }

    my int $serno := 0;
    method unique($prefix = '') { $prefix ~ $serno++ }

    method mast_compunit() { $!mast_compunit }
    method mast_frames() { %!mast_frames }
    method sc() { $!sc }

    method to_mast($qast) {
        # Set up compilation state.
        $!hll := '';
        $!mast_compunit := MAST::CompUnit.new();
        %!mast_frames := nqp::hash();
        $!file := nqp::ifnull(nqp::getlexdyn('$?FILES'), "<unknown file>");
        $!sc := NQPMu;

        # Compile, and evaluate to compilation unit.
        self.as_mast($qast);
        #CATCH {
        #    my $err    := $!;
        #    my $source := self.source_for_node($!last_op);
        #    nqp::die("QAST -> MAST failed while compiling op " ~ $!last_op.op ~ "$source: $err");
        #}

        $!mast_compunit
    }

    method coerce($res, $desired) {
        my $got := $res.result_kind;
        if $got != $desired {
            $res.append(self.coercion($res, $desired));
        }
        $res
    }

    # Expects that the value in need of coercing has already been
    # obtained. Produces instructions to coerce it.
    method coercion($res, $desired) {
        my $il := nqp::list();
        my $got := $res.result_kind;
        my $reg := $res.result_reg;
        if $got == $desired {
            # Nothing to do.
        }
        elsif $desired == $MVM_reg_void {
            $reg := MAST::VOID;
        }
        elsif $desired == $MVM_reg_obj {
            # See if we already have full-width native.
            if $got == $MVM_reg_int64 || $got == $MVM_reg_num64 ||
                    $got == $MVM_reg_str || $got == $MVM_reg_void ||
                    $got == $MVM_reg_uint64 {
                return QAST::MASTOperations.box(self, $!hll, $got, $reg);
            }
            elsif $got == $MVM_reg_num32 {
                my $grow := self.coercion($res, $MVM_reg_num64);
                my $box := QAST::MASTOperations.box(self, $!hll, $MVM_reg_num64, 
                    $grow.result_reg);
                $il := $grow.instructions;
                push_ilist($il, $box);
                $reg := $box.result_reg;
            }
            elsif $got == $MVM_reg_int32 || $got == $MVM_reg_int16 || $got == $MVM_reg_int8 {
                my $grow := self.coercion($res, $MVM_reg_int64);
                my $box := QAST::MASTOperations.box(self, $!hll, $MVM_reg_int64, 
                    $grow.result_reg);
                $il := $grow.instructions;
                push_ilist($il, $box);
                $reg := $box.result_reg;
            }
            elsif $got == $MVM_reg_uint32 || $got == $MVM_reg_uint16 || $got == $MVM_reg_uint8 {
                my $grow := self.coercion($res, $MVM_reg_uint64);
                my $box := QAST::MASTOperations.box(self, $!hll, $MVM_reg_uint64, 
                    $grow.result_reg);
                $il := $grow.instructions;
                push_ilist($il, $box);
                $reg := $box.result_reg;
            }
            else {
                nqp::die("Unknown boxing case; got: " ~ $got);
            }
        }
        elsif $got == $MVM_reg_obj {
            # See if we want a full-width native.
            if $desired == $MVM_reg_int64 || $desired == $MVM_reg_num64 ||
                    $desired == $MVM_reg_str || $desired == $MVM_reg_uint64 {
                return QAST::MASTOperations.unbox(self, $!hll, $desired, $reg);
            }
            elsif $desired == $MVM_reg_num32 {
                my $unbox := QAST::MASTOperations.unbox(self, $!hll, $MVM_reg_num64, $reg);
                my $shrink := self.coercion($unbox, $desired);
                $il := $unbox.instructions;
                push_ilist($il, $shrink);
                $reg := $shrink.result_reg;
            }
            elsif $desired == $MVM_reg_int32 || $desired == $MVM_reg_int16 || $desired == $MVM_reg_int8 {
                my $unbox := QAST::MASTOperations.unbox(self, $!hll, $MVM_reg_int64, $reg);
                my $shrink := self.coercion($unbox, $desired);
                $il := $unbox.instructions;
                push_ilist($il, $shrink);
                $reg := $shrink.result_reg;
            }
            elsif $desired == $MVM_reg_uint32 || $desired == $MVM_reg_uint16 || $desired == $MVM_reg_uint8 {
                my $unbox := QAST::MASTOperations.unbox(self, $!hll, $MVM_reg_uint64, $reg);
                my $shrink := self.coercion($unbox, $desired);
                $il := $unbox.instructions;
                push_ilist($il, $shrink);
                $reg := $shrink.result_reg;
            }
            else {
                nqp::die("Unknown unboxing case; desired: " ~ $desired);
            }
        }
        else {
            my $res_reg := $*REGALLOC.fresh_register($desired);
            my $release_type := $got;
            if $desired == $MVM_reg_int64 {
                if $got == $MVM_reg_num64 {
                    push_op($il, 'coerce_ni', $res_reg, $reg);
                }
                elsif $got == $MVM_reg_str {
                    push_op($il, 'coerce_si', $res_reg, $reg);
                }
                elsif $got == $MVM_reg_void {
                    push_op($il, 'const_i64', $res_reg, MAST::IVal.new( :value(0) ));
                }
                elsif $got == $MVM_reg_int32 {
                    push_op($il, 'extend_i32', $res_reg, $reg);
                }
                elsif $got == $MVM_reg_int16 {
                    push_op($il, 'extend_i16', $res_reg, $reg);
                }
                elsif $got == $MVM_reg_int8 {
                    push_op($il, 'extend_i8', $res_reg, $reg);
                }
                elsif $got == $MVM_reg_uint64 {
                    push_op($il, 'coerce_ui', $res_reg, $reg);
                }
                elsif $got == $MVM_reg_uint32 || $got == $MVM_reg_uint16 || $got == $MVM_reg_uint8 {
                    my $uint64 := self.coercion($res, $MVM_reg_uint64);
                    $il := $uint64.instructions;
                    $reg := $uint64.result_reg;
                    $release_type := $uint64.result_kind;
                    push_op($il, 'coerce_ui', $res_reg, $reg);
                }
                else {
                    nqp::die("Unknown coercion case for int; got: "~$got);
                }
            }
            elsif $desired == $MVM_reg_num64 {
                if $got == $MVM_reg_int64 {
                    push_op($il, 'coerce_in', $res_reg, $reg);
                }
                elsif $got == $MVM_reg_str {
                    push_op($il, 'coerce_sn', $res_reg, $reg);
                }
                elsif $got == $MVM_reg_num32 {
                    push_op($il, 'extend_n32', $res_reg, $reg);
                }
                elsif $got == $MVM_reg_void {
                    push_op($il, 'const_n64', $res_reg, MAST::NVal.new( :value(0) ));
                }
                else {
                    nqp::die("Unknown coercion case for num; got: "~$got);
                }
            }
            elsif $desired == $MVM_reg_str {
                if $got == $MVM_reg_int64 {
                    push_op($il, 'coerce_is', $res_reg, $reg);
                }
                elsif $got == $MVM_reg_num64 {
                    push_op($il, 'coerce_ns', $res_reg, $reg);
                }
                elsif $got == $MVM_reg_void {
                    push_op($il, 'const_s', $res_reg, MAST::SVal.new( :value('') ));
                }
                else {
                    nqp::die("Unknown coercion case for str; got: "~$got);
                }
            }
            elsif $desired == $MVM_reg_num32 {
                if $got == $MVM_reg_num64 {
                    push_op($il, 'trunc_n32', $res_reg, $reg);
                }
                else {
                    nqp::die("Unknown coercion case for num32; got: "~$got);
                }
            }
            elsif $desired == $MVM_reg_int32 {
                if $got == $MVM_reg_int64 {
                    push_op($il, 'trunc_i32', $res_reg, $reg);
                }
                else {
                    nqp::die("Unknown coercion case for int32; got: " ~ $got);
                }
            }
            elsif $desired == $MVM_reg_int16 {
                if $got == $MVM_reg_int64 {
                    push_op($il, 'trunc_i16', $res_reg, $reg);
                }
                else {
                    nqp::die("Unknown coercion case for int16; got: " ~ $got);
                }
            }
            elsif $desired == $MVM_reg_int8 {
                if $got == $MVM_reg_int64 {
                    push_op($il, 'trunc_i8', $res_reg, $reg);
                }
                else {
                    nqp::die("Unknown coercion case for int8; got: " ~ $got);
                }
            }
            elsif $desired == $MVM_reg_uint64 {
                if $got == $MVM_reg_uint32 {
                    push_op($il, 'extend_u32', $res_reg, $reg);
                }
                elsif $got == $MVM_reg_uint16 {
                    push_op($il, 'extend_u16', $res_reg, $reg);
                }
                elsif $got == $MVM_reg_uint8 {
                    push_op($il, 'extend_u8', $res_reg, $reg);
                }
                else {
                    unless $got == $MVM_reg_int64 {
                        my $int64 := self.coercion($res, $MVM_reg_int64);
                        $il := $int64.instructions;
                        $reg := $int64.result_reg;
                        $release_type := $int64.result_kind;
                    }
                    push_op($il, 'coerce_iu', $res_reg, $reg);
                }
            }
            elsif $desired == $MVM_reg_uint32 {
                unless $got == $MVM_reg_uint64 {
                    my $uint64 := self.coercion($res, $MVM_reg_uint64);
                    $il := $uint64.instructions;
                    $reg := $uint64.result_reg;
                    $release_type := $uint64.result_kind;
                }
                push_op($il, 'trunc_u32', $res_reg, $reg);
            }
            elsif $desired == $MVM_reg_uint16 {
                unless $got == $MVM_reg_uint64 {
                    my $uint64 := self.coercion($res, $MVM_reg_uint64);
                    $il := $uint64.instructions;
                    $reg := $uint64.result_reg;
                    $release_type := $uint64.result_kind;
                }
                push_op($il, 'trunc_u16', $res_reg, $reg);
            }
            elsif $desired == $MVM_reg_uint8 {
                unless $got == $MVM_reg_uint64 {
                    my $uint64 := self.coercion($res, $MVM_reg_uint64);
                    $il := $uint64.instructions;
                    $reg := $uint64.result_reg;
                    $release_type := $uint64.result_kind;
                }
                push_op($il, 'trunc_u8', $res_reg, $reg);
            }
            else {
                nqp::die("Coercion from type '$got' to '$desired' NYI");
            }
            $*REGALLOC.release_register($reg, $release_type);
            $reg := $res_reg;
        }
        MAST::InstructionList.new($il, $reg, $desired)
    }

    method as_mast($qast, :$want) {
        my $*WANT;
        if nqp::defined($want) {
            $*WANT := $want;
            if nqp::istype($qast, QAST::Want) {
                self.coerce(self.compile_node(want($qast, $want), :$want), $want)
            }
            else {
                self.coerce(self.compile_node($qast, :$want), $want)
            }
        }
        else {
            self.compile_node($qast)
        }
    }

    sub want($node, $type) {
        my @possibles := $node.list;
        my $best      := nqp::atpos(@possibles, 0);
        if $type != $MVM_reg_obj {
            my $char := $type == $MVM_reg_void  ?? 'v' !!
                        $type == $MVM_reg_int64 ?? 'I' !!
                        $type == $MVM_reg_num64 ?? 'N' !!
                        $type == $MVM_reg_str   ?? 'S' !!
                                                   'X';
            my int $i := 1;
            my int $n := nqp::elems(@possibles);
            while $i < $n {
                if nqp::index(nqp::atpos(@possibles, $i), $char) >= 0 {
                    $best := nqp::atpos(@possibles, $i + 1);
                    last;
                }
                $i := $i + 2;
            }
        }
        $best
    }

    my @return_opnames := [
        'return',
        'return_i',
        'return_i',
        'return_i',
        'return_i',
        'return_n',
        'return_n',
        'return_s',
        'return_o'
    ];

    my @type_initials := [
        '', 'i', 'i', 'i', 'i', 'n', 'n', 's', 'o'
    ];

    my @attr_opnames := [
        '',
        'attr_i',
        'attr_i',
        'attr_i',
        'attr_i',
        'attr_n',
        'attr_n',
        'attr_s',
        'attr_o'
    ];

    my @attrref_opnames := [
        '',
        'getattrref_i',
        'getattrref_i',
        'getattrref_i',
        'getattrref_i',
        'getattrref_n',
        'getattrref_n',
        'getattrref_s',
        '', '',  '',  '',  '',  '',  '',  '',  '',
        # XXX Want a getattrref_u in the end
        'getattrref_i',
        'getattrref_i',
        'getattrref_i',
        'getattrref_i'
    ];

    my @kind_to_op_slot := [
        0, 0, 0, 0, 0, 1, 1, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, 4, 4, 4, 4
    ];

    my @param_opnames := [
        'param_rp_i',
        'param_rp_n',
        'param_rp_s',
        'param_rp_o',
        'param_rp_u',
        'param_op_i',
        'param_op_n',
        'param_op_s',
        'param_op_o',
        'param_op_u',
        'param_rn_i',
        'param_rn_n',
        'param_rn_s',
        'param_rn_o',
        'param_rn_u',
        'param_on_i',
        'param_on_n',
        'param_on_s',
        'param_on_o',
        'param_on_u',
        'param_rn2_i',
        'param_rn2_n',
        'param_rn2_s',
        'param_rn2_o',
        'param_rn2_u',
        'param_on2_i',
        'param_on2_n',
        'param_on2_s',
        'param_on2_o',
        'param_on2_u'
    ];

    my @return_types := [ NQPMu, int, int, int, int, num, num, str, NQPMu ];

    method register_kind_to_type($kind) { @return_types[$kind] }

    proto method compile_node($node, :$want) { * }
    
    multi method compile_node(QAST::CompUnit $cu, :$want) {
        # Should have a single child which is the outer block.
        if +@($cu) != 1 || !nqp::istype($cu[0], QAST::Block) {
            nqp::die("QAST::CompUnit should have one child that is a QAST::Block");
        }

        # Set HLL and serialization context.
        if $cu.hll {
            $!hll := $cu.hll;
            $!mast_compunit.hll($!hll);
        }
        if $cu.sc {
            $!sc := $cu.sc;
        }

        # Blocks we've seen while compiling.
        my %*BLOCKS_DONE;

        # Compile the block; make sure $*BLOCK is clear.
        my $*BLOCK;
        self.as_mast($cu[0]);

        # If we are in compilation mode, or have pre-deserialization or
        # post-deserialization tasks, handle those. Overall, the process
        # is to desugar this into simpler QAST nodes, then compile those.
        my $comp_mode := $cu.compilation_mode;
        my @pre_des   := $cu.pre_deserialize;
        my @post_des  := $cu.post_deserialize;
        if $comp_mode || @pre_des || @post_des {
            # Create a block into which we'll install all of the other
            # pieces.
            my $block := QAST::Block.new( :blocktype('raw'), :name('<dependencies+deserialize>') );

            # Add pre-deserialization tasks, each as a QAST::Stmt.
            for @pre_des {
                $block.push(QAST::Stmt.new($_));
            }

            # If we need to do deserialization, emit code for that.
            if $comp_mode {
                $block.push(self.deserialization_code($cu.sc(), $cu.code_ref_blocks(),
                    $cu.repo_conflict_resolver()));
            }

            # Add post-deserialization tasks.
            for @post_des {
                $block.push(QAST::Stmt.new($_));
            }

            # Compile to MAST and register this block as the deserialization
            # handler.
            self.as_mast($block);
            $!mast_compunit.deserialize_frame(%!mast_frames{$block.cuid});
        }

        # Compile and include load-time logic, if any.
        if nqp::defined($cu.load) {
            my $load_block := QAST::Block.new(
                :blocktype('raw'), :name('<load>'),
                $cu.load
            );
            self.as_mast($load_block);
            $!mast_compunit.load_frame(%!mast_frames{$load_block.cuid});
        }

        # Compile and include main-time logic, if any, and wrap it up so that we
        # pass command line arguments.
        if nqp::defined($cu.main) {
            my $main_block := QAST::Block.new(
                :blocktype('raw'), :name('<entry>'),
                QAST::Op.new(
                    :op('call'),
                    QAST::Block.new(
                        :blocktype('declaration'), :name('<main>'),
                        $cu.main
                    ),
                    QAST::VM.new( :moarop('clargs'), :flat(1) )
                ));
            self.as_mast($main_block);
            $!mast_compunit.main_frame(%!mast_frames{$main_block.cuid});
        }
    }

    # this method is a hook point so that we can override serialization when cross-compiling
    method serialize_sc($sc) {
        # Serialize it.
        my $sh := nqp::list_s();
        my str $serialized := nqp::serialize($sc, $sh);

        # Now it's serialized, pop this SC off the compiling SC stack.
        nqp::popcompsc();

        [$serialized, nqp::null()];
    }

    method deserialization_code($sc, @code_ref_blocks, $repo_conf_res) {
        my $sc_tuple := self.serialize_sc($sc);
        my str $serialized := $sc_tuple[0];
        my $sh := $sc_tuple[1];

        # String heap QAST.
        my $sh_ast;

        if nqp::islist($sh) {
            $sh_ast := QAST::Op.new( :op('list_s') );
            my $sh_elems := nqp::elems($sh);
            my $i := 0;
            while $i < $sh_elems {
                $sh_ast.push(nqp::isnull_s(nqp::atpos_s($sh, $i))
                    ?? QAST::Op.new( :op('null_s') )
                    !! QAST::SVal.new( :value(nqp::atpos_s($sh, $i)) ));
                $i := $i + 1;
            }
        }
        else {
            $sh_ast := QAST::Op.new( :op('null') );
        }

        # Code references.
        my $cr_ast := QAST::Op.new( :op('list_b'), |@code_ref_blocks );

        # Handle repossession conflict resolution code, if any.
        if $repo_conf_res {
            $repo_conf_res.push(QAST::Var.new( :name('conflicts'), :scope('local') ));
        }
        else {
            $repo_conf_res := QAST::Op.new(
                :op('die_s'),
                QAST::SVal.new( :value('Repossession conflicts occurred during deserialization') )
            );
        }

        # Overall deserialization QAST.
        QAST::Stmts.new(
            QAST::Op.new(
                :op('bind'),
                QAST::Var.new( :name('cur_sc'), :scope('local'), :decl('var') ),
                QAST::Op.new( :op('createsc'), QAST::SVal.new( :value(nqp::scgethandle($sc)) ) )
            ),
            QAST::Op.new(
                :op('scsetdesc'),
                QAST::Var.new( :name('cur_sc'), :scope('local') ),
                QAST::SVal.new( :value(nqp::scgetdesc($sc)) )
            ),
            QAST::Op.new(
                :op('bind'),
                QAST::Var.new( :name('conflicts'), :scope('local'), :decl('var') ),
                QAST::Op.new( :op('list') )
            ),
            QAST::Op.new(
                :op('deserialize'),
                nqp::isnull_s($serialized)
                    ?? QAST::Op.new( :op('null_s') )
                    !! QAST::SVal.new( :value($serialized) ),
                QAST::Var.new( :name('cur_sc'), :scope('local') ),
                $sh_ast, # XXX I had to leave this in, otherwise the JS backend doesn't build.
                         #     I would love some help figuring out why!
                QAST::Block.new( :blocktype('immediate'), $cr_ast ),
                QAST::Var.new( :name('conflicts'), :scope('local') )
            ),
            QAST::Op.new(
                :op('if'),
                QAST::Op.new(
                    :op('elems'),
                    QAST::Var.new( :name('conflicts'), :scope('local') )
                ),
                $repo_conf_res
            )
        )
    }

    multi method compile_node(QAST::Block $node, :$want) {
        my $cuid := $node.cuid();
        my $block;
        my $outer;
        if %*BLOCKS_DONE{$cuid} -> @already {
            $block := @already[0];
            $outer := @already[1];
        }
        else {
            my $outer_frame := try $*MAST_FRAME;

            # Create an empty frame and add it to the compilation unit.
            my $frame := MAST::Frame.new(
                :name($node.name),
                :cuuid($cuid));

            $!mast_compunit.add_frame($frame);
            try $outer := $*BLOCK;
            $block     := BlockInfo.new($node, (nqp::defined($outer) ?? $outer !! NQPMu), self);
            %*BLOCKS_DONE{$cuid} := [$block, $outer];

            # stash the frame by the block's cuid so other references
            # by this block can find it.
            %!mast_frames{$cuid} := $frame;

            # Set the outer if it exists
            $frame.set_outer($outer_frame)
                if $outer_frame && $outer_frame ~~ MAST::Frame;

            # Set exit handler and thunk flags if needed.
            if $node.has_exit_handler {
                $frame.has_exit_handler(1);
            }
            if $node.is_thunk {
                $frame.is_thunk(1);
            }

            # Set code object, if any.
            my $code_obj := $node.code_object;
            if nqp::isconcrete($code_obj) {
                my $sc := nqp::getobjsc($code_obj);
                if nqp::isnull($sc) {
                    nqp::die("Object of type " ~ $code_obj.HOW.name($code_obj) ~
                        " is QAST::Block code object, but not in SC");
                }
                my int $idx    := nqp::scgetobjidx($sc, $code_obj);
                my int $sc_idx := $!mast_compunit.sc_idx($sc);
                $frame.set_code_object_idxs($sc_idx, $idx);
            }

            # Compile all the substatements.
            my $ins;
            {
                my $*BINDVAL := 0;

                # Create a register allocator for this frame.
                my $*REGALLOC := RegAlloc.new($frame);

                # when we enter a QAST::Stmt, the contextual will be cloned, and the locals of
                # newly declared QAST::Vars of local scope inside the Stmt will be stashed here,
                # so they can be released at the end of the QAST::Stmt in which they were
                # declared.  Inability to declare duplicate names is still enfoced, and types are
                # still enforced.
                my %*STMTTEMPS := nqp::hash();
                my $*INSTMT := 0;

                my $*BLOCK := $block;
                my $*MAST_FRAME := $frame;

                my $*WANT;
                if $node.blocktype eq 'immediate' || $node.blocktype eq 'immediate_static' {
                    $*WANT := $want;
                }
                $ins := self.compile_all_the_stmts(@($node));

                # Ensure we return full-width.
                my $ins_result_kind := $ins.result_kind;
                if $ins_result_kind == $MVM_reg_num32 {
                    $ins := self.coerce($ins, $MVM_reg_num64);
                }
                elsif $ins_result_kind == $MVM_reg_int32 || $ins_result_kind == $MVM_reg_int16 ||
                        $ins_result_kind == $MVM_reg_int8 || $ins_result_kind == $MVM_reg_uint64 ||
                        $ins_result_kind == $MVM_reg_uint32 || $ins_result_kind == $MVM_reg_uint16 ||
                        $ins_result_kind == $MVM_reg_uint8 {
                    $ins := self.coerce($ins, $MVM_reg_int64);
                }

                # Add to instructions list for this block.
                nqp::splice($frame.instructions, $ins.instructions, +$frame.instructions, 0);

                $block.return_kind($ins.result_kind);
                # generate a return statement
                # get the return op name
                my $ret_op := @return_opnames[$ins.result_kind];
                my @ret_args := nqp::list();

                # provide the return arg register if needed
                nqp::push(@ret_args, $ins.result_reg) unless $ret_op eq 'return';

                # fixup the end of this frame's instruction list with the return
                push_op($frame.instructions, $ret_op, |@ret_args);

                # Build up the frame prologue. Start with lexical captures and clones.
                my @pre := nqp::list();
                my $capture_reg := $*REGALLOC.fresh_register($MVM_reg_obj);
                for $block.captured_inners() {
                    push_op(@pre, 'getcode', $capture_reg, %!mast_frames{$_});
                    push_op(@pre, 'capturelex', $capture_reg);
                }
                $*REGALLOC.release_register($capture_reg, $MVM_reg_obj);
                for $block.cloned_inners() {
                    my $frame := %!mast_frames{$_.key};
                    my $reg   := $_.value;
                    push_op(@pre, 'getcode', $reg, $frame);
                    push_op(@pre, 'takeclosure', $reg, $reg);
                }

                # Set up for any contvar locals.
                for $block.contvar_locals() {
                    my $value_mast := self.as_mast(
                        QAST::WVal.new( :value($_.value) ),
                        :want($MVM_reg_obj));
                    push_ilist(@pre, $value_mast);
                    push_op(@pre, 'clone', $block.local($_.name), $value_mast.result_reg);
                }

                if $node.custom_args {
                    # The block does the arg processing by itself, so we accept any number
                    # of args here.
                    push_op(@pre, 'checkarity',
                        MAST::IVal.new( :size(16), :value(0)),
                        MAST::IVal.new( :size(16), :value(-1)));
                }
                else {
                    # Analyze parameters to get count of required/optional and make sure
                    # all is in order.
                    my $param_index := 0;
                    my int $pos_required := 0;
                    my int $pos_optional := 0;
                    my int $pos_slurpy   := 0;
                    my int $named_slurpy := 0;
                    for $block.params {
                        if $_.slurpy {
                            if $_.named {
                                $named_slurpy := 1
                            }
                            else {
                                if $pos_slurpy {
                                    nqp::die("Only one slurpy positional allowed");
                                }
                                $pos_slurpy := 1;
                            }
                        }
                        elsif nqp::defined($_.named) {
                            # Don't count towards arity or count.
                        }
                        elsif $_.default {
                            if $pos_slurpy {
                                nqp::die("Optional positionals must come before all slurpy positionals");
                            }
                            $pos_optional++;
                        }
                        else {
                            if $pos_optional {
                                nqp::die("Required positionals must come before all optional positionals");
                            }
                            if $pos_slurpy {
                                nqp::die("Required positionals must come before all slurpy positionals");
                            }
                            $pos_required++;
                        }
                    }

                    # check the arity
                    push_op(@pre, 'checkarity',
                        MAST::IVal.new( :size(16), :value($pos_required)),
                        MAST::IVal.new( :size(16), :value($pos_slurpy ?? -1 !! $pos_required + $pos_optional)));

                    # build up instructions to bind the params
                    for $block.params -> $var {
                        my $scope := $var.scope;
                        nqp::die("Param scope must be 'local' or 'lexical'")
                            if $scope ne 'lexical' && $scope ne 'local';

                        my $param_kind := self.type_to_register_kind($var.returns);
                        my $opslot := @kind_to_op_slot[$param_kind];

                        my $opname_index := (nqp::defined($var.named)
                                ?? (nqp::islist($var.named) ?? 20 !! 10)
                                !! 0)
                            + ($var.default ?? 5 !! 0) + $opslot;
                        my $opname := @param_opnames[$opname_index];

                        # what will be put in the value register
                        my $val;
                        my $val2;

                        if $var.slurpy {
                            if $var.named {
                                $opname := "param_sn";
                            }
                            else {
                                $opname := "param_sp";
                            }
                        }
                        elsif nqp::defined($var.named) {
                            my $name := $var.named;
                            if nqp::islist($name) {
                                unless nqp::elems($name) == 2 {
                                    nqp::die("Can only support a single fallback name for a named parameter");
                                }
                                $val := MAST::SVal.new( :value($name[0]) );
                                $val2 := MAST::SVal.new( :value($name[1]) );
                            }
                            else {
                                $val := MAST::SVal.new( :value($name) );
                            }
                        }
                        else { # positional
                            $val := MAST::IVal.new( :size(16), :value($param_index));
                        }

                        # Parameter passing is always at full width. In the best
                        # case the register we target is already full-width, but
                        # if not we need a truncation op.
                        my $targetreg := $scope eq 'lexical'
                            ?? $block.lexical_param($var.name)
                            !! $block.local($var.name);
                        my $valreg;
                        my $truncop;
                        if $param_kind == $MVM_reg_obj || $param_kind == $MVM_reg_int64 ||
                                $param_kind == $MVM_reg_num64 || $param_kind == $MVM_reg_str ||
                                $param_kind == $MVM_reg_uint64 {
                            $valreg := $targetreg;
                        }
                        elsif $param_kind == $MVM_reg_num32 {
                            $valreg := $*REGALLOC.fresh_register($MVM_reg_num64);
                            $truncop := 'trunc_n32';
                        }
                        elsif $param_kind == $MVM_reg_int32 {
                            $valreg := $*REGALLOC.fresh_register($MVM_reg_int64);
                            $truncop := 'trunc_i32';
                        }
                        elsif $param_kind == $MVM_reg_int16 {
                            $valreg := $*REGALLOC.fresh_register($MVM_reg_int64);
                            $truncop := 'trunc_i16';
                        }
                        elsif $param_kind == $MVM_reg_int8 {
                            $valreg := $*REGALLOC.fresh_register($MVM_reg_int64);
                            $truncop := 'trunc_i8';
                        }
                        elsif $param_kind == $MVM_reg_uint32 {
                            $valreg := $*REGALLOC.fresh_register($MVM_reg_uint64);
                            $truncop := 'trunc_u32';
                        }
                        elsif $param_kind == $MVM_reg_uint16 {
                            $valreg := $*REGALLOC.fresh_register($MVM_reg_uint64);
                            $truncop := 'trunc_u16';
                        }
                        elsif $param_kind == $MVM_reg_uint8 {
                            $valreg := $*REGALLOC.fresh_register($MVM_reg_uint64);
                            $truncop := 'trunc_u8';
                        }

                        # NQP->QAST always provides a default value for optional NQP params
                        # even if no default initializer expression is provided.
                        if $var.default {
                            # generate end label to skip initialization code
                            my $endlbl := MAST::Label.new();

                            # generate default initialization code. Could also be
                            # wrapped in another QAST::Block.
                            my $default_mast := self.as_mast($var.default, :want($param_kind));

                            # emit param grabbing op
                            $val2
                                ?? push_op(@pre, $opname, $valreg, $val, $val2, $endlbl)
                                !! push_op(@pre, $opname, $valreg, $val, $endlbl);

                            # emit default initialization code
                            push_ilist(@pre, $default_mast);

                            # put the initialization result in the variable register
                            push_op(@pre, 'set', $valreg, $default_mast.result_reg);
                            $*REGALLOC.release_register($default_mast.result_reg, $default_mast.result_kind);

                            # end label to skip initialization code
                            nqp::push(@pre, $endlbl);
                        }
                        elsif $var.slurpy {
                            if $var.named {
                                push_op(@pre, $opname, $valreg);
                            }
                            else {
                                push_op(@pre, $opname, $valreg, MAST::IVal.new( :value($pos_required + $pos_optional) ));
                            }
                        }
                        else {
                            # emit param grabbing op
                            $val2
                                ?? push_op(@pre, $opname, $valreg, $val, $val2)
                                !! push_op(@pre, $opname, $valreg, $val);
                        }

                        if $truncop {
                            push_op(@pre, $truncop, $targetreg, $valreg);
                        }

                        if $scope eq 'lexical' {
                            # emit the op to bind the lexical to the result register
                            push_op(@pre, 'bindlex', $block.lexical($var.name), $targetreg);
                        }

                        # Emit any additional tasks and typechecks.
                        for $var.list {
                            if nqp::istype($_, QAST::ParamTypeCheck) {
                                my $tc_mast := self.as_mast($_[0], :want($MVM_reg_int64));
                                push_ilist(@pre, $tc_mast);
                                push_op(@pre, 'assertparamcheck', $tc_mast.result_reg);
                                $*REGALLOC.release_register($tc_mast.result_reg, $MVM_reg_int64);
                            }
                            else {
                                push_ilist(@pre, self.as_mast($_, :want($MVM_reg_void)));
                            }
                        }

                        $param_index++;
                    }

                    # If we didn't slurp all the names, check there are no
                    # unexpected ones.
                    push_op(@pre, 'paramnamesused') unless $named_slurpy;
                }

                nqp::splice($frame.instructions, @pre, 0, 0);
            }
        }

        if $node.blocktype eq 'raw' || !nqp::istype($outer, BlockInfo) {
            MAST::InstructionList.new(nqp::list(), MAST::VOID, $MVM_reg_void);
        }
        elsif $node.blocktype eq 'immediate' {
            my $clone_reg := $*BLOCK.clone_inner($node);
            if nqp::defined($want) && $want == $MVM_reg_void {
                my @ins;
                nqp::push(@ins, MAST::Call.new( :target($clone_reg), :flags([]) ));
                MAST::InstructionList.new(@ins, MAST::VOID, $MVM_reg_void);
            }
            else {
                my $res_reg   := $*REGALLOC.fresh_register($block.return_kind);
                my @ins;
                nqp::push(@ins, MAST::Call.new(
                    :target($clone_reg), :flags([]), :result($res_reg)
                ));
                MAST::InstructionList.new(@ins, $res_reg, $block.return_kind)
            }
        }
        elsif $node.blocktype eq 'immediate_static' {
            $*BLOCK.capture_inner($node);
            my $code_reg := $*REGALLOC.fresh_register($MVM_reg_obj);
            my @ins;
            push_op(@ins, 'getcode', $code_reg, %!mast_frames{$node.cuid});
            if nqp::defined($want) && $want == $MVM_reg_void {
                nqp::push(@ins, MAST::Call.new( :target($code_reg), :flags([]) ));
                MAST::InstructionList.new(@ins, MAST::VOID, $MVM_reg_void);
            } else {
                my $res_reg  := $*REGALLOC.fresh_register($block.return_kind);
                nqp::push(@ins, MAST::Call.new(
                    :target($code_reg), :flags([]), :result($res_reg)
                ));
                MAST::InstructionList.new(@ins, $res_reg, $block.return_kind)
            }
        }
        elsif $node.blocktype eq '' || $node.blocktype eq 'declaration' {
            my $clone_reg := $*BLOCK.clone_inner($node);
            MAST::InstructionList.new(nqp::list(), $clone_reg, $MVM_reg_obj)
        }
        elsif $node.blocktype eq 'declaration_static' {
            $*BLOCK.capture_inner($node);
            if nqp::defined($want) && $want == $MVM_reg_void {
                my $code_reg := $*REGALLOC.fresh_register($MVM_reg_obj);
                my @ins;
                push_op(@ins, 'getcode', $code_reg, %!mast_frames{$node.cuid});
                MAST::InstructionList.new(@ins, $code_reg, $MVM_reg_obj)
            }
            else {
                my $clone_reg := $*BLOCK.clone_inner($node);
                MAST::InstructionList.new(nqp::list(), $clone_reg, $MVM_reg_obj)
            }
        }
        else {
            nqp::die("Unhandled blocktype " ~ $node.blocktype);
        }
    }

    multi method compile_node(QAST::Stmts $node, :$want) {
        my $resultchild := $node.resultchild;
        nqp::die("resultchild out of range")
            if (nqp::defined($resultchild) && $resultchild >= +@($node));
        self.compile_all_the_stmts(@($node), $resultchild)
    }

    multi method compile_node(QAST::Stmt $node, :$want) {
        my %stmt_temps := nqp::clone(%*STMTTEMPS); # guaranteed to be initialized
        my $result     := self.compile_with_stmt_temps($node, %stmt_temps);
        for %stmt_temps -> $temp_key {
            if !nqp::existskey(%*STMTTEMPS, $temp_key) &&
                    !nqp::eqaddr($*BLOCK.local($temp_key), $result.result_reg) {
                $*BLOCK.release_temp($temp_key);
            }
        }
        $result
    }
    method compile_with_stmt_temps($node, %stmt_temps) {
        my %*STMTTEMPS  := %stmt_temps;
        my $*INSTMT     := 1;
        my $resultchild := $node.resultchild;
        nqp::die("resultchild out of range")
            if (nqp::defined($resultchild) && $resultchild >= +@($node));
        self.compile_all_the_stmts(@($node), $resultchild);
    }

    # This takes any node that is a statement list of some kind and compiles
    # all of the statements within it.
    method compile_all_the_stmts(@stmts, $resultchild?) {
        my @all_ins;
        # the most recent statement mast
        my $last_stmt;
        my $result_stmt;
        my $result_count := 0;
        $resultchild := $resultchild // -1;
        my $final_stmt_idx := +@stmts - 1;
        my $WANT := $*WANT;
        my $all_void := nqp::defined($WANT) && $WANT == $MVM_reg_void;
        for @stmts {
            my int $use_result := 0;
            # Compile this child to MAST, and add its instructions to the end
            # of our instruction list. Also track the last statement.
            # if this is the statement we've been asked to make the result
            if !$all_void && ($result_count == $resultchild
            # or if we weren't given a particular result statement and we're on
            # the last statement,
                    || $resultchild == -1 && $result_count == $final_stmt_idx) {
                # compile $_ with an explicit $want, either what's given or obj
                $last_stmt := nqp::defined($WANT)
                    ?? self.as_mast($_, :want($WANT))
                    !! self.as_mast($_);
                if $last_stmt.result_kind == $MVM_reg_void {
                    $last_stmt := self.coerce($last_stmt, $MVM_reg_obj);
                }
                $use_result := 1;
            }
            else {
                $last_stmt := self.as_mast($_, :want($MVM_reg_void));
            }

            # Annotate with line number if we have one.
            my $node := $_.node;
            if nqp::isconcrete($node) && nqp::can($node,'orig') {
                my $line := HLL::Compiler.lineof($node.orig(), $node.from(), :cache(1));
                nqp::push(@all_ins, MAST::Annotated.new(
                    :$!file, :$line, :instructions($last_stmt.instructions) ));
            }
            else {
                nqp::splice(@all_ins, $last_stmt.instructions, +@all_ins, 0);
            }

            if $use_result {
                $result_stmt := $last_stmt;
            }
            else {
                # release top-level results (since they can't be used by anything anyway)
                $*REGALLOC.release_register($last_stmt.result_reg, $last_stmt.result_kind);
            }
            $result_count++;
        }
        if $result_stmt && $result_stmt.result_kind != $MVM_reg_void {
            MAST::InstructionList.new(@all_ins, $result_stmt.result_reg, $result_stmt.result_kind);
        }
        else {
            MAST::InstructionList.new(@all_ins, MAST::VOID, $MVM_reg_void);
        }
    }

    multi method compile_node(QAST::Op $node, :$want) {
        $!last_op := $node;
        QAST::MASTOperations.compile_op(self, $!hll, $node)
    }

    multi method compile_node(QAST::VM $node, :$want) {
        if $node.supports('moar') {
            return nqp::defined($want)
                ?? self.as_mast($node.alternative('moar'), :$want)
                !! self.as_mast($node.alternative('moar'));
        }
        elsif $node.supports('moarop') {
            return nqp::defined($want)
                ?? QAST::MASTOperations.compile_mastop(self, $node.alternative('moarop'), $node.list, [], :$want)
                !! QAST::MASTOperations.compile_mastop(self, $node.alternative('moarop'), $node.list, []);
        }
        elsif $node.supports('mast') {
            return $node.alternative('mast');
        }
        else {
            nqp::die("To compile on the MoarVM backend, QAST::VM must have an alternative 'moar' or 'moarop'");
        }
    }

    sub check_kinds($a, $b) {
        nqp::die("register types $a and $b don't match") unless $a == $b;
    }

    my @lex_n_opnames := [
        'lex_ni',
        'lex_nn',
        'lex_ns',
        'lex_no',
        'lex_nu'
    ];

    my @lexref_opnames := [
        '',
        'getlexref_i8',
        'getlexref_i16',
        'getlexref_i32',
        'getlexref_i',
        'getlexref_n32',
        'getlexref_n',
        'getlexref_s',
        '', '',  '',  '',  '',  '',  '',  '',  '',
        'getlexref_u8',
        'getlexref_u16',
        'getlexref_u32',
        'getlexref_u'
    ];

    my @lexref_n_opnames := [
        'getlexref_ni',
        'getlexref_nn',
        'getlexref_ns',
        '',
        'getlexref_nu',
    ];

    my @localref_opnames := [
        '',
        'getregref_i8',
        'getregref_i16',
        'getregref_i32',
        'getregref_i',
        'getregref_n32',
        'getregref_n',
        'getregref_s',
        '', '',  '',  '',  '',  '',  '',  '',  '',
        'getregref_u8',
        'getregref_u16',
        'getregref_u32',
        'getregref_u'
    ];

    my @decont_opnames := [
        'decont_i',
        'decont_n',
        'decont_s',
        'decont',
        'decont_u'
    ];

    multi method compile_node(QAST::Var $node, :$want) {
        self.compile_var($node, :$want)
    }

    multi method compile_node(QAST::VarWithFallback $node, :$want) {
        my $var_res := self.compile_var($node, :$want);
        if $*BINDVAL || $var_res.result_kind != $MVM_reg_obj {
            $var_res
        }
        else {
            my $il := nqp::list();
            push_ilist($il, $var_res);

            my $fallback_if_nonnull := MAST::Label.new();
            my $fallback_end := MAST::Label.new();
            my $res_reg := $*REGALLOC.fresh_o();
            push_op($il, 'ifnonnull', $var_res.result_reg, $fallback_if_nonnull);

            my $fallback_res := self.as_mast($node.fallback, :want($MVM_reg_obj));
            push_ilist($il, $fallback_res);
            push_op($il, 'set', $res_reg, $fallback_res.result_reg);
            push_op($il, 'goto', $fallback_end);
            nqp::push($il, $fallback_if_nonnull);
            push_op($il, 'set', $res_reg, $var_res.result_reg);
            nqp::push($il, $fallback_end);
            $*REGALLOC.release_register($var_res.result_reg, $MVM_reg_obj);
            $*REGALLOC.release_register($fallback_res.result_reg, $MVM_reg_obj);

            MAST::InstructionList.new($il, $res_reg, $MVM_reg_obj)
        }
    }

    method compile_var($node, :$want) {
        my $scope := $node.scope;
        my $decl  := $node.decl;

        my $res_reg;
        my $res_kind;

        # Handle any declarations; after this, we call through to the
        # lookup code.
        if $decl {
            # If it's a parameter, add it to the things we should bind
            # at block entry.
            if $decl eq 'param' {
                if $scope eq 'local' {
                    $*BLOCK.add_param($node);
                }
                elsif $scope eq 'lexical' {
                    my @details := $*BLOCK.add_param($node);
                    $res_kind := @details[0];
                    $res_reg := @details[1];
                }
                else {
                    nqp::die("Parameter cannot have scope '$scope'; use 'local' or 'lexical'");
                }
            }
            elsif $decl eq 'var' {
                if $scope eq 'local' {
                    $*BLOCK.register_local($node);
                }
                elsif $scope eq 'lexical' {
                    $*BLOCK.add_lexical($node);
                }
                elsif $scope eq 'lexicalref' {
                    $*BLOCK.add_lexicalref($node);
                }
                elsif $scope eq 'localref' {
                    $*BLOCK.register_localref($node);
                }
                else {
                    nqp::die("Cannot declare variable with scope '$scope'; use one of 'local', 'lexical', 'localref' or 'lexicalref'");
                }
            }
            elsif $decl eq 'static' {
                if $scope ne 'lexical' {
                    nqp::die("Can only use 'static' decl with scope 'lexical'");
                }
                $*BLOCK.add_lexical($node, :is_static);
            }
            elsif $decl eq 'contvar' {
                if $scope eq 'local' {
                    $*BLOCK.register_local($node, :is_cont);
                }
                elsif $scope eq 'lexical' {
                    $*BLOCK.add_lexical($node, :is_cont);
                }
                else {
                    nqp::die("Can only use 'contvar' decl with scope 'lexical'");
                }
            }
            elsif $decl eq 'statevar' {
                if $scope ne 'lexical' {
                    nqp::die("Can only use 'statevar' decl with scope 'lexical'");
                }
                $*BLOCK.add_lexical($node, :is_state);
            }
            else {
                nqp::die("Don't understand declaration type '$decl'");
            }
        }

        # If we know what we're after, some opts:
        if nqp::isconcrete($want) {
            # Declaration in void context need generate no code.
            if $want == $MVM_reg_void {
                return MAST::InstructionList.new([], MAST::VOID, $MVM_reg_void);
            }

            # Both lexicalref and attributeref in the context we want a
            # non-object devolve to lexical and attribute, since we'd only
            # de-ref right away anyway.
            if $want != $MVM_reg_obj {
                $scope := 'lexical'   if $scope eq 'lexicalref';
                $scope := 'attribute' if $scope eq 'attributeref';
            }
        }

        # Now go by scope.
        my $name := $node.name;
        my @ins;
        if $scope eq 'local' {
            my $local := $*BLOCK.local($name);
            my $localref := $*BLOCK.localref($name);

            if $local {
                $res_kind := $*BLOCK.local_kind($name);
                if $*BINDVAL {
                    my $valmast := self.as_mast_clear_bindval($*BINDVAL, :want($res_kind));
                    push_ilist(@ins, $valmast);
                    push_op(@ins, 'set', $local, $valmast.result_reg);
                    $*REGALLOC.release_register($valmast.result_reg, $res_kind);
                }
                $res_reg := $local;
            } elsif $localref {
                if $*BINDVAL {
                    nqp::die('Cannot bind to QAST::Var resolving to a localref');
                }
                $res_kind := $*BLOCK.localref_kind($name);
                $res_reg := $*REGALLOC.fresh_register($res_kind);
                push_op(@ins, @decont_opnames[@kind_to_op_slot[$res_kind]], $res_reg, $localref);
            }
            else {
                nqp::die("Cannot reference undeclared local '$name'");
            }
        }
        elsif $scope eq 'localref' {
            my $localref := $*BLOCK.localref($name);
            my $local    := $*BLOCK.local($name);
            if $localref {
                $res_kind := $MVM_reg_obj;
                if $*BINDVAL {
                    my $valmast := self.as_mast_clear_bindval($*BINDVAL, :want($MVM_reg_obj));
                    push_ilist(@ins, $valmast);
                    push_op(@ins, 'set', $localref, $valmast.result_reg);
                    $*REGALLOC.release_register($valmast.result_reg, $MVM_reg_obj);
                }
                $res_reg := $localref;
            }
            elsif $local {
                if $*BINDVAL {
                    nqp::die('Cannot bind to a local resolving to a localref');
                }
                my $local_kind := $*BLOCK.local_kind($name);
                if $local_kind == $MVM_reg_obj {
                    nqp::die('Cannot take a reference to non-native local ' ~ $name);
                }
                $res_reg := $*REGALLOC.fresh_register($MVM_reg_obj);
                $res_kind := $MVM_reg_obj;
                push_op(@ins, @localref_opnames[$local_kind], $res_reg, $local);
            }
            else {
                nqp::die("Cannot reference undeclared local '$name'");
            }
        }
        elsif $scope eq 'lexical' {
            my $lex;
            my $lexref;
            my $outer := 0;
            my $block := $*BLOCK;
            # find the block where the lexical was declared, if any
            while nqp::istype($block, BlockInfo) {
                last if $block.qast.ann('DYN_COMP_WRAPPER');
                $lex := $block.lexical($name);
                last if $lex;
                $lexref := $block.lexicalref($name);
                last if $lexref;
                $block := $block.outer;
                $outer++;
            }
            if $lex {
                $res_kind := $block.lexical_kind($name);
                if $outer {
                    # need to create lex that knows how many frames to go out
                    $lex := MAST::Lexical.new( :index($lex.index), :frames_out($outer) );
                }
                if $*BINDVAL {
                    my $valmast := self.as_mast_clear_bindval($*BINDVAL, :want($res_kind));
                    $res_reg := $valmast.result_reg;
                    push_ilist(@ins, $valmast);
                    push_op(@ins, 'bindlex', $lex, $res_reg);
                }
                elsif $decl ne 'param' {
                    $res_reg := $*REGALLOC.fresh_register($res_kind);
                    push_op(@ins, 'getlex', $res_reg, $lex);
                }
                else {
                    # for lexical param declarations, we don't actually have a result value,
                    # since the param bindlex may be stale by the time the result register
                    # could be used, since the bindlex always occurs at the very top,
                    # so turn around and release the temp register already preallocated.
                    $*REGALLOC.release_register($res_reg, $res_kind);
                    # get another one in case someone is using it...
                    $res_reg := $*REGALLOC.fresh_register($res_kind);
                    push_op(@ins, 'getlex', $res_reg, $lex);
                }
            }
            elsif $lexref {
                if $*BINDVAL {
                    nqp::die('Cannot bind to QAST::Var resolving to a lexicalref');
                }
                $res_kind := $block.lexicalref_kind($name);
                if $outer {
                    $lexref := MAST::Lexical.new( :index($lexref.index), :frames_out($outer) );
                }
                my $tmp_reg := $*REGALLOC.fresh_register($MVM_reg_obj);
                $res_reg := $*REGALLOC.fresh_register($res_kind);
                push_op(@ins, 'getlex', $tmp_reg, $lexref);
                push_op(@ins, @decont_opnames[@kind_to_op_slot[$res_kind]], $res_reg, $tmp_reg);
                $*REGALLOC.release_register($tmp_reg, $MVM_reg_obj);
            }
            else {
                $res_kind := self.type_to_register_kind($node.returns);
                if $*BINDVAL {
                    my $valmast := self.as_mast_clear_bindval($*BINDVAL, :want($res_kind));
                    $res_reg := $valmast.result_reg;
                    push_ilist(@ins, $valmast);
                    push_op(@ins, "bind"~@lex_n_opnames[@kind_to_op_slot[$res_kind]], MAST::SVal.new( :value($name) ), $res_reg);
                    $res_kind := $valmast.result_kind;
                }
                else {
                    $res_reg := $*REGALLOC.fresh_register($res_kind);
                    push_op(@ins, "get"~@lex_n_opnames[@kind_to_op_slot[$res_kind]],
                        $res_reg, MAST::SVal.new( :value($name) ));
                }
            }
        }
        elsif $scope eq 'lexicalref' {
            my $lex;
            my $lexref;
            my $outer := 0;
            my $block := $*BLOCK;
            # find the block where the lexical was declared, if any
            while nqp::istype($block, BlockInfo) {
                last if $block.qast.ann('DYN_COMP_WRAPPER');
                $lex := $block.lexical($name);
                last if $lex;
                $lexref := $block.lexicalref($name);
                last if $lexref;
                $block := $block.outer;
                $outer++;
            }
            $res_kind := $MVM_reg_obj;
            $res_reg := $*REGALLOC.fresh_register($res_kind);
            if $lex {
                # We need to take a reference to the lexical.
                if $*BINDVAL {
                    nqp::die("Cannot bind to non-reference QAST::Var '{$name}'");
                }
                if $outer {
                    $lex := MAST::Lexical.new( :index($lex.index), :frames_out($outer) );
                }
                my $lex_kind := $block.lexical_kind($name);
                if $lex_kind == $MVM_reg_obj {
                    nqp::die('Cannot take a reference to a non-native lexical');
                }
                push_op(@ins, @lexref_opnames[$lex_kind], $res_reg, $lex);
            }
            elsif $lexref {
                # We want a reference, the register contains a reference, so
                # just do the lookup.
                if $outer {
                    $lexref := MAST::Lexical.new( :index($lexref.index), :frames_out($outer) );
                }
                if $*BINDVAL {
                    my $valmast := self.as_mast_clear_bindval($*BINDVAL, :want($MVM_reg_obj));
                    $res_reg := $valmast.result_reg;
                    push_ilist(@ins, $valmast);
                    push_op(@ins, 'bindlex', $lexref, $res_reg);
                }
                else {
                    push_op(@ins, 'getlex', $res_reg, $lexref);
                }
            }
            else {
                if $*BINDVAL {
                    nqp::die('Cannot bind to late-bound QAST::Var with scope lexicalref');
                }
                my $lex_kind := self.type_to_register_kind($node.returns);
                push_op(@ins, @lexref_n_opnames[@kind_to_op_slot[$lex_kind]],
                    $res_reg, MAST::SVal.new( :value($name) ));
            }
        }
        elsif $scope eq 'typevar' {
            if $*BINDVAL {
                nqp::die('Cannot bind to QAST::Var with scope typevar');
            }
            my $name_reg := $*REGALLOC.fresh_s();
            $res_reg     := $*REGALLOC.fresh_o();
            $res_kind    := $MVM_reg_obj;
            push_op(@ins, 'const_s', $name_reg, MAST::SVal.new( :value($name) ));
            push_op(@ins, 'getlexperinvtype_o', $res_reg, $name_reg);
            $*REGALLOC.release_register($name_reg, $MVM_reg_str);
        }
        elsif $scope eq 'contextual' {
            my $name_const := const_s($name);
            my $lex := $*BLOCK.lexical($name);
            if $lex {
                # In current frame; do as lexical does.
                $res_kind := $*BLOCK.lexical_kind($name);
                if $*BINDVAL {
                    my $valmast := self.as_mast_clear_bindval($*BINDVAL, :want($res_kind));
                    $res_reg := $valmast.result_reg;
                    push_ilist(@ins, $valmast);
                    push_op(@ins, 'bindlex', $lex, $res_reg);
                }
                elsif $decl ne 'param' {
                    $res_reg := $*REGALLOC.fresh_register($res_kind);
                    push_op(@ins, 'getlex', $res_reg, $lex);
                }
                else {
                    $*REGALLOC.release_register($res_reg, $res_kind);
                    $res_reg := $*REGALLOC.fresh_register($res_kind);
                    push_op(@ins, 'getlex', $res_reg, $lex);
                }
            }
            else {
                # Need lookup.
                if $*BINDVAL {
                    my $valmast := self.as_mast_clear_bindval($*BINDVAL, :want($MVM_reg_obj));
                    $res_reg := $valmast.result_reg;
                    push_ilist(@ins, $valmast);
                    push_ilist(@ins, $name_const);
                    push_op(@ins, 'binddynlex', $name_const.result_reg, $res_reg);
                }
                else {
                    push_ilist(@ins, $name_const);
                    $res_reg := $*REGALLOC.fresh_register($MVM_reg_obj);
                    push_op(@ins, 'getdynlex', $res_reg, $name_const.result_reg);
                }
            }
            $*REGALLOC.release_register($name_const.result_reg, $MVM_reg_str);
            $res_kind := $MVM_reg_obj;
        }
        elsif $scope eq 'attribute' {
            # Ensure we have object and class handle.
            my @args := $node.list();
            if +@args != 2 {
                nqp::die("An attribute lookup needs an object and a class handle");
            }

            # Compile object and handle.
            my $obj := self.as_mast_clear_bindval(@args[0], :want($MVM_reg_obj));
            my $han := self.as_mast_clear_bindval(@args[1], :want($MVM_reg_obj));
            push_ilist(@ins, $obj);
            push_ilist(@ins, $han);

            my int $hint := -1;

            if nqp::istype(@args[1], QAST::WVal) {
                $hint := nqp::hintfor(@args[1].value, $name);
            }

            # Go by whether it's a bind or lookup. We always access the
            # attributes at full-width from the VM op interface.
            my $kind := self.type_to_register_kind($node.returns);
            if $kind == $MVM_reg_num32 {
                $kind := $MVM_reg_num64;
            }
            elsif $kind == $MVM_reg_int32 || $kind == $MVM_reg_int16 ||
                    $kind == $MVM_reg_int8 {
                $kind := $MVM_reg_int64;
            }
            elsif $kind == $MVM_reg_uint64 || $kind == $MVM_reg_uint32 ||
                    $kind == $MVM_reg_uint16 || $kind == $MVM_reg_uint8 {
                # For now compile as signed
                $kind := $MVM_reg_int64;
            }
            if $*BINDVAL {
                my $valmast := self.as_mast_clear_bindval($*BINDVAL, :want($kind));
                push_ilist(@ins, $valmast);
                push_op(@ins, 'bind' ~ @attr_opnames[$kind], $obj.result_reg,
                    $han.result_reg, MAST::SVal.new( :value($name) ), $valmast.result_reg,
                        MAST::IVal.new( :value($hint) ) );
                $res_reg := $valmast.result_reg;
                $res_kind := $valmast.result_kind;
            }
            else {
                $res_reg := $*REGALLOC.fresh_register($kind);
                $res_kind := $kind;
                push_op(@ins, 'get' ~ @attr_opnames[$kind], $res_reg, $obj.result_reg,
                    $han.result_reg, MAST::SVal.new( :value($name) ),
                        MAST::IVal.new( :value($hint) ) );
            }
            $*REGALLOC.release_register($obj.result_reg, $MVM_reg_obj);
            $*REGALLOC.release_register($han.result_reg, $MVM_reg_obj);
        }
        elsif $scope eq 'attributeref' {
            # Ensure we have object and class handle, and aren't binding.
            my @args := $node.list();
            if +@args != 2 {
                nqp::die("An attribute reference needs an object and a class handle");
            }
            if $*BINDVAL {
                nqp::die("Cannot bind to QAST::Var '{$name}' with scope attributeref");
            }

            # Ensure we've a natively typed attribute to take a ref to.
            my $kind := self.type_to_register_kind($node.returns);
            if $kind == $MVM_reg_obj {
                nqp::die("Attribute references can only be to native types");
            }

            # Compile object and handle, and get hint.
            my $obj := self.as_mast_clear_bindval(@args[0], :want($MVM_reg_obj));
            my $han := self.as_mast_clear_bindval(@args[1], :want($MVM_reg_obj));
            push_ilist(@ins, $obj);
            push_ilist(@ins, $han);
            my int $hint := -1;
            if nqp::istype(@args[1], QAST::WVal) {
                $hint := nqp::hintfor(@args[1].value, $name);
            }

            # Emit lookup.
            $res_reg := $*REGALLOC.fresh_register($MVM_reg_obj);
            $res_kind := $MVM_reg_obj;
            push_op(@ins, @attrref_opnames[$kind], $res_reg, $obj.result_reg,
                $han.result_reg, MAST::SVal.new( :value($name) ),
                    MAST::IVal.new( :value($hint) ) );
            $*REGALLOC.release_register($obj.result_reg, $MVM_reg_obj);
            $*REGALLOC.release_register($han.result_reg, $MVM_reg_obj);
        }
        elsif $scope eq 'positional' {
            return self.as_mast_clear_bindval($*BINDVAL
                ?? QAST::Op.new( :op('positional_bind'), |$node.list, $*BINDVAL)
                !! QAST::Op.new( :op('positional_get'), |$node.list));
        }
        elsif $scope eq 'associative' {
            return self.as_mast_clear_bindval($*BINDVAL
                ?? QAST::Op.new( :op('associative_bind'), |$node.list, $*BINDVAL)
                !! QAST::Op.new( :op('associative_get'), |$node.list));
        }
        else {
            nqp::die("QAST::Var with scope '$scope' NYI");
        }

        MAST::InstructionList.new(@ins, $res_reg, $res_kind)
    }

    multi method compile_node(MAST::InstructionList $ilist, :$want) {
        $ilist
    }

    multi method compile_node(MAST::Node $node, :$want) {
        MAST::InstructionList.new([$node], MAST::VOID, $MVM_reg_void)
    }

    method as_mast_clear_bindval($node, :$want) {
        my $*BINDVAL := 0;
        nqp::defined($want) ?? self.as_mast($node, :$want) !! self.as_mast($node)
    }

    proto method as_mast_constant($qast) { * }

    multi method as_mast_constant(QAST::IVal $iv) {
        MAST::IVal.new( :value($iv.value) )
    }
    multi method as_mast_constant(QAST::SVal $sv) {
        MAST::SVal.new( :value($sv.value) )
    }
    multi method as_mast_constant(QAST::NVal $nv) {
        MAST::NVal.new( :value($nv.value) )
    }
    multi method as_mast_constant(QAST::Want $want) {
        my int $finger := 1;
        my @children := $want.list;
        while $finger < nqp::elems(@children) {
            my str $got := @children[$finger];
            if $got eq 'Ss' || $got eq 'Ii' || $got eq 'Nn' {
                return self.as_mast_constant(@children[$finger + 1]);
            }
            $finger := $finger + 2;
        }
        return self.as_mast_constant(@children[0]);
    }
    multi method as_mast_constant(QAST::Node $qast) {
        nqp::die("expected QAST constant; didn't get one");
    }

    multi method compile_node(QAST::Want $node, :$want) {
        # If we're not in a coercive context, take the default.
        self.as_mast($node[0])
    }

    multi method compile_node(QAST::IVal $iv, :$want) {
        my $reg := $*REGALLOC.fresh_i();
        MAST::InstructionList.new(
            [MAST::Op.new(
                :op('const_i64'),
                $reg,
                MAST::IVal.new( :value($iv.value) )
            )],
            $reg,
            $MVM_reg_int64)
    }

    multi method compile_node(QAST::NVal $nv, :$want) {
        my $reg := $*REGALLOC.fresh_n();
        MAST::InstructionList.new(
            [MAST::Op.new(
                :op('const_n64'),
                $reg,
                MAST::NVal.new( :value($nv.value) )
            )],
            $reg,
            $MVM_reg_num64)
    }

    sub const_s($val) {
        my $reg := $*REGALLOC.fresh_s();
        MAST::InstructionList.new(
            [MAST::Op.new(
                :op('const_s'),
                $reg,
                MAST::SVal.new( :value($val) )
            )],
            $reg,
            $MVM_reg_str)
    }

    multi method compile_node(QAST::SVal $sv, :$want) {
        const_s($sv.value)
    }

    multi method compile_node(QAST::BVal $bv, :$want) {
        my $block := $bv.value;
        my $cuid  := $block.cuid();
        my $frame := %!mast_frames{$cuid};
        nqp::die("QAST::Block with cuid $cuid has not appeared")
            unless $frame && $frame ~~ MAST::Frame;

        my $reg := $*REGALLOC.fresh_o();
        MAST::InstructionList.new(
            [MAST::Op.new(
                :op('getcode'),
                $reg,
                $frame
            )],
            $reg,
            $MVM_reg_obj)
    }

    multi method compile_node(QAST::WVal $node, :$want) {
        if nqp::isconcrete($want) && $want == $MVM_reg_void {
            MAST::InstructionList.new([], MAST::VOID, $MVM_reg_void);
        }
        else {
            my $val    := $node.value;
            my $sc     := nqp::getobjsc($val);
            if nqp::isnull($sc) {
                nqp::die("Object of type " ~ $val.HOW.name($val) ~ " in QAST::WVal, but not in SC");
            }
            my $idx    := nqp::scgetobjidx($sc, $val);
            my $sc_idx := $!mast_compunit.sc_idx($sc);
            my $reg    := $*REGALLOC.fresh_o();
            my $op     := $idx < 32768 ?? 'wval' !! 'wval_wide';
            MAST::InstructionList.new(
                [MAST::Op.new(
                    :op($op),
                    $reg,
                    MAST::IVal.new( :value($sc_idx) ),
                    MAST::IVal.new( :value($idx) )
                )],
                $reg,
                $MVM_reg_obj)
        }
    }

    multi method compile_node(QAST::Regex $node, :$want) {
        my $rxcomp := QAST::MASTRegexCompiler.new(:qastcomp(self), :regalloc($*REGALLOC));
        nqp::defined($want)
            ?? $rxcomp.as_mast($node, :want($want))
            !! $rxcomp.as_mast($node)
    }

    multi method compile_node($unknown, :$want) {
        nqp::die("Unknown QAST node type " ~ $unknown.HOW.name($unknown));
    }

    method annotated($ilist, $file, $line) {
        MAST::InstructionList.new([
            MAST::Annotated.new(:file($file), :line($line),
                :instructions($ilist.instructions))],
            $ilist.result_reg, $ilist.result_kind)
    }

    method type_to_register_kind($type) {
        if nqp::isnull($type) {
            $MVM_reg_obj
        }
        else {
            my int $primspec := nqp::objprimspec($type);
            if $primspec == 0 {
                $MVM_reg_obj
            }
            elsif $primspec == 1 {
                my int $size := nqp::objprimbits($type);
                if nqp::objprimunsigned($type) {
                    if $size == 64    { $MVM_reg_uint64 }
                    elsif $size == 32 { $MVM_reg_uint32 }
                    elsif $size == 16 { $MVM_reg_uint16 }
                    elsif $size == 8  { $MVM_reg_uint8 }
                    else { nqp::die("Unknown int size $size") }
                }
                else {
                    if $size == 64    { $MVM_reg_int64 }
                    elsif $size == 32 { $MVM_reg_int32 }
                    elsif $size == 16 { $MVM_reg_int16 }
                    elsif $size == 8  { $MVM_reg_int8 }
                    else { nqp::die("Unknown int size $size") }
                }
            }
            elsif $primspec == 2 {
                my int $size := nqp::objprimbits($type);
                if $size == 64    { $MVM_reg_num64 }
                elsif $size == 32 { $MVM_reg_num32 }
                else { nqp::die("Unknown num size $size") }
            }
            else {
                $MVM_reg_str
            }
        }
    }
}

# Shim that makes a compiler instance and uses it to drive compilation.
class QAST::MASTCompiler {
    method to_mast($qast) {
        MASTCompilerInstance.new.to_mast($qast)
    }

    method operations() {
        QAST::MASTOperations
    }

    method instance() {
        MASTCompilerInstance
    }
}

# Register as the QAST compiler.
if nqp::isnull(nqp::getcomp('QAST')) {
    nqp::bindcomp('QAST', QAST::MASTCompiler);
}

class MASTBytecodeAssembler {
    method node_hash() {
        nqp::hash(
            'CompUnit',         MAST::CompUnit,
            'Frame',            MAST::Frame,
            'Op',               MAST::Op,
            'ExtOp',            MAST::ExtOp,
            'SVal',             MAST::SVal,
            'IVal',             MAST::IVal,
            'NVal',             MAST::NVal,
            'Label',            MAST::Label,
            'Local',            MAST::Local,
            'Lexical',          MAST::Lexical,
            'Call',             MAST::Call,
            'Annotated',        MAST::Annotated,
            'HandlerScope',     MAST::HandlerScope
        )
    }
    
    method assemble_to_file($mast, $file) {
        nqp::masttofile($mast, self.node_hash(), $file)
    }
    
    method assemble_and_load($mast) {
        nqp::masttocu($mast, self.node_hash())
    }
}

if nqp::isnull(nqp::getcomp('MAST')) {
    nqp::bindcomp('MAST', MASTBytecodeAssembler);
}
 
# vim: set ft=perl6 nomodifiable :
