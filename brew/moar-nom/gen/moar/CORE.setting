# This file automatically generated by tools/build/gen-cat.nqp

#line 1 SETTING::src/core/core_prologue.pm
# Stub a few things the compiler wants to have really early on.
my class Pair { ... }   # must be first for some reason
my class Block { ... }
my class HyperWhatever { ... }
my class List { ... }
my class Map { ... }
my class Match { ... }
my class Failure { ... }
my class Rakudo::Internals { ... }
my class Rakudo::Internals::JSON { ... }
my class Rakudo::Iterator { ... }
my class ThreadPoolScheduler { ... }
my class Whatever { ... }
my class WhateverCode { ... }
my class X::Attribute::Required { ... }
my class X::Numeric::Overflow { ... }
my class X::Numeric::Underflow { ... }

# Stub these or we can't use any sigil other than $.
my role Positional { ... }
my role Associative { ... }
my role Callable { ... }
my role Iterable { ... }
my role PositionalBindFailover { ... }

# Set up Empty, which is a Slip created with an empty IterationBuffer (which
# we also stub here). This is needed in a bunch of simple constructs (like if
# with only one branch).
my class IterationBuffer is repr('VMArray') { ... }
my constant Empty = nqp::p6bindattrinvres(nqp::create(Slip),
    List, '$!reified', nqp::create(IterationBuffer));

# We use a sentinel value to mark the end of an iteration.
my constant IterationEnd = nqp::create(Mu);

# To allow passing of nqp::hash without being HLLized, we create a HLL class
# with the same low level REPR as nqp::hash.
my class Rakudo::Internals::IterationSet is repr('VMHash') { }

# The value for \n.
my constant $?NL = "\x0A";

# Make sure we have an environment
PROCESS::<%ENV> := Rakudo::Internals.createENV(0);

# This thread pool scheduler will be the default one.
PROCESS::<$SCHEDULER> = ThreadPoolScheduler.new();

#line 1 SETTING::src/core/traits.pm
# for errors
my class X::Inheritance::Unsupported { ... }
my class X::Inheritance::UnknownParent { ... }
my class X::Export::NameClash        { ... }
my class X::Composition::NotComposable { ... }
my class X::Import::MissingSymbols   { ... }
my class X::Redeclaration { ... }
my class X::Inheritance::SelfInherit { ... }
my class X::Comp::Trait::Unknown { ... }
my class X::Experimental { ... }
my class Pod::Block::Declarator { ... }

proto sub trait_mod:<is>(|) { * }
multi sub trait_mod:<is>(Mu:U $child, Mu:U $parent) {
    if $parent.HOW.archetypes.inheritable() {
        $child.^add_parent($parent);
    }
    elsif $parent.HOW.archetypes.inheritalizable() {
        if my @required-methods = $parent.^methods.grep({$_.yada}) {
            my $type = $child.HOW.archetypes.inheritable()
                ?? 'Class '
                !! $child.HOW.archetypes.inheritalizable()
                    ?? 'Role '
                    !! '';
            die $type ~ "{$child.^name} can't pun role {$parent.^name} because it has required methods: "
                ~ @required-methods.map({$_.name}).join(', ') ~ '. Did you mean to use "does" instead?';
        }
        else {
            $child.^add_parent($parent.^inheritalize)
        }
    }
    else {
        X::Inheritance::Unsupported.new(
            :child-typename($child.^name),
            :$parent,
        ).throw;
    }
}
multi sub trait_mod:<is>(Mu:U $child, :$DEPRECATED!) {
# add COMPOSE phaser for this child, which will add an ENTER phaser to an
# existing "new" method, or create a "new" method with a call to DEPRECATED
# and a nextsame.
}
multi sub trait_mod:<is>(Mu:U $type, :$rw!) {
    $type.^set_rw;
}
multi sub trait_mod:<is>(Mu:U $type, :$nativesize!) {
    $type.^set_nativesize($nativesize);
}
multi sub trait_mod:<is>(Mu:U $type, :$ctype!) {
    $type.^set_ctype($ctype);
}
multi sub trait_mod:<is>(Mu:U $type, :$unsigned!) {
    $type.^set_unsigned($unsigned);
}
multi sub trait_mod:<is>(Mu:U $type, :$hidden!) {
    $type.^set_hidden;
}
multi sub trait_mod:<is>(Mu:U $type, Mu :$array_type!) {
    $type.^set_array_type($array_type);
}
multi sub trait_mod:<is>(Mu:U $type, *%fail) {
    if %fail.keys[0] !eq $type.^name {
        X::Inheritance::UnknownParent.new(
            :child($type.^name),
            :parent(%fail.keys[0]),
            :suggestions([])
        ).throw;
    } else {
        X::Inheritance::SelfInherit.new(
            :name(%fail.keys[0])
        ).throw;
    }
}

multi sub trait_mod:<is>(Attribute:D $attr, |c ) {
    X::Comp::Trait::Unknown.new(
      file       => $?FILE,
      line       => $?LINE,
      type       => 'is',
      subtype    => c.hash.keys[0],
      declaring  => 'n attribute',
      highexpect => <rw readonly box_target leading_docs trailing_docs>,
    ).throw;
}
multi sub trait_mod:<is>(Attribute:D $attr, :$rw!) {
    $attr.set_rw();
    warn "useless use of 'is rw' on $attr.name()" unless $attr.has_accessor;
}
multi sub trait_mod:<is>(Attribute:D $attr, :$readonly!) {
    $attr.set_readonly();
    warn "useless use of 'is readonly' on $attr.name()" unless $attr.has_accessor;
}
multi sub trait_mod:<is>(Attribute $attr, :$required!) {
    die "'is required' must be Cool" unless nqp::istype($required,Cool);
    $attr.set_required(
      nqp::istype($required,Bool) ?? +$required !! $required
    );
}
multi sub trait_mod:<is>(Attribute $attr, Mu :$default!) {
    $attr.container_descriptor.set_default(nqp::decont($default));
    $attr.container = nqp::decont($default) if nqp::iscont($attr.container);
}
multi sub trait_mod:<is>(Attribute:D $attr, :$box_target!) {
    $attr.set_box_target();
}
multi sub trait_mod:<is>(Attribute:D $attr, :$DEPRECATED!) {
# need to add a COMPOSE phaser to the class, that will add an ENTER phaser
# to the (possibly auto-generated) accessor method.
}
multi sub trait_mod:<is>(Attribute:D $attr, :$leading_docs!) {
    Rakudo::Internals.SET_LEADING_DOCS($attr, $leading_docs);
}

multi sub trait_mod:<is>(Attribute:D $attr, :$trailing_docs!) {
    Rakudo::Internals.SET_TRAILING_DOCS($attr, $trailing_docs);
}

multi sub trait_mod:<is>(Routine:D $r, |c ) {
    my $subtype = c.hash.keys[0];
    $subtype eq 'cached'
      ?? X::Experimental.new(
        feature => "the 'is cached' trait",
        use     => "cached",
        ).throw
      !! X::Comp::Trait::Unknown.new(
        file       => $?FILE,
        line       => $?LINE,
        type       => 'is',
        subtype    => $subtype,
        declaring  => ' ' ~ lc( $r.^name ),
        highexpect => ('rw raw hidden-from-backtrace hidden-from-USAGE',
                       'pure default DEPRECATED inlinable nodal',
                       'prec equiv tighter looser assoc leading_docs trailing_docs' ),
        ).throw;
}
multi sub trait_mod:<is>(Routine:D $r, :$rw!) {
    $r.set_rw();
}
multi sub trait_mod:<is>(Routine:D $r, :$raw!) {
    $r.set_rw(); # for now, until we have real raw handling
}
multi sub trait_mod:<is>(Routine:D $r, :$default!) {
    $r.^mixin: role { method default(--> True) { } }
}
multi sub trait_mod:<is>(Routine:D $r, :$DEPRECATED!) {
    my $new := nqp::istype($DEPRECATED,Bool)
      ?? "something else"
      !! $DEPRECATED;
    $r.add_phaser( 'ENTER', -> { DEPRECATED($new) } );
}
multi sub trait_mod:<is>(Routine:D $r, Mu :$inlinable!) {
    $r.set_inline_info(nqp::decont($inlinable));
}
multi sub trait_mod:<is>(Routine:D $r, :$onlystar!) {
    $r.set_onlystar();
}
multi sub trait_mod:<is>(Routine:D $r, :prec(%spec)!) {
    my role Precedence {
        has %!prec;
        proto method prec(|) { * }
        multi method prec() is raw { %!prec }
        multi method prec(Str:D $key) {
            nqp::ifnull(
              nqp::atkey(nqp::getattr(%!prec,Map,'$!storage'),$key),
              ''
            )
        }
    }
    if nqp::istype($r, Precedence) {
        for %spec {
            $r.prec.{.key} := .value;
        }
    }
    else {
        $r.^mixin(Precedence);
        nqp::bindattr(nqp::decont($r), $r.WHAT, '%!prec', %spec);
    }
    0;
}
# three other trait_mod sub for equiv/tighter/looser in operators.pm
multi sub trait_mod:<is>(Routine $r, :&equiv!) {
    nqp::can(&equiv, 'prec')
        ?? trait_mod:<is>($r, :prec(&equiv.prec))
        !! die "Routine given to equiv does not appear to be an operator";
    $r.prec<assoc>:delete;
}
multi sub trait_mod:<is>(Routine $r, :&tighter!) {
    die "Routine given to tighter does not appear to be an operator"
        unless nqp::can(&tighter, 'prec');
    if !nqp::can($r, 'prec') || ($r.prec<prec> // "") !~~ /<[@:]>/ {
        trait_mod:<is>($r, :prec(&tighter.prec))
    }
    $r.prec<prec> := $r.prec<prec>.subst(/\=/, '@=');
    $r.prec<assoc>:delete;
}
multi sub trait_mod:<is>(Routine $r, :&looser!) {
    die "Routine given to looser does not appear to be an operator"
        unless nqp::can(&looser, 'prec');
    if !nqp::can($r, 'prec') || ($r.prec<prec> // "") !~~ /<[@:]>/ {
        trait_mod:<is>($r, :prec(&looser.prec))
    }
    $r.prec<prec> := $r.prec<prec>.subst(/\=/, ':=');
    $r.prec<assoc>:delete;
}
multi sub trait_mod:<is>(Routine $r, :$assoc!) {
    trait_mod:<is>($r, :prec({ :$assoc }))
}

# Since trait_mod:<is> to set onlystar isn't there at the
# point we wrote its proto, we do it manually here.
BEGIN &trait_mod:<is>.set_onlystar();

multi sub trait_mod:<is>(Parameter:D $param, |c ) {
    X::Comp::Trait::Unknown.new(
      file       => $?FILE,
      line       => $?LINE,
      type       => 'is',
      subtype    => c.hash.keys[0],
      declaring  => ' parameter',
      highexpect => <rw readonly copy required raw leading_docs trailing_docs>,
    ).throw;
}
multi sub trait_mod:<is>(Parameter:D $param, :$readonly!) {
    # This is the default.
}
multi sub trait_mod:<is>(Parameter:D $param, :$rw!) {
    $param.set_rw();
}
multi sub trait_mod:<is>(Parameter:D $param, :$copy!) {
    $param.set_copy();
}
multi sub trait_mod:<is>(Parameter:D $param, :$required!) {
    $param.set_required();
}
multi sub trait_mod:<is>(Parameter:D $param, :$raw!) {
    $param.set_raw();
}
multi sub trait_mod:<is>(Parameter:D $param, :$onearg!) {
    $param.set_onearg();
}
multi sub trait_mod:<is>(Parameter:D $param, :$leading_docs!) {
    Rakudo::Internals.SET_LEADING_DOCS($param, $leading_docs);
}
multi sub trait_mod:<is>(Parameter:D $param, :$trailing_docs!) {
    Rakudo::Internals.SET_TRAILING_DOCS($param, $trailing_docs);
}

# Declare these, as setting mainline doesn't get them automatically (as the
# Mu/Any/Scalar are not loaded).
my $!;
my $/;
my $_;

multi sub trait_mod:<is>(Routine:D \r, :$export!, :$SYMBOL = '&' ~ r.name) {
    my $to_export := r.multi ?? r.dispatcher !! r;
    my @tags = flat 'ALL', (nqp::istype($export,Pair) ?? $export.key() !!
                            nqp::istype($export,Positional) ?? @($export)>>.key !!
                            'DEFAULT');
    Rakudo::Internals.EXPORT_SYMBOL(nqp::decont($SYMBOL), @tags, $to_export);
}
multi sub trait_mod:<is>(Mu:U \type, :$export!) {
    my $exp_name := type.^shortname;
    my @tags = flat 'ALL', (nqp::istype($export,Pair) ?? $export.key !!
                            nqp::istype($export,Positional) ?? @($export)>>.key !!
                            'DEFAULT');
    Rakudo::Internals.EXPORT_SYMBOL($exp_name, @tags, type);
    if nqp::istype(type.HOW, Metamodel::EnumHOW) {
        type.^set_export_callback( {
            for type.^enum_values.keys -> $value_name {
                Rakudo::Internals.EXPORT_SYMBOL(
                  $value_name, @tags, type.WHO{$value_name});
            }
        });
    }
}
# for constants
multi sub trait_mod:<is>(Mu \sym, :$export!, :$SYMBOL!) {
    my @tags = flat 'ALL', (nqp::istype($export,Pair) ?? $export.key !!
                            nqp::istype($export,Positional) ?? @($export)>>.key !!
                            'DEFAULT');
    Rakudo::Internals.EXPORT_SYMBOL($SYMBOL, @tags, sym);
}

multi sub trait_mod:<is>(Block:D $r, :$leading_docs!) {
    Rakudo::Internals.SET_LEADING_DOCS($r, $leading_docs);
}
multi sub trait_mod:<is>(Block:D $r, :$trailing_docs!) {
    Rakudo::Internals.SET_TRAILING_DOCS($r, $trailing_docs);
}

# this should be identical to Mu:D, :leading_docs, otherwise the fallback Block:D, |c
# will catch it and declare "leading_docs" to be an unknown trait.  This is why
# we need this redundant form in spite of having a Block:D candidate above
multi sub trait_mod:<is>(Routine:D $r, :$leading_docs!) {
    Rakudo::Internals.SET_LEADING_DOCS($r, $leading_docs);
}
multi sub trait_mod:<is>(Routine:D $r, :$trailing_docs!) {
    Rakudo::Internals.SET_TRAILING_DOCS($r, $trailing_docs);
}

multi sub trait_mod:<is>(Mu:U $docee, :$leading_docs!) {
    Rakudo::Internals.SET_LEADING_DOCS($docee, $leading_docs);
}
multi sub trait_mod:<is>(Mu:U $docee, :$trailing_docs!) {
    Rakudo::Internals.SET_TRAILING_DOCS($docee.HOW, $trailing_docs);
}

proto sub trait_mod:<does>(|) { * }
multi sub trait_mod:<does>(Mu:U $doee, Mu:U $role) {
    if $role.HOW.archetypes.composable() {
        $doee.^add_role($role)
    }
    elsif $role.HOW.archetypes.composalizable() {
        $doee.^add_role($role.HOW.composalize($role))
    }
    else {
        X::Composition::NotComposable.new(
            target-name => $doee.^name,
            composer    => $role,
        ).throw;
    }
}

proto sub trait_mod:<of>(|) { * }
multi sub trait_mod:<of>(Mu:U $target, Mu:U $type) {
    # XXX Ensure we can do this, die if not.
    $target.^set_of($type);
}
multi sub trait_mod:<of>(Routine:D $target, Mu:U $type) {
    my $sig := $target.signature;
    X::Redeclaration.new(what => 'return type for', symbol => $target,
        postfix => " (previous return type was {$sig.returns.^name})").throw
        if $sig.has_returns;
    $sig.set_returns($type);
    $target.^mixin(Callable.^parameterize($type))
}

multi sub trait_mod:<is>(Routine:D $r, :$hidden-from-backtrace!) {
    $r.^mixin( role is-hidden-from-backtrace {
        method is-hidden-from-backtrace(--> True) { }
    }) if $hidden-from-backtrace;
}

multi sub trait_mod:<is>(Routine:D $r, :$hidden-from-USAGE!) {
    $r.^mixin( role is-hidden-from-USAGE {
        method is-hidden-from-USAGE(--> True) { }
    }) if $hidden-from-USAGE;
}

multi sub trait_mod:<is>(Routine:D $r, :$pure!) {
    $r.^mixin( role is-pure {
        method is-pure (--> True) { }
    }) if $pure;
}

multi sub trait_mod:<is>(Routine:D $r, :$nodal!) {
    $r.^mixin( role is-nodal {
        method nodal(--> True) { }
    }) if $nodal;
}

proto sub trait_mod:<returns>(|) { * }
multi sub trait_mod:<returns>(Routine:D $target, Mu:U $type) {
    my $sig := $target.signature;
    X::Redeclaration.new(what => 'return type for', symbol => $target,
        postfix => " (previous return type was {$sig.returns.^name})").throw
        if $sig.has_returns;
    $sig.set_returns($type);
    $target.^mixin(Callable.^parameterize($type))
}

proto sub trait_mod:<handles>(|) { * }
multi sub trait_mod:<handles>(Attribute:D $target, $thunk) {
    $target does role {
        has $.handles;

        method set_handles($expr) {
            $!handles := $expr;
        }

        method add_delegator_method($attr: $pkg, $meth_name, $call_name) {
            my $meth := method (|c) is rw {
                $attr.get_value(self)."$call_name"(|c)
            };
            $meth.set_name($meth_name);
            $pkg.^add_method($meth_name, $meth);
        }

        method apply_handles($attr: Mu $pkg) {
            sub applier($expr) {
                if $expr.defined() {
                    if nqp::istype($expr,Str) {
                        self.add_delegator_method($pkg, $expr, $expr);
                    }
                    elsif nqp::istype($expr,Pair) {
                        self.add_delegator_method($pkg, $expr.key, $expr.value);
                    }
                    elsif nqp::istype($expr,Positional) {
                        for $expr.list {
                            applier($_);
                        }
                        0;
                    }
                    elsif $expr.isa(Whatever) {
                        $pkg.^add_fallback(
                            -> $obj, $name {
                                so $attr.get_value($obj).can($name);
                            },
                            -> $obj, $name {
                                -> $self, |c {
                                    $attr.get_value($self)."$name"(|c)
                                }
                            });
                    }
                    elsif $expr.isa(HyperWhatever) {
                        $pkg.^add_fallback(
                            -> $obj, $name { True },
                            -> $obj, $name {
                                -> $self, |c {
                                    $attr.get_value($self)."$name"(|c)
                                }
                            });
                    }
                    else {
                        $pkg.^add_fallback(
                            -> $obj, $name {
                                ?($name ~~ $expr)
                            },
                            -> $obj, $name {
                                -> $self, |c {
                                    $attr.get_value($self)."$name"(|c)
                                }
                            });
                    }
                }
                else {
                    $pkg.^add_fallback(
                        -> $obj, $name {
                            ?$expr.can($name)
                        },
                        -> $obj, $name {
                            -> $self, |c {
                                $attr.get_value($self)."$name"(|c)
                            }
                        });
                }
            }
            applier($!handles);
        }
    };
    $target.set_handles($thunk());
}

multi sub trait_mod:<handles>(Method:D $m, &thunk) {
    my $pkg := $m.signature.params[0].type;
    my $call_name := $m.name;
    for flat thunk() -> $meth_name {
        my $meth := method (|c) is rw {
            self."$call_name"()."$meth_name"(|c);
        }
        $meth.set_name($meth_name);
        $pkg.^add_method($meth_name, $meth);
    }
    0;
}

proto sub trait_mod:<will>(|) { * }
multi sub trait_mod:<will>(Attribute:D $attr, |c ) {
    X::Comp::Trait::Unknown.new(
      file       => $?FILE,
      line       => $?LINE,
      type       => 'will',
      subtype    => c.hash.keys[0],
      declaring  => 'n attribute',
      highexpect => <lazy>,
    ).throw;
}
multi sub trait_mod:<will>(Attribute $attr, Mu :$build!) {  # internal usage
    $attr.set_build($build)
}

proto sub trait_mod:<trusts>(|) { * }
multi sub trait_mod:<trusts>(Mu:U $truster, Mu:U $trustee) {
    $truster.^add_trustee($trustee);
}

proto sub trait_mod:<hides>(|) { * }
multi sub trait_mod:<hides>(Mu:U $child, Mu:U $parent) {
    if $parent.HOW.archetypes.inheritable() {
        $child.^add_parent($parent, :hides);
    }
    elsif $parent.HOW.archetypes.inheritalizable() {
        $child.^add_parent($parent.^inheritalize, :hides)
    }
    else {
        X::Inheritance::Unsupported.new(
            :child-typename($child.^name),
            :$parent,
        ).throw;
    }
}

#line 1 SETTING::src/core/Positional.pm
my role Positional[::T = Mu] {
    method of() { T }
}

#line 1 SETTING::src/core/Associative.pm
my role Associative[::TValue = Mu, ::TKey = Str(Any)] {
    method of() { TValue }
    method keyof() { TKey }
}

#line 1 SETTING::src/core/Callable.pm
my class X::Cannot::Capture { ... }

my role Callable[::T = Mu] {
    method of() { T }
    method returns() { T }
    method Capture() { die X::Cannot::Capture.new: :what(self) }
}

#line 1 SETTING::src/core/natives.pm
my native   int is repr('P6int') is Int { }
my native  int8 is repr('P6int') is Int is nativesize( 8) { }
my native int16 is repr('P6int') is Int is nativesize(16) { }
my native int32 is repr('P6int') is Int is nativesize(32) { }
my native int64 is repr('P6int') is Int is nativesize(64) { }

my native   uint is repr('P6int') is Int is unsigned { }
my native  uint8 is repr('P6int') is Int is nativesize( 8) is unsigned { }
my native   byte is repr('P6int') is Int is nativesize( 8) is unsigned { }
my native uint16 is repr('P6int') is Int is nativesize(16) is unsigned { }
my native uint32 is repr('P6int') is Int is nativesize(32) is unsigned { }
my native uint64 is repr('P6int') is Int is nativesize(64) is unsigned { }

my native   num is repr('P6num') is Num { }
my native num32 is repr('P6num') is Num is nativesize(32) { }
my native num64 is repr('P6num') is Num is nativesize(64) { }

my native   str is repr('P6str') is Str { }

#line 1 SETTING::src/core/stubs.pm
# This file contains various stubs. Note that a few are created already
# outside of the setting, such as Mu/Any/Cool, Attribute, Signature/Parameter,
# Code/Block/Routine/Sub/Method and Str/Int/Num. They are built in BOOTSTRAP.pm
# in Perl6::Metamodel for now, though should be a BEGIN block in CORE.setting
# in the end.
my class Exception { ... }
my class X::AdHoc  { ... }
my class FatRat    { ... }
my class Pair      { ... }
my class Promise   { ... }
my class Channel   { ... }
my class X::OutOfRange { ... }
my class X::Dynamic::NotFound { ... }
my class X::SecurityPolicy::Eval { ... }
my class X::Channel::ReceiveOnClosed { ... }

my role QuantHash { ... }
my role Setty { ... }
my class Set { ... }
my class SetHash { ... }

my role Baggy { ... }
my class Bag { ... }
my class BagHash { ... }

my role Mixy { ... }
my class Mix { ... }
my class MixHash { ... }

my class Lock is repr('ReentrantMutex') { ... }
my class Lock::Async { ... }

sub DYNAMIC(\name) is raw {
    nqp::ifnull(
      nqp::getlexdyn(name),
      nqp::stmts(
        nqp::unless(
          nqp::isnull(my $prom := nqp::getlexdyn('$*PROMISE')),
          (my Mu $x := nqp::getlexreldyn(
            nqp::getattr($prom,Promise,'$!dynamic_context'),name)
          )
        ),
        nqp::ifnull(
          $x,
          nqp::stmts(
            (my str $pkgname = nqp::replace(name,1,1,'')),
            nqp::ifnull(
              nqp::atkey(GLOBAL.WHO,$pkgname),
              nqp::ifnull(
                nqp::atkey(PROCESS.WHO,$pkgname),
                Rakudo::Internals.INITIALIZE-DYNAMIC(name)
              )
            )
          )
        )
      )
    )
}

# Set up ClassHOW's auto-gen proto (nested scope so it won't
# actually appear in the setting).
{
    my class Dummy {
        our proto method AUTOGEN(::T $: |) { * }
    }
    Dummy.HOW.set_autogen_proto(&Dummy::AUTOGEN);
}

#line 1 SETTING::src/core/control.pm
my class X::ControlFlow::Return { ... }
my class X::Eval::NoSuchLang { ... }
my class X::Multi::NoMatch { ... }
my class X::NYI { ... }
my class PseudoStash { ... }
my class Label { ... }
class CompUnit::DependencySpecification { ... }

sub THROW(int $type, Mu \arg) {
    my Mu $ex := nqp::newexception();
    nqp::setpayload($ex, arg);
    nqp::setextype($ex, $type);
    nqp::throw($ex);
    arg;
}
sub THROW-NIL(int $type --> Nil) {
    my Mu $ex := nqp::newexception();
#    nqp::setpayload($ex, Nil);
    nqp::setextype($ex, $type);
    nqp::throw($ex);
}

sub RETURN-LIST(Mu \list) is raw {
    my Mu $storage := nqp::getattr(list, List, '$!reified');
    nqp::iseq_i(nqp::elems($storage), 0)
      ?? Nil
      !! (nqp::iseq_i(nqp::elems($storage), 1)
            ?? nqp::shift($storage)
            !! list)
}

proto sub return-rw(|) {*}
multi sub return-rw(--> Nil) {
    nqp::throwpayloadlexcaller(nqp::const::CONTROL_RETURN, Nil);
}
multi sub return-rw(Mu \x --> Nil) {
    nqp::throwpayloadlexcaller(nqp::const::CONTROL_RETURN, x);
}
multi sub return-rw(**@x is raw --> Nil) {
    nqp::throwpayloadlexcaller(nqp::const::CONTROL_RETURN, @x);
}
proto sub return(|) {*}
multi sub return(--> Nil) {
    nqp::throwpayloadlexcaller(nqp::const::CONTROL_RETURN, Nil);
}
multi sub return(Mu \x --> Nil) {
    nqp::throwpayloadlexcaller(nqp::const::CONTROL_RETURN, nqp::p6recont_ro(x));
}
multi sub return(**@x is raw --> Nil) {
    nqp::throwpayloadlexcaller(nqp::const::CONTROL_RETURN, @x);
}

proto sub take-rw(|) { * }
multi sub take-rw()   { die "take-rw without parameters doesn't make sense" }
multi sub take-rw(\x) { THROW(nqp::const::CONTROL_TAKE, x) }
multi sub take-rw(|) {
    THROW(nqp::const::CONTROL_TAKE,RETURN-LIST(nqp::p6argvmarray))
}

proto sub take(|) { * }
multi sub take()   { die "take without parameters doesn't make sense" }
multi sub take(\x) {
    THROW(nqp::const::CONTROL_TAKE, nqp::p6recont_ro(x))
}
multi sub take(|) {
    THROW(
      nqp::const::CONTROL_TAKE,
      nqp::p6recont_ro(RETURN-LIST(nqp::p6argvmarray))
    )
}

proto sub goto(|) { * }
multi sub goto(Label:D \x --> Nil) { x.goto }

proto sub last(|) { * }
multi sub last(--> Nil) { nqp::throwextype(nqp::const::CONTROL_LAST); Nil }
multi sub last(Label:D \x --> Nil) { x.last }

proto sub next(|) { * }
multi sub next(--> Nil) { nqp::throwextype(nqp::const::CONTROL_NEXT); Nil }
multi sub next(Label:D \x --> Nil) { x.next }

proto sub redo(|) { * }
multi sub redo(--> Nil) { nqp::throwextype(nqp::const::CONTROL_REDO); Nil }
multi sub redo(Label:D \x --> Nil) { x.redo }

proto sub succeed(|) { * }
multi sub succeed(--> Nil) { THROW-NIL(nqp::const::CONTROL_SUCCEED) }
multi sub succeed(\x --> Nil) { THROW(nqp::const::CONTROL_SUCCEED, x) }
multi sub succeed(| --> Nil) {
    THROW(nqp::const::CONTROL_SUCCEED,RETURN-LIST(nqp::p6argvmarray))
}

sub proceed(--> Nil) { THROW-NIL(nqp::const::CONTROL_PROCEED) }

sub callwith(|c) is raw {
    $/ := nqp::getlexcaller('$/');
    my Mu $dispatcher := nqp::p6finddispatcher('callwith');
    $dispatcher.exhausted ?? Nil !!
        $dispatcher.call_with_args(|c)
}

sub nextwith(|c) is raw {
    $/ := nqp::getlexcaller('$/');
    my Mu $dispatcher := nqp::p6finddispatcher('nextwith');
    nqp::throwpayloadlexcaller(nqp::const::CONTROL_RETURN, $dispatcher.exhausted
        ?? Nil
        !! $dispatcher.call_with_args(|c))
}

sub callsame() is raw {
    $/ := nqp::getlexcaller('$/');
    my Mu $dispatcher := nqp::p6finddispatcher('callsame');
    $dispatcher.exhausted ?? Nil !!
        $dispatcher.call_with_capture(
            nqp::p6argsfordispatcher($dispatcher))
}

sub nextsame() is raw {
    $/ := nqp::getlexcaller('$/');
    my Mu $dispatcher := nqp::p6finddispatcher('nextsame');
    nqp::throwpayloadlexcaller(nqp::const::CONTROL_RETURN, $dispatcher.exhausted
        ?? Nil
        !! $dispatcher.call_with_capture(nqp::p6argsfordispatcher($dispatcher)))
}

sub lastcall(--> True) {
    nqp::p6finddispatcher('lastcall').last();
}

sub nextcallee() {
    my Mu $dispatcher := nqp::p6finddispatcher('nextsame');
    $dispatcher.exhausted ?? Nil !! $dispatcher.shift_callee()
}

sub samewith(|c) {
    $/ := nqp::getlexcaller('$/');
    my Mu $ctx := nqp::ctxcaller(nqp::ctx());
    until nqp::isnull($ctx) {
        my $caller := nqp::getcodeobj(nqp::ctxcode($ctx));
        if nqp::istype($caller, Routine) {
            if $caller.multi {
                my $dispatcher := $caller.?dispatcher || die "Could not find dispatcher";
                return nqp::istype($caller, Method)
                  ?? $dispatcher(nqp::atkey($ctx, 'self') // $caller.package,|c)
                  !! $dispatcher(|c);
            }
            else {
                return $caller(|c);
            }
        }
        $ctx := nqp::ctxouter($ctx);
    }
    die "Cannot use samewith outside of a routine";
}

sub leave(|) { X::NYI.new(feature => 'leave').throw }

sub emit(\value --> Nil) {
    THROW(nqp::const::CONTROL_EMIT, nqp::p6recont_ro(value));
}
sub done(--> Nil) {
    THROW-NIL(nqp::const::CONTROL_DONE);
}

proto sub die(|) {*};
multi sub die(--> Nil) {
    my $stash  := CALLER::;
    my $payload = $stash<$!>.DEFINITE ?? $stash<$!> !! "Died";
    $payload ~~ Exception
      ?? $payload.throw
      !! X::AdHoc.new(:$payload).throw
}
multi sub die(Exception:U $e --> Nil) {
    X::AdHoc.new(:payload("Died with undefined " ~ $e.^name)).throw;
}
multi sub die($payload --> Nil) {
    $payload ~~ Exception
      ?? $payload.throw
      !! X::AdHoc.new(:$payload).throw
}
multi sub die(|cap ( *@msg ) --> Nil) {
    X::AdHoc.from-slurpy(|cap).throw
}

multi sub warn(*@msg) {
    my $msg = @msg.join || "Warning: something's wrong";
    my $ex := nqp::newexception();
    nqp::setmessage($ex, nqp::unbox_s($msg));
    nqp::setextype($ex, nqp::const::CONTROL_WARN);
    nqp::throw($ex);
    0;
}

constant Inf = nqp::p6box_n(nqp::inf());
constant NaN = nqp::p6box_n(nqp::nan());

# For some reason, we cannot move this to Rakudo::Internals as a class
# method, because then the return value is always HLLized :-(
sub CLONE-HASH-DECONTAINERIZED(\hash) {
    nqp::if(
      nqp::getattr(hash,Map,'$!storage').DEFINITE,
      nqp::stmts(
        (my $clone := nqp::hash),
        (my $iter  := nqp::iterator(nqp::getattr(hash,Map,'$!storage'))),
        nqp::while(
          $iter,
          nqp::bindkey($clone,
            nqp::iterkey_s(nqp::shift($iter)),
            nqp::if(
              nqp::defined(nqp::iterval($iter)),
              nqp::decont(nqp::iterval($iter)).Str,
              ''
            )
          )
        ),
        $clone
      ),
      nqp::hash
    )
}

sub CLONE-LIST-DECONTAINERIZED(*@list) {
    my Mu $list-without := nqp::list();
    nqp::push($list-without, nqp::decont(~$_)) for @list.eager;
    $list-without;
}

#line 1 SETTING::src/core/Mu.pm
my class X::Cannot::Lazy             { ... }
my class X::Constructor::Positional  { ... }
my class X::Method::NotFound         { ... }
my class X::Method::InvalidQualifier { ... }
my class X::Attribute::Required      { ... }

my class Mu { # declared in BOOTSTRAP

    method self { self }

    method sink(--> Nil) { }

    proto method ACCEPTS(|) { * }
    multi method ACCEPTS(Mu:U: Any \topic) {
        nqp::p6bool(nqp::istype(topic, self))
    }
    multi method ACCEPTS(Mu:U: Mu:U \topic) {
        nqp::p6bool(nqp::istype(topic, self))
    }

    method WHERE() {
        nqp::p6box_i(nqp::where(self))
    }

    proto method WHICH(|) {*}
    multi method WHICH(Mu:U:) {
        nqp::box_s(
            nqp::concat(
                nqp::concat(nqp::unbox_s(self.^name), '|U'),
                nqp::objectid(self)
            ),
            ObjAt
        )
    }
    multi method WHICH(Mu:D:) {
        nqp::box_s(
            nqp::concat(
                nqp::concat(nqp::unbox_s(self.^name), '|'),
                nqp::objectid(self)
            ),
            ObjAt
        )
    }

    proto method iterator(|) { * }
    multi method iterator(Mu:) {
        my $buf := nqp::create(IterationBuffer);
        $buf.push(Mu);
        # note: cannot use R:I.OneValue, as that doesn't (and shouldn't)
        # take Mu for the value to produce, as Mu is used to indicate
        # exhaustion.
        Rakudo::Iterator.ReifiedList($buf)
    }

    proto method split(|) { * }
    proto method splice(|) is nodal { * }

    method emit {
        emit self;
    }
    method take {
        take self;
    }
    method return-rw(|) {  # same code as control.pm's return-rw
        my $list := RETURN-LIST(nqp::p6argvmarray());
        nqp::throwpayloadlexcaller(nqp::const::CONTROL_RETURN, $list);
        $list;
    }
    method return(|) {  # same code as control.pm's return
        my $list := RETURN-LIST(nqp::p6argvmarray());
        nqp::throwpayloadlexcaller(nqp::const::CONTROL_RETURN, nqp::p6recont_ro($list));
        $list;
    }

    proto method WHY(|) { * }
    multi method WHY(Mu:) {
        my Mu $why;

        my role Suggestion[$name] {
            method gist {
                "No documentation available for type '$name'.
Perhaps it can be found at https://docs.perl6.org/type/$name"
            }
        }

        if nqp::can(self.HOW, 'WHY') {
            $why := self.HOW.WHY;
        }

        if $why.defined && !$.defined #`(ie. we're a type object) {
            $why.set_docee(self);
        }
        $why // Nil but Suggestion[self.^name]
    }

    method set_why($why) {
        self.HOW.set_why($why);
    }

    proto method Bool() {*}
    multi method Bool(Mu:U: --> False) { }
    multi method Bool(Mu:D:) { self.defined }

    method so()  { self.Bool }
    method not() { self ?? False !! True }

    method defined() {
        nqp::p6bool(nqp::isconcrete(self))
    }

    proto method new(|) { * }
    multi method new(*%attrinit) {
        nqp::if(
          nqp::eqaddr(
            (my $bless := nqp::findmethod(self,'bless')),
            nqp::findmethod(Mu,'bless')
          ),
          nqp::create(self).BUILDALL(Empty, %attrinit),
          nqp::invokewithcapture($bless,nqp::usecapture)
        )
    }
    multi method new($, *@) {
        X::Constructor::Positional.new(:type( self )).throw();
    }

    proto method is-lazy (|) { * }
    multi method is-lazy(Mu: --> False) { }

    method CREATE() {
        nqp::create(self)
    }

    method bless(*%attrinit) {
        nqp::create(self).BUILDALL(Empty, %attrinit);
    }

    method BUILDALL(Mu:D: @autovivs, %attrinit) {
        my $init := nqp::getattr(%attrinit,Map,'$!storage');
        # Get the build plan. Note that we do this "low level" to
        # avoid the NQP type getting mapped to a Rakudo one, which
        # would get expensive.
        my $bp := nqp::findmethod(self.HOW,'BUILDALLPLAN')(self.HOW, self);
        my int $count = nqp::elems($bp);
        my int $i = -1;

        nqp::while(
          nqp::islt_i($i = nqp::add_i($i,1),$count),

          nqp::if(
            nqp::istype((my $task := nqp::atpos($bp,$i)),Callable),
            nqp::if(                             # BUILD/TWEAK
              nqp::istype(
                (my $build := nqp::if(
                  nqp::elems($init),
                  $task(self,|%attrinit),
                  $task(self)
                )),
                Failure
              ),
              return $build
            ),

            nqp::if(                             # not just calling
              (my int $code = nqp::atpos($task,0)),

              nqp::if(                           # >0
                nqp::isle_i($code,3),
                nqp::if(                         # 1|2|3
                  nqp::existskey($init,nqp::atpos($task,3)),
                  nqp::if(                       # can initialize
                    nqp::iseq_i($code,1),
                    nqp::bindattr_i(self,        # 1
                      nqp::atpos($task,1),
                      nqp::atpos($task,2),
                      nqp::decont(%attrinit.AT-KEY(nqp::atpos($task,3)))
                    ),
                    nqp::if(
                      nqp::iseq_i($code,2),
                      nqp::bindattr_n(self,      # 2
                        nqp::atpos($task,1),
                        nqp::atpos($task,2),
                        nqp::decont(%attrinit.AT-KEY(nqp::atpos($task,3)))
                      ),
                      nqp::bindattr_s(self,      # 3
                        nqp::atpos($task,1),
                        nqp::atpos($task,2),
                        nqp::decont(%attrinit.AT-KEY(nqp::atpos($task,3)))
                      )
                    )
                  )
                ),

                nqp::if(
                  nqp::iseq_i($code,4),
                  nqp::unless(                   # 4
                    nqp::attrinited(self,
                      nqp::atpos($task,1),
                      nqp::atpos($task,2)
                    ),
                    nqp::if(
                      nqp::istype(nqp::atpos($task,3),Block),
                      nqp::stmts(
                        (my \attr := nqp::getattr(self,
                          nqp::atpos($task,1),
                          nqp::atpos($task,2)
                        )),
                        (attr = nqp::atpos($task,3)(self,attr))
                      ),
                      nqp::getattr(self,nqp::atpos($task,1),nqp::atpos($task,2)) =
                        nqp::atpos($task,3)
                    )
                  ),

                  nqp::if(
                    nqp::iseq_i($code,5),
                    nqp::if(                     # 5
                      nqp::iseq_i(my $int = nqp::getattr_i(self,
                        nqp::atpos($task,1),
                        nqp::atpos($task,2)
                      ), 0),
                      nqp::bindattr_i(self,
                        nqp::atpos($task,1),
                        nqp::atpos($task,2),
                        nqp::if(
                          nqp::istype(nqp::atpos($task,3),Block),
                          (nqp::atpos($task,3)(self,$int)),
                          nqp::atpos($task,3)
                        )
                      )
                    ),

                    nqp::if(
                      nqp::iseq_i($code,6),
                      nqp::if(                   # 6
                        nqp::iseq_n(my num $num = nqp::getattr_n(self,
                          nqp::atpos($task,1),
                          nqp::atpos($task,2)
                        ), 0e0),
                        nqp::bindattr_n(self,
                          nqp::atpos($task,1),
                          nqp::atpos($task,2),
                          nqp::if(
                            nqp::istype(nqp::atpos($task,3),Block),
                            (nqp::atpos($task,3)(self,$num)),
                            nqp::atpos($task,3)
                          )
                        )
                      ),

                      nqp::if(
                        nqp::iseq_i($code,7),
                        nqp::if(                 # 7
                          nqp::isnull_s(my str $str = nqp::getattr_s(self,
                            nqp::atpos($task,1),
                            nqp::atpos($task,2)
                          )),
                          nqp::bindattr_s(self,
                            nqp::atpos($task,1),
                            nqp::atpos($task,2),
                            nqp::if(
                              nqp::istype(nqp::atpos($task,3),Block),
                              (nqp::atpos($task,3)(self,$str)),
                              nqp::atpos($task,3)
                            )
                          )
                        ),

                      nqp::if(
                        nqp::iseq_i($code,8),
                        nqp::unless(             # 8
                          nqp::attrinited(self,
                            nqp::atpos($task,1),
                            nqp::atpos($task,2)
                          ),
                          X::Attribute::Required.new(
                            name => nqp::atpos($task,2),
                            why  => nqp::atpos($task,3)
                          ).throw
                        ),

                        nqp::if(
                          nqp::iseq_i($code,9),
                          nqp::bindattr(self,    # 9
                            nqp::atpos($task,1),
                            nqp::atpos($task,2),
                            (nqp::atpos($task,3)())
                          ),
                          nqp::if(
                            nqp::iseq_i($code,11),
                            nqp::if(             # 11
                              nqp::existskey($init,nqp::atpos($task,3)),
                              (nqp::getattr(self,
                                nqp::atpos($task,1),nqp::atpos($task,2))
                                = %attrinit.AT-KEY(nqp::atpos($task,3))),
                              nqp::bindattr(self,
                                nqp::atpos($task,1),nqp::atpos($task,2),
                                nqp::list
                              )
                            ),
                            nqp::if(
                              nqp::iseq_i($code,12),
                              nqp::if(           # 12
                                nqp::existskey($init,nqp::atpos($task,3)),
                                (nqp::getattr(self,
                                  nqp::atpos($task,1),nqp::atpos($task,2))
                                  = %attrinit.AT-KEY(nqp::atpos($task,3))),
                                nqp::bindattr(self,
                                  nqp::atpos($task,1),nqp::atpos($task,2),
                                  nqp::hash
                                )
                              ),
                              die('Invalid ' ~ self.^name ~ ".BUILDALL plan: $code"),
                  ))))))))),

                  nqp::if(                       # 0
                    nqp::existskey($init,nqp::atpos($task,3)),
                    (nqp::getattr(self,nqp::atpos($task,1),nqp::atpos($task,2))
                      = %attrinit.AT-KEY(nqp::atpos($task,3))),
                  )
                )
              )
            );
            self
        }

        method BUILD_LEAST_DERIVED(%attrinit) {
            my $init := nqp::getattr(%attrinit,Map,'$!storage');
            # Get the build plan for just this class.
            my $bp := nqp::findmethod(self.HOW,'BUILDPLAN')(self.HOW,self);
            my int $count = nqp::elems($bp);
            my int $i     = -1;

        nqp::while(
          nqp::islt_i($i = nqp::add_i($i,1),$count),

          nqp::if(
            nqp::istype((my $task := nqp::atpos($bp,$i)),Callable),
            nqp::if(                             # BUILD/TWEAK
              nqp::istype(
                (my $build := nqp::if(
                  nqp::elems($init),
                  $task(self,|%attrinit),
                  $task(self)
                )),
                Failure
              ),
              return $build
            ),

            nqp::if(                             # not just calling
              (my int $code = nqp::atpos($task,0)),

              nqp::if(                           # >0
                nqp::isle_i($code,3),
                nqp::if(                         # 1|2|3
                  nqp::existskey($init,nqp::atpos($task,3)),
                  nqp::if(                       # can initialize
                    nqp::iseq_i($code,1),
                    nqp::bindattr_i(self,        # 1
                      nqp::atpos($task,1),
                      nqp::atpos($task,2),
                      nqp::decont(%attrinit.AT-KEY(nqp::atpos($task,3)))
                    ),
                    nqp::if(
                      nqp::iseq_i($code,2),
                      nqp::bindattr_n(self,      # 2
                        nqp::atpos($task,1),
                        nqp::atpos($task,2),
                        nqp::decont(%attrinit.AT-KEY(nqp::atpos($task,3)))
                      ),
                      nqp::bindattr_s(self,      # 3
                        nqp::atpos($task,1),
                        nqp::atpos($task,2),
                        nqp::decont(%attrinit.AT-KEY(nqp::atpos($task,3)))
                      )
                    )
                  )
                ),

                nqp::if(
                  nqp::iseq_i($code,4),
                  nqp::unless(                   # 4
                    nqp::attrinited(self,
                      nqp::atpos($task,1),
                      nqp::atpos($task,2)
                    ),
                    nqp::if(
                      nqp::istype(nqp::atpos($task,3),Block),
                      nqp::stmts(
                        (my \attr := nqp::getattr(self,
                          nqp::atpos($task,1),
                          nqp::atpos($task,2)
                        )),
                        (attr = nqp::atpos($task,3)(self,attr))
                      ),
                      nqp::getattr(self,nqp::atpos($task,1),nqp::atpos($task,2)) =
                        nqp::atpos($task,3)
                    )
                  ),

                  nqp::if(
                    nqp::iseq_i($code,5),
                    nqp::if(                     # 5
                      nqp::iseq_i(my $int = nqp::getattr_i(self,
                        nqp::atpos($task,1),
                        nqp::atpos($task,2)
                      ), 0),
                      nqp::bindattr_i(self,
                        nqp::atpos($task,1),
                        nqp::atpos($task,2),
                        nqp::if(
                          nqp::istype(nqp::atpos($task,3),Block),
                          (nqp::atpos($task,3)(self,$int)),
                          nqp::atpos($task,3)
                        )
                      )
                    ),

                    nqp::if(
                      nqp::iseq_i($code,6),
                      nqp::if(                   # 6
                        nqp::iseq_n(my num $num = nqp::getattr_n(self,
                          nqp::atpos($task,1),
                          nqp::atpos($task,2)
                        ), 0e0),
                        nqp::bindattr_n(self,
                          nqp::atpos($task,1),
                          nqp::atpos($task,2),
                          nqp::if(
                            nqp::istype(nqp::atpos($task,3),Block),
                            (nqp::atpos($task,3)(self,$num)),
                            nqp::atpos($task,3)
                          )
                        )
                      ),

                      nqp::if(
                        nqp::iseq_i($code,7),
                        nqp::if(                 # 7
                          nqp::isnull_s(my str $str = nqp::getattr_s(self,
                            nqp::atpos($task,1),
                            nqp::atpos($task,2)
                          )),
                          nqp::bindattr_s(self,
                            nqp::atpos($task,1),
                            nqp::atpos($task,2),
                            nqp::if(
                              nqp::istype(nqp::atpos($task,3),Block),
                              (nqp::atpos($task,3)(self,$str)),
                              nqp::atpos($task,3)
                            )
                          )
                        ),

                      nqp::if(
                        nqp::iseq_i($code,8),
                        nqp::unless(             # 8
                          nqp::attrinited(self,
                            nqp::atpos($task,1),
                            nqp::atpos($task,2)
                          ),
                          X::Attribute::Required.new(
                            name => nqp::atpos($task,2),
                            why  => nqp::atpos($task,3)
                          ).throw
                        ),

                        nqp::if(
                          nqp::iseq_i($code,9),
                          nqp::bindattr(self,    # 9
                            nqp::atpos($task,1),
                            nqp::atpos($task,2),
                            (nqp::atpos($task,3)())
                          ),
                          nqp::if(
                            nqp::iseq_i($code,10),
                            # Force vivification, for the sake of meta-object
                            # mix-ins at compile time ending up with correctly
                            # shared containers.
                            nqp::stmts(          # 10
                              nqp::getattr(self,
                                nqp::atpos($task,1),
                                nqp::atpos($task,2)
                              ),
                              nqp::while(        # 10's flock together
                                nqp::islt_i(($i = nqp::add_i($i,1)),$count)
                                  && nqp::iseq_i(
                                       nqp::atpos(
                                         ($task := nqp::atpos($bp,$i)),
                                         0
                                       ),10
                                     ),
                                nqp::getattr(self,
                                  nqp::atpos($task,1),
                                  nqp::atpos($task,2)
                                )
                              ),
                              ($i = nqp::sub_i($i,1))
                            ),
                            nqp::if(
                              nqp::iseq_i($code,11),
                              nqp::if(           # 11
                                nqp::existskey($init,nqp::atpos($task,3)),
                                (nqp::getattr(self,
                                  nqp::atpos($task,1),nqp::atpos($task,2))
                                  = %attrinit.AT-KEY(nqp::atpos($task,3))),
                                nqp::bindattr(self,
                                  nqp::atpos($task,1),nqp::atpos($task,2),
                                  nqp::list
                                )
                              ),
                              nqp::if(
                                nqp::iseq_i($code,12),
                                nqp::if(         # 12
                                  nqp::existskey($init,nqp::atpos($task,3)),
                                  (nqp::getattr(self,
                                    nqp::atpos($task,1),nqp::atpos($task,2))
                                    = %attrinit.AT-KEY(nqp::atpos($task,3))),
                                  nqp::bindattr(self,
                                    nqp::atpos($task,1),nqp::atpos($task,2),
                                    nqp::hash
                                  )
                                ),
                                die('Invalid ' ~ self.^name ~ ".BUILD_LEAST_DERIVED plan: $code"),
              )))))))))),

              nqp::if(                           # 0
                nqp::existskey($init,nqp::atpos($task,3)),
                (nqp::getattr(self,nqp::atpos($task,1),nqp::atpos($task,2))
                  = %attrinit.AT-KEY(nqp::atpos($task,3))),
              )
            )
          )
        );
        self
    }

    proto method Numeric(|) { * }
    multi method Numeric(Mu:U \v:) {
        warn "Use of uninitialized value of type {self.^name} in numeric context";
        0
    }
    proto method Real(|) { * }
    multi method Real(Mu:U \v:) {
        warn "Use of uninitialized value of type {self.^name} in numeric context";
        0
    }

    proto method Str(|) { * }
    multi method Str(Mu:U \v:) {
        my $name = (defined($*VAR_NAME) ?? $*VAR_NAME !! try v.VAR.?name) // '';
        $name   ~= ' ' if $name ne '';
        warn "Use of uninitialized value {$name}of type {self.^name} in string"
                ~ " context.\nMethods .^name, .perl, .gist, or .say can be"
                ~ " used to stringify it to something meaningful.";
        ''
    }
    multi method Str(Mu:D:) {
        nqp::if(
          nqp::eqaddr(self,IterationEnd),
          "IterationEnd",
          self.^name ~ '<' ~ nqp::tostr_I(nqp::objectid(self)) ~ '>'
        )
    }

    proto method Stringy(|) { * }
    multi method Stringy(Mu:U \v:) {
        my $*VAR_NAME = try v.VAR.?name;
        self.Str
    }
    multi method Stringy(Mu:D $:) { self.Str }

    method item(Mu \item:) is raw { item }

    proto method say(|) { * }
    multi method say() { say(self) }
    method print() { print(self) }
    method put() { put(self) }
    method note() { note(self) }

    method gistseen(Mu:D \SELF: $id, $gist, *%named) {
        if nqp::not_i(nqp::isnull(nqp::getlexdyn('$*gistseen'))) {
            my \sems := $*gistseen;
            my str $WHICH = nqp::unbox_s(self.WHICH);
            if nqp::existskey(sems,$WHICH) && nqp::atkey(sems,$WHICH) {
                nqp::bindkey(sems,$WHICH,2);
                "{$id}_{nqp::objectid(SELF)}";
            }
            else {
                nqp::bindkey(sems,$WHICH,1);
                my $result   := $gist(|%named);
                my int $value = nqp::atkey(sems,$WHICH);
                nqp::deletekey(sems,$WHICH);
                $value == 2
                  ?? "(\\{$id}_{nqp::objectid(SELF)} = $result)"
                  !! $result
            }
        }
        else {
            my $*gistseen := nqp::hash("TOP",1);
            SELF.gistseen($id,$gist,|%named)
        }
    }

    proto method gist(|) { * }
    multi method gist(Mu:U:) { '(' ~ self.^shortname ~ ')' }
    multi method gist(Mu:D:) { self.perl }

    method perlseen(Mu:D \SELF: $id, $perl, *%named) {
        my $sigil = nqp::iseq_s($id, 'Array') ?? '@'
            !! nqp::iseq_s($id, 'Hash') ?? '%' !! '\\';
        if nqp::not_i(nqp::isnull(nqp::getlexdyn('$*perlseen'))) {
            my \sems := $*perlseen;
            my str $WHICH = nqp::unbox_s(self.WHICH);
            if nqp::existskey(sems,$WHICH) && nqp::atkey(sems,$WHICH) {
                nqp::bindkey(sems,$WHICH,2);
                $sigil x nqp::isne_s($sigil, '\\') ~ "{$id}_{nqp::objectid(SELF)}";
            }
            else {
                nqp::bindkey(sems,$WHICH,1);
                my $result := $perl(|%named);
                my int $value = nqp::atkey(sems,$WHICH);
                nqp::deletekey(sems,$WHICH);
                $value == 2
                  ?? nqp::iseq_s($sigil, '\\')
                    ??  "(my {$sigil}{$id}_{nqp::objectid(SELF)} = $result)"
                    !! "((my {$sigil}{$id}_{nqp::objectid(SELF)}) = $result)"
                  !! $result
            }
        }
        else {
            my $*perlseen := nqp::hash("TOP",1);
            SELF.perlseen($id,$perl,|%named)
        }
    }

    proto method perl(|) { * }
    multi method perl(Mu:U:) { self.^name }
    multi method perl(Mu:D:) {
        nqp::if(
          nqp::eqaddr(self,IterationEnd),
          "IterationEnd",
          self.perlseen(self.^name, {
              my @attrs;
              for self.^attributes().flat.grep: { .has_accessor } -> $attr {
                  my $name := substr($attr.Str,2);
                  @attrs.push: $name ~ ' => ' ~ $attr.get_value(self).perl
              }
              self.^name ~ '.new' ~ ('(' ~ @attrs.join(', ') ~ ')' if @attrs)
          })
        )
    }

    proto method DUMP(|) { * }
    multi method DUMP(Mu:U:) { self.perl }
    multi method DUMP(Mu:D: :$indent-step = 4, :%ctx?) {
        return DUMP(self, :$indent-step) unless %ctx;

        my Mu $attrs := nqp::list();
        for self.^attributes.flat -> $attr {
            my str $name       = $attr.name;
            my str $acc_name   = nqp::substr($name, 2, nqp::chars($name) - 2);
            my str $build_name = $attr.has_accessor ?? $acc_name !! $name;

            my Mu $value;
            if    $attr.has_accessor {
                $value := self."$acc_name"();
            }
            elsif nqp::can($attr, 'get_value') {
                $value := $attr.get_value(self);
            }
            elsif nqp::can($attr, 'package') {
                my Mu $decont  := nqp::decont(self);
                my Mu $package := $attr.package;

                $value := do given nqp::p6box_i(nqp::objprimspec($attr.type)) {
                    when 0 {              nqp::getattr(  $decont, $package, $name)  }
                    when 1 { nqp::p6box_i(nqp::getattr_i($decont, $package, $name)) }
                    when 2 { nqp::p6box_n(nqp::getattr_n($decont, $package, $name)) }
                    when 3 { nqp::p6box_s(nqp::getattr_s($decont, $package, $name)) }
                };
            }
            else {
                next;
            }

            nqp::push($attrs, $build_name);
            nqp::push($attrs, $value);
        }

        self.DUMP-OBJECT-ATTRS($attrs, :$indent-step, :%ctx);
    }
    method DUMP-PIECES(@pieces: $before, $after = ')', :$indent = @pieces > 1, :$indent-step) {
        $indent ?? $before ~ "\n" ~ @pieces.join(",\n").indent($indent-step) ~ "\n" ~ $after
                !! $before ~        @pieces.join(', ')                              ~ $after;
    }
    method DUMP-OBJECT-ATTRS(|args (*@args, :$indent-step, :%ctx, :$flags?)) {
        my Mu  $attrs := nqp::clone(nqp::captureposarg(nqp::usecapture(), 1));
        my str $where  = nqp::base_I(nqp::where(self), 16);
        my str $before = ($flags if defined $flags) ~ self.^name ~ '<' ~ %ctx{$where} ~ '>(';

        my @pieces;
        while $attrs {
            my str $name  = nqp::shift($attrs);
            my Mu $value := nqp::shift($attrs);
            @pieces.push: ':' ~ $name ~ '(' ~ DUMP($value, :$indent-step, :%ctx) ~ ')';
        }
        @pieces.DUMP-PIECES($before, :$indent-step);
    }

    proto method isa(|) { * }
    multi method isa(Mu \SELF: Mu $type) {
        nqp::p6bool(SELF.^isa($type.WHAT))
    }
    multi method isa(Mu \SELF: Str:D $name) {
        my @mro = SELF.^mro;
        my int $mro_count = @mro.elems;
        my int $i = -1;

        return True
          if @mro[$i].^name eq $name
          while nqp::islt_i(++$i,$mro_count);

        False
    }

    method does(Mu \SELF: Mu $type) {
        nqp::p6bool(nqp::istype(SELF, $type.WHAT))
    }

    method can(Mu \SELF: $name) {
        SELF.^can($name)
    }

    proto method clone (|) { * }
    multi method clone(Mu:U: *%twiddles) {
        %twiddles and die 'Cannot set attribute values when cloning a type object';
        self
    }
    multi method clone(Mu:D: *%twiddles) {
        my $cloned := nqp::clone(self);
        if %twiddles.elems {
            for self.^attributes.flat -> $attr {
                my $name    := $attr.name;
                my $package := $attr.package;

                nqp::bindattr($cloned, $package, $name,
                  nqp::clone(nqp::getattr($cloned, $package, $name).VAR)
                ) if nqp::attrinited(self, $package, $name)
                    and nqp::not_i(nqp::objprimspec($attr.type));

                my $acc_name := substr($name,2);
                nqp::getattr($cloned, $package, $name) =
                  nqp::decont(%twiddles{$acc_name})
                  if $attr.has_accessor && %twiddles.EXISTS-KEY($acc_name);
            }
        }
        else {
            for self.^attributes.flat -> $attr {
                unless nqp::objprimspec($attr.type) {
                    my $name     := $attr.name;
                    my $package  := $attr.package;
                    if nqp::attrinited(self, $package, $name) {
                        my $attr_val := nqp::getattr($cloned, $package, $name);
                        nqp::bindattr($cloned,
                          $package, $name, nqp::clone($attr_val.VAR))
                            if nqp::iscont($attr_val);
                    }
                }
            }
        }
        $cloned
    }

    method Capture() {
        my $attrs := nqp::hash;
        for self.^attributes.flat -> $attr {
            if $attr.has_accessor {
                my str $name = substr($attr.name,2);
                nqp::bindkey($attrs,$name,self."$name"())
                  unless nqp::existskey($attrs,$name);
            }
        }
        my $capture := nqp::create(Capture);
        nqp::bindattr($capture,Capture,'%!hash',$attrs) if nqp::elems($attrs);
        $capture
    }

    # XXX TODO: Handle positional case.
    method dispatch:<var>(Mu \SELF: $var, |c) is raw {
        $var(SELF, |c)
    }

    method dispatch:<::>(Mu \SELF: $name, Mu $type, |c) is raw {
        unless nqp::istype(SELF, $type) {
            X::Method::InvalidQualifier.new(
                    method          => $name,
                    invocant        => SELF,
                    qualifier-type  => $type,

            ).throw;
        }
        self.^find_method_qualified($type, $name)(SELF, |c)
    }

    method dispatch:<!>(Mu \SELF: \name, Mu \type, |c) is raw {
        my $meth := type.^find_private_method(name);
        $meth ??
            $meth(SELF, |c) !!
            X::Method::NotFound.new(
              invocant => SELF,
              method   => '!' ~ name,
              typename => type.^name,
              :private,
            ).throw;
    }

    method dispatch:<.=>(\mutate: Str() $name, |c) is raw {
        $/ := nqp::getlexcaller('$/');
        mutate = mutate."$name"(|c)
    }

    method dispatch:<.?>(Mu \SELF: Str() $name, |c) is raw {
        nqp::can(SELF,$name) ??
            SELF."$name"(|c) !!
            Nil
    }

    method dispatch:<.+>(Mu \SELF: $name, |c) {
        my @result := SELF.dispatch:<.*>($name, |c);
        if @result.elems == 0 {
            X::Method::NotFound.new(
              invocant => SELF,
              method   => $name,
              typename => SELF.^name,
            ).throw;
        }
        @result
    }

    method dispatch:<.*>(Mu \SELF: \name, |c) {
        my @mro = SELF.^mro;
        my int $mro_count = @mro.elems;
        my $results := nqp::create(IterationBuffer);
        my int $i = -1;
        while nqp::islt_i(++$i,$mro_count) {
            my $obj = @mro[$i];
            my $meth = ($obj.^method_table){name};
            $meth = ($obj.^submethod_table){name} if !$meth && $i == 0;
            nqp::push($results,$meth(SELF, |c))    if $meth;
        }
        nqp::p6bindattrinvres(nqp::create(List),List,'$!reified',$results)
    }

    method dispatch:<hyper>(Mu \SELF: Str() $name, |c) {
        nqp::if(
          nqp::can(List,$name) && nqp::can(List.can($name).AT-POS(0),"nodal"),
          nqp::if(
            c,
            HYPER( sub (\obj) is nodal { obj."$name"(|c) }, SELF ),
            HYPER( sub (\obj) is nodal { obj."$name"() }, SELF )
          ),
          nqp::if(
            c,
            HYPER( -> \obj { obj."$name"(|c) }, SELF ),
            HYPER( -> \obj { obj."$name"() }, SELF )
          )
        )
    }

    method WALK(:$name!, :$canonical, :$ascendant, :$descendant, :$preorder, :$breadth,
                :$super, :$omit, :$include) {
        # First, build list of classes in the order we'll need them.
        my @classes;
        if $super {
            @classes = self.^parents(:local);
        }
        elsif $breadth {
            my @search_list = self.WHAT;
            while @search_list {
                append @classes, @search_list;
                my @new_search_list;
                for @search_list -> $current {
                    for flat $current.^parents(:local) -> $next {
                        unless @new_search_list.grep({ $^c.WHAT =:= $next.WHAT }) {
                            push @new_search_list, $next;
                        }
                    }
                }
                @search_list = @new_search_list;
            }
        } elsif $ascendant | $preorder {
            sub build_ascendent(Mu $class) {
                unless @classes.grep({ $^c.WHAT =:= $class.WHAT }) {
                    push @classes, $class;
                    for flat $class.^parents(:local) {
                        build_ascendent($^parent);
                    }
                }
            }
            build_ascendent(self.WHAT);
        } elsif $descendant {
            sub build_descendent(Mu $class) {
                unless @classes.grep({ $^c.WHAT =:= $class.WHAT }) {
                    for flat $class.^parents(:local) {
                        build_descendent($^parent);
                    }
                    push @classes, $class;
                }
            }
            build_descendent(self.WHAT);
        } else {
            # Canonical, the default (just whatever the meta-class says) with us
            # on the start.
            @classes = self.^mro();
        }

        # Now we have classes, build method list.
        my @methods;
        for @classes -> $class {
            if (!defined($include) || $include.ACCEPTS($class)) &&
              (!defined($omit) || !$omit.ACCEPTS($class)) {
                try {
                    for flat $class.^methods(:local) -> $method {
                        my $check_name = $method.?name;
                        if $check_name.defined && $check_name eq $name {
                            @methods.push($method);
                        }
                    }
                    0;
                }
            }
        }

        @methods;
    }
}


proto sub defined(Mu) is pure { * }
multi sub defined(Mu \x) { x.defined }

proto sub infix:<~~>(Mu \topic, Mu \matcher) { * }
multi sub infix:<~~>(Mu \topic, Mu \matcher) {
    matcher.ACCEPTS(topic).Bool;
}

proto sub infix:<!~~>(Mu \topic, Mu \matcher) { * }
multi sub infix:<!~~>(Mu \topic, Mu \matcher) {
    matcher.ACCEPTS(topic).not;
}

proto sub infix:<=:=>(Mu $?, Mu $?) is pure { * }
multi sub infix:<=:=>($?)      { Bool::True }
multi sub infix:<=:=>(Mu \a, Mu \b) {
    nqp::p6bool(nqp::eqaddr(a, b));
}

proto sub infix:<eqv>(Any $?, Any $?) is pure { * }
multi sub infix:<eqv>($?)            { Bool::True }

# Last ditch snapshot semantics.  We shouldn't come here too often, so
# please do not change this to be faster but wronger.  (Instead, add
# specialized multis for datatypes that can be tested piecemeal.)
multi sub infix:<eqv>(Any:U \a, Any:U \b) {
    nqp::p6bool(nqp::eqaddr(nqp::decont(a),nqp::decont(b)))
}
multi sub infix:<eqv>(Any:D \a, Any:U \b) { False }
multi sub infix:<eqv>(Any:U \a, Any:D \b) { False }
multi sub infix:<eqv>(Any:D \a, Any:D \b) {
    nqp::p6bool(
      nqp::eqaddr(a,b)
        || (nqp::eqaddr(a.WHAT,b.WHAT) && nqp::iseq_s(a.perl,b.perl))
    )
}

multi sub infix:<eqv>(Iterable:D \a, Iterable:D \b) {
    nqp::p6bool(
      nqp::unless(
        nqp::eqaddr(nqp::decont(a),nqp::decont(b)),
        nqp::if(                                 # not same object
          nqp::eqaddr(a.WHAT,b.WHAT),
          nqp::if(                               # same type
            a.is-lazy,
            nqp::if(                             # a lazy
              b.is-lazy,
              die(X::Cannot::Lazy.new: :action<eqv>) # a && b lazy
            ),
            nqp::if(                             # a NOT lazy
              b.is-lazy,
              0,                                 # b lazy
              nqp::if(                           # a && b NOT lazy
                nqp::iseq_i((my int $elems = a.elems),b.elems),
                nqp::stmts(                      # same # elems
                  (my int $i = -1),
                  nqp::while(
                    nqp::islt_i(($i = nqp::add_i($i,1)),$elems) # not exhausted
                      && a.AT-POS($i) eqv b.AT-POS($i),         # still same
                    nqp::null
                  ),
                  nqp::iseq_i($i,$elems)         # exhausted = success!
                )
              )
            )
          )
        )
      )
    )
}

sub DUMP(|args (*@args, :$indent-step = 4, :%ctx?)) {
    my Mu $capture := nqp::usecapture();
    my Mu $topic   := nqp::captureposarg($capture, 0);

    return "\x25b6" ~ DUMP(nqp::decont($topic), :$indent-step, :%ctx)
        if nqp::iscont($topic);
    return '(null)' if nqp::isnull($topic);

    my str $type  = $topic.^name;
    my str $where = nqp::base_I(nqp::where($topic), 16);

    if %ctx{$where} -> $obj_num {
        nqp::istype($topic, Bool) ?? $topic.DUMP(:$indent-step, :%ctx)  !!
        nqp::isconcrete($topic)   ?? '=' ~ $type ~ '<' ~ $obj_num ~ '>' !!
        nqp::can($topic, 'DUMP')  ?? $topic.DUMP(:$indent-step, :%ctx)  !!
                                     $type;
    }
    else {
        my int $obj_num = %ctx.elems + 1;
        %ctx{$where} = $obj_num;

        if    nqp::islist($topic) {
            my str $id = $type ~ '<' ~ $obj_num ~ '>';

            my @pieces;
            $topic := nqp::clone($topic);
            while $topic {
                my Mu $x := nqp::shift($topic);
                @pieces.push: DUMP($x, :$indent-step, :%ctx);
            }

            @pieces.DUMP-PIECES($id ~ '(', :$indent-step);
        }
        elsif nqp::ishash($topic) {
            my str $id = $type ~ '<' ~ $obj_num ~ '>';

            my @pieces;
            {
                for $topic.pairs {
                    @pieces.push: $_.key ~ ' => ' ~ DUMP($_.value, :$indent-step, :%ctx);
                }
                CATCH { default { @pieces.push: '...' } }
            }

            @pieces.DUMP-PIECES($id ~ '(', :$indent-step);
        }
        elsif nqp::can($topic, 'DUMP') {
            $topic.DUMP(:$indent-step, :%ctx);
        }
        else {
            given nqp::p6box_i(nqp::captureposprimspec($capture, 0)) {
                when 0 { $type ~ '<' ~ $obj_num ~ '>(...)' }
                when 1 { nqp::captureposarg_i($capture, 0).DUMP(:$indent-step, :%ctx) }
                when 2 { nqp::captureposarg_n($capture, 0).DUMP(:$indent-step, :%ctx) }
                when 3 { nqp::captureposarg_s($capture, 0).DUMP(:$indent-step, :%ctx) }
            }
        }
    }
}

# U+2212 minus (forward call to regular minus)
proto sub  infix:<>(|)  is pure { * }
multi sub  infix:<>(|c)         {  infix:<->(|c) }
proto sub prefix:<>(|)  is pure { * }
multi sub prefix:<>(|c)         { prefix:<->(|c) }

# These must collapse Junctions
proto sub so(Mu $) {*}
multi sub so(Mu $x)  { ?$x }
proto sub not(Mu $) {*}
multi sub not(Mu $x) { !$x }

Metamodel::ClassHOW.exclude_parent(Mu);

#line 1 SETTING::src/core/Stringy.pm
my class X::NYI { ... }

my role Stringy { }

multi sub infix:<eqv>(Stringy:D \a, Stringy:D \b) {
    nqp::p6bool(
      nqp::unless(
        nqp::eqaddr(a,b),
        nqp::eqaddr(a.WHAT,b.WHAT) && nqp::iseq_i(a cmp b,0)  # XXX RT #128092
      )
    )
}

proto sub prefix:<~>($) is pure { * }
multi sub prefix:<~>(\a)          { a.Stringy }
multi sub prefix:<~>(int $a)      { nqp::p6box_s($a) }
multi sub prefix:<~>(num $a)      { nqp::p6box_s($a) }

proto sub infix:<~>(|) is pure { * }
multi sub infix:<~>($x = '')       { $x.Stringy }
multi sub infix:<~>(\a, \b)        { a.Stringy ~ b.Stringy }

proto sub infix:<x>(Mu $?, Mu $?)  is pure { * }
multi sub infix:<x>() { Failure.new("No zero-arg meaning for infix:<x>") }
multi sub infix:<x>($x)            { $x.Stringy }
multi sub infix:<x>($s, Num:D $n) {
    $n == Inf
      ?? Failure.new(X::NYI.new(:feature('Cat object')))
      !! $s.Stringy x $n.Int;
}
multi sub infix:<x>($s, Any:D $n) { $s.Stringy x $n.Int         }
multi sub infix:<x>($s, Any:U $n) { $s.Stringy x $n.Numeric.Int }

proto sub infix:<leg>(Mu $?, Mu $?) is pure { * }
multi sub infix:<leg>(\a, \b)      { a.Stringy cmp b.Stringy }

proto sub infix:<eq>(Mu $?, Mu $?)  is pure { * }
multi sub infix:<eq>($x?)          { Bool::True }
multi sub infix:<eq>(\a, \b)       { a.Stringy eq b.Stringy }

proto sub infix:<ne>(Mu $?, Mu $?) is pure { * }
multi sub infix:<ne>($x?)            { Bool::True }
multi sub infix:<ne>(Mu \a, Mu \b)   { a !eq b }
multi sub infix:<ne>(Any \a, Any \b) { a.Stringy ne b.Stringy }

proto sub infix:<lt>(Mu $?, Mu $?) is pure { * }
multi sub infix:<lt>($x?)          { Bool::True }
multi sub infix:<lt>(\a, \b)       { a.Stringy lt b.Stringy }

proto sub infix:<le>(Mu $?, Mu $?) is pure { * }
multi sub infix:<le>($x?)          { Bool::True }
multi sub infix:<le>(\a, \b)       { a.Stringy le b.Stringy }

proto sub infix:<gt>(Mu $?, Mu $?) is pure { * }
multi sub infix:<gt>($x?)          { Bool::True }
multi sub infix:<gt>(\a, \b)       { a.Stringy gt b.Stringy }

proto sub infix:<ge>(Mu $?, Mu $?) is pure { * }
multi sub infix:<ge>($x?)          { Bool::True }
multi sub infix:<ge>(\a, \b)       { a.Stringy ge b.Stringy }

proto sub infix:<~|>(Mu $?, Mu $?) is pure { * }
multi sub infix:<~|>($x = '')      { $x.Stringy }
multi sub infix:<~|>(\a, \b)       { a.Stringy ~| b.Stringy }

proto sub infix:<~^>(Mu $?, Mu $?)  is pure { * }
multi sub infix:<~^>($x = '')      { $x.Stringy }
multi sub infix:<~^>(\a, \b)       { a.Stringy ~^ b.Stringy }

proto sub infix:<~&>(Mu $?, Mu $?) is pure { * }
multi sub infix:<~&>() { Failure.new("No zero-arg meaning for infix:<~&>") }
multi sub infix:<~&>($x)           { $x.Stringy }
multi sub infix:<~&>(\a, \b)       { a.Stringy ~& b.Stringy }

proto sub prefix:<~^>(Mu $) is pure { * }
multi sub prefix:<~^>(\a)         { ~^ a.Stringy }

#line 1 SETTING::src/core/Any.pm
my class Pair                   { ... }
my class Range                  { ... }
my class Seq                    { ... }
my class X::Adverb              { ... }
my class X::Bind                { ... }
my class X::Bind::Slice         { ... }
my class X::Bind::ZenSlice      { ... }
my class X::Item                { ... }
my class X::Match::Bool         { ... }
my class X::Pairup::OddNumber   { ... }
my class X::Subscript::Negative { ... }

my role  Numeric { ... }

my class Any { # declared in BOOTSTRAP
    # my class Any is Mu

    multi method ACCEPTS(Any:D: Mu:D \a) { self === a }
    multi method ACCEPTS(Any:D: Mu:U $ --> False) { }
    multi method ACCEPTS(Any:U: Any \topic) { # use of Any on topic to force autothreading
        nqp::p6bool(nqp::istype(topic, self)) # so that all(@foo) ~~ Type works as expected
    }

    proto method EXISTS-KEY(|) is nodal { * }
    multi method EXISTS-KEY(Any:U: $ --> False) { }
    multi method EXISTS-KEY(Any:D: $ --> False) { }

    proto method DELETE-KEY(|) is nodal { * }
    multi method DELETE-KEY(Any:U: $ --> Nil) { }
    multi method DELETE-KEY(Any:D: $) {
        Failure.new("Can not remove values from a {self.^name}")
    }

    proto method DELETE-POS(|) is nodal { * }
    multi method DELETE-POS(Any:U: $pos --> Nil) { }
    multi method DELETE-POS(Any:D: $pos) {
        Failure.new("Can not remove elements from a {self.^name}")
    }
    multi method DELETE-POS(Any:D: \one, \two) is raw {
        self.AT-POS(one).DELETE-POS(two)
    }
    multi method DELETE-POS(Any:D: \one, \two, \three) is raw {
        self.AT-POS(one).AT-POS(two).DELETE-POS(three)
    }
    multi method DELETE-POS(Any:D: **@indices) {
        my $final := @indices.pop;
        Rakudo::Internals.WALK-AT-POS(self,@indices).DELETE-POS($final)
    }

    method cache() { self.list }

    proto method list(|) is nodal { * }
    multi method list(Any:U:) { infix:<,>(self) }
    multi method list(Any:D \SELF:) { infix:<,>(SELF) }

    proto method flat(|) is nodal { * }
    multi method flat() { self.list.flat }

    proto method eager(|) is nodal { * }
    multi method eager() { self.list.eager }

    proto method serial(|) is nodal { * }
    multi method serial() { self }

    # derived from .list
    proto method List(|) is nodal { * }
    multi method List() { self.list }
    proto method Slip(|) is nodal { * }
    multi method Slip() { self.list.Slip }
    proto method Array(|) is nodal { * }
    multi method Array() { self.list.Array }
    proto method Seq(|) is nodal { * }
    multi method Seq() { Seq.new(self.iterator) }

    proto method hash(|) is nodal { * }
    multi method hash(Any:U:) { my % = () }
    multi method hash(Any:D:) { my % = self }

    # derived from .hash
    proto method Hash(|) is nodal { * }
    multi method Hash() { self.hash.Hash }

    proto method Map(|) is nodal { * }
    multi method Map() { self.hash.Map }

    proto method elems(|) is nodal { * }
    multi method elems(Any:U: --> 1) { }
    multi method elems(Any:D:) { self.list.elems }

    proto method end(|) is nodal { * }
    multi method end(Any:U: --> 0) { }
    multi method end(Any:D:) { self.list.end }

    proto method keys(|) is nodal { * }
    multi method keys(Any:U:) { () }
    multi method keys(Any:D:) { self.list.keys }

    proto method kv(|) is nodal { * }
    multi method kv(Any:U:) { () }
    multi method kv(Any:D:) { self.list.kv }

    proto method values(|) is nodal { * }
    multi method values(Any:U:) { () }
    multi method values(Any:D:) { self.list }

    proto method pairs(|) is nodal { * }
    multi method pairs(Any:U:) { () }
    multi method pairs(Any:D:) { self.list.pairs }

    proto method antipairs(|) is nodal { * }
    multi method antipairs(Any:U:) { () }
    multi method antipairs(Any:D:) { self.list.antipairs }

    proto method invert(|) is nodal { * }
    multi method invert(Any:U:) { () }
    multi method invert(Any:D:) { self.list.invert }

    proto method pick(|) is nodal { * }
    multi method pick()   { self.list.pick     }
    multi method pick($n) { self.list.pick($n) }

    proto method roll(|) is nodal { * }
    multi method roll()   { self.list.roll     }
    multi method roll($n) { self.list.roll($n) }

    multi method iterator(Any:) { self.list.iterator }

    method match(Any:U: |) { self.Str; nqp::getlexcaller('$/') = Nil }

    proto method classify(|) is nodal { * }
    multi method classify() {
        die "Must specify something to classify with, a Callable, Hash or List";
    }
    multi method classify(Whatever) {
        die "Doesn't make sense to classify with itself";
    }
    multi method classify($test, :$into!, :&as)   {
        ( $into // $into.new ).classify-list( $test, self, :&as);
    }
    multi method classify($test, :&as)   {
        Hash.^parameterize(Any,Any).new.classify-list( $test, self, :&as );
    }

    proto method categorize(|) is nodal { * }
    multi method categorize() {
        die "Must specify something to categorize with, a Callable, Hash or List";
    }
    multi method categorize(Whatever) {
        die "Doesn't make sense to categorize with itself";
    }
    multi method categorize($test, :$into!, :&as) {
        ( $into // $into.new ).categorize-list( $test, self.list, :&as );
    }
    multi method categorize($test, :&as) {
        Hash.^parameterize(Any,Any).new.categorize-list($test, self.list, :&as);
    }

    method reverse() is nodal { self.list.reverse }
    method combinations(|c) is nodal { self.list.combinations(|c) }
    method permutations(|c) is nodal { self.list.permutations(|c) }
    method join($separator = '') is nodal { self.list.join($separator) }

    # XXX GLR should move these
    method nodemap(&block) is nodal { nodemap(&block, self) }
    method duckmap(&block) is nodal { duckmap(&block, self) }
    method deepmap(&block) is nodal { deepmap(&block, self) }

    # XXX GLR Do we need tree post-GLR?
    proto method tree(|) is nodal { * }
    multi method tree(Any:U:) { self }
    multi method tree(Any:D:) {
        nqp::istype(self, Iterable)
            ?? self.map({ .tree }).item
            !! self
    }
    multi method tree(Any:D: Whatever ) { self.tree }
    multi method tree(Any:D: Int(Cool) $count) {
        nqp::istype(self, Iterable) && $count > 0
            ?? self.map({ .tree($count - 1) }).item
            !! self
    }
    multi method tree(Any:D: @ [&first, *@rest]) { self.tree(&first, |@rest); }
    multi method tree(Any:D: &first, *@rest) {
        nqp::istype(self, Iterable)
            ?? @rest ?? first(self.map({ .tree(|@rest) }))
                     !! first(self)
            !! self
    }

    # auto-vivifying
    proto method push(|) is nodal {*}
    multi method push(Any:U \SELF: |values) {
        SELF = nqp::istype(SELF,Positional) ?? SELF.new !! Array.new;
        SELF.push(|values);
    }

    proto method append(|) is nodal { * }
    multi method append(Any:U \SELF: |values) {
        SELF = nqp::istype(SELF,Positional) ?? SELF.new !! Array.new;
        SELF.append(|values);
    }

    proto method unshift(|) is nodal { * }
    multi method unshift(Any:U \SELF: |values) {
        SELF = Array.new;
        SELF.unshift(|values);
    }

    proto method prepend(|) is nodal { * }
    multi method prepend(Any:U \SELF: |values) {
        SELF = Array.new;
        SELF.prepend(|values);
    }

    proto method EXISTS-POS(|) is nodal { * }
    multi method EXISTS-POS(Any:U: Any:D $ --> False) { }
    multi method EXISTS-POS(Any:U: Any:U $pos) {
        die "Cannot use '{$pos.^name}' as an index";
    }

    multi method EXISTS-POS(Any:D: int \pos) {
        nqp::p6bool(nqp::iseq_i(pos,0));
    }
    multi method EXISTS-POS(Any:D: Int:D \pos) {
        pos == 0;
    }
    multi method EXISTS-POS(Any:D: Num:D \pos) {
        X::Item.new(aggregate => self, index => pos).throw
          if nqp::isnanorinf(pos);
        self.AT-POS(nqp::unbox_i(pos.Int));
        pos == 0;
    }
    multi method EXISTS-POS(Any:D: Any:D \pos) {
        pos.Int == 0;
    }
    multi method EXISTS-POS(Any:D: Any:U \pos) {
        die "Cannot use '{pos.^name}' as an index";
    }
    multi method EXISTS-POS(Any:D: \one, \two) is raw {
        self.AT-POS(one).EXISTS-POS(two)
    }
    multi method EXISTS-POS(Any:D: \one, \two,\three) is raw {
        self.AT-POS(one).AT-POS(two).EXISTS-POS(three)
    }
    multi method EXISTS-POS(Any:D: **@indices) {
        my $final := @indices.pop;
        Rakudo::Internals.WALK-AT-POS(self,@indices).EXISTS-POS($final)
    }

    proto method AT-POS(|) is nodal {*}
    multi method AT-POS(Any:U \SELF: int \pos) is raw {
        nqp::p6bindattrinvres(
          my $scalar,
          Scalar,
          '$!whence',
          -> { nqp::if(
                 nqp::isconcrete(SELF),
                 SELF,
                 (SELF = Array.new)
               ).BIND-POS(pos, $scalar)
             }
        )
    }
    multi method AT-POS(Any:U \SELF: Int:D \pos) is raw {
        nqp::p6bindattrinvres(
          my $scalar,
          Scalar,
          '$!whence',
          -> { nqp::if(
                 nqp::isconcrete(SELF),
                 SELF,
                 (SELF = Array.new)
               ).BIND-POS(pos, $scalar)
             }
        )
    }
    multi method AT-POS(Any:U: Num:D \pos) is raw {
        nqp::isnanorinf(pos)
          ?? Failure.new(X::Item.new(aggregate => self, index => pos))
          !! self.AT-POS(nqp::unbox_i(pos.Int))
    }
    multi method AT-POS(Any:U: Any:D \pos) is raw {
        self.AT-POS(nqp::unbox_i(pos.Int));
    }

    multi method AT-POS(Any:D: int \pos) is raw {
        pos
          ?? Failure.new(X::OutOfRange.new(
               :what($*INDEX // 'Index'), :got(pos), :range<0..0>))
          !! self
    }
    multi method AT-POS(Any:D: Int:D \pos) is raw {
        pos
          ?? Failure.new(X::OutOfRange.new(
               :what($*INDEX // 'Index'), :got(pos), :range<0..0>))
          !! self
    }
    multi method AT-POS(Any:D: Num:D \pos) is raw {
        nqp::isnanorinf(pos)
          ?? Failure.new(X::Item.new(aggregate => self, index => pos))
          !! self.AT-POS(nqp::unbox_i(pos.Int))
    }
    multi method AT-POS(Any:D: Any:D \pos) is raw {
        self.AT-POS(nqp::unbox_i(pos.Int));
    }
    multi method AT-POS(Any:   Any:U \pos) is raw {
        die "Cannot use '{pos.^name}' as an index";
    }
    multi method AT-POS(Any:D: \one, \two) is raw {
        self.AT-POS(one).AT-POS(two)
    }
    multi method AT-POS(Any:D: \one, \two, \three) is raw {
        self.AT-POS(one).AT-POS(two).AT-POS(three)
    }
    multi method AT-POS(Any:D: **@indices) is raw {
        my $final := @indices.pop;
        Rakudo::Internals.WALK-AT-POS(self,@indices).AT-POS($final)
    }

    proto method ZEN-POS(|) { * }
    multi method ZEN-POS(*%unexpected) {
        %unexpected
          ?? Failure.new(X::Adverb.new(
               :what('[] slice'),
               :source(try { self.VAR.name } // self.WHAT.perl),
               :unexpected(%unexpected.keys)))
          !! self
    }

    proto method ZEN-KEY(|) { * }
    multi method ZEN-KEY(*%unexpected) {
        %unexpected
          ?? Failure.new(X::Adverb.new(
               :what('{} slice'),
               :source(try { self.VAR.name } // self.WHAT.perl),
               :unexpected(%unexpected.keys)))
          !! self
    }

    proto method ASSIGN-POS(|) is nodal { * }
    multi method ASSIGN-POS(Any:U \SELF: \pos, Mu \assignee) {
       SELF.AT-POS(pos) = assignee;                     # defer < 0 check
    }

    multi method ASSIGN-POS(Any:D: int \pos, Mu \assignee) {
        self.AT-POS(pos) = assignee;                    # defer < 0 check
    }
    multi method ASSIGN-POS(Any:D: Int:D \pos, Mu \assignee) {
        self.AT-POS(pos) = assignee;                    # defer < 0 check
    }
    multi method ASSIGN-POS(Any:D: Num:D \pos, Mu \assignee) {
        nqp::isnanorinf(pos)
          ?? Failure.new(X::Item.new(aggregate => self, index => pos))
          !! self.AT-POS(nqp::unbox_i(pos.Int)) = assignee;  # defer < 0 check
    }
    multi method ASSIGN-POS(Any:D: Any:D \pos, Mu \assignee) {
        self.AT-POS(nqp::unbox_i(pos.Int)) = assignee;  # defer < 0 check
    }
    multi method ASSIGN-POS(Any:D: Any:U \pos, Mu \assignee) {
        die "Cannot use '{pos.^name}' as an index";
    }
    multi method ASSIGN-POS(Any:D: \one, \two, Mu \assignee) is raw {
        self.AT-POS(one).ASSIGN-POS(two, assignee)
    }
    multi method ASSIGN-POS(Any:D: \one, \two, \three, Mu \assignee) is raw {
        self.AT-POS(one).AT-POS(two).ASSIGN-POS(three, assignee)
    }
    multi method ASSIGN-POS(Any:D: **@indices) {
        my \value := @indices.pop;
        my $final := @indices.pop;
        Rakudo::Internals.WALK-AT-POS(self,@indices).ASSIGN-POS($final,value)
    }

    proto method BIND-POS(|) { * }
    multi method BIND-POS(Any:D: **@indices is raw) is raw {
# looks like Array.pop doesn't really return a bindable container
#        my \value := @indices.pop;
#        my $final := @indices.pop;
#        Rakudo::Internals.WALK-AT-POS(self,@indices).BIND-POS($final,value)

        my int $elems = @indices.elems;   # reifies
        my \value  := @indices.AT-POS(--$elems);
        my $final  := @indices.AT-POS(--$elems);
        my $target := self;
        my int $i = -1;
        $target := $target.AT-POS(@indices.AT-POS($i))
          while nqp::islt_i(++$i,$elems);
        X::Bind.new.throw if $target =:= self;
        $target.BIND-POS($final, value)
    }

    method all()  is nodal { Junction.new("all", self) }
    method any()  is nodal { Junction.new("any", self) }
    method one()  is nodal { Junction.new("one", self) }
    method none() is nodal { Junction.new("none",self) }

    # internals
    proto method AT-KEY(|) is nodal { * }
    multi method AT-KEY(Any:D: $key) is raw {
        Failure.new( self ~~ Associative
          ?? "Associative indexing implementation missing from type {self.WHAT.perl}"
          !! "Type {self.WHAT.perl} does not support associative indexing."
        )
    }
    multi method AT-KEY(Any:U \SELF: \key) is raw {
        nqp::p6bindattrinvres(
          my $scalar,
          Scalar,
          '$!whence',
          # NOTE: even though the signature indicates a non-concrete SELF,
          # by the time the below code is executed, it *may* have become
          # concrete: and then we don't want the execution to reset it to
          # an empty Hash.
          -> { nqp::if(
                 nqp::isconcrete(SELF),
                 SELF,
                 (SELF = nqp::create(Hash))
               ).BIND-KEY(key, $scalar)
             }
        )
    }

    proto method BIND-KEY(|) is nodal { * }
    multi method BIND-KEY(Any:D: \k, \v) is raw {
        Failure.new(X::Bind.new(target => self.^name))
    }
    multi method BIND-KEY(Any:U \SELF: $key, $BIND ) is raw {
        SELF = Hash.new;
        SELF.BIND-KEY($key, $BIND);
        $BIND
    }

    proto method ASSIGN-KEY(|) is nodal { * }
    multi method ASSIGN-KEY(\SELF: \key, Mu \assignee) is raw {
        SELF.AT-KEY(key) = assignee;
    }

    # XXX GLR review these
    method FLATTENABLE_LIST() is nodal {
        my $list := self.list;
        nqp::findmethod($list, 'FLATTENABLE_LIST')($list);
    }
    method FLATTENABLE_HASH() is nodal { nqp::hash() }

    proto method Set(|) is nodal { * }
    multi method Set(Any:) { Set.new-from-pairs(self.list) }

    proto method SetHash(|) is nodal { * }
    multi method SetHash(Any:) { SetHash.new-from-pairs(self.list) }

    proto method Bag(|) is nodal { * }
    multi method Bag(Any:) { Bag.new-from-pairs(self.list) }

    proto method BagHash(|) is nodal { * }
    multi method BagHash(Any:) { BagHash.new-from-pairs(self.list) }

    proto method Mix(|) is nodal { * }
    multi method Mix(Any:) { Mix.new-from-pairs(self.list) }

    proto method MixHash(|) is nodal { * }
    multi method MixHash() { MixHash.new-from-pairs(self.list) }

    # XXX GLR does this really need to force a list?
    proto method Supply(|) is nodal { * }
    multi method Supply() { self.list.Supply }

    method nl-out() { "\n" }
    method print-nl() { self.print(self.nl-out) }

    method lazy-if($flag) { self }  # no-op on non-Iterables

    method sum() is nodal {
        my \iter = self.iterator;
        my $sum = 0;
        my Mu $value;
        nqp::until(
          nqp::eqaddr(($value := iter.pull-one),IterationEnd),
          ($sum = $sum + $value)
        );
        $sum;
    }
}
Metamodel::ClassHOW.exclude_parent(Any);

# builtin ops
proto sub infix:<===>(Mu $?, Mu $?) is pure { * }
multi sub infix:<===>($?)    { Bool::True }
multi sub infix:<===>(\a, \b) {
    nqp::p6bool(
      nqp::eqaddr(nqp::decont(a),nqp::decont(b))
      || (nqp::eqaddr(a.WHAT,b.WHAT)
           && nqp::iseq_s(nqp::unbox_s(a.WHICH), nqp::unbox_s(b.WHICH)))
    )
}

proto sub infix:<before>(Mu $?, Mu $?)  is pure { * }
multi sub infix:<before>($?)      { Bool::True }
multi sub infix:<before>(\a, \b)   { (a cmp b) < 0 }

proto sub infix:<after>(Mu $?, Mu $?) is pure { * }
multi sub infix:<after>($x?)       { Bool::True }
multi sub infix:<after>(\a, \b)    { (a cmp b) > 0 }

proto prefix:<++>(Mu)             { * }
multi prefix:<++>(Mu:D $a is rw) { $a = $a.succ }
multi prefix:<++>(Mu:U $a is rw) { $a = 1 }
proto prefix:<-->(Mu)             { * }
multi prefix:<-->(Mu:D $a is rw) { $a = $a.pred }
multi prefix:<-->(Mu:U $a is rw) { $a = -1 }

proto postfix:<++>(Mu)             { * }
multi postfix:<++>(Mu:D $a is rw) { my $b = $a; $a = $a.succ; $b }
multi postfix:<++>(Mu:U $a is rw) { $a = 1; 0 }
proto postfix:<-->(Mu)             { * }
multi postfix:<-->(Mu:D $a is rw) { my $b = $a; $a = $a.pred; $b }
multi postfix:<-->(Mu:U $a is rw) { $a = -1; 0 }

proto sub pick(|) { * }
multi sub pick($n, +values) { values.pick($n) }

proto sub roll(|) { * }
multi sub roll($n, +values) { values.roll($n) }

proto sub keys(|) { * }
multi sub keys($x) { $x.keys }

proto sub values(|) { * }
multi sub values($x) { $x.values }

proto sub pairs(|) { * }
multi sub pairs($x) { $x.pairs }

proto sub kv(|) { * }
multi sub kv($x) { $x.kv }

proto sub elems(|) is nodal { * }
multi sub elems($a) { $a.elems }

proto sub end(|) { * }
multi sub end($a) { $a.end }

proto sub sum(|) {*}
multi sub sum() { 0 }
multi sub sum(\SELF) { SELF.sum }
multi sub sum(+SELF) { SELF.sum }

sub classify( $test, +items, *%named ) {
    if %named.EXISTS-KEY("into") {
        my $into := %named.DELETE-KEY("into");
        ( $into // $into.new).classify-list($test, items, |%named);
    }
    else {
        Hash.^parameterize(Any,Any).new.classify-list($test, items, |%named);
    }
}
sub categorize( $test, +items, *%named ) {
    if %named.EXISTS-KEY("into") {
        my $into := %named.DELETE-KEY("into");
        ( $into // $into.new).categorize-list($test, items, |%named);
    }
    else {
        Hash.^parameterize(Any,Any).new.categorize-list($test, items, |%named);
    }
}

proto sub item(|) is pure { * }
multi sub item(\x)    { my $ = x }
multi sub item(|c)    { my $ = c.list }
multi sub item(Mu $a) { $a }

sub SLICE_HUH(\SELF, @nogo, %d, %adv) {
    @nogo.unshift('delete')  # recover any :delete if necessary
      if @nogo && @nogo[0] ne 'delete' && %adv.EXISTS-KEY('delete');
    for <delete exists kv p k v> -> $valid { # check all valid params
        if nqp::existskey(%d,nqp::unbox_s($valid)) {
            nqp::deletekey(%d,nqp::unbox_s($valid));
            @nogo.push($valid);
        }
    }

    Failure.new(X::Adverb.new(
      :what<slice>,
      :source(try { SELF.VAR.name } // SELF.WHAT.perl),
      :unexpected(%d.keys),
      :nogo(@nogo),
    ))
} #SLICE_HUH

sub DELETEKEY(Mu \d, str $key) {
    nqp::if(
      nqp::existskey(d,$key),
      nqp::stmts(
        (my Mu $value := nqp::atkey(d,$key)),
        (nqp::deletekey(d,$key)),
        $value
      ),
      Nil
    )
} #DELETEKEY

sub dd(|) {
    my Mu $args := nqp::p6argvmarray();
    if nqp::elems($args) {
        while $args {
            my $var  := nqp::shift($args);
            my $name := try $var.VAR.?name;
            my $type := $var.WHAT.^name;
            my $what := $var.?is-lazy
              ?? $var[^10].perl.chop ~ "... lazy list)"
              !! $var.perl;
            note $name ?? "$type $name = $what" !! $what;
        }
    }
    else { # tell where we are
        note .name
          ?? "{lc .^name} {.name}{.signature.gist}"
          !! "{lc .^name} {.signature.gist}"
          with callframe(1).code;
    }
    return
}

#line 1 SETTING::src/core/Attribute.pm
my class Attribute { # declared in BOOTSTRAP
    # class Attribute is Any
    #     has str $!name;
    #     has int $!rw;
    #     has int $!has_accessor;
    #     has Mu $!type;
    #     has Mu $!container_descriptor;
    #     has Mu $!auto_viv_container;
    #     has Mu $!build_closure;
    #     has Mu $!package;
    #     has int $!inlined;
    #     has int $!positional_delegate;
    #     has int $!associative_delegate;
    #     has Mu $!why;
    #     has $!required;
    #     has Mu $!container_initializer;

    method compose(Mu $package, :$compiler_services) {
        # Generate accessor method, if we're meant to have one.
        if self.has_accessor {
            my str $name   = nqp::unbox_s(self.name);
            my $meth_name := nqp::substr($name, 2);
            unless $package.^declares_method($meth_name) {
                my $dcpkg := nqp::decont($package);
                my $meth;
                my int $attr_type = nqp::objprimspec($!type);

                # Get the compiler to generate us an accessor when possible.
                if $compiler_services.DEFINITE {
                    $meth := $compiler_services.generate_accessor($meth_name,
                        $dcpkg, $name, $!type, self.rw ?? 1 !! 0);
                }

                # No compiler services available, so do it as a closure.
                elsif self.rw {
                    $meth  := nqp::p6bool(nqp::iseq_i($attr_type, 0))
                        ??
                        method (Mu:D \fles:) is raw {
                            nqp::getattr(nqp::decont(fles), $dcpkg, $name)
                        }
                        !!
                        nqp::p6bool(nqp::iseq_i($attr_type, 1))
                        ??
                        method (Mu:D \fles:) is raw {
                            nqp::getattrref_i(nqp::decont(fles), $dcpkg, $name)
                        }
                        !!
                        nqp::p6bool(nqp::iseq_i($attr_type, 2))
                        ??
                        method (Mu:D \fles:) is raw {
                            nqp::getattrref_n(nqp::decont(fles), $dcpkg, $name)
                        }
                        !!
                        method (Mu:D \fles:) is raw {
                            nqp::getattrref_s(nqp::decont(fles), $dcpkg, $name)
                        }
                    $meth.set_name($meth_name);
                } else {
                    # ro accessor
                    $meth  := nqp::p6bool(nqp::iseq_i($attr_type, 0))
                        ??
                        method (Mu:D \fles:) {
                            nqp::getattr(nqp::decont(fles), $dcpkg, $name)
                        }
                        !!
                        nqp::p6bool(nqp::iseq_i($attr_type, 1))
                        ??
                        method (Mu:D \fles:) {
                            nqp::p6box_i(
                                nqp::getattr_i(nqp::decont(fles), $dcpkg, $name)
                            );
                        }
                        !!
                        nqp::p6bool(nqp::iseq_i($attr_type, 2))
                        ??
                        method (Mu:D \fles:) {
                            nqp::p6box_n(
                                nqp::getattr_n(nqp::decont(fles), $dcpkg, $name)
                            );
                        }
                        !!
                        method (Mu:D \fles:) {
                            nqp::p6box_s(
                                nqp::getattr_s(nqp::decont(fles), $dcpkg, $name)
                            );
                        }
                    $meth.set_name($meth_name);
                }
                $package.^add_method($meth_name, $meth);
            }
        }

        # Apply any handles trait we may have.
        self.apply_handles($package);
    }

    method apply_handles(Mu $pkg) {
        # None by default.
    }

    method get_value(Mu $obj) {
        nqp::if(
          nqp::iseq_i((my int $t = nqp::objprimspec($!type)),0),
          nqp::getattr(nqp::decont($obj),$!package,$!name),
          nqp::if(
            nqp::iseq_i($t,1),
            nqp::p6box_i(nqp::getattr_i(nqp::decont($obj),$!package,$!name)),
            nqp::if(
              nqp::iseq_i($t,2),
              nqp::p6box_n(nqp::getattr_n(nqp::decont($obj),
                $!package,$!name)),
              nqp::if(
                nqp::iseq_i($t,3),
                nqp::p6box_s(nqp::getattr_s(nqp::decont($obj),
                  $!package,$!name))
              )
            )
          )
        )
    }

    method set_value(Mu $obj, Mu \value) {
        nqp::if(
          nqp::iseq_i((my int $t = nqp::objprimspec($!type)),0),
          nqp::bindattr(nqp::decont($obj),$!package,$!name,value),
          nqp::if(
            nqp::iseq_i($t,1),
            nqp::p6box_i(nqp::bindattr_i(nqp::decont($obj),
              $!package,$!name,value)),
            nqp::if(
              nqp::iseq_i($t,2),
              nqp::p6box_n(nqp::bindattr_n(nqp::decont($obj),
                $!package,$!name,value)),
              nqp::if(
                nqp::iseq_i($t,3),
                nqp::p6box_s(nqp::bindattr_s(nqp::decont($obj),
                  $!package,$!name,value))
              )
            )
          )
        )
    }

    method container() is raw { nqp::ifnull($!auto_viv_container,Nil) }
    method readonly() { !self.rw }
    method package() { $!package }
    method inlined() { $!inlined }
    multi method Str(Attribute:D:) { self.name }
    multi method gist(Attribute:D:) { self.type.^name ~ " " ~ self.name }

    method WHY() {
        if nqp::isnull($!why) {
            nextsame
        } else {
            $!why.set_docee(self);
            $!why
        }
    }

    method set_why($why) {
        $!why := $why;
    }
}

#line 1 SETTING::src/core/Iterator.pm
# The Iterator role defines the API for an iterator and provides simple
# fallback implementations for most of it, so any given iterator can pick
# and choose what bits it can implement better for performance and/or
# correctness reasons.
my role Iterator {
    # Pulls one value from the iterator. If there's nothing more to pull,
    # returns the constant IterationEnd. If you don't override any other
    # methods in this role, they'll all end up falling back to using this.
    method pull-one() { ... }

    # Skip one value from the iterator.  Should return a true-like value to
    # indicate the skip was successful.  Override this method if you can
    # make an iterator that has significantly less to do when skipping a
    # generated value.
    method skip-one() {
        nqp::not_i(nqp::eqaddr(self.pull-one,IterationEnd))
    }

    # Has the iterator produce a certain number of values and push them into
    # the target. The only time the iterator may push less values than asked
    # for is when it reaches the end of the iteration. It may never push more
    # values than are requested. Iterators that can do something smarter than
    # the default implementation here should override this method. Should
    # return how many things were pushed. Note that if the iterator does any
    # side-effects as a result of producing values then up to $n of them will
    # occur; you must be sure this is desired. Returns the number of things
    # pushed, or IterationEnd if it reached the end of the iteration.
    method push-exactly($target, int $n) {
        nqp::stmts(
          (my int $i = -1),
          nqp::until(  # doesn't sink
            nqp::isge_i($i = nqp::add_i($i,1),$n)
              || nqp::eqaddr((my $pulled := self.pull-one),IterationEnd),
            $target.push($pulled) # don't .sink $pulled here, it can be a Seq
          ),
          nqp::if(
            nqp::eqaddr($pulled,IterationEnd),
            IterationEnd,
            $i
          )
        )
    }

    # Has the iteration push at least a certain number of values into the
    # target buffer. For iterators that do side-effects, this should always
    # be the same as push-exactly. Those that know they can safely work ahead
    # to achieve better throughput may do so. Returns the number of things
    # pushed, or IterationEnd if it reached the end of the iteration.
    method push-at-least($target, int $n) {
        self.push-exactly($target, $n)
    }

    # Has the iterator produce all of its values into the target.  Typically
    # called in .STORE if the iterator is non-lazy.  Returns IterationEnd.
    method push-all($target --> IterationEnd) {
        nqp::until( # we may not .sink $pulled here, since it can be a Seq
          nqp::eqaddr((my $pulled := self.pull-one),IterationEnd),
          $target.push($pulled)
        )
    }

    # Pushes things until we hit a lazy iterator (one whose is-lazy method returns
    # True). The default works well for non-composite iterators (that is, those
    # that don't trigger the evaluation of other iterators): it looks at the
    # lazy property of itself, and if it's true, does nothing, otherwise it
    # calls push-all. If all values the iterator can produce are pushed, then
    # IterationEnd should be returned. Otherwise, return something else (Mu
    # will do fine).
    method push-until-lazy($target) {
        nqp::unless(
          self.is-lazy,
          self.push-all($target)
        )
    }

    # Skip the given number of values.  Return true if succesful in
    # skipping that many values.
    method skip-at-least(int $toskip) {
        nqp::stmts(
          (my int $left = $toskip),
          nqp::while(
            nqp::isge_i(($left = nqp::sub_i($left,1)),0) && self.skip-one,
            nqp::null
          ),
          nqp::islt_i($left,0)
        )
    }

    # Skip the given number of values produced before returning the next
    # pulled value.  Given 0 it is an expensive way to do .pull-one
    method skip-at-least-pull-one(int $toskip) {
        nqp::if(
          self.skip-at-least($toskip),
          self.pull-one,
          IterationEnd
        )
    }

    # The optional "count-only" method in an Iterator class returns the number
    # of elements that the iterator would be return when generating values,
    # but *without* actually generating any values.  This can e.g. be the case
    # when an iterator is created for a hash, or for all the characters in a
    # string, of which the number elements is already known.
    # method count-only(--> Int:D) { ... }

    # The optional "bool-only" method in an Iterator class returns a Bool
    # to indicate whether the generator is able to generate *any* value,
    # *without* actually generating any value.  This can e.g. be the case
    # when an iterator is created for a hash.
    # method bool-only(--> Bool:D) { ... }

    # Consumes all of the values in the iterator for their side-effects only.
    # May be overridden by iterators to either warn about use of things in
    # sink context that should not be used that way, or to process things in
    # a more efficient way when we know we don't need the results.
    method sink-all(--> IterationEnd) {
        nqp::until(
          nqp::eqaddr(self.pull-one,IterationEnd),
          nqp::null
        )
    }

    # Whether the iterator is lazy (True if yes, False if no).
    # If True, the iterator must *never* try to evaluate more than the
    # user absolutely asks for.  This has e.g. effect on the behaviour
    # on .STORE: a lazy iterator would not reify, a non-lazy would.
    method is-lazy(--> False) { }
}

#line 1 SETTING::src/core/SlippyIterator.pm
# A SlippyIterator is one that comes with some infrastructure for handling
# flattening a received Slip into its own stream of values.
my role SlippyIterator does Iterator {
    # Flat set to non-zero if the iterator is currently consuming a Slip.
    has int $!slipping;

    # The current Slip we're iterating.
    has $!slip-iter;

    proto method start-slip(|) { * }
    multi method start-slip(Slip:U $slip) {
        $slip
    }
    multi method start-slip(Slip:D $slip) {
        nqp::if(
          nqp::eqaddr($slip,Empty),
          IterationEnd,                  # we know there's nothing
          nqp::if(
            nqp::eqaddr(
              (my \result := ($!slip-iter := $slip.iterator).pull-one),
              IterationEnd
            ),
            IterationEnd,                # we've determined there's nothing
            nqp::stmts(                  # need to start a Slip
              ($!slipping = 1),
              result
            )
          )
        )
    }

    method slip-one() {
        nqp::stmts(
          nqp::if(
            nqp::eqaddr((my \result := $!slip-iter.pull-one),IterationEnd),
            nqp::stmts(
              ($!slipping = 0),
              ($!slip-iter := nqp::null)
            )
          ),
          result
        )
    }

    proto method slip-all(|) { * }
    multi method slip-all(Slip:U $slip, $target) {
        $target.push($slip)
    }
    multi method slip-all(Slip:D $slip, $target) {
        nqp::unless(
          nqp::eqaddr($slip,Empty),
          $slip.iterator.push-all($target)
        )
    }
}

#line 1 SETTING::src/core/Rakudo/Internals.pm
my class DateTime { ... }
my role  IO { ... }
my class IO::Handle { ... }
my class IO::Path { ... }
my class Rakudo::Metaops { ... }
my class X::Cannot::Lazy { ... }
my class X::IllegalOnFixedDimensionArray { ... };
my class X::Assignment::ToShaped { ... };
my class X::Str::Sprintf::Directives::BadType { ... };
my class X::Str::Sprintf::Directives::Count { ... };
my class X::Str::Sprintf::Directives::Unsupported { ... };
my class X::TypeCheck { ... }
my class X::IllegalDimensionInShape { ... };

my class Rakudo::Internals {

    # for use in nqp::splice
    my $empty := nqp::list;

    our class CompilerServices {
        has Mu $!compiler;
        has Mu $!current-match;

        method generate_accessor(str $name, Mu \package_type, str $attr_name, Mu \type, int $rw) {
            $!compiler.generate_accessor(
              $!current-match, $name, package_type, $attr_name, type, $rw);
        }
        method generate_buildplan_executor(Mu \obj, Mu \buildplan) {
            $!compiler.generate_buildplan_executor(
              $!current-match, obj, buildplan)
        }
    }

    # rotate nqp list to another given list without using push/pop
    method RotateListToList(\from,\n,\to) {
        nqp::stmts(
          (my $from := nqp::getattr(from,List,'$!reified')),
          nqp::if((my int $elems = nqp::elems($from)),
            nqp::stmts(
              (my $to := nqp::getattr(to,List,'$!reified')),
              (my int $i = -1),
              (my int $j = nqp::mod_i(nqp::sub_i(nqp::sub_i($elems,1),n),$elems)),
              nqp::if(nqp::islt_i($j,0),($j = nqp::add_i($j,$elems))),
              nqp::while(
                nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                nqp::bindpos(
                  $to,
                  ($j = nqp::mod_i(nqp::add_i($j,1),$elems)),
                  nqp::atpos($from,$i)
                ),
              ),
            ),
          ),
          to
        )
    }

    method RANGE-AS-ints ($range, $exception) {
        # Convert a Range to min/max values that can fit into an `int`
        # Treats values smaller than int.Range.min as int.Range.min
        # Treats values larger than int.Range.max as int.Range.max
        # Throws $exception for non-Numeric ranges or ranges with any NaN endpoints
        # If $exception is a Str, calls `die $exception`
        my $min := $range.min;
        my $max := $range.max;
        nqp::unless(
             nqp::istype($min, Numeric) && nqp::isfalse($min.isNaN)
          && nqp::istype($max, Numeric) && nqp::isfalse($max.isNaN),
          nqp::if(nqp::istype($exception, Str), die($exception), $exception.throw));

        # Get rid of Infs
        $min := Int($min + $range.excludes-min) // -2**63;
        $max := Int($max - $range.excludes-max) //  2**63-1;

        # we have isbig_I, but it tells whether the value is above max int32 value
        nqp::if( nqp::islt_I(nqp::decont($min), -2**63),
                                         $min = -2**63);
        nqp::if( nqp::isgt_I(nqp::decont($max),  2**63-1),
                                         $max =  2**63-1);
        ($min, $max);
    }

    method SET_LEADING_DOCS($obj, $docs) {
        my $current_why := $obj.WHY;

        if $current_why {
            my $end := nqp::elems($*POD_BLOCKS) - 1;
            my $i   := $end;

            while $i >= 0 {
                if $docs === nqp::atpos($*POD_BLOCKS, $i) {
                    nqp::splice($*POD_BLOCKS, $empty, $i, 1);
                    last;
                }
                $i := $i - 1;
            }

            $current_why._add_leading(~$docs);
        } else {
            $obj.set_why($docs);
        }
    }

    method SET_TRAILING_DOCS($obj, $docs) {
        my $current_why := $obj.WHY;

        if $current_why {
            $current_why._add_trailing(~$docs);
        } else {
            $obj.set_why($docs);
            $*POD_BLOCKS.push($docs);
        }
    }

    method EXPORT_SYMBOL(\exp_name, @tags, Mu \sym) {
        my @export_packages = $*EXPORT;
        for flat nqp::hllize(@*PACKAGES) {
            unless .WHO.EXISTS-KEY('EXPORT') {
                .WHO<EXPORT> := Metamodel::PackageHOW.new_type(:name('EXPORT'));
                .WHO<EXPORT>.^compose;
            }
            @export_packages.append: .WHO<EXPORT>;
        }
        for @export_packages -> $p {
            for @tags -> $tag {
                my $install_in;
                if $p.WHO.EXISTS-KEY($tag) {
                    $install_in := $p.WHO.{$tag};
                }
                else {
                    $install_in := Metamodel::PackageHOW.new_type(:name($tag));
                    $install_in.^compose;
                    $p.WHO{$tag} := $install_in;
                }
                if $install_in.WHO.EXISTS-KEY(exp_name) {
                    unless ($install_in.WHO){exp_name} =:= sym {
                        X::Export::NameClash.new(symbol => exp_name).throw;
                    }
                }
                $install_in.WHO{exp_name} := sym;
            }
        }
        0;
    }

    method createENV(int $bind) {
        nqp::stmts(
          (my $hash := nqp::hash),
          (my $iter := nqp::iterator(nqp::getenvhash)),
          nqp::while(
            $iter,
            nqp::bindkey(
              $hash,
              nqp::iterkey_s(nqp::shift($iter)),
              nqp::if(
                $bind,
                val(nqp::iterval($iter)),
                nqp::p6scalarfromdesc(nqp::null) = val(nqp::iterval($iter))
              )
            )
          ),
          nqp::p6bindattrinvres(
            nqp::create(nqp::if($bind,Map,Hash)),Map,'$!storage',$hash
          )
        )
    }

    # fast whitespace trim: str to trim, str to store trimmed str
    method TRIM(\string, \trimmed --> Nil) {
        my int $pos  = nqp::chars(string) - 1;
        my int $left =
          nqp::findnotcclass(nqp::const::CCLASS_WHITESPACE, string, 0, $pos + 1);
        $pos = $pos - 1
          while nqp::isge_i($pos, $left)
            && nqp::iscclass(nqp::const::CCLASS_WHITESPACE, string, $pos);
        trimmed = nqp::islt_i($pos, $left)
          ?? ''
          !! nqp::substr(string, $left, $pos + 1 - $left);
        Nil
    }

    # fast key:value split: Str to split, str to store key, str to store value
    method KEY_COLON_VALUE(Str $command, \key, \value --> Nil) {
        my str $str   = nqp::unbox_s($command);
        my int $index = nqp::index($str,':');
        if nqp::isgt_i($index,0) {
            self.TRIM(nqp::substr($str,0,$index),key);
            self.TRIM(nqp::substr($str,$index + 1,nqp::chars($str) - $index),value);
        }
        elsif nqp::islt_i($index,0) {
            self.TRIM($str,key);
            value = '';
        }
        else {
            key = '';
            self.TRIM(nqp::substr($str,1,nqp::chars($str) - 1),value);
        }
        Nil
    }

    # key space value split: Str to split, str to store key, str to store value
    method KEY_SPACE_VALUE(Str $command, \key, \value --> Nil) {
        my str $str   = nqp::unbox_s($command);
        my int $index = nqp::index($str,' ');
        if nqp::isgt_i($index,0) {
            key   = nqp::substr($str,0,$index);
            value = nqp::substr($str,$index + 1,nqp::chars($str) - $index);
        }
        elsif nqp::islt_i($index,0) {
            key   = $str;
            value = '';
        }
        else {
            key   = '';
            value = nqp::substr($str,1,nqp::chars($str) - 1);
        }
        Nil
    }

    my $encodings := nqp::hash(
      # fast mapping for identicals
      'utf8',            'utf8',
      'utf16',           'utf16',
      'utf32',           'utf32',
      'ascii',           'ascii',
      'iso-8859-1',      'iso-8859-1',
      'windows-1252',    'windows-1252',
      # with dash
      'utf-8',           'utf8',
      'utf-16',          'utf16',
      'utf-32',          'utf32',
      # according to http://de.wikipedia.org/wiki/ISO-8859-1
      'iso_8859-1:1987', 'iso-8859-1',
      'iso_8859-1',      'iso-8859-1',
      'iso-ir-100',      'iso-8859-1',
      'latin1',          'iso-8859-1',
      'latin-1',         'iso-8859-1',
      'csisolatin1',     'iso-8859-1',
      'l1',              'iso-8859-1',
      'ibm819',          'iso-8859-1',
      'cp819',           'iso-8859-1',
    );
    method NORMALIZE_ENCODING(Str:D \encoding) {
        my str $key = nqp::unbox_s(encoding);
        if nqp::existskey($encodings,$key) {
            nqp::atkey($encodings,$key)
        }
        else {
            my str $lc = nqp::lc($key);
            nqp::existskey($encodings,$lc)
              ?? nqp::atkey($encodings,$lc)
              !! nqp::lc($key)
        }
    }

    # 1 if all elements of given type, otherwise 0
    method ALL_TYPE(\values,\type) {
        nqp::if(
          (my int $elems = values.elems),   # reifies
          nqp::stmts(
            (my $values := nqp::getattr(values,List,'$!reified')),
            (my int $i = -1),
            nqp::while(
              nqp::islt_i(($i = nqp::add_i($i,1)),$elems)
                && nqp::istype(nqp::atpos($values,$i),type),
              nqp::null
            ),
            nqp::iseq_i($i,$elems)
          )
        )
    }

    # 1 if all elems defined && type, otherwise 0
    method ALL_DEFINED_TYPE(\values,\type) {
        nqp::if(
          (my int $elems = values.elems),   # reifies
          nqp::stmts(
            (my $values := nqp::getattr(values,List,'$!reified')),
            (my int $i = -1),
            nqp::while(
              nqp::islt_i(($i = nqp::add_i($i,1)),$elems)
                && nqp::istype(nqp::atpos($values,$i),type)
                && nqp::defined(nqp::atpos($values,$i)),
              nqp::null
            ),
            nqp::iseq_i($i,$elems)
          )
        )
    }

    # 1 if any element of defined && type, otherwise 0
    method ANY_DEFINED_TYPE(\values,\type) {
        nqp::if(
          (my int $elems = values.elems),   # reifies
          nqp::stmts(
            (my $values := nqp::getattr(values,List,'$!reified')),
            (my int $i = -1),
            nqp::until(
              nqp::iseq_i(($i = nqp::add_i($i,1)),$elems)
                || (nqp::istype(nqp::atpos($values,$i),type)
                     && nqp::defined(nqp::atpos($values,$i))),
              nqp::null
            ),
            nqp::isne_i($i,$elems)
          )
        )
    }

    method TRANSPOSE(Str:D $string, Str:D $original, Str:D $final) {
        nqp::join($final,nqp::split($original,$string))
    }
    method TRANSPOSE-ONE(Str:D $string, Str:D $original, Str:D $final) {
        nqp::if(
          nqp::iseq_i((my int $index = nqp::index($string, $original)), -1),
          $string,
          nqp::concat(
            nqp::substr($string,0,$index),
            nqp::concat(
              $final,
              nqp::substr($string,nqp::add_i($index,nqp::chars($original)))
            )
          )
        )
    }

    my constant \SHAPE-STORAGE-ROOT := do {
        my Mu $root := nqp::newtype(nqp::knowhow(), 'Uninstantiable');
        nqp::setparameterizer($root, -> $, $key {
            my $dims := $key.elems.pred;
            my $type := $key.AT-POS(1);
            my $dim_type := nqp::newtype($key.AT-POS(0), 'MultiDimArray');
            nqp::composetype($dim_type, nqp::hash('array',
                nqp::hash('dimensions', $dims, 'type', $type)));
            nqp::settypehll($dim_type, 'perl6');
            $dim_type
        });
        nqp::settypehll($root, 'perl6');
        $root
    }

    method SHAPED-ARRAY-STORAGE(\spec, Mu \meta-obj, Mu \type) {
        nqp::stmts(
          (my $types := nqp::list(meta-obj)),  # meta + type of each dimension
          (my $dims  := nqp::list_i),          # elems per dimension
          nqp::if(
            nqp::istype(spec,List),
            nqp::stmts(                        # potentially more than 1 dim
              (my $spec  := nqp::getattr(nqp::decont(spec),List,'$!reified')),
              (my int $elems = nqp::elems($spec)),
              (my int $i     = -1),
              nqp::while(
                nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                nqp::if(
                  nqp::istype((my $dim := nqp::atpos($spec,$i)),Whatever),
                  X::NYI.new(feature => 'Jagged array shapes').throw,
                  nqp::if(
                    nqp::isbig_I(nqp::decont($dim := nqp::decont($dim.Int)))
                      || nqp::isle_i($dim,0),
                    X::IllegalDimensionInShape.new(:$dim).throw,
                    nqp::stmts(
                      nqp::push($types,type),
                      nqp::push_i($dims,$dim)
                    )
                  )
                )
              )
            ),
            nqp::stmts(                        # only 1 dim
              nqp::push($types,type),
              nqp::push_i($dims,spec.Int)
            )
          ),
          nqp::setdimensions(
            nqp::create(nqp::parameterizetype(SHAPE-STORAGE-ROOT,$types)),
            $dims
          )
        )
    }

    our role ShapedArrayCommon {
        method !illegal($operation) {
            X::IllegalOnFixedDimensionArray.new(:$operation).throw
        }
        proto method pop(::?CLASS:D: |)    { self!illegal("pop")    }
        proto method shift(::?CLASS:D: |)  { self!illegal("shift")  }
        proto method splice(::?CLASS:D: |) { self!illegal("splice") }

        proto method push(|c) is nodal {
            self.DEFINITE ?? self!illegal("push")    !! self.Any::push(|c)
        }
        proto method append(|c) is nodal {
            self.DEFINITE ?? self!illegal("append")  !! self.Any::append(|c)
        }
        proto method unshift(|c) is nodal {
            self.DEFINITE ?? self!illegal("unshift") !! self.Any::unshift(|c)
        }
        proto method prepend(|c) is nodal {
            self.DEFINITE ?? self!illegal("prepend") !! self.Any::prepend(|c)
        }

        multi method STORE(::?CLASS:D: Slip:D \slip) {
            nqp::if(
              nqp::eqaddr(slip,Empty),
              (die "Cannot Empty a shaped array as its size is fixed"),
              self.STORE(slip.List)
            )
        }

        # illegal unless overridden for 1dimmed case
        method reverse(::?CLASS:D: |) { self!illegal("reverse") }
        method rotate(::?CLASS:D: |)  { self!illegal("rotate") }

        multi method values(::?CLASS:D:) { Seq.new(self.iterator) }
        multi method keys(::?CLASS:D:) {
            Seq.new(Rakudo::Iterator.ShapeIndex(self.shape))
        }
        multi method invert(::?CLASS:D:) {
            Seq.new(Rakudo::Iterator.Invert(self.pairs.iterator))
        }

        # These work on the flat view
        method roll(|c)         { self.flat.roll(|c) }
        method pick(|c)         { self.flat.pick(|c) }
        method permutations(|c) { self.flat.permutations(|c) }
        method combinations(|c) { self.flat.combinations(|c) }
        method join(|c)         { self.flat.join(|c) }
        method sort(|c)         { self.flat.sort(|c) }

        multi method gist(::?CLASS:D:) {
            self.gistseen('Array', { self!gist([], self.shape) })
        }
        method !gist(@path, @dims) {
            if @dims.elems == 1 {
                 '[' ~ (^@dims[0]).map({ self.AT-POS(|@path, $_).gist }).join(' ') ~ ']';
            }
            else {
                my @nextdims = @dims[1..^@dims.elems];
                '[' ~ (^@dims[0]).map({ self!gist((flat @path, $_), @nextdims) }).join(' ') ~ ']';
            }
        }

        multi method perl(::?CLASS:D \SELF:) {
            SELF.perlseen('Array', {
                self.^name
                ~ '.new(:shape'
                ~ nqp::decont(self.shape).perl
                ~ ', '
                ~ self!perl([], self.shape)
                ~ ')'
                ~ (nqp::iscont(SELF) ?? '.item' !! '')
            })
        }
        method !perl(@path, @dims) {
            if @dims.elems == 1 {
                 '[' ~
                    (^@dims[0]).map({ nqp::decont(self.AT-POS(|@path, $_)).perl }).join(', ') ~
                    ',' x (@dims[0] == 1 && nqp::istype(self.AT-POS(|@path, 0), Iterable)) ~
                 ']'
            }
            else {
                my @nextdims = @dims[1..^@dims.elems];
                '[' x (@path.elems > 0) ~
                    (^@dims[0]).map({ self!perl((flat @path, $_), @nextdims) }).join(', ') ~
                    ',' x (@dims[0] == 1) ~
                ']' x (@path.elems > 0)
            }
        }

        multi method Slip() {
            Slip.from-iterator(self.iterator)
        }

        proto method AT-POS(|) is raw {*}
        multi method AT-POS(::?CLASS:U: |c) is raw {
            self.Any::AT-POS(|c)
        }
        multi method AT-POS(::?CLASS:D:) is raw {
            die "Must specify at least one index with {self.^name}.AT-POS"
        }

        proto method ASSIGN-POS(|) {*}
        multi method ASSIGN-POS(::?CLASS:U: |c) {
            self.Any::ASSIGN-POS(|c)
        }
        multi method ASSIGN-POS(::?CLASS:D:) {
            die "Must specify at least one index and a value with {self.^name}.ASSIGN-POS"
        }
        multi method ASSIGN-POS(::?CLASS:D: $) {
            die "Must specify at least one index and a value with {self.^name}.ASSIGN-POS"
        }

        proto method EXISTS-POS(|) {*}
        multi method EXISTS-POS(::?CLASS:U: |c) {
            self.Any::EXISTS-POS(|c)
        }
        multi method EXISTS-POS(::?CLASS:D:) {
            die "Must specify at least one index with {self.^name}.EXISTS-POS"
        }
    }

    our class SupplySequencer {
        has &!on-data-ready;
        has &!on-completed;
        has &!on-error;
        has $!buffer;
        has int $!buffer-start-seq;
        has int $!done-target;
        has int $!bust;
        has $!lock;

        submethod BUILD(
          :&!on-data-ready!, :&!on-completed!, :&!on-error! --> Nil) {
            $!buffer := nqp::list();
            $!buffer-start-seq = 0;
            $!done-target = -1;
            $!bust = 0;
            $!lock := Lock::Async.new;
        }

        method process(Mu \seq, Mu \data, Mu \err) {
            $!lock.protect: {
                if err {
                    &!on-error(err);
                    $!bust = 1;
                }
                elsif nqp::isconcrete(data) {
                    my int $insert-pos = seq - $!buffer-start-seq;
                    nqp::bindpos($!buffer, $insert-pos, data);
                    self!emit-events();
                }
                else {
                    $!done-target = seq;
                    self!emit-events();
                }
            }
        }

        method !emit-events() {
            unless $!bust {
                until nqp::elems($!buffer) == 0 || nqp::isnull(nqp::atpos($!buffer, 0)) {
                    &!on-data-ready(nqp::shift($!buffer));
                    $!buffer-start-seq = $!buffer-start-seq + 1;
                }
                if $!buffer-start-seq == $!done-target {
                    &!on-completed();
                }
            }
        }
    }

    my int $sprintfHandlerInitialized = 0;
    method initialize-sprintf-handler(--> Nil) {
        class SprintfHandler {
            method mine($x) { nqp::reprname($x) eq "P6opaque"; }
            method int($x) { $x.Int }
        }
        unless $sprintfHandlerInitialized {
            nqp::sprintfaddargumenthandler(SprintfHandler.new);
            $sprintfHandlerInitialized = 1;
        }
    }

    method SUBSTR-START-OOR(\from,\max) {
        X::OutOfRange.new(
          :what('Start argument to substr'),
          :got(from.gist),
          :range("0.." ~ max),
          :comment( nqp::istype(from, Callable) || -from > max
            ?? ''
            !! "use *-{abs from} if you want to index relative to the end"),
        );
    }
    method SUBSTR-CHARS-OOR(\chars) {
        X::OutOfRange.new(
          :what('Number of characters argument to substr'),
          :got(chars.gist),
          :range<0..^Inf>,
          :comment("use *-{abs chars} if you want to index relative to the end"),
        );
    }
    method SUBSTR-SANITY(Str \what, $start, $want, \from, \chars) {
        my Int $max := what.chars;
        from = nqp::istype($start, Callable)
          ?? $start($max)
          !! nqp::istype($start, Range)
            ?? $start.min + $start.excludes-min
            !! $start.Int;
        Rakudo::Internals.SUBSTR-START-OOR(from,$max).fail
          if from < 0 || from > $max;

        chars = nqp::istype($start, Range)
          ?? $start == Inf
            ?? $max - from
            !! $start.max - $start.excludes-max - from + 1
          !! $want.defined
            ?? $want === Inf
              ?? $max - from
              !! nqp::istype($want, Callable)
                ?? $want($max - from)
                !! (nqp::istype($want,Int) ?? $want !! $want.Int)
            !! $max - from;
        chars < 0 ?? Rakudo::Internals.SUBSTR-CHARS-OOR(chars).fail !! 1;
    }

    my $IS-WIN = do {
        my str $os = Rakudo::Internals.TRANSPOSE(nqp::lc(




          nqp::atkey(nqp::backendconfig,'osname')

        )," ","");
        nqp::p6bool(
          nqp::iseq_s($os,'mswin32')
            || nqp::iseq_s($os,'mingw')
            || nqp::iseq_s($os,'msys')
            || nqp::iseq_s($os,'cygwin')
        )
    }
    method IS-WIN() { $IS-WIN }

    method NUMERIC-ENV-KEY(\key) {
        %*ENV.EXISTS-KEY(key)
          ?? %*ENV.AT-KEY(key)
            ?? +%*ENV.AT-KEY(key)
            !! 0
          !! Nil
    }

    method error-rcgye() {  # red clear green yellow eject
        self.NUMERIC-ENV-KEY("RAKUDO_ERROR_COLOR") // !self.IS-WIN
          ?? ("\e[31m", "\e[0m", "\e[32m", "\e[33m", "\x[23CF]")
          !! ("", "", "", "", "<HERE>");
    }

    my num $init-time-num = nqp::time_n;
    method INITTIME() { $init-time-num }

    my $init-thread := nqp::currentthread();
    method INITTHREAD() { $init-thread }

    my $escapes := nqp::hash(
     "\0",   '\0',
     '$',    '\$',
     '@',    '\@',
     '%',    '\%',
     '&',    '\&',
     '{',    '\{',
     "\b",   '\b',
     "\x0A", '\n',
     "\r",   '\r',
     "\t",   '\t',
     '"',    '\"',
     '\\',   '\\\\',
    );

    method PERLIFY-STR(Str \string) {
        sub char-to-escapes(Str $char) {

            '\x[' ~ $char.NFC.list.map({ .fmt('%0x') }).join(',') ~ ']'




        }

        # Under NFG-supporting implementations, must be sure that any leading
        # combiners are escaped, otherwise they will be combined onto the "
        # under concatenation closure, which ruins round-tripping. Also handle
        # the \r\n grapheme correctly.
        my str $to-escape = nqp::unbox_s(string);
        my str $escaped = '';

        my int $chars = nqp::chars($to-escape);
        my int $i = -1;
        while ($i = $i + 1) < $chars {
            my str $char = nqp::substr($to-escape, $i, 1);

            my int $ord = nqp::ord($char);
            $escaped ~= nqp::isge_i($ord,256)
              && +uniprop($ord,'Canonical_Combining_Class')
              ?? char-to-escapes($char)
              !! nqp::iseq_s($char,"\r\n") ?? '\r\n' !!





              nqp::existskey($escapes,$char)
                ?? nqp::atkey($escapes,$char)
                !! nqp::iscclass(nqp::const::CCLASS_PRINTING,$char,0)
                  ?? $char
                  !! char-to-escapes($char);
        }
        $escaped
    }

    # easy access to compile options
    my Mu $compiling-options := nqp::atkey(%*COMPILING, '%?OPTIONS');

    # running with --ll-exception
    method LL-EXCEPTION() {
        nqp::existskey($compiling-options, 'll-exception')
          ?? '--ll-exception'
          !! Empty
    }
    # running with --profile
    method PROFILE() {
        nqp::existskey($compiling-options, 'profile')
          ?? '--profile'
          !! Empty
    }
    # running with --optimize=X
    method OPTIMIZE() {
        nqp::existskey($compiling-options, 'optimize')
          ?? '--optimize=' ~ nqp::atkey($compiling-options, 'optimize')
          !! Empty
    }
    # whatever specified with -I
    method INCLUDE() {
        nqp::existskey($compiling-options,'I')
          ?? do {
                my $I := nqp::atkey($compiling-options,'I');
                nqp::islist($I) ?? $I !! nqp::list($I)
             }
          !! nqp::list()
    }


    method PRECOMP-EXT()    { "moarvm" }
    method PRECOMP-TARGET() { "mbc"    }






    method get-local-timezone-offset() {
        my $utc     = time;
        my Mu $fia := nqp::p6decodelocaltime(nqp::unbox_i($utc));

        DateTime.new(
          :year(nqp::atpos_i($fia,5)),
          :month(nqp::atpos_i($fia,4)),
          :day(nqp::atpos_i($fia,3)),
          :hour(nqp::atpos_i($fia,2)),
          :minute(nqp::atpos_i($fia,1)),
          :second(nqp::atpos_i($fia,0)),
        ).posix(True) - $utc;
    }

# Keep track of the differences between TAI and UTC for internal use.
# The "BEGIN" and "END" comments are for tools/update-tai-utc.pl.
#
# Some handy tables:
# http://tf.nist.gov/pubs/bulletin/leapsecond.htm
# http://hpiers.obspm.fr/eop-pc/earthor/utc/TAI-UTC_tab.html

    my int $initial-offset = 10;
    # TAI - UTC at the Unix epoch (1970-01-01T00:00:00Z).

    my $dates := nqp::list_s(
        #BEGIN leap-second-dates
        '1972-06-30',
        '1972-12-31',
        '1973-12-31',
        '1974-12-31',
        '1975-12-31',
        '1976-12-31',
        '1977-12-31',
        '1978-12-31',
        '1979-12-31',
        '1981-06-30',
        '1982-06-30',
        '1983-06-30',
        '1985-06-30',
        '1987-12-31',
        '1989-12-31',
        '1990-12-31',
        '1992-06-30',
        '1993-06-30',
        '1994-06-30',
        '1995-12-31',
        '1997-06-30',
        '1998-12-31',
        '2005-12-31',
        '2008-12-31',
        '2012-06-30',
        '2015-06-30',
        '2016-12-31',
        #END leap-second-dates
    );

    # our %leap-seconds =
    #     @leap-second-dates Z=> $initial-offset + 1 .. *;

    # So for any date $d in @leap-second-dates, $d 23:59:00 UTC
    # is the leap second that made (or will make) UTC
    # %leap-seconds{$d} seconds behind TAI.

    # Ambiguous POSIX times.
    my $posixes := nqp::list_i(
        #BEGIN leap-second-posix
          78796800,
          94694400,
         126230400,
         157766400,
         189302400,
         220924800,
         252460800,
         283996800,
         315532800,
         362793600,
         394329600,
         425865600,
         489024000,
         567993600,
         631152000,
         662688000,
         709948800,
         741484800,
         773020800,
         820454400,
         867715200,
         915148800,
        1136073600,
        1230768000,
        1341100800,
        1435708800,
        1483228800,
        #END leap-second-posix
    );
    my int $elems = nqp::elems($dates);

    method is-leap-second-date(\date) {
        nqp::p6bool(
          nqp::stmts(
            (my str $date = date),
            (my int $i = -1),
            nqp::while(
              nqp::islt_i(($i = nqp::add_i($i,1)),$elems)
                && nqp::isgt_s($date,nqp::atpos_s($dates,$i)),
              nqp::null
            ),
            nqp::islt_i($i,$elems) && nqp::iseq_s($date,nqp::atpos_s($dates,$i))
          )
        )
    }

    method tai-from-posix(\posix, int $prefer-leap-second) {
        nqp::stmts(
          (my int $p = posix.floor),
          (my int $i = -1),
          nqp::while(
            nqp::islt_i(($i = nqp::add_i($i,1)),$elems)
              && nqp::isgt_i($p,nqp::atpos_i($posixes,$i)),
            nqp::null
          ),
          posix + nqp::add_i(
            nqp::add_i($initial-offset,$i),
            nqp::islt_i($i,$elems)
              && nqp::not_i($prefer-leap-second)
              && nqp::iseq_i($p,nqp::atpos_i($posixes,$i))
          )
        )
    }

    method posix-from-tai(\tai) {
        nqp::stmts(
          (my int $t = tai.floor - $initial-offset),
          (my int $i = -1),
          nqp::while(
            nqp::islt_i(($i = nqp::add_i($i,1)),$elems)
              && nqp::islt_i(nqp::atpos_i($posixes,$i),nqp::sub_i($t,$i)),
            nqp::null
          ),
          (tai - nqp::add_i($initial-offset,$i),
            nqp::p6bool(
              nqp::islt_i($i,$elems)
                && nqp::iseq_i(nqp::atpos_i($posixes,$i),nqp::sub_i($t,$i))
            )
          )
        )
    }

    my $initializers;
#nqp::print("running mainline\n");
#method INITIALIZERS() { $initializers }

    method REGISTER-DYNAMIC(Str:D \name, &code, Str $version = '6.c' --> Nil) {
#nqp::say('Registering ' ~ name);
        nqp::stmts(
          (my str $with = nqp::concat($version, nqp::concat("\0", name))),
          nqp::if(
            nqp::existskey(
              nqp::unless($initializers,$initializers := nqp::hash),
              $with
            ),
            (die "Already have initializer for '{name}' ('$version')"),
            nqp::bindkey($initializers,$with,&code)
          ),
          nqp::unless(                                 # first come, first kept
            nqp::existskey($initializers,nqp::unbox_s(name)),
            nqp::bindkey($initializers,nqp::unbox_s(name),&code)
          )
        )
    }
    method INITIALIZE-DYNAMIC(str \name) is raw {
#nqp::say('Initializing ' ~ name);
        nqp::stmts(
          (my str $with = nqp::concat(
            nqp::getcomp('perl6').language_version, nqp::concat("\0", name))),
          nqp::if(
            nqp::existskey(
              nqp::unless($initializers,$initializers := nqp::hash),
              $with
            ),
            nqp::atkey($initializers,$with)(),
            nqp::if(
              nqp::existskey($initializers,name),
              nqp::atkey($initializers,name)(),
              Failure.new(X::Dynamic::NotFound.new(:name(name)))
            )
          )
        )
    }

    method EXPAND-LITERAL-RANGE(Str:D \x,$list) {
        my str $s      = nqp::unbox_s(x);
        my int $chars  = nqp::chars($s);
        my Mu $result := nqp::list();
        my int $start  = 1;
        my int $found  = nqp::index($s,'..',$start);

        # found and not at the end without trail
        while nqp::isne_i($found,-1) && nqp::isne_i($found,$chars-2) {

            if $found - $start -> $unsplit {
                nqp::splice(
                  $result,
                  nqp::split("",nqp::substr($s,$start - 1,$unsplit)),
                  nqp::elems($result),
                  0
                )
            }

            # add the range excluding last (may be begin point next range)
            my int $from = nqp::ordat($s,$found - 1) - 1;
            my int $to   = nqp::ordat($s,$found + 2);
            nqp::push($result,nqp::chr($from))
              while nqp::islt_i($from = $from + 1,$to);

            # look for next range
            $found = nqp::index($s,'..',$start = $found + 3);
        }

        # add final bits
        nqp::splice(
          $result,
          nqp::split("",nqp::substr($s,$start - 1)),
          nqp::elems($result),
          0
        ) if nqp::isle_i($start,$chars);

        $list ?? $result !! nqp::join("",$result)
    }

    my int $VERBATIM-EXCEPTION = 0;
    method VERBATIM-EXCEPTION($set?) {
        my int $value = $VERBATIM-EXCEPTION;
        $VERBATIM-EXCEPTION = $set if defined($set);
        $value
    }

    method MAKE-ABSOLUTE-PATH(Str:D $path, Str:D $abspath) {
        if $path.ord == 47 {              # 4x faster substr($path,0,1) eq "/"
            $path
        }
        elsif $path.substr-eq(":",1) {  # assume C: something
            if $path.substr-eq("/",2) { #  assume C:/ like prefix
                $path
            }
            elsif !$abspath.starts-with(substr($path,0,2)) {
                die "Can not set relative dir from different roots";
            }
            else {
                $abspath ~ substr($path,2)
            }
        }
        else {                            # assume relative path
            $abspath ~ $path;
        }
    }

    method MAKE-BASENAME(Str:D \abspath) {
        my str $abspath = nqp::unbox_s(abspath);
        my int $offset  = nqp::rindex($abspath,'/');
        nqp::iseq_i($offset,-1)
          ?? abspath
          !! nqp::p6box_s(nqp::substr($abspath,$offset + 1));
    }

    my $clean-parts-nul := nqp::hash( '..', 1, '.', 1, '', 1);
    method MAKE-CLEAN-PARTS(Str:D \abspath) {
        my str $abspath = nqp::unbox_s(abspath);
        my $parts := nqp::split('/',$abspath);

        # handle //unc/ on win
        if nqp::iseq_s(nqp::atpos($parts,1),'')        # //
          && nqp::iseq_s(nqp::atpos($parts,0),'') {    # and no C: like stuff
            my str $front = nqp::join('/',nqp::list(   # collapse to '//unc/'
                nqp::atpos($parts,0),
                nqp::atpos($parts,1),
                nqp::atpos($parts,2),
            ));
            nqp::splice($parts,nqp::list($front),0,3); # and replace
        }

        # front part cleanup
        nqp::splice($parts,$empty,1,1)
          while nqp::existskey($clean-parts-nul,nqp::atpos($parts,1));

        # recursive ".." and "." handling
        sub updirs($index is copy) {

            # the end
            if $index == 1 {
                nqp::splice($parts,$empty,1,1);
                1
            }

            # something to check
            elsif nqp::atpos($parts,$index - 1) -> $part {
                if nqp::iseq_i(nqp::ord($part),46) { # substr($part,0,1) eq '.'
                    if nqp::iseq_s($part,'..') {
                        updirs($index - 1);
                    }
                    elsif nqp::iseq_s($part,'.') {
                        nqp::splice($parts,$empty,$index,1);
                        updirs($index - 1);
                    }
                    else {
                        nqp::splice($parts,$empty,--$index,2);
                        $index;
                    }
                }
                else {
                    nqp::splice($parts,$empty,--$index,2);
                    $index;
                }
            }

            # nul, just ignore
            else {
                nqp::splice($parts,$empty,$index,1);
                updirs($index);
            }
        }

        # back part cleanup
        my int $checks = nqp::elems($parts) - 1;
        while nqp::isgt_i($checks,1) {
            if nqp::atpos($parts,$checks) -> $part {
                nqp::iseq_s($part,'..')
                  ?? ($checks = updirs($checks))
                  !! nqp::iseq_s($part,'.')
                    ?? nqp::splice($parts,$empty,$checks--,1)
                    !! --$checks;
            }
            else {
                nqp::splice($parts,$empty,$checks--,1);
            }
        }

        # need / at the end
        nqp::push($parts,"");
        $parts
    }

    method REMOVE-ROOT(Str:D \root, Str:D \path) {
        my str $root = nqp::unbox_s(root);
        my str $path = nqp::unbox_s(path);

        nqp::eqat($path,$root,0)
          ?? nqp::p6box_s(nqp::substr($path,nqp::chars($root)))
          !! path;
    }

    method DIR-RECURSE(
      \abspath,
      Mu :$dir  = -> str $elem { nqp::not_i(nqp::eqat($elem,'.',0)) },
      Mu :$file = True
    ) {
        Seq.new(class :: does Iterator {
            has str $!abspath;
            has $!handle;
            has $!dir;
            has $!file,
            has str $!dir-sep;
            has $!todo;
            has $!seen;
            method !SET-SELF(\abspath,$!dir,$!file) {
                nqp::stmts(
                  ($!abspath = abspath),
                  ($!handle := nqp::opendir($!abspath)),
                  ($!dir-sep = $*SPEC.dir-sep),
                  ($!todo   := nqp::list_s),
                  ($!seen   := nqp::hash($!abspath,1)),
                  ($!abspath = nqp::concat($!abspath,$!dir-sep)),
                  self
                )
            }
            method new(\abspath,\dir,\file) {
                nqp::if(
                  nqp::stat(abspath,nqp::const::STAT_EXISTS)
                    && nqp::stat(abspath,nqp::const::STAT_ISDIR),
                  nqp::create(self)!SET-SELF(abspath,dir,file),
                  Rakudo::Iterator.Empty
                )
            }

            method !next() {
                nqp::while(
                  nqp::isnull_s(my str $elem = nqp::nextfiledir($!handle))
                    || nqp::iseq_i(nqp::chars($elem),0),
                  nqp::stmts(
                    nqp::closedir($!handle),
                    nqp::if(
                      nqp::elems($!todo),
                      nqp::stmts(
                        ($!abspath = nqp::pop_s($!todo)),
                        ($!handle := nqp::opendir($!abspath)),
                        ($!abspath = nqp::concat($!abspath,$!dir-sep))
                      ),
                      return ''
                    )
                  )
                );
                $elem
            }
            method pull-one() {
                nqp::while(
                  nqp::chars(my str $entry = self!next),
                  nqp::if(
                    nqp::stat(
                      (my str $path = nqp::concat($!abspath,$entry)),
                      nqp::const::STAT_EXISTS
                    ),
                    nqp::if(
                      nqp::stat($path,nqp::const::STAT_ISREG)
                        && $!file.ACCEPTS($entry),
                      (return $path),
                      nqp::if(
                        nqp::stat($path,nqp::const::STAT_ISDIR)
                          && $!dir.ACCEPTS($entry),
                        nqp::stmts(
                          nqp::if(
                            nqp::fileislink($path),
                            $path = IO::Path.new(
                              $path,:CWD($!abspath)).resolve.absolute
                          ),
                          nqp::unless(
                            nqp::existskey($!seen,$path),
                            nqp::stmts(
                              nqp::bindkey($!seen,$path,1),
                              nqp::push_s($!todo,$path)
                            )
                          )
                        )
                      )
                    )
                  )
                );
                IterationEnd
            }
        }.new(abspath,$dir,$file))
    }

    method FILETEST-E(Str:D \abspath) {
        nqp::stat(nqp::unbox_s(abspath),nqp::const::STAT_EXISTS)
    }
    method FILETEST-LE(Str:D \abspath) {
        nqp::lstat(nqp::unbox_s(abspath),nqp::const::STAT_EXISTS)
    }
    method FILETEST-D(Str:D \abspath) {
        my int $d = nqp::stat(nqp::unbox_s(abspath),nqp::const::STAT_ISDIR);
        nqp::isge_i($d,0)
          ?? $d
          !! Failure.new(X::IO::Unknown.new(:trying<d>))
    }
    method FILETEST-F(Str:D \abspath) {
        my int $f = nqp::stat(nqp::unbox_s(abspath),nqp::const::STAT_ISREG);
        nqp::isge_i($f,0)
          ?? $f
          !! Failure.new(X::IO::Unknown.new(:trying<f>))
    }
    method FILETEST-S(Str:D \abspath) {
        nqp::stat(nqp::unbox_s(abspath),nqp::const::STAT_FILESIZE)
    }
    method FILETEST-L(Str:D \abspath) {
        my int $l = nqp::fileislink(nqp::unbox_s(abspath));
        nqp::isge_i($l,0)
          ?? $l
          !! Failure.new(X::IO::Unknown.new(:trying<l>))
    }
    method FILETEST-R(Str:D \abspath) {
        my int $r = nqp::filereadable(nqp::unbox_s(abspath));
        nqp::isge_i($r,0)
          ?? $r
          !! Failure.new(X::IO::Unknown.new(:trying<r>))
    }
    method FILETEST-W(Str:D \abspath) {
        my int $w = nqp::filewritable(nqp::unbox_s(abspath));
        nqp::isge_i($w,0)
          ?? $w
          !! Failure.new(X::IO::Unknown.new(:trying<w>))
    }
    method FILETEST-RW(Str:D \abspath) {
        my str $abspath = nqp::unbox_s(abspath);
        my int $r = nqp::filereadable($abspath);
        my int $w = nqp::filewritable($abspath);
        nqp::isge_i($r,0)
          ?? nqp::isge_i($w,0)
            ?? nqp::bitand_i($r,$w)
            !! Failure.new(X::IO::Unknown.new(:trying<w>))
          !! Failure.new(X::IO::Unknown.new(:trying<r>))
    }
    method FILETEST-X(Str:D \abspath) {
        my int $x = nqp::fileexecutable(nqp::unbox_s(abspath));
        nqp::isge_i($x,0)
          ?? $x
          !! Failure.new(X::IO::Unknown.new(:trying<x>))
    }
    method FILETEST-RWX(Str:D \abspath) {
        my str $abspath = nqp::unbox_s(abspath);
        my int $r = nqp::filereadable($abspath);
        my int $w = nqp::filewritable($abspath);
        my int $x = nqp::fileexecutable($abspath);
        nqp::isge_i($r,0)
          ?? nqp::isge_i($w,0)
            ?? nqp::isge_i($x,0)
              ?? nqp::bitand_i(nqp::bitand_i($r,$w),$x)
              !! Failure.new(X::IO::Unknown.new(:trying<x>))
            !! Failure.new(X::IO::Unknown.new(:trying<w>))
          !! Failure.new(X::IO::Unknown.new(:trying<r>))
    }
    method FILETEST-Z(Str:D \abspath) {
        nqp::iseq_i(
          nqp::stat(nqp::unbox_s(abspath),nqp::const::STAT_FILESIZE),0)
    }

    method FILETEST-MODIFIED(Str:D \abspath) {
        nqp::stat_time(nqp::unbox_s(abspath), nqp::const::STAT_MODIFYTIME)
    }
    method FILETEST-ACCESSED(Str:D \abspath) {
        nqp::stat_time(nqp::unbox_s(abspath), nqp::const::STAT_ACCESSTIME)
    }
    method FILETEST-CHANGED(Str:D \abspath) {
        nqp::stat_time(nqp::unbox_s(abspath), nqp::const::STAT_CHANGETIME)
    }

    method HANDLE-NQP-SPRINTF-ERRORS(Mu \exception) {
        my $vmex := nqp::getattr(nqp::decont(exception), Exception, '$!ex');
        my \payload := nqp::getpayload($vmex);
        if nqp::elems(payload) == 1 {
            if nqp::existskey(payload, 'BAD_TYPE_FOR_DIRECTIVE') {
                X::Str::Sprintf::Directives::BadType.new(
                    type      => nqp::atkey(nqp::atkey(payload, 'BAD_TYPE_FOR_DIRECTIVE'), 'TYPE'),
                    directive => nqp::atkey(nqp::atkey(payload, 'BAD_TYPE_FOR_DIRECTIVE'), 'DIRECTIVE'),
                ).throw
            }
            if nqp::existskey(payload, 'BAD_DIRECTIVE') {
                X::Str::Sprintf::Directives::Unsupported.new(
                    directive => nqp::atkey(nqp::atkey(payload, 'BAD_DIRECTIVE'), 'DIRECTIVE'),
                    sequence  => nqp::atkey(nqp::atkey(payload, 'BAD_DIRECTIVE'), 'SEQUENCE'),
                ).throw
            }
            if nqp::existskey(payload, 'DIRECTIVES_COUNT') {
                X::Str::Sprintf::Directives::Count.new(
                    args-have => nqp::atkey(nqp::atkey(payload, 'DIRECTIVES_COUNT'), 'ARGS_HAVE'),
                    args-used => nqp::atkey(nqp::atkey(payload, 'DIRECTIVES_COUNT'), 'ARGS_USED'),
                ).throw
            }
        }
    }

#- start of generated part of succ/pred ---------------------------------------
#- Generated on 2016-08-10T14:19:20+02:00 by tools/build/makeMAGIC_INC_DEC.pl6
#- PLEASE DON'T CHANGE ANYTHING BELOW THIS LINE

    # normal increment magic chars & incremented char at same index
    my $succ-nlook = '012345678ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy';
    my $succ-nchrs = '123456789BCDEFGHIJKLMNOPQRSTUVWXYZbcdefghijklmnopqrstuvwxyz';

    # magic increment chars at boundary & incremented char at same index
    my $succ-blook = '9Zz';
    my $succ-bchrs = '10AAaa';

    # normal decrement magic chars & incremented char at same index
    my $pred-nlook = '123456789BCDEFGHIJKLMNOPQRSTUVWXYZbcdefghijklmnopqrstuvwxyz';
    my $pred-nchrs = '012345678ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy';

    # magic decrement chars at boundary & incremented char at same index
    my $pred-blook = '0Aa';
    my $pred-bchrs = '9Zz';

#- PLEASE DON'T CHANGE ANYTHING ABOVE THIS LINE
#- end of generated part of succ/pred -----------------------------------------

    # number of chars that should be considered for magic .succ/.pred
    method POSSIBLE-MAGIC-CHARS(str \string) {

        # only look at stuff before the last period
        my int $i = nqp::index(string,".");
        nqp::iseq_i($i,-1) ?? nqp::chars(string) !! $i
    }

    # return -1 if string cannot support .succ, else index of last char
    method CAN-SUCC-INDEX(str \string, int \chars) {
        my int $i = chars;
        Nil while nqp::isge_i($i = nqp::sub_i($i,1),0)
          && nqp::iseq_i(nqp::index($succ-nlook,nqp::substr(string,$i,1)),-1)
          && nqp::iseq_i(nqp::index($succ-blook,nqp::substr(string,$i,1)),-1);
        $i
    }

    # next logical string frontend, hopefully inlineable (pos >= 0)
    method SUCC(str \string, int \pos) {
        my int $at = nqp::index($succ-nlook,nqp::substr(string,pos,1));
        nqp::iseq_i($at,-1)
          ?? SUCC-NOT-SO-SIMPLE(string,pos)
          !! nqp::replace(string,pos,1,nqp::substr($succ-nchrs,$at,1))
    }

    # slow path for next logical string
    sub SUCC-NOT-SO-SIMPLE(str \string, int \pos) {

        # nothing magical going on
        my int $at = nqp::index($succ-blook,nqp::substr(string,pos,1));
        if nqp::iseq_i($at,-1) {
            string
        }

        # we have a boundary
        else {

            # initial change
            my int $i   = pos;
            my str $str = nqp::replace(string,$i,1,
              nqp::substr($succ-bchrs,nqp::add_i($at,$at),2));

            # until we run out of chars to check
            while nqp::isge_i($i = nqp::sub_i($i,1),0) {

                # not an easy magical
                $at = nqp::index($succ-nlook,nqp::substr($str,$i,1));
                if nqp::iseq_i($at,-1) {

                    # done if not a boundary magical either
                    $at = nqp::index($succ-blook,nqp::substr($str,$i,1));
                    return $str if nqp::iseq_i($at,-1);

                    # eat first of last magical, and continue
                    $str = nqp::replace($str,$i,2,
                      nqp::substr($succ-bchrs,nqp::add_i($at,$at),2));
                }

                # normal magical, eat first of last magical, and we're done
                else {
                   return nqp::replace($str,$i,2,
                     nqp::substr($succ-nchrs,$at,1));
                }
            }
            $str
        }
    }

    # previous logical string frontend, hopefully inlineable
    method PRED(str \string, int \pos) {
        my int $at = nqp::index($pred-nlook,nqp::substr(string,pos,1));
        nqp::iseq_i($at,-1)
          ?? PRED-NOT-SO-SIMPLE(string,pos)
          !! nqp::replace(string,pos,1,nqp::substr($pred-nchrs,$at,1))
    }

    # slow path for previous logical string
    sub PRED-NOT-SO-SIMPLE(str \string, int \pos) {

        # nothing magical going on
        my int $at = nqp::index($pred-blook,nqp::substr(string,pos,1));
        if nqp::iseq_i($at,-1) {
            string
        }

        # we have a boundary
        else {

            # initial change
            my int $i   = pos;
            my str $str = nqp::replace(string,$i,1,
              nqp::substr($pred-bchrs,$at,1));

            # until we run out of chars to check
            while nqp::isge_i($i = nqp::sub_i($i,1),0) {

                # not an easy magical
                $at = nqp::index($pred-nlook,nqp::substr($str,$i,1));
                if nqp::iseq_i($at,-1) {

                    # not a boundary magical either
                    $at = nqp::index($pred-blook,nqp::substr($str,$i,1));
                    nqp::iseq_i($at,-1)
                      ?? fail('Decrement out of range')
                      !! ($str = nqp::replace($str,$i,1,
                           nqp::substr($pred-bchrs,$at,1)))
                }

                # normal magical, update, and we're done
                else {
                    return nqp::replace($str,$i,1,
                      nqp::substr($pred-nchrs,$at,1))
                }
            }
            Failure.new('Decrement out of range')
        }
    }

    method WALK-AT-POS(\target,\indices) is raw {
        my $target   := target;
        my $indices  := nqp::getattr(indices,List,'$!reified');
        my int $elems = nqp::elems($indices);
        my int $i     = -1;
        $target := $target.AT-POS(nqp::atpos($indices,$i))
          while nqp::islt_i(++$i,$elems);
        $target
    }

    proto method coremap(|) { * }

    multi method coremap(\op, Associative \h, Bool :$deep) {
        my @keys = h.keys;
        hash @keys Z self.coremap(op, h{@keys}, :$deep)
    }

    multi method coremap(\op, \obj, Bool :$deep) {
        my \iterable = obj.DEFINITE && nqp::istype(obj, Iterable)
                ?? obj
                !! obj.list;

        my \result := class :: does SlippyIterator {
            has &!block;
            has $!source;

            method new(&block, $source) {
                my $iter := nqp::create(self);
                nqp::bindattr($iter, self, '&!block', &block);
                nqp::bindattr($iter, self, '$!source', $source);
                $iter
            }

            method is-lazy() {
                $!source.is-lazy
            }

            method pull-one() is raw {
                my int $redo = 1;
                my $value;
                my $result;
                if $!slipping && nqp::not_i(nqp::eqaddr(($result := self.slip-one),IterationEnd)) {
                    $result
                }
                elsif nqp::eqaddr(($value := $!source.pull-one),IterationEnd) {
                    $value
                }
                else {
                    nqp::while(
                        $redo,
                        nqp::stmts(
                            $redo = 0,
                            nqp::handle(
                                nqp::stmts(
                                    nqp::if(
                                        $deep,
                                        nqp::if(
                                            nqp::istype($value, Iterable) && $value.DEFINITE,
                                            ($result := Rakudo::Internals.coremap(&!block, $value, :$deep).item),
                                            ($result := &!block($value))
                                        ),
                                        ($result := &!block($value))
                                    ),
                                    nqp::if(
                                        nqp::istype($result, Slip),
                                        nqp::stmts(
                                            ($result := self.start-slip($result)),
                                            nqp::if(
                                                nqp::eqaddr($result, IterationEnd),
                                                nqp::stmts(
                                                    ($value := $!source.pull-one()),
                                                    ($redo = 1 unless nqp::eqaddr($value, IterationEnd))
                                            ))
                                        ))
                                ),
                                'NEXT', nqp::stmts(
                                    ($value := $!source.pull-one()),
                                    nqp::eqaddr($value, IterationEnd)
                                        ?? ($result := IterationEnd)
                                        !! ($redo = 1)),
                                'REDO', $redo = 1,
                                'LAST', ($result := IterationEnd))),
                        :nohandler);
                    $result
                }
            }
        }.new(op, iterable.iterator);

        my $type = nqp::istype(obj, List) ?? obj.WHAT !! List; # keep subtypes of List
        my \buffer := IterationBuffer.new;
        result.push-all(buffer);
        my \retval = $type.new;
        nqp::bindattr(retval, List, '$!reified', buffer);
        nqp::iscont(obj) ?? retval.item !! retval;
    }

}

# expose the number of bits a native int has
my constant $?BITS = nqp::isgt_i(nqp::add_i(2147483648, 1), 0) ?? 64 !! 32;

{   # setting up END phaser handling
    my int $the-end-is-done;
    my $the-end-locker = Lock.new;
    # END handling, returns trueish if END handling already done/in progress
    nqp::bindcurhllsym('&THE_END', {
        unless $the-end-is-done {
            $the-end-locker.protect: {
                unless $the-end-is-done {
                    my $comp := nqp::getcomp('perl6');
                    my $end  := nqp::getcurhllsym('@END_PHASERS');
                    while nqp::elems($end) {           # run all END blocks
                        my $result := nqp::shift($end)();
                        $result.sink if nqp::can($result,'sink');
                        CATCH { $comp.handle-exception($_) }
                        CONTROL { $comp.handle-control($_) }
                    }

                    # close all open files
                    IO::Handle.^find_private_method(
                      'close-all-open-handles'
                    )(IO::Handle);

                    nqp::not_i(($the-end-is-done = 1)); # we're really done now
                }
            }
        }
    } );
}

# we need this to run *after* the mainline of Rakudo::Internals has run
Rakudo::Internals.REGISTER-DYNAMIC: '&*EXIT', {
    PROCESS::<&EXIT> := sub exit($status) {
        state $exit = $status;  # first call to exit sets value

        nqp::getcurhllsym('&THE_END')()
          ?? $exit
          !! nqp::exit(nqp::unbox_i($exit.Int))
    }
}

sub exit(Int(Any) $status = 0) { &*EXIT($status) }

#line 1 SETTING::src/core/Rakudo/Iterator.pm
# This class contains generally usable methods creating Iterators.
# There are two reasons for having this in a separate class:
#
# 1. Nice to have a separate file for similar stuff.  Rakudo::Internals
#    has become a hodgepodge of stuff of late.
# 2. Improve readability/searchability of code using these iterators, as
#    many already have a long name, and having them prefixed with the more
#    general Rakudo::Internals in the code, as opposed for the definite
#    Rakudo::Iterator, feels better.

class Rakudo::Iterator {
    my $empty := nqp::list;   # an empty list for nqp::splice

#-------------------------------------------------------------------------------
# Roles that are used by iterators in the rest of the core settings, in
# alphabetical order for easier perusal.

    # Generic role for iterating over a Blob / Buf.  You need to
    # supply at least a .pull-one.  Takes a Blob / Buf as the only
    # parameter to .new.
    our role Blobby does Iterator {
        has $!blob;
        has Int $!i;   # sadly, this can not be a native int yet  :-(

        method SET-SELF(\blob) {
            nqp::stmts(               # something to iterator over
              ($!blob := blob),
              ($!i     = -1),
              self
            )
        }
        method new(\blob) {
            nqp::if(
              nqp::isgt_i(nqp::elems(blob),0),
              nqp::create(self).SET-SELF(blob),
              Rakudo::Iterator.Empty    # nothing to iterate
            )
        }

        # We can provide a generic push-all to the iterator as the
        # result of a push-all is always immutable, so we can use
        # the atpos_i here in both cases.
        method push-all($target --> IterationEnd) {
            nqp::stmts(
              (my $blob := $!blob),     # attribute access is slower
              (my int $elems = nqp::elems($blob)),
              (my int $i = $!i),
              nqp::while(
                nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                $target.push(nqp::atpos_i($blob,$i))
              )
            )
        }
        method count-only() { nqp::p6box_i(nqp::elems($!blob)) }
        method sink-all(--> IterationEnd) { $!i = nqp::elems($!blob) }
    }

    # Generic role for iterating over a Map / Hash.  You must
    # at least provide your own .pull-one.  Takes a Map / Hash
    # as the only parameter to .new.
    our role Mappy does Iterator {
        has $!hash;
        has $!iter;

        method SET-SELF(\hash) {
            nqp::if(
              ($!hash := nqp::if(
                nqp::istype(hash,Rakudo::Internals::IterationSet),
                hash,
                nqp::getattr(hash,Map,'$!storage')
              )) && ($!iter := nqp::iterator($!hash)),
              self,
              Rakudo::Iterator.Empty   # nothing to iterate
            )
        }
        method new(\hash) { nqp::create(self).SET-SELF(hash) }
        method skip-one() { nqp::if($!iter,nqp::stmts(nqp::shift($!iter),1)) }
        method count-only() { nqp::elems($!hash) }
        method bool-only(--> True) { }
        method sink-all(--> IterationEnd) { $!iter := nqp::null }
    }

    # Generic role for iterating over a Map / Hash that has pairs
    # for values providing the "real" key and value.  A default
    # .pull-one and .push-all is provided.  Takes a Map / Hash as
    # the only parameter to .new.
    our role Mappy-kv-from-pairs does Iterator {
        has $!hash;
        has $!iter;
        has $!on;

        method SET-SELF(\hash) {
            nqp::if(
              ($!hash := nqp::if(
                nqp::istype(hash,Rakudo::Internals::IterationSet),
                hash,
                nqp::getattr(hash,Map,'$!storage')
              )) && ($!iter := nqp::iterator($!hash)),
              self,
              Rakudo::Iterator.Empty   # nothing to iterate
            )
        }
        method new(\hash) { nqp::create(self).SET-SELF(hash) }

        method pull-one() is raw {
            nqp::if(
              $!on,
              nqp::stmts(
                ($!on = 0),
                nqp::getattr(nqp::iterval($!iter),Pair,'$!value')
              ),
              nqp::if(
                $!iter,
                nqp::stmts(
                  ($!on = 1),
                  nqp::getattr(nqp::iterval(nqp::shift($!iter)),Pair,'$!key')
                ),
                IterationEnd
              )
            )
        }
        method push-all($target --> IterationEnd) {
            nqp::while(
              $!iter,
              nqp::stmts(  # doesn't sink
                (my $pair := nqp::decont(nqp::iterval(nqp::shift($!iter)))),
                $target.push(nqp::getattr($pair,Pair,'$!key')),
                $target.push(nqp::getattr($pair,Pair,'$!value'))
              )
            )
        }
        method skip-one() {               # must define our own skip-one
            nqp::if(
              $!on,
              nqp::not_i($!on = 0),
              nqp::if(
                $!iter,
                nqp::stmts(
                  nqp::shift($!iter),
                  ($!on = 1)
                )
              )
            )
        }
        method count-only() { nqp::mul_i(nqp::elems($!hash),2) }
        method bool-only(--> True) { }
        method sink-all(--> IterationEnd) { $!iter := nqp::null }
    }

    # Generic role for iterating over a >1 dimensional shaped list
    # for its lowest branches.  The default .new method takes a List
    # to iterate over.  A consuming class needs to provide a .process
    # method, which will be called with each iteration with the
    # $!indices attribute set to the coordinates of the branch being
    # iterated for this time (with the highest element index set to 0).
    # Consuming class can optionally provide a .done method that will
    # be called just before the iterator returns IterationEnd.
    our role ShapeBranch does Iterator {
        has $!dims;
        has $!indices;
        has Mu $!list;
        has int $!maxdim;
        has int $!maxind;
        has int $!level;

        # Every time process() gets called, the following attributes are set:
        # $!indices  a list_i with current position, with the highest elem 0
        # $!level    level at which exhaustion happened
        # $!dims     a list_i with dimensions
        # $!maxdim   maximum element number in $!dims
        # $!maxind   maximum element number in lowest level list
        method process { ... }           # consumer needs to supply a .process
        method done(--> Nil) { }         # by default no action at end

        method dims() {                  # HLL version of $!dims
            nqp::stmts(
              (my $buffer :=
                nqp::setelems(nqp::create(IterationBuffer),nqp::elems($!dims))),
              (my int $i = -1),
              nqp::while(                # convert list_i to list
                nqp::isle_i(($i = nqp::add_i($i,1)),$!maxdim),
                nqp::bindpos($buffer,$i,nqp::atpos_i($!dims,$i))
              ),
              nqp::p6bindattrinvres(nqp::create(List),List,'$!reified',$buffer)
            )
        }

        method SET-SELF(Mu \list) {
            nqp::stmts(
              nqp::if(
                nqp::istype(list,List),
                nqp::stmts(                                 # List like
                  ($!list := nqp::getattr(list,List,'$!reified')),
                  (my $shape := list.shape),
                  (my int $dims = $shape.elems),     # reifies
                  ($!dims := nqp::setelems(nqp::list_i,$dims)),
                  (my int $i = -1),
                  nqp::while(
                    nqp::islt_i(($i = nqp::add_i($i,1)),$dims),
                    nqp::bindpos_i($!dims,$i,
                      nqp::atpos(nqp::getattr($shape,List,'$!reified'),$i))
                  )
                ),
                ($dims = nqp::elems($!dims := nqp::dimensions($!list := list)))
              ),
              ($!indices := nqp::setelems(nqp::list_i,$dims)),
              ($!maxdim = nqp::sub_i($dims,1)),
              ($!maxind = nqp::sub_i(nqp::atpos_i($!dims,$!maxdim),1)),
              self
            )
        }
        method new(Mu \list) { nqp::create(self).SET-SELF(list) }

        method pull-one() is raw {
            nqp::if(
              nqp::isge_i($!level,0),
              nqp::stmts(                      # still iterating
                (my $result := self.process),  # do the processing
                (my int $level = $!maxdim),
                nqp::until(                    # update indices
                  nqp::islt_i(                 # exhausted ??
                    ($level = nqp::sub_i($level,1)),0) # next level
                    || nqp::stmts(
                    nqp::bindpos_i($!indices,nqp::add_i($level,1),0),  # reset
                    nqp::islt_i(
                      nqp::bindpos_i($!indices,$level, # increment this level
                        nqp::add_i(nqp::atpos_i($!indices,$level),1)),
                      nqp::atpos_i($!dims,$level)      # out of range?
                    ),
                  ),
                  nqp::null
                ),
                ($!level = $level),            # set level for next call
                $result                        # what we found
              ),
              nqp::stmts(
                nqp::if(
                  nqp::iseq_i($!level,-1),
                  nqp::stmts(                  # first time telling we're done
                    self.done,                 # notify we're done
                    ($!level = -2)             # do this only once
                  )
                ),
                IterationEnd                   # done iterating
              )
            )
        }
    }

    # Generic role for iterating over a >1 dimensional shaped list
    # for its values (leaves).  The default .new method takes a List
    # to iterate over.  A consuming class needs to provide a .result
    # method, which will be called with each iteration with the
    # $!indices attribute set to the coordinates of the element being
    # iterated for this time.  In some cases, the iterator is iterated
    # over for the side-effects in .result only.  Which is why this
    # role supplies an optimized .sink-all.
    our role ShapeLeaf does Iterator {
        has $!dims;
        has $!indices;
        has Mu $!list;
        has int $!maxdim;
        has int $!max;

        # Every time .result gets called, the following attributes are set:
        # $!indices  a list_i with current coordinate
        # $!dims     a list_i with dimensions
        # $!maxdim   maximum element number in $!dims
        method result { ... }            # consumer needs to supply a .result

        method indices() {               # HLL version of $!indices
            nqp::stmts(
              (my $result := nqp::setelems(nqp::list,nqp::elems($!indices))),
              (my int $i = -1),
              nqp::while(                # convert list_i to list
                nqp::isle_i(($i = nqp::add_i($i,1)),$!maxdim),
                nqp::bindpos($result,$i,nqp::atpos_i($!indices,$i))
              ),
              $result
            )
        }
        method SET-SELF(Mu \list) {
            nqp::stmts(
              nqp::if(
                nqp::istype(list,List),
                nqp::stmts(                                 # List like
                  ($!list := nqp::getattr(list,List,'$!reified')),
                  (my $shape := list.shape),
                  (my int $dims = $shape.elems),            # reifies
                  ($!dims := nqp::setelems(nqp::list_i,$dims)),
                  (my int $i = -1),
                  nqp::while(
                    nqp::islt_i(($i = nqp::add_i($i,1)),$dims),
                    nqp::bindpos_i($!dims,$i,
                      nqp::atpos(nqp::getattr($shape,List,'$!reified'),$i))
                  )
                ),
                ($dims = nqp::elems($!dims := nqp::dimensions($!list := list)))
              ),
              ($!indices := nqp::setelems(nqp::list_i,$dims)),
              ($!maxdim = nqp::sub_i($dims,1)),
              ($!max    = nqp::atpos_i($!dims,$!maxdim)),
              self
            )
        }
        method new(Mu \list) { nqp::create(self).SET-SELF(list) }

        method pull-one() is raw {
            nqp::if(
              $!indices,
              nqp::stmts(                                 # still iterating
                (my $result := self.result),              # process
                nqp::if(
                  nqp::islt_i(
                    (my int $i =
                      nqp::add_i(nqp::atpos_i($!indices,$!maxdim),1)),
                    $!max
                  ),
                  nqp::bindpos_i($!indices,$!maxdim,$i),  # ready for next
                  nqp::stmts(                             # done for now
                    (my int $level = $!maxdim),
                    nqp::until(                           # update indices
                      nqp::islt_i(                        # exhausted ??
                        ($level = nqp::sub_i($level,1)),0)
                        || nqp::stmts(
                        nqp::bindpos_i($!indices,nqp::add_i($level,1),0),
                        nqp::islt_i(
                          nqp::bindpos_i($!indices,$level,
                            nqp::add_i(nqp::atpos_i($!indices,$level),1)),
                          nqp::atpos_i($!dims,$level)
                        ),
                      ),
                      nqp::null
                    ),
                    nqp::if(
                      nqp::islt_i($level,0),
                      $!indices := nqp::null              # done next time
                    )
                  )
                ),
                $result                                   # what we found
              ),
              IterationEnd                                # done now
            )
        }

        method push-all($target --> IterationEnd) {
            nqp::while(
              $!indices,
              nqp::stmts(                                   # still iterating
                (my int $i = nqp::atpos_i($!indices,$!maxdim)),
                nqp::while(
                  nqp::isle_i(($i = nqp::add_i($i,1)),$!max),
                  nqp::stmts(
                    $target.push(self.result),              # process
                    nqp::bindpos_i($!indices,$!maxdim,$i),  # ready for next
                  )
                ),
                (my int $level = $!maxdim),                 # done for now
                nqp::until(                                 # update indices
                  nqp::islt_i(                              # exhausted ??
                    ($level = nqp::sub_i($level,1)),0)
                    || nqp::stmts(
                    nqp::bindpos_i($!indices,nqp::add_i($level,1),0),
                    nqp::islt_i(
                      nqp::bindpos_i($!indices,$level,
                        nqp::add_i(nqp::atpos_i($!indices,$level),1)),
                      nqp::atpos_i($!dims,$level)
                    ),
                  ),
                  nqp::null
                ),
                nqp::if(
                  nqp::islt_i($level,0),
                  $!indices := nqp::null                    # done
                )
              )
            )
        }

        method sink-all(--> IterationEnd) {
            nqp::while(
              $!indices,
              nqp::stmts(                                   # still iterating
                (my int $i = nqp::atpos_i($!indices,$!maxdim)),
                nqp::while(
                  nqp::isle_i(($i = nqp::add_i($i,1)),$!max),
                  nqp::stmts(
                    self.result,                            # process
                    nqp::bindpos_i($!indices,$!maxdim,$i),  # ready for next
                  )
                ),
                (my int $level = $!maxdim),                 # done for now
                nqp::until(                                 # update indices
                  nqp::islt_i(                              # exhausted ??
                    ($level = nqp::sub_i($level,1)),0)
                    || nqp::stmts(
                    nqp::bindpos_i($!indices,nqp::add_i($level,1),0),
                    nqp::islt_i(
                      nqp::bindpos_i($!indices,$level,
                        nqp::add_i(nqp::atpos_i($!indices,$level),1)),
                      nqp::atpos_i($!dims,$level)
                    ),
                  ),
                  nqp::null
                ),
                nqp::if(
                  nqp::islt_i($level,0),
                  $!indices := nqp::null                    # done
                )
              )
            )
        }
    }

#-------------------------------------------------------------------------------
# Methods that generate an Iterator (in alphabetical order)

    # Create iterator that produces all values *except* the last N values
    # of a given iterator.  Returns an empty iterator if the given iterator
    # produced fewer than N values.
    method AllButLastNValues(\iterator, \n) {
        class :: does Iterator {
            has $!iterator;
            has $!buffered;
            has int $!size;
            has int $!index;

            method !SET-SELF(\iterator, int $size) {
                nqp::stmts(
                  (my int $i = -1),
                  (my $buffered := nqp::setelems(nqp::list,$size)),
                  nqp::while(                      # fill buffer to produce from
                    nqp::islt_i(($i = nqp::add_i($i,1)),$size)
                      && nqp::not_i(nqp::eqaddr(
                           (my $pulled := iterator.pull-one),
                           IterationEnd
                         )),
                    nqp::bindpos($buffered,$i,$pulled)
                  ),
                  nqp::if(
                    nqp::islt_i($i,$size),
                    Rakudo::Iterator.Empty,        # didn't produce enough
                    nqp::stmts(                    # we're in business
                      ($!iterator := iterator),
                      ($!buffered := $buffered),
                      ($!size = $size),
                      self
                    )
                  )
                )
            }
            method new(\iterator,\n) {
                nqp::if(
                  nqp::isle_i(n,0),
                  iterator,                        # we wants it all
                  nqp::create(self)!SET-SELF(iterator,n)
                )
            }
            method pull-one() is raw {
                nqp::if(
                  nqp::eqaddr((my $pulled := $!iterator.pull-one),IterationEnd),
                  $pulled,                         # we're done
                  nqp::stmts(                      # produce/update buffer
                    (my $value := nqp::atpos($!buffered,$!index)),
                    nqp::bindpos($!buffered,$!index,$pulled),
                    ($!index = nqp::mod_i(nqp::add_i($!index,1),$!size)),
                    $value
                  )
                )
            }
        }.new(iterator, n)
    }

    # Return an iterator that will generate a pair with the value as the
    # key and as value the key of the given iterator, basically the
    # .antipairs functionality on 1 dimensional lists.
    method AntiPair(\iterator) {
        class :: does Iterator {
            has Mu $!iter;
            has int $!key;

            method !SET-SELF(\iter) { $!iter := iter; $!key = -1; self }
            method new(\iter) { nqp::create(self)!SET-SELF(iter) }

            method pull-one() is raw {
                nqp::if(
                  nqp::eqaddr((my $pulled := $!iter.pull-one),IterationEnd),
                  IterationEnd,
                  Pair.new($pulled,+($!key = nqp::add_i($!key,1)))
                )
            }
            method push-all($target --> IterationEnd) {
                my $pulled;
                my int $key = -1;
                nqp::until(
                  nqp::eqaddr(($pulled := $!iter.pull-one),IterationEnd),
                  $target.push(Pair.new($pulled,+($key = nqp::add_i($key,1))))
                )
            }
        }.new(iterator)
    }

    # Return an iterator that batches the given source iterator in
    # batches of the given size.  The third parameter indicates whether
    # a partial batch should be returned when the source iterator has
    # exhausted.  The returned iterator is as lazy as the source iterator.
    method Batch(\iterator,\size,\partial) {
        class :: does Iterator {
            has $!iterator;
            has int $!size;
            has int $!complete;
            has int $!is-exhausted;
            method !SET-SELF(\iterator,\size,\partial) {
                nqp::stmts(
                  ($!iterator := iterator),
                  nqp::if(
                    nqp::istype(size,Whatever),
                    ($!size = -1),        # set to never stop and ok partial
                    nqp::if(
                      size < 1,
                      X::OutOfRange.new(
                        what    => "Batching sublist length is",
                        got     => size,
                        range   => "1..^Inf",
                      ).throw,
                      nqp::if(
                        (nqp::istype(size,Int)
                          && nqp::isbig_I(nqp::decont(size)))
                          || size == Inf,
                        ($!size = -1),    # set to never stop and ok partial
                        nqp::stmts(
                          ($!size     = size),
                          ($!complete = !partial),
                        )
                      )
                    )
                  ),
                  self
                )
            }
            method new(\it,\si,\pa) { nqp::create(self)!SET-SELF(it,si,pa) }
            method pull-one() is raw {
              nqp::if($!is-exhausted,
                IterationEnd,
                nqp::stmts(
                  (my $reified := nqp::create(IterationBuffer)),
                  nqp::until(
                    nqp::iseq_i(nqp::elems($reified),$!size)
                      || nqp::eqaddr(
                           (my $pulled := $!iterator.pull-one),
                           IterationEnd
                         ),
                    nqp::push($reified,$pulled)
                  ),
                  nqp::if(
                    nqp::eqaddr($pulled,IterationEnd)
                      && ($!is-exhausted = 1) # set the flag
                      && ($!complete || nqp::not_i(nqp::elems($reified))),
                    IterationEnd,
                    nqp::p6bindattrinvres(
                      nqp::create(List),List,'$!reified',$reified
                    )
                  )
                )
              )
            }
            method is-lazy() { $!iterator.is-lazy }
        }.new(iterator,size,partial)
    }

    # Return an iterator for a given Callable.  The Callable is supposed
    # to return a value for the iterator, or IterationEnd to indicate the
    # data from the Callable is exhausted.  No checks for Slips are done,
    # so they will be passed on as is.  Also optionally takes a flag to
    # mark the iterator as lazy or not: default is False (not lazy)
    proto method Callable(|) { * }
    multi method Callable(&callable) {
        class :: does Iterator {
            has &!callable;
            method new(&callable) {
                nqp::p6bindattrinvres(
                  nqp::create(self),self,'&!callable',&callable)
            }
            method pull-one() is raw { &!callable() }
        }.new(&callable)
    }
    multi method Callable(&callable, Bool() $lazy) {
        nqp::if(
          $lazy,
          class :: does Iterator {
              has &!callable;
              method new(&callable) {
                  nqp::p6bindattrinvres(
                    nqp::create(self),self,'&!callable',&callable)
              }
              method pull-one() is raw { &!callable() }
              method is-lazy(--> True) { }
          }.new(&callable),
          Rakudo::Iterator.Callable(&callable)
        )
    }

    # Return an iterator for the "thunk xx 42" functionality.
    method Callable-xx-Times(&code, Int:D \times) {
        class :: does Iterator {
            has @!slipped;
            has $!code;
            has $!times;
            method !SET-SELF(\code,\times) {
                nqp::stmts(
                  ($!code := code),
                  ($!times = times),
                  self
                )
            }
            method new(\code,\times) {
                nqp::if(
                  times > 0,
                  nqp::create(self)!SET-SELF(code,times),
                  Rakudo::Iterator.Empty
                )
            }
            method pull-one() {
                nqp::if(
                  @!slipped,
                  @!slipped.shift,
                  nqp::if(
                    $!times > 0,
                    nqp::stmts(
                      --$!times,             # consumed a value
                      nqp::if(
                        nqp::istype((my $pulled := $!code()),Slip),
                        nqp::if(
                          (@!slipped = $pulled),
                          @!slipped.shift,
                          IterationEnd
                        ),
                        nqp::if(
                          nqp::istype($pulled,Seq),
                          $pulled.cache,
                          $pulled
                        )
                      )
                    ),
                    IterationEnd
                  )
                )
            }
        }.new(&code,times)
    }

    # Return an iterator for the "thunk xx *" functionality.
    method Callable-xx-Whatever(&code) {
        class :: does Iterator {
            has @!slipped;
            has $!code;
            method new(\code) {
                nqp::p6bindattrinvres(nqp::create(self),self,'$!code',code)
            }
            method pull-one() {
                nqp::if(
                  @!slipped,
                  @!slipped.shift,
                  nqp::if(
                    nqp::istype((my $pulled := $!code()),Slip),
                    nqp::if(
                      (@!slipped = $pulled),
                      @!slipped.shift,
                      IterationEnd
                    ),
                    nqp::if(
                      nqp::istype($pulled,Seq),
                      $pulled.cache,
                      $pulled
                    )
                  )
                )
            }
            method is-lazy(--> True) { }
        }.new(&code)
    }

    # Return an iterator for a range of 0..^N with a number of elements.
    # The third parameter indicates whether an IterationBuffer should be
    # returned (1) for each combinatin, or a fully reified List (0).
    # Has a highly optimized count-only, for those cases when one is only
    # interested in the number of combinations, rather than the actual
    # combinations.  The workhorse of combinations().
    method Combinations($n, $k, int $b) {
        nqp::if(
          $n > 0 && nqp::isbig_I(nqp::decont($n)),    # must be HLL comparison
          X::OutOfRange.new(
            :what("First parameter"),
            :got($n),
            :range("-Inf^..{$?BITS == 32 ?? 2**28-1 !! 2**31-1}")
          ).throw,
          nqp::if(
            # k = 0  can pick just 1 combination (empty list); return ((),)
            $k == 0,                                  # Must be HLL comparison
            Rakudo::Iterator.OneValue(
              nqp::create(nqp::if($b,IterationBuffer,List))
            ),
            nqp::if(
              # n < 1  we have an empty list to pick from
              # n < k  not enough items to pick combination of k items
              $n < 1 || $n < $k || $k < 0,            # must be HLL comparisons
              Rakudo::Iterator.Empty,                 # nothing to return
              class :: does Iterator {
                  has int $!n;
                  has int $!k;
                  has int $!b;
                  has Mu $!stack;
                  has Mu $!combination;
                  method !SET-SELF(\n,\k,\b) {
                      nqp::stmts(
                        ($!n = n),
                        ($!k = k),
                        ($!b = b),
                        ($!stack := nqp::list_i(0)),
                        ($!combination := nqp::create(IterationBuffer)),
                        self
                    )
                  }
                  method new(\n,\k,\b) { nqp::create(self)!SET-SELF(n,k,b) }

                  method pull-one() {
                      nqp::stmts(
                        (my int $n = $!n),          # lexicals faster
                        (my int $k = $!k),
                        (my int $running = 1),
                        nqp::while(
                          ($running && (my int $elems = nqp::elems($!stack))),
                          nqp::stmts(
                            (my int $index = nqp::sub_i($elems,1)),
                            (my int $value = nqp::pop_i($!stack)),
                            nqp::while(
                              (nqp::islt_i($value,$n)
                                && nqp::islt_i($index,$k)),
                              nqp::stmts(
                                nqp::bindpos($!combination,
                                  $index,nqp::clone($value)),
                                ($index = nqp::add_i($index,1)),
                                ($value = nqp::add_i($value,1)),
                                nqp::push_i($!stack,$value)
                              )
                            ),
                            ($running = nqp::isne_i($index,$k)),
                          )
                        ),
                        nqp::if(
                          nqp::iseq_i($index,$k),
                          nqp::if(
                            $!b,
                            nqp::clone($!combination),
                            nqp::p6bindattrinvres(
                              nqp::create(List),List,'$!reified',
                              nqp::clone($!combination)
                            )
                          ),
                          IterationEnd
                        )
                      )
                  }
                  method count-only {
                      ([*] ($!n ... 0) Z/ 1 .. min($!n - $!k, $!k)).Int
                  }
                  method bool-only(--> True) { }
              }.new($n,$k,$b)
            )
          )
        )
    }

    # Return an iterator that will cross the given iterables (with &[,])
    # Basically the functionality of @a X @b
    method CrossIterables(@iterables) {
        nqp::if(
          nqp::isgt_i((my int $n = @iterables.elems),1),  # reifies

          # actually need to do some crossing (probably)
          class :: does Iterator {
              has $!iterators;  # iterator per iterable, if any
              has $!reifieds;   # cached values (either complete, or so far)
              has $!indices;    # indices of virtual matrix of crossed values
              has $!next;       # IterationBuffer with next values to return
              has int $!lazy;   # whether the outer iterator is lazy
              has int $!top;    # index of top reified/iterator

              method !SET-SELF(\iterables) {
                  nqp::stmts(
                    (my $iterables := nqp::getattr(iterables,List,'$!reified')),
                    (my int $elems  = nqp::elems($iterables)),
                    ($!iterators   := nqp::setelems(nqp::list,$elems)),
                    ($!reifieds    := nqp::setelems(nqp::list,$elems)),
                    ($!next :=
                      nqp::setelems(nqp::create(IterationBuffer),$elems)),

                    # loop over all iterables
                    (my int $i = -1),
                    nqp::while(
                      nqp::islt_i(($i = nqp::add_i($i,1)),$elems),

                      # set up initial value of index $i with...
                      nqp::bindpos($!next,$i,nqp::if(
                        nqp::iscont(my $elem := nqp::atpos($iterables,$i))
                          || nqp::not_i(nqp::istype($elem,Iterable)),

                        # single value same as reified list of 1
                        nqp::bindpos(
                          nqp::bindpos($!reifieds,$i,nqp::list),
                          0,
                          $elem
                        ),

                        # something more elaborate
                        nqp::if(
                          nqp::istype($elem,List)
                            && nqp::not_i(
                                 nqp::getattr($elem,List,'$!todo').DEFINITE),

                          # it's a List, may have a reified we can use directly
                          nqp::if(
                            ($elem := nqp::getattr($elem,List,'$!reified'))
                              && nqp::isgt_i(nqp::elems($elem),0),

                            # use the available reified directly
                            nqp::stmts(
                              nqp::bindpos($!reifieds,$i,$elem),
                              nqp::atpos($elem,0)
                            ),

                            # cross with an empty list is always an empty list
                            return Rakudo::Iterator.Empty
                          ),

                          # need to set up an iterator
                          nqp::stmts(
                            nqp::if($elem.is-lazy,($!lazy = 1)),
                            nqp::if(
                              nqp::eqaddr(
                                (my $pulled :=
                                  ($elem := $elem.iterator).pull-one),
                                IterationEnd
                              ),

                              # cross with an empty list is an empty list
                              (return Rakudo::Iterator.Empty),

                              # set up the iterator stuff
                              nqp::stmts(
                                nqp::bindpos($!iterators,$i,$elem),
                                nqp::bindpos($!reifieds,$i,nqp::list($pulled)),
                                $pulled
                              )
                            )
                          )
                        )
                      ))
                    ),

                    # indices start with 0 xx $elems
                    ($!indices := nqp::setelems(nqp::list_i,$elems)),
                    ($!top = nqp::sub_i($elems,1)),
                    self
                  )
              }
              method new(\iterables) { nqp::create(self)!SET-SELF(iterables) }
              method pull-one() {
                  nqp::if(




                    nqp::isnull($!next),

                    IterationEnd,
                    nqp::stmts(

                      # set up result of this pull
                      (my $result := nqp::p6bindattrinvres(
                        nqp::create(List),List,'$!reified',nqp::clone($!next))),

                      # start working on next result
                      nqp::unless(
                        nqp::isnull(nqp::atpos($!iterators,$!top)),

                        # top level is still iterator, fetch
                        nqp::if(
                          nqp::eqaddr(
                            (my $pulled :=
                              nqp::atpos($!iterators,$!top).pull-one),
                            IterationEnd
                          ),
                          # iterator no more
                          nqp::bindpos($!iterators,$!top,nqp::null),

                          # push value, let normal reifier handler handle
                          nqp::push(
                            nqp::atpos($!reifieds,$!top),
                            $pulled
                          )
                        )
                      ),

                      # no iterator, must use reified list
                      nqp::if(
                        nqp::islt_i(
                          (my int $index =
                            nqp::add_i(nqp::atpos_i($!indices,$!top),1)),
                          nqp::elems(nqp::atpos($!reifieds,$!top))
                        ),

                        # within range, update next result and index
                        nqp::bindpos($!next,$!top,
                          nqp::atpos(
                            nqp::atpos($!reifieds,$!top),
                            nqp::bindpos_i($!indices,$!top,$index)
                          )
                        ),

                        # need to update lower levels
                        nqp::stmts(

                          # update topmost value (go back to first)
                          nqp::bindpos($!next,$!top,
                            nqp::atpos(
                              nqp::atpos($!reifieds,$!top),
                              nqp::bindpos_i($!indices,$!top,0)
                            )
                          ),

                          # until we're at the bottom
                          (my int $level = $!top),
                          nqp::while(
                            nqp::isge_i(($level = nqp::sub_i($level,1)),0),
                            nqp::if(
                              nqp::isnull(nqp::atpos($!iterators,$level)),

                              # can use reified list at this level
                              nqp::if(
                                nqp::islt_i(
                                  ($index = nqp::add_i(
                                    nqp::atpos_i($!indices,$level),1)),
                                  nqp::elems(nqp::atpos($!reifieds,$level))
                                ),

                                # within range, update next result and index
                                nqp::stmts(
                                  nqp::bindpos($!next,$level,
                                    nqp::atpos(
                                      nqp::atpos($!reifieds,$level),
                                      nqp::bindpos_i($!indices,$level,$index)
                                    )
                                  ),
                                  ($level = -1)  # done searching
                                ),

                                # reset this level
                                nqp::bindpos($!next,$level,
                                  nqp::atpos(
                                    nqp::atpos($!reifieds,$level),
                                    nqp::bindpos_i($!indices,$level,0)
                                  )
                                )
                              ),

                              # still an iterator at this level
                              nqp::if(
                                nqp::eqaddr(
                                  ($pulled :=
                                    nqp::atpos($!iterators,$level).pull-one),
                                  IterationEnd
                                ),

                                # exhausted iterator, reset to reified
                                nqp::stmts(
                                  nqp::bindpos($!iterators,$level,nqp::null),
                                  nqp::bindpos($!next,$level,
                                    nqp::atpos(
                                      nqp::atpos($!reifieds,$level),
                                      nqp::bindpos_i($!indices,$level,0)
                                    )
                                  )
                                ),

                                # new value, add to reified, update indices
                                nqp::stmts(
                                  nqp::bindpos(
                                    $!next,
                                    $level,
                                  nqp::bindpos(
                                      nqp::atpos($!reifieds,$level),
                                      nqp::bindpos_i(
                                        $!indices,
                                        $level,
                                        nqp::add_i(
                                          nqp::atpos_i($!indices,$level),
                                          1
                                        )
                                      ),
                                      $pulled
                                    )
                                  ),
                                  ($level = -1)  # done searching
                                )
                            )
                            )
                          ),
                          nqp::if(
                            nqp::iseq_i($level,-1),

                            # was last iteration, free up everything now
                            ($!next :=
                              $!iterators := $!reifieds := $!indices :=




                              nqp::null)

                          )
                        )
                      ),
                      $result
                    )
                  )
              }
              method is-lazy() { nqp::p6bool($!lazy) }
          }.new(@iterables),

          # simpler cases
          nqp::if(
            nqp::iseq_i($n,0),
            # nothing to cross, so return an empty list
            Rakudo::Iterator.Empty,
            # only 1 list to cross, which is the list itself
            nqp::atpos(nqp::getattr(@iterables,List,'$!reified'),0).iterator
          )
        )
    }

    # Return an iterator that will cross the given iterables and map
    # the result with the given mapper Callable.  Basically the
    # functionality of @a Xop @b (with the op  -> mapper functionality
    # to be supplied externally).
    method CrossIterablesMap(@iterables,&mapper) {
        nqp::if(
          nqp::isgt_i((my int $n = @iterables.elems),1),  # reifies

          # actually need to do some crossing (probably)
          class :: does Iterator {
              has $!iterators;  # iterator per iterable, if any
              has $!reifieds;   # cached values (either complete, or so far)
              has $!indices;    # indices of virtual matrix of crossed values
              has $!next;       # IterationBuffer with next values to return
              has $!mapper;     # Callable to do final result mapping
              has int $!lazy;   # whether the outer iterator is lazy
              has int $!top;    # index of top reified/iterator

              method !SET-SELF(\iterables,\mapper) {
                  nqp::stmts(
                    (my $iterables := nqp::getattr(iterables,List,'$!reified')),
                    (my int $elems  = nqp::elems($iterables)),
                    ($!iterators   := nqp::setelems(nqp::list,$elems)),
                    ($!reifieds    := nqp::setelems(nqp::list,$elems)),
                    ($!next :=
                      nqp::setelems(nqp::create(IterationBuffer),$elems)),

                    # loop over all iterables
                    (my int $i = -1),
                    nqp::while(
                      nqp::islt_i(($i = nqp::add_i($i,1)),$elems),

                      # set up initial value of index $i with...
                      nqp::bindpos($!next,$i,nqp::if(
                        nqp::iscont(my $elem := nqp::atpos($iterables,$i))
                          || nqp::not_i(nqp::istype($elem,Iterable)),

                        # single value same as reified list of 1
                        nqp::bindpos(
                          nqp::bindpos($!reifieds,$i,nqp::list),
                          0,
                          $elem
                        ),

                        # something more elaborate
                        nqp::if(
                          nqp::istype($elem,List)
                            && nqp::not_i(
                                 nqp::getattr($elem,List,'$!todo').DEFINITE),

                          # it's a List, may have a reified we can use directly
                          nqp::if(
                            nqp::isnull(
                              $elem := nqp::getattr($elem,List,'$!reified'))
                              || nqp::iseq_i(nqp::elems($elem),0),

                            # cross with an empty list is always an empty list
                            (return Rakudo::Iterator.Empty),

                            # use the available reified directly
                            nqp::stmts(
                              nqp::bindpos($!reifieds,$i,$elem),
                              nqp::atpos($elem,0)
                            )
                          ),

                          # need to set up an iterator
                          nqp::stmts(
                            nqp::if($elem.is-lazy,($!lazy = 1)),
                            nqp::if(
                              nqp::eqaddr(
                                (my $pulled :=
                                  ($elem := $elem.iterator).pull-one),
                                IterationEnd
                              ),

                              # cross with an empty list is an empty list
                              (return Rakudo::Iterator.Empty),

                              # set up the iterator stuff
                              nqp::stmts(
                                nqp::bindpos($!iterators,$i,$elem),
                                nqp::bindpos($!reifieds,$i,nqp::list($pulled)),
                                $pulled
                              )
                            )
                          )
                        )
                      ))
                    ),

                    # indices start with 0 xx $elems
                    ($!indices := nqp::setelems(nqp::list_i,$elems)),
                    ($!top = nqp::sub_i($elems,1)),
                    ($!mapper := mapper),
                    self
                  )
              }
              method new(\its,\map) { nqp::create(self)!SET-SELF(its,map) }
              method pull-one() {
                  nqp::if(




                    nqp::isnull($!next),

                    IterationEnd,
                    nqp::stmts(

                      # set up result of this pull
                      # we *MUST* clone here, because we cannot be sure
                      # the mapper isn't going to throw the buffer away.
                      (my $result := $!mapper(nqp::clone($!next))),

                      # start working on next result
                      nqp::unless(
                        nqp::isnull(nqp::atpos($!iterators,$!top)),

                        # top level is still iterator, fetch
                        nqp::if(
                          nqp::eqaddr(
                            (my $pulled :=
                              nqp::atpos($!iterators,$!top).pull-one),
                            IterationEnd
                          ),
                          # iterator no more
                          nqp::bindpos($!iterators,$!top,nqp::null),

                          # push value, let normal reifier handler handle
                          nqp::push(
                            nqp::atpos($!reifieds,$!top),
                            $pulled
                          )
                        )
                      ),

                      # no iterator, must use reified list
                      nqp::if(
                        nqp::islt_i(
                          (my int $index =
                            nqp::add_i(nqp::atpos_i($!indices,$!top),1)),
                          nqp::elems(nqp::atpos($!reifieds,$!top))
                        ),

                        # within range, update next result and index
                        nqp::bindpos($!next,$!top,
                          nqp::atpos(
                            nqp::atpos($!reifieds,$!top),
                            nqp::bindpos_i($!indices,$!top,$index)
                          )
                        ),

                        # need to update lower levels
                        nqp::stmts(

                          # update topmost value (go back to first)
                          nqp::bindpos($!next,$!top,
                            nqp::atpos(
                              nqp::atpos($!reifieds,$!top),
                              nqp::bindpos_i($!indices,$!top,0)
                            )
                          ),

                          # until we're at the bottom
                          (my int $level = $!top),
                          nqp::while(
                            nqp::isge_i(($level = nqp::sub_i($level,1)),0),
                            nqp::if(
                              nqp::isnull(nqp::atpos($!iterators,$level)),

                              # can use reified list at this level
                              nqp::if(
                                nqp::islt_i(
                                  ($index = nqp::add_i(
                                    nqp::atpos_i($!indices,$level),1)),
                                  nqp::elems(nqp::atpos($!reifieds,$level))
                                ),

                                # within range, update next result and index
                                nqp::stmts(
                                  nqp::bindpos($!next,$level,
                                    nqp::atpos(
                                      nqp::atpos($!reifieds,$level),
                                      nqp::bindpos_i($!indices,$level,$index)
                                    )
                                  ),
                                  ($level = -1)  # done searching
                                ),

                                # reset this level
                                nqp::bindpos($!next,$level,
                                  nqp::atpos(
                                    nqp::atpos($!reifieds,$level),
                                    nqp::bindpos_i($!indices,$level,0)
                                  )
                                )
                              ),

                              # still an iterator at this level
                              nqp::if(
                                nqp::eqaddr(
                                  ($pulled :=
                                    nqp::atpos($!iterators,$level).pull-one),
                                  IterationEnd
                                ),

                                # exhausted iterator, reset to reified
                                nqp::stmts(
                                  nqp::bindpos($!iterators,$level,nqp::null),
                                  nqp::bindpos($!next,$level,
                                    nqp::atpos(
                                      nqp::atpos($!reifieds,$level),
                                      nqp::bindpos_i($!indices,$level,0)
                                    )
                                  )
                                ),

                                # new value, add to reified, update indices
                                nqp::stmts(
                                  nqp::bindpos(
                                    $!next,
                                    $level,
                                  nqp::bindpos(
                                      nqp::atpos($!reifieds,$level),
                                      nqp::bindpos_i(
                                        $!indices,
                                        $level,
                                        nqp::add_i(
                                          nqp::atpos_i($!indices,$level),
                                          1
                                        )
                                      ),
                                      $pulled
                                    )
                                  ),
                                  ($level = -1)  # done searching
                                )
                            )
                            )
                          ),
                          nqp::if(
                            nqp::iseq_i($level,-1),

                            # was last iteration, free up everything now
                            ($!next :=
                              $!iterators := $!reifieds := $!indices :=




                              nqp::null)

                          )
                        )
                      ),
                      $result
                    )
                  )
              }
              method is-lazy() { nqp::p6bool($!lazy) }
          }.new(@iterables,&mapper),

          # simpler cases
          nqp::if(
            nqp::iseq_i($n,0),
            # nothing to cross, so return an empty list
            Rakudo::Iterator.Empty,
            # only 1 list to cross, which is the list itself
            nqp::atpos(nqp::getattr(@iterables,List,'$!reified'),0).iterator
          )
        )
    }

    # Return an iterator that will cross the given iterables and operator.
    # Basically the functionality of @a Z=> @b, with &[=>] being the op.
    method CrossIterablesOp(@iterables,\op) {
        nqp::if(
          nqp::eqaddr(op,&infix:<,>),
          Rakudo::Iterator.CrossIterables(@iterables),
          Rakudo::Iterator.CrossIterablesMap(
            @iterables,
            Rakudo::Metaops.MapperForOp(op)
          )
        )
    }

    # Returns an iterator that handles all properties of a -while- with
    # a condition.  Takes a Callable to be considered the body of the loop,
    # and a Callable for the condition..
    method CStyleLoop(&body,&cond,&afterwards) {
        class :: does SlippyIterator {
            has &!body;
            has &!cond;
            has &!afterwards;
            has int $!seen-first;

            method !SET-SELF(\body,\cond,\afterwards) {
                nqp::stmts(
                  (&!body := body),
                  (&!cond := cond),
                  (&!afterwards := afterwards),
                  self
                )
            }
            method new(\body,\cond,\afterwards) {
                nqp::create(self)!SET-SELF(body,cond,afterwards)
            }

            method pull-one() {
                if $!slipping && nqp::not_i(
                    nqp::eqaddr((my $result := self.slip-one),IterationEnd)
                ) {
                    $result
                }
                else {
                    nqp::stmts(
                      nqp::if(
                        $!seen-first,
                        &!afterwards(),
                        ($!seen-first = 1)
                      ),
                      nqp::if(
                        &!cond(),
                        nqp::stmts(
                          nqp::until(
                            (my int $stopped),
                            nqp::stmts(
                              ($stopped = 1),
                              nqp::handle(
                                nqp::if(
                                  nqp::istype(($result := &!body()),Slip),
                                  nqp::if(
                                    nqp::eqaddr(
                                      ($result := self.start-slip($result)),
                                      IterationEnd
                                    ),
                                    nqp::stmts(
                                      &!afterwards(),
                                      ($stopped = nqp::if(&!cond(),0,1))
                                    )
                                  )
                                ),
                                'NEXT', nqp::stmts(
                                  &!afterwards(),
                                  ($stopped = nqp::if(&!cond(),0,1))
                                ),
                                'REDO', ($stopped = 0),
                                'LAST', ($result := IterationEnd)
                              )
                            ),
                            :nohandler
                          ),
                          $result
                        ),
                        IterationEnd
                      )
                    )
                }
            }
        }.new(&body,&cond,&afterwards)
    }

    # Create an iterator from a source iterator that will repeat the
    # values of the source iterator indefinitely *unless* a Whatever
    # was encountered, in which case it will repeat the last seen value
    # indefinitely (even if the source iterator wasn't actually exhausted).
    # Only if the source iterator did not produce any values at all, then
    # the resulting iterator will not produce any either.
    method DWIM(\source) {
        class :: does Iterator {
            has $!source;
            has $!buffer;
            has int $!ended;
            has int $!whatever;
            has int $!i;
            method !SET-SELF(\source) {
                $!source := source;
                $!buffer := IterationBuffer.new;
                self
            }
            method new(\source) { nqp::create(self)!SET-SELF(source) }

            method pull-one() is raw {
                nqp::if(
                  $!ended,
                  nqp::if(                          # source exhausted
                    $!whatever,
                    nqp::if(                        # seen a Whatever
                      nqp::elems($!buffer),
                      nqp::atpos($!buffer,          # last value seen
                        nqp::sub_i(nqp::elems($!buffer),1)),
                      Nil                           # no last value seen
                    ),
                    nqp::atpos($!buffer,            # not seen, so modulo repeat
                      nqp::mod_i(
                        nqp::sub_i(($!i = nqp::add_i($!i,1)),1),
                        nqp::elems($!buffer)
                      )
                    )
                  ),
                  nqp::if(                          # source not exhausted
                    nqp::eqaddr((my $value := $!source.pull-one),IterationEnd),
                    nqp::stmts(                     # exhausted now
                      ($!ended = 1),
                      nqp::if(
                        nqp::iseq_i(nqp::elems($!buffer),0),
                        IterationEnd,               # nothing to repeat, done
                        self.pull-one               # last or repeat
                      )
                    ),
                    nqp::if(                        # got a value
                      nqp::istype($value,Whatever),
                      nqp::stmts(                   # done, repeat last value
                        ($!whatever = $!ended = 1),
                        self.pull-one,
                      ),
                      nqp::stmts(                   # save / return value
                        $!buffer.push($value),
                        $value
                      )
                    )
                  )
                )
            }

            # Is the source iterator considered exhausted?
            method ended() { nqp::p6bool($!ended) }

            # Eat the iterator trying to find out the number of elements
            # produced by the iterator.  Intended to provide information
            # for error messages.
            method count-elems() {
                nqp::if(
                  $!ended,
                  nqp::elems($!buffer),
                  nqp::stmts(
                    (my int $elems = nqp::elems($!buffer)),
                    nqp::until(
                      nqp::eqaddr($!source.pull-one,IterationEnd),
                      $elems = nqp::add_i($elems,1)
                    ),
                    $elems
                  )
                )
            }
        }.new(source)
    }

    # Returns a sentinel Iterator object that will never generate any value.
    # Does not take a parameter.
    method Empty() {
        BEGIN class :: does Iterator {
            method new() { nqp::create(self) }
            method pull-one(--> IterationEnd)  { }
            method push-all($ --> IterationEnd) { }
            method sink-all(--> IterationEnd)  { }
            method skip-one(--> 0) { }
            method skip-at-least($ --> 0) { }
            method count-only(--> 0) { }
            method bool-only(--> False) { }
        }.new
    }

    # Returns at most N items, then calls .sink-all on source. Optionally,
    # executes a Callable when either N items were returned or original iterator
    # got exhausted. N can be negative to ask for "all values".
    # This is used in several places in IO::Handle, e.g. in
    # .lines to read N lines and then close the filehandle via .sink-all
    method FirstNThenSinkAll(\source,\n,&callable?) {
        # XXX TODO: Make this code DRYer by moving common bits to a role,
        # but currently (2017-04) assigning to `int $!n` attribute from SET-SELF
        # signature complains about immutable ints if done in a role, and
        # private methods **in roles** are slow, so we duplicated stuff here
        nqp::if(
          nqp::isge_i(n, 0),
          class :: does Iterator {               # only want N pull's
              has $!source;
              has int $!n;
              has int $!i = -1;
              has &!callable;
              method pull-one() is raw {
                  nqp::if(
                    nqp::islt_i($!n, ($!i = nqp::add_i($!i, 1)))
                      && self!FINISH-UP(1)
                    || nqp::eqaddr((my $got := $!source.pull-one),IterationEnd)
                      && self!FINISH-UP(0),
                    IterationEnd,
                    $got
                  )
              }
              method sink-all(--> IterationEnd) { self!FINISH-UP }
              method new(\s,\n,\c) { nqp::create(self)!SET-SELF(s,n,c) }
              method !SET-SELF($!source,$!n,&!callable) { self }
              method !FINISH-UP(\do-sink) {
                  do-sink    && $!source.sink-all;
                  &!callable && &!callable();
                  1
              }
          }.new(source,n,&callable),
          nqp::if(                               # want it all
            &callable,
            class :: does Iterator {             # want it all with callable
                has $!source;
                has &!callable;
                method pull-one() is raw {
                    nqp::if(
                      nqp::eqaddr((my $got := $!source.pull-one),IterationEnd)
                        && (&!callable()||1),
                      IterationEnd,
                      $got
                    )
                }
                method sink-all(--> IterationEnd) {
                    $!source.sink-all;
                    &!callable();
                }
                method new(\s,\c) { nqp::create(self)!SET-SELF(s,c) }
                method !SET-SELF($!source,&!callable) { self }
            }.new(source,&callable),
            source                               # want it all without callable
          )
        )
    }

    # Return an iterator that will cache a source iterator for the index
    # values that the index iterator provides, from a given offest in the
    # cached source iterator.  Values from the index iterator below the
    # offset, are considered to be illegal and will throw.  Also takes an
    # optional block to be called when an otherwise out-of-bounds index
    # value is given by the index iterator: if not given, Nil will be
    # returned for such index values.
    method FromIndexes(\source,\indexes,\offset,&out?) {
        class :: does Iterator {
            has $!source;
            has $!indexes;
            has int $!offset;
            has &!out;
            has $!cache;
            method !SET-SELF($!source,$!indexes,\offset,&!out) {
                $!cache := nqp::setelems(nqp::list,$!offset = offset);
                self
            }
            method new(\s,\i,\o,\out) { nqp::create(self)!SET-SELF(s,i,o,out) }
            method pull-one() is raw {
                nqp::if(
                  nqp::eqaddr((my $got := $!indexes.pull-one),IterationEnd),
                  IterationEnd,
                  nqp::if(
                    nqp::istype(                      # doesn't look like int
                      (my $number = +$got),Failure),
                    $number.throw,
                    nqp::if(                          # out of range
                      nqp::islt_i((my int $index = $number.Int),$!offset),
                      X::OutOfRange.new(:$got,:range("$!offset..^Inf")).throw,
                      nqp::if(
                        nqp::existspos($!cache,$index),
                        nqp::atpos($!cache,$index),   # it's in the cache
                        nqp::if(
                          nqp::defined($!source),
                          nqp::stmts(                 # can still search it
                            nqp::until(
                              nqp::existspos($!cache,$index)
                                || nqp::eqaddr(
                                     (my $pulled := $!source.pull-one),
                                     IterationEnd
                                   ),
                              nqp::push($!cache,$pulled)
                            ),
                            nqp::if(
                              nqp::eqaddr($pulled,IterationEnd),
                              nqp::stmts(
                                ($!source := Mu),
                                nqp::if(
                                  $!indexes.is-lazy,
                                  IterationEnd,       # not going to be any more
                                  nqp::stmts(         # didn't find it
                                    nqp::if(&out,out($index)),
                                    Nil
                                  )
                                )
                              ),
                              $pulled                 # found it
                            )
                          ),
                          nqp::stmts(                 # cannot be found
                            nqp::if(&out,out($index)),
                            Nil
                          )
                        )
                      )
                    )
                  )
                )
            }
            method is-lazy() { $!source.is-lazy && $!indexes.is-lazy }
        }.new(source,indexes,offset,&out)
    }

    # Return an iterator for the given low/high integer value (inclusive).
    # Has dedicated .push-all for those cases one needs to fill a list
    # with consecutive numbers quickly.
    method IntRange(\from,\to) {
        class :: does Iterator {
            has int $!i;
            has int $!last;

            method !SET-SELF(int $i, int $last) {
                nqp::stmts(
                  ($!i    = nqp::sub_i($i,1)),
                  ($!last = $last),
                  self
                )
            }
            method new(\f,\t) { nqp::create(self)!SET-SELF(f,t) }

            method pull-one() {
                nqp::if(
                  nqp::isle_i(($!i = nqp::add_i($!i,1)),$!last),
                  $!i,
                  IterationEnd
                )
            }
            method push-all($target --> IterationEnd) {
                nqp::stmts(
                  (my int $i    = $!i),      # lexicals are faster than attrs
                  (my int $last = $!last),
                  nqp::while(
                    nqp::isle_i(($i = nqp::add_i($i,1)),$last),
                    $target.push(nqp::p6box_i($i))
                  ),
                  ($!i = $i),                # make sure pull-one ends
                )
            }
            method count-only() { nqp::p6box_i(nqp::sub_i($!last,$!i)) }
            method bool-only()  { nqp::p6bool(nqp::isgt_i($!last,$!i)) }
            method sink-all(--> IterationEnd) { $!i = $!last }
        }.new(from,to)
    }

    # Return an iterator from a given iterator producing Pairs, in which
    # each .value is checked for iterability: if Iterable, produce Pairs
    # with the original key as its value, and key with the values produced
    # by the Iterable.  Otherwise, just produce an antipair.
    method Invert(\iterator) {
        class :: does Iterator {
            has $!iterator;   # source iterator
            has $!value;      # original key to repeat for Iterable
            has $!slipper;    # iterator if Iterable value in source

            method new(\iterator) {
                nqp::p6bindattrinvres(
                  nqp::create(self),self,'$!iterator',iterator)
            }
            method pull-one() {
                nqp::if(
                  $!slipper,                            # we have a slipper
                  nqp::if(
                    nqp::eqaddr(
                      (my $pulled := $!slipper.pull-one),
                      IterationEnd
                    ),
                    nqp::stmts(                         # slipper exhausted
                      ($!slipper := nqp::null),         # deny all knowledge
                      self.pull-one                     # rinse and repeat
                    ),
                    Pair.new($pulled,$!value)           # not the end, slip it
                  ),
                  nqp::if(                              # no slipper
                    nqp::eqaddr(
                      ($pulled := nqp::decont($!iterator.pull-one)),
                      IterationEnd
                    ),
                    IterationEnd,                       # source exhausted
                    nqp::if(                            # still in business
                      nqp::istype($pulled,Pair),
                      nqp::if(                          # it's a Pair, whee!
                        nqp::istype(
                          (my $key := nqp::getattr($pulled,Pair,'$!value')),
                          Iterable
                        ),
                        nqp::stmts(                     # need to slip it!
                          ($!slipper := $key.iterator), # set up the slipper
                          ($!value := nqp::getattr($pulled,Pair,'$!key')),
                          self.pull-one                 # rinse and repeat
                        ),
                        Pair.new(                       # just needs swapping
                          $key,
                          nqp::getattr($pulled,Pair,'$!key')
                        )
                      ),
                      X::TypeCheck.new(                 # naughty, slap it!
                        operation => 'invert',
                        got       => $pulled,
                        expected  => Pair
                      ).throw
                    )
                  )
                )
            }
            method is-lazy() { $!iterator.is-lazy }
            method sink-all(--> IterationEnd) {
                nqp::until(
                  nqp::eqaddr((my $pulled := $!iterator.pull-one),IterationEnd),
                  nqp::unless(
                    nqp::istype($pulled,Pair),
                    X::TypeCheck.new(                   # naughty, slap it!
                      operation => 'invert',
                      got       => $pulled,
                      expected  => Pair
                    ).throw
                  )
                )
            }
        }.new(iterator)
    }

    # Return an iterator that will alternately generate an index value,
    # and the value of the given iterator, basically the .kv functionality
    # for 1 dimensional lists.
    method KeyValue(\iterator) {
        class :: does Iterator {
            has Mu $!iter;
            has Mu $!pulled;
            has int $!on-key;
            has int $!key;

            method !SET-SELF(\iter) { $!iter := iter; $!key = -1; self }
            method new(\iter) { nqp::create(self)!SET-SELF(iter) }

            method pull-one() is raw {
                nqp::if(
                  ($!on-key = nqp::not_i($!on-key)),
                  nqp::if(
                    nqp::eqaddr(
                      ($!pulled := $!iter.pull-one),IterationEnd
                    ),
                    IterationEnd,
                    nqp::p6box_i(($!key = nqp::add_i($!key,1))),
                  ),
                  $!pulled,
                )
            }
            method push-all($target --> IterationEnd) {
                my $pulled;
                my int $key = -1;
                nqp::until(
                  nqp::eqaddr(
                    ($pulled := $!iter.pull-one),
                    IterationEnd
                  ),
                  nqp::stmts(
                    $target.push(nqp::p6box_i(($key = nqp::add_i($key,1)))),
                    $target.push($pulled),
                  )
                )
            }
        }.new(iterator)
    }

    # Create iterator for the last N values of a given iterator.  Needs
    # to specify the :action part of X::Cannot::Lazy in case the given
    # iterator is lazy.  Optionally returns an empty iterator if the
    # given iterator produced fewer than N values.
    method LastNValues(\iterator, \n, \action, $full = 0) {
        class :: does Iterator {
            has $!iterator;
            has int $!size;
            has int $!full;
            has $!lastn;
            has int $!todo;
            has int $!index;
            method !SET-SELF(\iterator, \size, \full) {
                nqp::stmts(
                  ($!iterator := iterator),
                  ($!full = full),
                  ($!lastn := nqp::setelems(nqp::list, $!size = size)),
                  nqp::setelems($!lastn, 0),
                  self
                )
            }
            method new(\iterator,\n,\action,\f) {
                nqp::if(
                  iterator.is-lazy,
                  X::Cannot::Lazy.new(:action(action)).throw,
                  nqp::if(
                    nqp::istype(n,Whatever),
                    iterator,                   # * just give back itself
                    nqp::if(
                      n <= 0,                   # must be HLL comparison
                      Rakudo::Iterator.Empty,   # negative is just nothing
                      nqp::if(
                        (nqp::istype(n,Int)
                          && nqp::isbig_I(nqp::decont(n)))
                          || n == Inf,
                        iterator,               # big value = itself
                        nqp::create(self)!SET-SELF(iterator,n,f)
                      )
                    )
                  )
                )
            }
            method !next() is raw {
                nqp::stmts(
                  (my int $index = $!index),
                  ($!index = nqp::mod_i(nqp::add_i($!index,1),$!size)),
                  ($!todo  = nqp::sub_i($!todo,1)),
                  nqp::atpos($!lastn,$index)
                )
            }
            method pull-one() is raw {
                nqp::if(
                  $!todo,
                  self!next,
                  nqp::if(
                    nqp::defined($!iterator),
                    nqp::stmts(
                      (my int $index),
                      (my int $size = $!size),
                      nqp::until(
                        nqp::eqaddr(
                          (my $pulled := $!iterator.pull-one),IterationEnd),
                        nqp::stmts(
                          nqp::bindpos($!lastn, $index, $pulled),
                          ($index = nqp::mod_i(nqp::add_i($index,1),$size))
                        )
                      ),
                      nqp::if(
                        nqp::iseq_i(nqp::elems($!lastn),$size),   # full set
                        nqp::stmts(
                          ($!index = $index),
                          ($!todo  = $!size)
                        ),
                        ($!todo =       # not a full set, $!index still at 0
                          nqp::if($!full,0,nqp::elems($!lastn))),
                      ),
                      ($!iterator := Mu),                   # done iterating
                      nqp::if($!todo, self!next, IterationEnd)
                    ),
                    IterationEnd
                  )
                )
            }
        }.new(iterator, n, action, $full)
    }

    # Return the last value of the given source iterator (if any).
    # Also needs the action string to be used in X::Cannot::Lazy if
    # the source iterator turns out to be lazy.
    method LastValue(\iterator, $action) is raw {
        nqp::if(
          iterator.is-lazy,
          X::Cannot::Lazy.new(:$action).throw,
          nqp::stmts(
            (my $result := IterationEnd),
            nqp::if(
              nqp::can(iterator, 'count-only'),
              nqp::if(
                (my $count := iterator.count-only)
                && iterator.skip-at-least($count - 1),
                $result := iterator.pull-one
              ),
              nqp::until(
                nqp::eqaddr((my $pulled := iterator.pull-one),IterationEnd),
                ($result := $pulled)
              ),
            ),
            $result
          )
        )
    }

    # Return an iterator given a List and an iterator that generates
    # an IterationBuffer of indexes for each pull.  Each value is
    # is a List with the mapped elements.
    method ListIndexes(\list,\indexes) {
        nqp::if(
          (my int $elems = list.elems),     # reifies
          class :: does Iterator {          # actually need to do some mapping
              has $!list;
              has $!indexes;
              method !SET-SELF(\list,\indexes) {
                  nqp::stmts(
                    ($!list := nqp::getattr(list,List,'$!reified')),
                    ($!indexes := indexes),
                    self
                  )
                }
              method new(\l,\i) { nqp::create(self)!SET-SELF(l,i) }
              method pull-one() {
                  nqp::if(
                    nqp::eqaddr(
                      (my $buffer := $!indexes.pull-one),
                      IterationEnd
                    ),
                    IterationEnd,
                    nqp::stmts(
                      (my int $elems = nqp::elems($buffer)),
                      (my int $i = -1),
                      nqp::while(           # repurpose buffer for result
                        nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                        nqp::bindpos($buffer,$i,
                          nqp::atpos($!list,nqp::atpos($buffer,$i))
                        )
                      ),
                      nqp::p6bindattrinvres(
                        nqp::create(List),List,'$!reified',$buffer)
                    )
                  )
              }
          }.new(list,indexes),
          Rakudo::Iterator.OneValue(nqp::create(List)) # only one
        )
    }

    # Returns an iterator that handles all properties of a bare -loop-
    # Takes a Callable to be considered the body of the loop.
    method Loop(&body) {
        class :: does SlippyIterator {
            has &!body;

            method new(&body) {
                nqp::p6bindattrinvres(nqp::create(self),self,'&!body',&body)
            }

            method pull-one() {
                my $result;
                my int $stopped;
                nqp::if(
                  $!slipping && nqp::not_i(
                    nqp::eqaddr(($result := self.slip-one),IterationEnd)
                  ),
                  $result,
                  nqp::stmts(
                    nqp::until(
                      $stopped,
                      nqp::stmts(
                        ($stopped = 1),
                        nqp::handle(
                          nqp::if(
                            nqp::istype(($result := &!body()),Slip),
                            ($stopped = nqp::eqaddr(
                              ($result := self.start-slip($result)),
                              IterationEnd
                            ))
                          ),
                          'NEXT', ($stopped = 0),
                          'REDO', ($stopped = 0),
                          'LAST', ($result := IterationEnd)
                        )
                      ),
                      :nohandler
                    ),
                    $result
                  )
                )
            }

            method is-lazy(--> True) { }
        }.new(&body)
    }

    # An often occurring use of the Mappy role to generate all of the
    # keys of a Map / Hash.  Takes a Map / Hash as the only parameter.
    method Mappy-keys(\map) {
        class :: does Rakudo::Iterator::Mappy {
            method pull-one() {
                nqp::if(
                  $!iter,
                  nqp::iterkey_s(nqp::shift($!iter)),
                  IterationEnd
                )
            }
            method push-all($target --> IterationEnd) {
                nqp::while(
                  $!iter,
                  $target.push(nqp::iterkey_s(nqp::shift($!iter)))
                )
            }
        }.new(map)
    }

    # An often occurring use of the Mappy role to generate alternating
    # key and values of a Map/Hash in which each value is a Pair to
    # be interpreted as the actual key/value.  Takes a Map / Hash as
    # the only parameter.
    method Mappy-kv-from-pairs(\map) {
        # make sure class gets created at compile time, to avoid global
        # de-opt at run-time
        class :: does Mappy-kv-from-pairs { }.new(map)
    }

    # An often occurring use of the Mappy role to generate all of the
    # values of a Map / Hash.  Takes a Map / Hash as the only parameter.
    method Mappy-values(\map) {
        class :: does Mappy {
            method pull-one() is raw {
                nqp::if(
                  $!iter,
                  nqp::iterval(nqp::shift($!iter)),
                  IterationEnd
                )
            }
            method push-all($target --> IterationEnd) {
                nqp::while(  # doesn't sink
                  $!iter,
                  $target.push(nqp::iterval(nqp::shift($!iter)))
                )
            }
        }.new(map)
    }

    # Return an iterator that will iterate over a source iterator and an
    # iterator generating monotonically increasing index values from a
    # given offset.  Optionally, call block if an out-of-sequence index
    # value is obtained, or simply ignore out of sequence index values.
    method MonotonicIndexes(\source,\indexes,\offset,&out?) {
        class :: does Iterator {
            has $!source;     # source iterator
            has $!indexes;    # iterator providing index values
            has int $!next;   # virtual index of next source value
            has &!out;        # callable for out of sequence values
            method !SET-SELF($!source,$!indexes,\offset,&!out) {
                $!next = offset;
                self
            }
            method new(\s,\i,\o,\out) { nqp::create(self)!SET-SELF(s,i,o,out) }
            method pull-one() is raw {
                nqp::stmts(
                  nqp::until(
                    nqp::eqaddr(
                      (my $got := $!indexes.pull-one),
                      IterationEnd
                    ),
                    nqp::if(
                      nqp::istype((my $number = +$got),Failure),
                      $number.throw,
                      nqp::if(
                        nqp::isle_i($!next,(my int $index = $number.Int)),
                        nqp::stmts(                      # possibly valid index
                          nqp::while(
                            nqp::islt_i($!next,$index) && $!source.skip-one,
                            ($!next = nqp::add_i($!next,1))
                          ),
                          (return-rw nqp::if(
                            nqp::iseq_i($!next,$index),
                            nqp::stmts(
                              ($!next = nqp::add_i($!next,1)),
                              $!source.pull-one
                            ),
                            IterationEnd
                          ))
                        ),
                        nqp::if(&out,out($index,$!next)) # out of sequence
                      )
                    )
                  ),
                  IterationEnd
                )
            }
        }.new(source,indexes,offset,&out)
    }

    # Returns an iterator for the next N values of given iterator.
    method NextNValues(\iterator,\times) {
        class :: does Iterator {
            has $!iterator;
            has int $!times;
            method !SET-SELF($!iterator,$!times) { self }
            method new(\iterator,\times) {
                nqp::if(
                  nqp::istype(times,Whatever),
                  iterator,                   # * just give back itself
                  nqp::if(
                    times <= 0,               # must be HLL comparison
                    Rakudo::Iterator.Empty,   # negative is just nothing
                    nqp::if(
                      (nqp::istype(times,Int)
                        && nqp::isbig_I(nqp::decont(times)))
                        || times == Inf,
                      iterator,               # big value = itself
                      nqp::create(self)!SET-SELF(iterator,times)
                    )
                  )
                )
            }
            method pull-one() is raw {
                nqp::if(
                  nqp::isgt_i($!times,0),
                  nqp::if(
                    nqp::eqaddr(
                      (my $pulled := $!iterator.pull-one),
                      IterationEnd
                    ),
                    nqp::stmts(
                      ($!times = 0),
                      IterationEnd
                    ),
                    nqp::stmts(
                      ($!times = nqp::sub_i($!times,1)),
                      $pulled
                    )
                  ),
                  IterationEnd
                )
            }
        }.new(iterator,times)
    }

    # Return an iterator that only will return the given value once.
    # Basically the same as 42 xx 1.
    method OneValue(Mu \value) {
        class :: does Iterator {
            has Mu $!value;
            method new(Mu \value) {
                nqp::p6bindattrinvres(nqp::create(self),self,'$!value',value)
            }
            method pull-one() is raw {
                nqp::if(




                  nqp::isnull($!value),

                  IterationEnd,
                  nqp::stmts(
                    (my Mu $value := $!value),




                    ($!value := nqp::null),

                    $value
                  )
                )
            }
            method push-all($target --> IterationEnd) {
                nqp::stmts(





                  nqp::unless(nqp::isnull($!value),$target.push($!value)),
                  ($!value := nqp::null)

                )
            }
            method skip-one() {
                nqp::if(





                  nqp::not_i(nqp::isnull($!value)),
                  nqp::isfalse($!value := nqp::null)

                )
            }
            method sink-all(--> IterationEnd) {




                $!value := nqp::null

            }
            method count-only(--> 1) { }
            method bool-only(--> True) { }
        }.new(value)
    }

    # Return an iterator that only will return the given value for the
    # given number of times.  Basically the same as 42 xx N.
    method OneValueTimes(Mu \value,\times) {
        class :: does Iterator {
            has Mu $!value;
            has Int $!times;
            has int $!is-lazy;

            method !SET-SELF(Mu \value,\times) {
                nqp::stmts(
                  ($!value := value),
                  ($!times  = times),
                  ($!is-lazy = nqp::isbig_I(nqp::decont(times))),
                  self
                )
            }
            method new(Mu \value,\times) {
                nqp::if(
                  times > 0,
                  nqp::create(self)!SET-SELF(value,times),
                  Rakudo::Iterator.Empty
                )
            }
            method pull-one() is raw {
                nqp::if(
                  $!times,
                  nqp::stmts(
                    --$!times,
                    $!value
                  ),
                  IterationEnd
                )
            }
            method push-all($target --> IterationEnd) {
                nqp::while(
                  $!times,
                  nqp::stmts(
                    --$!times,
                    $target.push($!value)
                  )
                )
            }
            method skip-one() { nqp::if($!times,$!times--) }
            method is-lazy() { nqp::p6bool($!is-lazy) }
            method sink-all(--> IterationEnd) { $!times = 0 }
            method count-only() { $!times }
            method bool-only(--> True) { }
        }.new(value,times)
    }

    # Return an iterator that will generate a pair with the index as the
    # key and as value the value of the given iterator, basically the
    # .pairs functionality on 1 dimensional lists.
    method Pair(\iterator) {
        class :: does Iterator {
            has Mu $!iter;
            has int $!key;

            method !SET-SELF(\iter) { $!iter := iter; $!key = -1; self }
            method new(\iter) { nqp::create(self)!SET-SELF(iter) }

            method pull-one() is raw {
                nqp::if(
                  nqp::eqaddr((my $pulled := $!iter.pull-one),IterationEnd),
                  IterationEnd,
                  Pair.new(($!key = nqp::add_i($!key,1)),$pulled)
                )
            }
            method push-all($target --> IterationEnd) {
                my $pulled;
                my int $key = -1;
                nqp::until(
                  nqp::eqaddr(($pulled := $!iter.pull-one),IterationEnd),
                  $target.push(Pair.new(($key = nqp::add_i($key,1)),$pulled))
                )
            }
        }.new(iterator)
    }

    # Return an iterator for a given number of permutations.  Also specify
    # whether an IterationBuffer should be returned for each iteration (1),
    # or a List (0).  Basically the workhorse of permutations.
    method Permutations($n, int $b) {
        nqp::if(
          $n > nqp::if(nqp::iseq_i($?BITS,32),13,20),  # must be HLL comparison
          (die "Cowardly refusing to permutate more than {
              $?BITS == 32 ?? 13 !! 20
          } elements, tried $n"),
          nqp::if(
            $n < 1,                                    # must be HLL comparison
            Rakudo::Iterator.OneValue(
              nqp::create(nqp::if($b,IterationBuffer,List))
            ),
            # See:  L<https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order>
            class :: does Iterator {
                has int $!n;
                has int $!b;
                has int $!todo;
                has int $!elems;
                has $!next;
                method !SET-SELF(int $n, int $b) {
                    nqp::stmts(
                      ($!n = $n),
                      ($!b = $b),
                      ($!todo = 1),
                      (my int $i = 1),
                      nqp::while(
                        nqp::isle_i(($i = nqp::add_i($i,1)),$n),
                        ($!todo = nqp::mul_i($!todo,$i))
                      ),
                      ($!elems = $!todo),
                      ($!next :=
                        nqp::setelems(nqp::create(IterationBuffer),$n)),
                      ($i = -1),
                      nqp::while(
                        nqp::islt_i(($i = nqp::add_i($i,1)),$n),
                        nqp::bindpos($!next,$i,nqp::clone($i))
                      ),
                      self
                    )
                }
                method new(\n,\b) { nqp::create(self)!SET-SELF(n,b) }
                method pull-one {
                    nqp::if(
                      nqp::isge_i(($!todo = nqp::sub_i($!todo,1)),0),
                      nqp::stmts(
                        (my $permuted := nqp::clone($!next)),
                        nqp::if(
                          $!todo,     # need to calculate next one
                          nqp::stmts( # largest index k such that a[k] < a[k+1]
                            (my int $k = nqp::sub_i($!n,2)),
                            nqp::until(
                              nqp::islt_i(
                                nqp::atpos($!next,$k),
                                nqp::atpos($!next,nqp::add_i($k,1))
                              ),
                              ($k = nqp::sub_i($k,1)),
                            ),
                            (my int $l = nqp::sub_i($!n,1)),
                            nqp::until(
                              nqp::islt_i( # largest index l>k where a[k] < a[l]
                                nqp::atpos($!next,$k),
                                nqp::atpos($!next,$l)
                              ),
                              ($l = nqp::sub_i($l,1))
                            ),
                            (my $tmp := nqp::atpos($!next,$k)),
                            nqp::bindpos($!next,$k,nqp::atpos($!next,$l)),
                            nqp::bindpos($!next,$l,$tmp)
                          )
                        ),
                        ($l = $!n),
                        nqp::until(
                          nqp::isge_i(
                            ($k = nqp::add_i($k,1)),
                            ($l = nqp::sub_i($l,1))
                          ),
                          nqp::stmts(
                            ($tmp := nqp::atpos($!next,$k)),
                            nqp::bindpos($!next,$k,nqp::atpos($!next,$l)),
                            nqp::bindpos($!next,$l,$tmp)
                          )
                        ),
                        nqp::if(
                          $!b,
                          $permuted,
                          nqp::p6bindattrinvres(
                            nqp::create(List),List,'$!reified',$permuted)
                        )
                      ),
                      IterationEnd
                    )
                }
                method count-only { $!elems }
                method bool-only(--> True) { }
            }.new($n,$b)
          )
        )
    }

    # Return an iterator for an Array that has been completely reified
    # already.  Returns a assignable container for elements don't exist
    # before the end of the reified array.
    method ReifiedArray(\array, Mu \descriptor) {
        class :: does Iterator {
            has $!reified;
            has $!descriptor;
            has int $!i;

            method !SET-SELF(\array, Mu \des) {
                nqp::stmts(
                  ($!reified    := nqp::getattr(array, List,  '$!reified')),
                  ($!descriptor := des),
                  ($!i = -1),
                  self
                )
            }
            method new(\arr, Mu \des) { nqp::create(self)!SET-SELF(arr, des) }

            method pull-one() is raw {
                nqp::ifnull(
                  nqp::atpos($!reified,$!i = nqp::add_i($!i,1)),
                  nqp::if(
                    nqp::islt_i($!i,nqp::elems($!reified)), # found a hole
                    nqp::p6bindattrinvres(
                      (my \v := nqp::p6scalarfromdesc($!descriptor)),
                      Scalar,
                      '$!whence',
                      -> { nqp::bindpos($!reified,$!i,v) }
                    ),
                    IterationEnd
                  )
                )
            }

            method push-all($target --> IterationEnd) {
                nqp::stmts(
                  (my int $elems = nqp::elems($!reified)),
                  nqp::while(   # doesn't sink
                    nqp::islt_i($!i = nqp::add_i($!i,1),$elems),
                    $target.push(nqp::ifnull(
                      nqp::atpos($!reified,$!i),
                      nqp::p6bindattrinvres(
                        (my \v := nqp::p6scalarfromdesc($!descriptor)),
                        Scalar,
                        '$!whence',
                        -> { nqp::bindpos($!reified,$!i,v) }
                      )
                    ))
                  )
                )
            }
            method skip-one() {
                nqp::islt_i(
                  ($!i = nqp::add_i($!i,1)),
                  nqp::elems($!reified)
                )
            }
            method skip-at-least(Int:D $toskip) {
                nqp::unless(
                  $toskip <= 0,  # must be HLL
                  nqp::stmts(
                    ($!i = nqp::if(
                      $!i + $toskip < nqp::elems($!reified),  # must be HLL
                      nqp::add_i($!i,$toskip),
                      nqp::elems($!reified)
                    )),
                    nqp::islt_i($!i,nqp::elems($!reified))
                  )
                )
            }
            method count-only() { nqp::p6box_i(nqp::elems($!reified)) }
            method bool-only()  { nqp::p6bool(nqp::elems($!reified)) }
            method sink-all(--> IterationEnd) { $!i = nqp::elems($!reified) }
        }.new(array, descriptor)
    }

    # Return an iterator for a List that has been completely reified
    # already.  Returns an nqp::null for elements that don't exist
    # before the end of the reified list.
    method ReifiedList(\list) {
        class :: does Iterator {
            has $!reified;
            has int $!i;

            method !SET-SELF(\list) {
                nqp::stmts(
                  ($!reified := nqp::if(
                    nqp::istype(list,List),
                    nqp::getattr(list,List,'$!reified'),
                    list)),
                  ($!i = -1),
                  self
                )
            }
            method new(\list) { nqp::create(self)!SET-SELF(list) }

            method pull-one() is raw {
                nqp::ifnull(
                  nqp::atpos($!reified,$!i = nqp::add_i($!i,1)),
                  nqp::if(
                    nqp::islt_i($!i,nqp::elems($!reified)), # found a hole
                    nqp::null,                              # it's a hole
                    IterationEnd                            # it's the end
                  )
                )
            }
            method push-all($target --> IterationEnd) {
                nqp::stmts(
                  (my int $elems = nqp::elems($!reified)),
                  (my int $i = $!i), # lexicals are faster than attributes
                  nqp::while(  # doesn't sink
                    nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                    $target.push(nqp::atpos($!reified,$i))
                  ),
                  ($!i = $i)
                )
            }
            method skip-one() {
                nqp::islt_i(
                  ($!i = nqp::add_i($!i,1)),
                  nqp::elems($!reified)
                )
            }
            method skip-at-least(Int:D $toskip) {
                nqp::unless(
                  $toskip <= 0,  # must be HLL
                  nqp::stmts(
                    ($!i = nqp::if(
                      $!i + $toskip < nqp::elems($!reified),  # must be HLL
                      nqp::add_i($!i,$toskip),
                      nqp::elems($!reified)
                    )),
                    nqp::islt_i($!i,nqp::elems($!reified))
                  )
                )
            }
            method count-only() { nqp::p6box_i(nqp::elems($!reified)) }
            method bool-only()  { nqp::p6bool(nqp::elems($!reified)) }
            method sink-all(--> IterationEnd) { $!i = nqp::elems($!reified) }
        }.new(list)
    }

    # Return an iterator that produces values in reverse order for a
    # List that has been completely reified already.  Returns an nqp::null
    # for elements don't exist before the end of the reified list.
    method ReifiedListReverse(\list) {
        class :: does Iterator {
            has $!reified;
            has int $!i;

            method !SET-SELF(\list) {
                nqp::stmts(
                  ($!reified := nqp::if(
                    nqp::istype(list,List),
                    nqp::getattr(list,List,'$!reified'),
                    list)),
                  ($!i = nqp::elems($!reified)),
                  self
                )
            }
            method new(\list) { nqp::create(self)!SET-SELF(list) }

            method pull-one() is raw {
                nqp::if(
                  $!i,
                  nqp::atpos($!reified,$!i = nqp::sub_i($!i,1)),
                  IterationEnd
                )
            }
            method push-all($target --> IterationEnd) {
                nqp::stmts(
                  (my int $i = nqp::elems($!reified)),
                  nqp::while(  # doesn't sink
                    $i,
                    $target.push(nqp::atpos($!reified,($i = nqp::sub_i($i,1))))
                  ),
                  ($!i = 0)
                )
            }
            method skip-one() {
                nqp::if(
                  $!i,
                  nqp::isge_i(($!i = nqp::sub_i($!i,1)),0)
                )
            }
            method skip-at-least(int $toskip) {
                nqp::unless(
                  nqp::isge_i(($!i = nqp::sub_i($!i,$toskip)),0),
                  ($!i = 0)
                )
            }
            method count-only() { nqp::p6box_i(nqp::elems($!reified)) }
            method bool-only()  { nqp::p6bool(nqp::elems($!reified)) }
            method sink-all(--> IterationEnd) { $!i = 0 }
        }.new(list)
    }

    # Return a lazy iterator that will repeat the values of a given
    # source iterator indefinitely.  Even when given a lazy iterator,
    # it will cache the values seen to handle case that the iterator
    # will exhaust after all.  Only if the source iterator did not
    # produce any values at all, then the returned iterator will not
    # produce any either.
    method Repeat(\iterator) {
        class :: does Iterator {
            has $!iterator;
            has $!reified;
            has int $!i;
            method !SET-SELF(\iterator) {
                nqp::stmts(
                  ($!iterator := iterator),
                  ($!reified  := nqp::create(IterationBuffer)),
                  self
                )
            }
            method new(\iter) { nqp::create(self)!SET-SELF(iter) }
            method pull-one() is raw {
                nqp::if(




                  nqp::isnull($!iterator),

                  nqp::atpos(                # supplying from cache
                    $!reified,
                    nqp::mod_i(
                      ($!i = nqp::add_i($!i,1)),
                      nqp::elems($!reified)
                    )
                  ),
                  nqp::if(                   # supplying from iterator
                    nqp::eqaddr(
                      (my $pulled := $!iterator.pull-one),
                      IterationEnd
                    ),
                    nqp::if(
                      nqp::elems($!reified),
                      nqp::stmts(            # exhausted, something in cache




                        ($!iterator := nqp::null),

                        nqp::atpos($!reified,0)
                      ),
                      IterationEnd           # exhausted, nothing in cache
                    ),
                    nqp::push(               # cache and supply
                      $!reified,
                      $pulled
                    )
                  )
                )
            }
            method is-lazy(--> True) { }     # we're lazy, always
        }.new(iterator)
    }

    # Returns an iterator that handles all properties of a -repeat- with
    # a condition.  Takes a Callable to be considered the body of the loop,
    # and a Callable for the condition..
    method RepeatLoop(&body, &cond) {
        class :: does SlippyIterator {
            has $!body;
            has $!cond;
            has int $!skip;

            method !SET-SELF(\body,\cond) {
                nqp::stmts(
                  ($!body := body),
                  ($!cond := cond),
                  ($!skip = 1),
                  self
                )
            }
            method new(\body,\cond) {
                nqp::create(self)!SET-SELF(body,cond)
            }

            method pull-one() {
                if $!slipping && nqp::not_i(
                    nqp::eqaddr((my $result := self.slip-one),IterationEnd)
                ) {
                    $result
                }
                else {
                    nqp::if(
                      $!skip || $!cond(),
                      nqp::stmts(
                        ($!skip = 0),
                        nqp::until(
                          (my int $stopped),
                          nqp::stmts(
                            ($stopped = 1),
                            nqp::handle(
                              nqp::if(
                                nqp::istype(($result := $!body()),Slip),
                                ($stopped = nqp::eqaddr(
                                  ($result := self.start-slip($result)),
                                  IterationEnd
                                ) && nqp::if($!cond(),0,1))
                              ),
                              'NEXT', ($stopped = nqp::if($!cond(),0,1)),
                              'REDO', ($stopped = 0),
                              'LAST', ($result := IterationEnd)
                            )
                          ),
                          :nohandler
                        ),
                        $result
                      ),
                      IterationEnd
                    )
                }
            }
        }.new(&body,&cond)
    }

    # Return an iterator that rotorizes the given iterator with the
    # given cycle.  If the cycle is a Cool, then it is assumed to
    # be a single Int value to R:It.Batch with.  Otherwise it is
    # considered to be something Iterable that will be repeated
    # until the source iterator is exhausted.  The third parameter
    # indicates whether a partial result is acceptable when the
    # source iterator is exhausted.
    method Rotor(\iterator,\cycle,\partial) {
        class :: does Iterator {
            has $!iterator;
            has $!cycle;
            has $!buffer;
            has int $!complete;
            method !SET-SELF(\iterator,\cycle,\partial) {
                nqp::stmts(
                  ($!iterator := iterator),
                  ($!cycle    := Rakudo::Iterator.Repeat(cycle.iterator)),
                  ($!buffer   := nqp::create(IterationBuffer)),
                  ($!complete  = !partial),
                  self
                )
            }
            method new(\iterator,\cycle,\partial) {
                nqp::if(
                  nqp::istype(cycle,Iterable),
                  nqp::create(self)!SET-SELF(iterator,cycle,partial),
                  Rakudo::Iterator.Batch(iterator,cycle,partial)
                )
            }
            method pull-one() is raw {
                nqp::stmts(
                  nqp::if(
                    nqp::istype((my $todo := $!cycle.pull-one),Pair),
                    nqp::stmts(
                      (my $size := $todo.key),
                      nqp::if(
                        nqp::istype($size,Whatever),
                        nqp::stmts(                    # eat everything
                          (my int $elems = -1),
                          ($!complete = 0)
                        ),
                        nqp::if(
                          $size < 1,                   # must be HLL comparison
                          X::OutOfRange.new(
                            what    => "Rotorizing sublist length is",
                            got     => $size,
                            range   => "1..^Inf",
                          ).throw,
                          nqp::if(
                            $size == Inf || (
                              nqp::istype($size,Int)
                                && nqp::isbig_I(nqp::decont($size))
                            ),
                            nqp::stmts(                # eat everything
                              ($elems = -1),
                              ($!complete = 0)
                            ),
                            nqp::if(
                              nqp::isle_i(
                                nqp::add_i(
                                  ($elems = $size.Int),
                                  (my int $gap = $todo.value.Int)
                                ),
                                -1
                              ),
                              X::OutOfRange.new(       # gap out of range
                                what    => "Rotorizing gap is",
                                got     => $gap,
                                range   => "-$elems..^Inf",
                                comment => "\nEnsure a negative gap is not larger than the length of the sublist",
                              ).throw
                            )
                          )
                        )
                      )
                    ),
                    nqp::if(                           # just a size
                      nqp::istype($todo,Whatever),
                      nqp::stmts(                      # eat everything
                        ($elems = -1),
                        ($!complete = 0)
                      ),
                      nqp::if(
                        $todo < 1,                     # must be HLL comparison
                        X::OutOfRange.new(             # size out of range
                          what    => "Rotorizing sublist length is",
                          got     => $todo,
                          range   => "1..^Inf",
                          comment => "\nDid you mean to specify a Pair with => $todo?"
                        ).throw,
                        nqp::if(
                          (nqp::istype($todo,Int)
                            && nqp::isbig_I(nqp::decont($todo)))
                            || $todo == Inf,
                          nqp::stmts(                  # eat everything
                            ($elems = -1),
                            ($!complete = 0)
                          ),
                          ($elems = $todo.Int)
                        )
                      )
                    )
                  ),
                  nqp::until(                          # fill the buffer
                    nqp::isge_i(nqp::elems($!buffer),$elems)
                      || nqp::eqaddr(
                           (my $pulled := $!iterator.pull-one),
                           IterationEnd
                         ),
                    nqp::push($!buffer,$pulled)
                  ),
                  nqp::if(
                    nqp::not_i(nqp::elems($!buffer))
                      || (nqp::eqaddr($pulled,IterationEnd)
                           && $!complete
                           && nqp::islt_i(nqp::elems($!buffer),$elems)
                         ),
                    IterationEnd,                      # done
                    nqp::if(
                      nqp::islt_i($gap,0),
                      nqp::stmts(                      # keep some for next
                        (my $result := nqp::p6bindattrinvres(
                          nqp::create(List),List,'$!reified',
                          nqp::clone($!buffer)
                        )),
                        nqp::if(
                          nqp::islt_i(nqp::elems($!buffer),$elems),
                          nqp::setelems($!buffer,0),   # was :partial, now done
                          nqp::splice($!buffer,$empty,0,nqp::add_i($elems,$gap))
                        ),
                        $result
                      ),
                      nqp::stmts(
                        nqp::if(
                          nqp::isgt_i($gap,0),
                          $!iterator.skip-at-least($gap) # need to skip a few
                        ),
                        nqp::if(
                          nqp::isle_i(nqp::elems($!buffer),$elems),
                          nqp::stmts(                    # whole buffer ok
                            ($result := nqp::p6bindattrinvres(
                              nqp::create(List),List,'$!reified',
                              $!buffer
                            )),
                            ($!buffer := nqp::create(IterationBuffer))
                          ),
                          nqp::stmts(                    # partial buffer ok
                            ($result := nqp::p6bindattrinvres(
                              nqp::create(List),List,'$!reified',
                              nqp::splice(
                                nqp::clone($!buffer),
                                $empty,
                                $elems,
                                nqp::sub_i(nqp::elems($!buffer),$elems)
                              )
                            )),
                            nqp::splice($!buffer,$empty,0,$elems)
                          )
                        ),
                        $result
                      )
                    )
                  )
                )
            }
            method is-lazy() { $!iterator.is-lazy }
        }.new(iterator,cycle,partial)
    }

    # Return an iterator that will roundrobin the given iterables
    # (with &[,]).  Basically the functionality of roundrobin(@a,@b)
    method RoundrobinIterables(@iterables) {
        nqp::if(
          nqp::isgt_i((my int $n = @iterables.elems),1),  # reifies
          class :: does Iterator {
              has $!iters;
              has int $!lazy;
              method !SET-SELF(\iterables) {
                  nqp::stmts(
                    (my $iterables := nqp::getattr(iterables,List,'$!reified')),
                    (my int $elems = nqp::elems($iterables)),
                    ($!iters := nqp::setelems(nqp::list,$elems)),
                    (my int $i = -1),
                    nqp::while(
                      nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                      nqp::bindpos($!iters,$i,
                        nqp::if(
                          nqp::iscont(my $elem := nqp::atpos($iterables,$i)),
                          Rakudo::Iterator.OneValue($elem),
                          nqp::stmts(
                            nqp::if($elem.is-lazy,($!lazy = 1)),
                            $elem.iterator
                          )
                        )
                      )
                    ),
                    self
                  )
              }
              method new(\iterables) { nqp::create(self)!SET-SELF(iterables) }
              method pull-one() {
                  nqp::if(




                    nqp::isnull($!iters),

                    IterationEnd,
                    nqp::stmts(
                      (my int $i = -1),
                      (my int $elems = nqp::elems($!iters)),
                      (my $buf := nqp::create(IterationBuffer)),
                      nqp::until(
                        nqp::iseq_i(($i = nqp::add_i($i,1)),$elems),
                        nqp::if(
                          nqp::eqaddr(
                            (my $pulled := nqp::atpos($!iters,$i).pull-one),
                            IterationEnd
                          ),
                          nqp::stmts(          # remove exhausted iterator
                            nqp::splice($!iters,$empty,$i,1),
                            ($i = nqp::sub_i($i,1)),
                            ($elems = nqp::sub_i($elems,1))
                          ),
                          nqp::push($buf,$pulled)
                        )
                      ),
                      nqp::if(
                        nqp::elems($buf),
                        nqp::p6bindattrinvres( # at least one not exhausted
                          nqp::create(List),List,'$!reified',$buf),
                        nqp::stmts(            # we're done




                          ($!iters := nqp::null),

                          IterationEnd
                        )
                      )
                    )
                  )
              }
              method is-lazy() { nqp::p6bool($!lazy) }
          }.new(@iterables),
          nqp::if(
            nqp::iseq_i($n,0),
            Rakudo::Iterator.Empty,
            nqp::atpos(nqp::getattr(@iterables,List,'$!reified'),0).iterator
          )
        )
    }

    # Return an iterator from a source iterator that is supposed to
    # generate iterators.  As soon as a iterator, the next iterator
    # will be fetched and iterated over until exhausted.
    method SequentialIterators(\source) {
        class :: does Iterator {
            has $!source;
            has $!current;
            method !SET-SELF(\source) {
                nqp::stmts(
                  ($!current := ($!source := source).pull-one),
                  self
                )
            }
            method new(\source) { nqp::create(self)!SET-SELF(source) }
            method pull-one() {
                nqp::if(
                  nqp::eqaddr($!current,IterationEnd),
                  IterationEnd,
                  nqp::if(
                    nqp::eqaddr(
                      (my $pulled := $!current.pull-one),
                      IterationEnd
                    ),
                    nqp::stmts(
                      ($!current := $!source.pull-one),
                      self.pull-one
                    ),
                    $pulled
                  )
                )
            }
        }.new(source)
    }

    # Return an iterator that generates all possible keys of the
    # given shape.  Each value generated is a reified List.  This is
    # basically a copy of the internal engine of ShapeLeaf and
    # ShapeBranchi roles, but without any additional processing.
    # Intended for ad-hoc iterators that feed .AT-POS on shaped lists.
    method ShapeIndex(\shape) {
        class :: does Iterator {
            has $!dims;
            has $!indices;
            has int $!maxdim;
            has int $!max;

            method SET-SELF(\shape) {
                nqp::stmts(
                  ($!dims := nqp::getattr(nqp::decont(shape),List,'$!reified')),
                  (my int $dims = nqp::elems($!dims)),
                  ($!indices :=
                    nqp::setelems(nqp::create(IterationBuffer),$dims)),
                  (my int $i = -1),
                  nqp::while(
                    nqp::islt_i(($i = nqp::add_i($i,1)),$dims),
                    nqp::bindpos($!indices,$i,0)
                  ),
                  ($!maxdim = nqp::sub_i($dims,1)),
                  ($!max    = nqp::atpos($!dims,$!maxdim)),
                  self
                )
            }
            method new(\shape) { nqp::create(self).SET-SELF(shape) }

            method pull-one() is raw {
                nqp::if(
                  $!indices,
                  nqp::stmts(                      # still iterating
                    (my $buf := nqp::clone($!indices)),
                    nqp::if(
                      nqp::islt_i(                        (my int $i =
                          nqp::add_i(nqp::atpos($!indices,$!maxdim),1)),
                        $!max
                      ),
                      nqp::bindpos($!indices,$!maxdim,$i),    # ready for next
                      nqp::stmts(                             # done for now
                        (my int $level = $!maxdim),
                        nqp::until(                           # update indices
                          nqp::islt_i(                        # exhausted ??
                            ($level = nqp::sub_i($level,1)),0)
                            || nqp::stmts(
                            nqp::bindpos($!indices,nqp::add_i($level,1),0),
                            nqp::islt_i(
                              nqp::bindpos($!indices,$level,
                                nqp::add_i(nqp::atpos($!indices,$level),1)),
                              nqp::atpos($!dims,$level)
                            ),
                          ),
                          nqp::null
                        ),
                        nqp::if(                   # this was the last value
                          nqp::islt_i($level,0),
                          $!indices := nqp::null
                        )
                      )
                    ),
                    nqp::p6bindattrinvres(         # what we found
                      nqp::create(List),List,'$!reified',$buf)
                  ),
                  IterationEnd                     # done iterating
                )
            }
        }.new(shape)
    }

    # Return an iterator that only will return the two given values.
    method TwoValues(Mu \val1, Mu \val2) {
        class :: does Iterator {
            has Mu $!val1;
            has Mu $!val2;
            method new(Mu \val1, Mu \val2) {
                nqp::p6bindattrinvres(
                  nqp::p6bindattrinvres(
                    nqp::create(self),self,'$!val1',val1),
                  self,'$!val2',val2
                )
            }
            method pull-one() is raw {
                nqp::if(
















                  nqp::isnull($!val1),
                  nqp::if(
                    nqp::isnull($!val2),
                    IterationEnd,
                    nqp::stmts(
                      (my Mu $val2 := $!val2),
                      ($!val2 := nqp::null),
                      $val2
                    )
                  ),
                  nqp::stmts(
                    (my $val1 := $!val1),
                    ($!val1 := nqp::null),

                    $val1
                  )
                )
            }
            method push-all($target --> IterationEnd) {
                nqp::stmts(












                  nqp::if(
                    nqp::isnull($!val1),
                    nqp::unless(nqp::isnull($!val2),$target.push($!val2)),
                    nqp::stmts(
                      $target.push($!val1),
                      $target.push($!val2)
                    )
                  ),
                  ($!val1 := $!val2 := nqp::null)

                )
            }
            method skip-one() {
                nqp::if(








                  nqp::not_i(nqp::isnull($!val1)),
                  nqp::isfalse($!val1 := nqp::null),
                  nqp::if(
                    nqp::not_i(nqp::isnull($!val2)),
                    nqp::isfalse($!val2 := nqp::null)

                  )
                )
            }
            method sink-all(--> IterationEnd) {




                $!val1 := $!val2 := nqp::null

            }
            method count-only(--> 2) { }
            method bool-only(--> True) { }
        }.new(val1, val2)
    }

    # Return a lazy iterator that will keep producing the given value.
    # Basically the functionality of 42 xx *
    method UnendingValue(Mu \value) {
        class :: does Iterator {
            has Mu $!value;
            method new(Mu \value) {
                nqp::p6bindattrinvres(nqp::create(self),self,'$!value',value)
            }
            method pull-one() is raw { $!value }
            method is-lazy(--> True) { }
        }.new(value)
    }

    # Return an iterator from a given iterator with a given mapper callable
    # and a compare callable, producing values either with unique or repeated
    # semantics.
    method UniqueRepeatedAsWith(\iterator, \as, \with, \unique) {
        class :: does Iterator {
            has Mu $!iter;
            has &!as;
            has &!with;
            has int $!unique;
            has $!seen;
            method !SET-SELF(\iterator, \as, \with, \unique) {
                nqp::stmts(
                  ($!iter := iterator),
                  (&!as := as),
                  (&!with := with),
                  ($!unique = nqp::istrue(unique)),
                  ($!seen := nqp::list),
                  self
                )
            }
            method new( \iterator, \as, \with, \union) {
                nqp::create(self)!SET-SELF(iterator, as, with, union)
            }
            method pull-one() is raw {
                nqp::stmts(
                  (my &as := &!as),      # lexicals are faster than attributes
                  (my &with := &!with),
                  (my $seen := $!seen),
                  nqp::until(
                    nqp::eqaddr((my $needle := $!iter.pull-one),IterationEnd),
                    nqp::stmts(
                      (my int $i = -1),
                      (my int $elems = nqp::elems($!seen)),
                      (my $target := as($needle)),
                      nqp::until(
                        nqp::iseq_i(($i = nqp::add_i($i,1)),$elems)
                          || with($target,nqp::atpos($seen,$i)),
                        nqp::null
                      ),
                      nqp::if(                         # done searching
                        $!unique,
                        nqp::if(                       # need unique semantics
                          nqp::iseq_i($i,$elems),
                          nqp::stmts(                  # new, so add and produce
                            nqp::push($!seen,$target),
                            (return-rw $needle)
                          )
                        ),
                        nqp::if(                       # need repeated semantics
                          nqp::iseq_i($i,$elems),
                          nqp::push($!seen,$target),   # new, just add
                          (return-rw $needle)          # not new, produce
                        )
                      )
                    )
                  ),
                  IterationEnd
                )
            }
            method is-lazy() { $!iter.is-lazy }
            method sink-all(--> IterationEnd) { $!iter.sink-all }
        }.new(iterator, as, with, unique)
    }

    # Return an iterator from a given iterator with a given compare
    # callable, producing values either with unique or repeated semantics.
    method UniqueRepeatedWith(\iterator, \with, \unique) {
        class :: does Iterator {
            has Mu $!iter;
            has &!with;
            has int $!unique;
            has $!seen;
            method !SET-SELF(\iterator, \with, \unique) {
                nqp::stmts(
                  ($!iter := iterator),
                  (&!with := with),
                  ($!unique = nqp::istrue(unique)),
                  ($!seen := nqp::list),
                  self
                )
            }
            method new( \iterator, \with, \union) {
                nqp::create(self)!SET-SELF(iterator, with, union)
            }
            method pull-one() is raw {
                nqp::stmts(
                  (my &with := &!with),  # lexicals are faster than attributes
                  (my $seen := $!seen),
                  nqp::until(
                    nqp::eqaddr((my $needle := $!iter.pull-one),IterationEnd),
                    nqp::stmts(
                      (my int $i = -1),
                      (my int $elems = nqp::elems($!seen)),
                      nqp::until(
                        nqp::iseq_i(($i = nqp::add_i($i,1)),$elems)
                          || with($needle,nqp::atpos($seen,$i)),
                        nqp::null
                      ),
                      nqp::if(                         # done searching
                        $!unique,
                        nqp::if(                       # need unique semantics
                          nqp::iseq_i($i,$elems),
                          nqp::stmts(                  # new, so add and produce
                            nqp::push($!seen,$needle),
                            (return-rw $needle)
                          )
                        ),
                        nqp::if(                       # need repeated semantics
                          nqp::iseq_i($i,$elems),
                          nqp::push($!seen,$needle),   # new, just add
                          (return-rw $needle)          # not new, produce
                        )
                      )
                    )
                  ),
                  IterationEnd
                )
            }
            method is-lazy() { $!iter.is-lazy }
            method sink-all(--> IterationEnd) { $!iter.sink-all }
        }.new(iterator, with, unique)
    }

    # Returns an iterator from a given iterator where the occurrence of
    # a Whatever value indicates that last value seen from the source
    # iterator should be repeated indefinitely until either another
    # non-Whatever value is seen from the source iterator, or the source
    # iterator is exhausted.
    method Whatever(\source) {
        class :: does Iterator {
            has $!source;
            has $!last;
            has int $!whatever;
            method new(\source) {
                nqp::p6bindattrinvres(nqp::create(self),self,'$!source',source)
            }
            method pull-one() is raw {
                nqp::if(
                  $!whatever,
                  nqp::if(                          # we're repeating
                    nqp::iseq_i($!whatever,2),      # source exhausted, repeat
                    $!last,
                    nqp::if(
                      nqp::eqaddr(
                        (my $value := $!source.pull-one),
                        IterationEnd
                      ),
                      nqp::stmts(                   # exhausted now, repeat
                        ($!whatever = 2),
                        $!last
                      ),
                      nqp::if(
                        nqp::istype($value,Whatever),
                        $!last,                     # another Whatever, repeat
                        nqp::stmts(                 # something else, no repeat
                          ($!whatever = 0),
                          ($!last := $value)
                        )
                      )
                    )
                  ),
                  nqp::if(                          # not repeating
                    nqp::eqaddr(
                      ($value := $!source.pull-one),
                      IterationEnd
                    ),
                    IterationEnd,                   # exhausted, stop
                    nqp::if(
                      nqp::istype($value,Whatever), # start repeating
                      nqp::stmts(
                        ($!whatever = 1),
                        $!last
                      ),
                      ($!last := $value)            # keep value for repeat
                    )
                  )
                )
            }
        }.new(source)
    }

    # Returns an iterator that handles all properties of a -while- with
    # a condition.  Takes a Callable to be considered the body of the loop,
    # and a Callable for the condition..
    method WhileLoop(&body, &cond) {
        class :: does SlippyIterator {
            has $!body;
            has $!cond;

            method !SET-SELF(\body,\cond) {
                nqp::stmts(
                  ($!body := body),
                  ($!cond := cond),
                  self
                )
            }
            method new(\body,\cond) {
                nqp::create(self)!SET-SELF(body,cond)
            }

            method pull-one() {
                if $!slipping && nqp::not_i(
                    nqp::eqaddr((my $result := self.slip-one),IterationEnd)
                ) {
                    $result
                }
                else {
                    nqp::if(
                      $!cond(),
                      nqp::stmts(
                        nqp::until(
                          (my int $stopped),
                          nqp::stmts(
                            ($stopped = 1),
                            nqp::handle(
                              nqp::if(
                                nqp::istype(($result := $!body()),Slip),
                                ($stopped = nqp::eqaddr(
                                  ($result := self.start-slip($result)),
                                  IterationEnd
                                ) && nqp::if($!cond(),0,1))
                              ),
                              'NEXT', ($stopped = nqp::if($!cond(),0,1)),
                              'REDO', ($stopped = 0),
                              'LAST', ($result := IterationEnd)
                            )
                          ),
                          :nohandler
                        ),
                        $result
                      ),
                      IterationEnd
                    )
                }
            }
        }.new(&body,&cond)
    }

    # Return an iterator that will zip the given iterables (with &[,])
    # Basically the functionality of @a Z @b
    method ZipIterables(@iterables) {
        nqp::if(
          nqp::isgt_i((my int $n = @iterables.elems),1),  # reifies
          class :: does Iterator {
              has $!iters;
              has int $!lazy;
              method !SET-SELF(\iterables) {
                  nqp::stmts(
                    (my $iterables := nqp::getattr(iterables,List,'$!reified')),
                    (my int $elems = nqp::elems($iterables)),
                    ($!iters := nqp::setelems(nqp::list,$elems)),
                    ($!lazy = 1),
                    (my int $i = -1),
                    nqp::while(
                      nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                      nqp::bindpos($!iters,$i,
                        nqp::if(
                          nqp::iscont(my $elem := nqp::atpos($iterables,$i)),
                          nqp::stmts(
                            ($!lazy = 0),
                            Rakudo::Iterator.OneValue($elem)
                          ),
                          nqp::stmts(
                            nqp::unless($elem.is-lazy,($!lazy = 0)),
                            Rakudo::Iterator.Whatever($elem.iterator)
                          )
                        )
                      )
                    ),
                    self
                  )
              }
              method new(\iterables) { nqp::create(self)!SET-SELF(iterables) }
              method pull-one() {
                  nqp::if(




                    nqp::isnull($!iters),

                    IterationEnd,
                    nqp::stmts(
                      (my int $i = -1),
                      (my int $elems = nqp::elems($!iters)),
                      (my $buf :=
                        nqp::setelems(nqp::create(IterationBuffer),$elems)),
                      nqp::until(
                        nqp::iseq_i(($i = nqp::add_i($i,1)),$elems)
                         || nqp::eqaddr(
                              (my $pulled := nqp::atpos($!iters,$i).pull-one),
                              IterationEnd
                            ),
                        nqp::bindpos($buf,$i,$pulled)
                      ),
                      nqp::if(
                        nqp::islt_i($i,$elems),  # at least one exhausted
                        nqp::stmts(




                          ($!iters := nqp::null),

                          IterationEnd
                        ),
                        nqp::p6bindattrinvres(
                          nqp::create(List),List,'$!reified',$buf)
                      )
                    )
                  )
              }
              method is-lazy() { nqp::p6bool($!lazy) }
          }.new(@iterables),
          nqp::if(
            nqp::iseq_i($n,0),
            Rakudo::Iterator.Empty,
            nqp::atpos(nqp::getattr(@iterables,List,'$!reified'),0).iterator
          )
        )
    }

    # Same as ZipIterablesOp, but takes a mapper Callable instead of
    # an op.  This is the underlying workhorse of ZipIterablesOp.
    method ZipIterablesMap(@iterables,&mapper) {
        nqp::if(
          nqp::isgt_i((my int $n = @iterables.elems),1),  # reifies
          class :: does Iterator {
              has $!iters;
              has $!mapper;
              has int $!lazy;
              method !SET-SELF(\iterables,\mapper) {
                  nqp::stmts(
                    (my $iterables := nqp::getattr(iterables,List,'$!reified')),
                    (my int $elems = nqp::elems($iterables)),
                    ($!iters  := nqp::setelems(nqp::list,$elems)),
                    ($!mapper := mapper),
                    ($!lazy = 1),
                    (my int $i = -1),
                    nqp::while(
                      nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                      nqp::bindpos($!iters,$i,
                        nqp::if(
                          nqp::iscont(my $elem := nqp::atpos($iterables,$i)),
                          nqp::stmts(
                            ($!lazy = 0),
                            Rakudo::Iterator.OneValue($elem)
                          ),
                          nqp::stmts(
                            nqp::unless($elem.is-lazy,($!lazy = 0)),
                            Rakudo::Iterator.Whatever($elem.iterator)
                          )
                        )
                      )
                    ),
                    self
                  )
              }
              method new(\iters,\map) { nqp::create(self)!SET-SELF(iters,map) }
              method pull-one() {
                  nqp::if(




                    nqp::isnull($!iters),

                    IterationEnd,
                    nqp::stmts(
                      (my int $i = -1),
                      (my int $elems = nqp::elems($!iters)),
                      (my $list :=
                        nqp::setelems(nqp::create(IterationBuffer),$elems)),
                      nqp::until(
                        nqp::iseq_i(($i = nqp::add_i($i,1)),$elems)
                         || nqp::eqaddr(
                              (my $pulled := nqp::atpos($!iters,$i).pull-one),
                              IterationEnd
                            ),
                        nqp::bindpos($list,$i,$pulled)
                      ),
                      nqp::if(
                        nqp::islt_i($i,$elems),  # at least one exhausted
                        nqp::stmts(




                          ($!iters := nqp::null),

                          IterationEnd
                        ),
                        $!mapper($list)
                      )
                    )
                  )
              }
              method is-lazy() { nqp::p6bool($!lazy) }
          }.new(@iterables,&mapper),
          nqp::if(
            nqp::iseq_i($n,0),
            Rakudo::Iterator.Empty,
            nqp::atpos(nqp::getattr(@iterables,List,'$!reified'),0).iterator
          )
        )
    }

    # Return an iterator that will zip the given iterables and operator.
    # Basically the functionality of @a Z=> @b, with &[=>] being the op.
    method ZipIterablesOp(@iterables,\op) {
        nqp::if(
          nqp::eqaddr(op,&infix:<,>),
          Rakudo::Iterator.ZipIterables(@iterables),
          Rakudo::Iterator.ZipIterablesMap(
            @iterables,
            Rakudo::Metaops.MapperForOp(op)
          )
        )
    }
}

#line 1 SETTING::src/core/Rakudo/QuantHash.pm
my role Real { ... }

my class Rakudo::QuantHash {

    # a Pair with the value 0
    my $p0 := nqp::p6bindattrinvres(nqp::create(Pair),Pair,'$!value',0);

    # Specialized role for .kv methods on QuantHashes: copied methods
    # from Quanty because of visibility issues wrt to $!elems and $!iter :-(
    our role Quanty-kv does Iterator {
        has $!elems;
        has $!iter;
        has $!on;

        method SET-SELF(\elems) {
            nqp::stmts(
              ($!elems := elems),
              ($!iter  := nqp::iterator(elems)),
              self
            )
        }
        method new(\quanthash) {
            nqp::if(
              (my $elems := quanthash.RAW-HASH) && nqp::elems($elems),
              nqp::create(self).SET-SELF($elems),
              Rakudo::Iterator.Empty   # nothing to iterate
            )
        }
        method skip-one() {
            nqp::if(
              $!on,
              nqp::not_i($!on = 0),
              nqp::if(
                $!iter,
                nqp::stmts(
                  nqp::shift($!iter),
                  ($!on = 1)
                )
              )
            )
        }
        method count-only() {
            nqp::add_i(nqp::elems($!elems),nqp::elems($!elems))
        }
        method bool-only(--> True) { }
        method sink-all(--> IterationEnd) { $!iter := nqp::null }
    }

    our role Pairs does Iterator {
        has $!elems;
        has $!picked;

        method !SET-SELF(\elems,\count) {
            nqp::stmts(
              ($!elems := elems),
              ($!picked := Rakudo::QuantHash.PICK-N(elems, count)),
              self
            )
        }
        method new(Mu \elems, \count) {
            nqp::if(
              (my $todo := Rakudo::QuantHash.TODO(count))
                && elems
                && nqp::elems(elems),
              nqp::create(self)!SET-SELF(elems, $todo),
              Rakudo::Iterator.Empty
            )
        }
    }

    # Return the iterator state of a randomly selected entry in a
    # given IterationSet
    method ROLL(Mu \elems) {
        nqp::stmts(
          (my int $i = nqp::add_i(nqp::rand_n(nqp::elems(elems)),1)),
          (my $iter := nqp::iterator(elems)),
          nqp::while(
            nqp::shift($iter) && ($i = nqp::sub_i($i,1)),
            nqp::null
          ),
          $iter
        )
    }

    # Return a list_s of N keys of the given IterationSet in random order.
    method PICK-N(Mu \elems, \count) {
        nqp::stmts(
          (my int $elems = nqp::elems(elems)),
          (my int $count = nqp::if(count > $elems,$elems,count)),
          (my $keys := nqp::setelems(nqp::list_s,$elems)),
          (my $iter := nqp::iterator(elems)),
          (my int $i = -1),
          nqp::while(
            nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
            nqp::bindpos_s($keys,$i,nqp::iterkey_s(nqp::shift($iter)))
          ),
          (my $picked := nqp::setelems(nqp::list_s,$count)),
          ($i = -1),
          nqp::while(
            nqp::islt_i(($i = nqp::add_i($i,1)),$count),
            nqp::stmts(
              nqp::bindpos_s($picked,$i,
                nqp::atpos_s($keys,(my int $pick = $elems.rand.floor))
              ),
              nqp::bindpos_s($keys,$pick,
                nqp::atpos_s($keys,($elems = nqp::sub_i($elems,1)))
              )
            )
          ),
          $picked
        )
    }

    # Return number of items to be done if > 0, or 0 if < 1, or throw if NaN
    method TODO(\count) is raw {
        nqp::if(
          count < 1,
          0,
          nqp::if(
            count == Inf,
            count,
            nqp::if(
              nqp::istype((my $todo := count.Int),Failure),
              $todo.throw,
              $todo
            )
          )
        )
    }

    # Return an nqp::list_s of all keys of a QuantHash
    method RAW-KEYS(\quanthash) is raw {
        nqp::if(
          (my $elems := quanthash.RAW-HASH)
            && (my $iter := nqp::iterator($elems)),
          nqp::stmts(
            (my $keys := nqp::setelems(nqp::list_s,nqp::elems($elems))),
            (my int $i = -1),
            nqp::while(
              $iter,
              nqp::bindpos_s(
                $keys,
                ($i = nqp::add_i($i,1)),
                nqp::iterkey_s(nqp::shift($iter))
              )
            ),
            $keys
          ),
          nqp::list_s
        )
    }

    # Return an nqp::list_s of all values of a QuantHash, mapped to a str
    method RAW-VALUES-MAP(\quanthash, &mapper) is raw {
        nqp::if(
          (my $elems := quanthash.RAW-HASH)
            && (my $iter := nqp::iterator($elems)),
          nqp::stmts(
            (my $values := nqp::setelems(nqp::list_s,nqp::elems($elems))),
            (my int $i = -1),
            nqp::while(
              $iter,
              nqp::bindpos_s(
                $values,
                ($i = nqp::add_i($i,1)),
                mapper(nqp::iterval(nqp::shift($iter)))
              )
            ),
            $values
          ),
          nqp::list_s
        )
    }

    # Return an nqp::list_s of all keys in a Baggy with the weight
    # joined with a null-byte inbetween.
    method BAGGY-RAW-KEY-VALUES(\baggy) is raw {
        nqp::if(
          (my $elems := baggy.RAW-HASH)
            && (my $iter := nqp::iterator($elems)),
          nqp::stmts(
            (my $list := nqp::setelems(nqp::list_s,nqp::elems($elems))),
            (my int $i = -1),
            nqp::while(
              $iter,
              nqp::stmts(
                nqp::shift($iter),
                nqp::bindpos_s(
                  $list,
                  ($i = nqp::add_i($i,1)),
                  nqp::concat(
                    nqp::iterkey_s($iter),
                    nqp::concat(
                      '\0',
                      nqp::getattr(nqp::iterval($iter),Pair,'$!value').Str
                    )
                  )
                )
              )
            ),
            $list
          ),
          nqp::list_s
        )
    }

    # Create intersection of 2 Baggies, default to given empty type
    method INTERSECT-BAGGIES(\a,\b,\empty) {
        nqp::if(
          (my $araw := a.RAW-HASH) && nqp::elems($araw)
            && (my $braw := b.RAW-HASH) && nqp::elems($braw),
          nqp::stmts(                          # both have elems
            nqp::if(
              nqp::islt_i(nqp::elems($araw),nqp::elems($braw)),
              nqp::stmts(                      # $a smallest, iterate over it
                (my $iter := nqp::iterator($araw)),
                (my $base := $braw)
              ),
              nqp::stmts(                      # $b smallest, iterate over that
                ($iter := nqp::iterator($braw)),
                ($base := $araw)
              )
            ),
            (my $elems := nqp::create(Rakudo::Internals::IterationSet)),
            nqp::while(
              $iter,
              nqp::if(                         # bind if in both
                nqp::existskey($base,nqp::iterkey_s(nqp::shift($iter))),
                nqp::bindkey(
                  $elems,
                  nqp::iterkey_s($iter),
                  nqp::if(
                    nqp::getattr(
                      nqp::decont(nqp::iterval($iter)),
                      Pair,
                      '$!value'
                    ) < nqp::getattr(          # must be HLL comparison
                          nqp::atkey($base,nqp::iterkey_s($iter)),
                          Pair,
                          '$!value'
                        ),
                    nqp::iterval($iter),
                    nqp::atkey($base,nqp::iterkey_s($iter))
                  )
                )
              )
            ),
            nqp::create(empty.WHAT).SET-SELF($elems),
          ),
          empty                                # one/neither has elems
        )
    }

    # create a deep clone of the given IterSet with baggy
    method BAGGY-CLONE(\raw) {
        nqp::stmts(
          (my $elems := nqp::clone(raw)),
          (my $iter  := nqp::iterator($elems)),
          nqp::while(
            $iter,
            nqp::bindkey(
              $elems,
              nqp::iterkey_s(nqp::shift($iter)),
              nqp::p6bindattrinvres(
                nqp::clone(nqp::iterval($iter)),
                Pair,
                '$!value',
                nqp::getattr(nqp::iterval($iter),Pair,'$!value')
              )
            )
          ),
          $elems
        )
    }

#--- Set/SetHash related methods

    # Create an IterationSet with baggy semantics from IterationSet with
    # Setty semantics.
    method SET-BAGGIFY(\raw) {
        nqp::stmts(
          (my $elems := nqp::clone(raw)),
          (my $iter  := nqp::iterator($elems)),
          nqp::while(
            $iter,
            nqp::bindkey(
              $elems,
              nqp::iterkey_s(nqp::shift($iter)),
              Pair.new(nqp::decont(nqp::iterval($iter)),1)
            )
          ),
          $elems
        )
    }

    # add to given IterationSet with setty semantics the values of iterator
    method ADD-ITERATOR-TO-SET(\elems,Mu \iterator) {
        nqp::stmts(
          nqp::until(
            nqp::eqaddr(
              (my $pulled := nqp::decont(iterator.pull-one)),
              IterationEnd
            ),
            nqp::bindkey(elems,$pulled.WHICH,$pulled)
          ),
          elems
        )
    }

    # Add to IterationSet with setty semantics the values of the given
    # iterator while checking for Pairs (only include if value is trueish)
    method ADD-PAIRS-TO-SET(\elems,Mu \iterator) {
        nqp::stmts(
          nqp::until(
            nqp::eqaddr((my $pulled := iterator.pull-one),IterationEnd),
            nqp::if(
              nqp::istype($pulled,Pair),
              nqp::if(
                nqp::getattr(nqp::decont($pulled),Pair,'$!value'),
                nqp::bindkey(
                  elems,
                  nqp::getattr(nqp::decont($pulled),Pair,'$!key').WHICH,
                  nqp::getattr(nqp::decont($pulled),Pair,'$!key')
                )
              ),
              nqp::bindkey(elems,$pulled.WHICH,$pulled)
            )
          ),
          elems
        )
    }

    # Add to given IterationSet with setty semantics the keys of given Map
    method ADD-MAP-TO-SET(\elems, \map) {
        nqp::stmts(
          nqp::if(
            (my $raw := nqp::getattr(nqp::decont(map),Map,'$!storage'))
              && (my $iter := nqp::iterator($raw)),
            nqp::if(
              nqp::eqaddr(map.keyof,Str(Any)),
              nqp::while(                        # normal Map
                $iter,
                nqp::if(
                  nqp::iterval(nqp::shift($iter)),
                  nqp::bindkey(
                    elems,nqp::iterkey_s($iter).WHICH,nqp::iterkey_s($iter))
                )
              ),
              nqp::while(                        # object hash
                $iter,
                nqp::if(
                  nqp::getattr(
                    nqp::decont(nqp::iterval(nqp::shift($iter))),
                    Pair,
                    '$!value'
                  ),
                  nqp::bindkey(
                    elems,
                    nqp::iterkey_s($iter),
                    nqp::getattr(nqp::iterval($iter),Pair,'$!key')
                  )
                )
              )
            )
          ),
          elems
        )
    }

    # coerce a Map to an IterationSet with setty semantics
    method COERCE-MAP-TO-SET(\map) {
        # Once object hashes have IterationSets, we could optimize the
        # object hash case by cloning the object hash, rather than creating
        # an empty IterationSet.  Until then, this is just a wrapper.
        Rakudo::QuantHash.ADD-MAP-TO-SET(
          nqp::create(Rakudo::Internals::IterationSet),
          map
        )
    }

    # remove set elements from set, stop when the result is the empty Set
    method SUB-SET-FROM-SET(\aelems, \belems) {
        nqp::stmts(                            # both have elems
          (my $elems := nqp::clone(aelems)),
          (my $iter  := nqp::iterator(belems)),
          nqp::while(
            $iter && nqp::elems($elems),
            nqp::deletekey($elems,nqp::iterkey_s(nqp::shift($iter)))
          ),
          $elems
        )
    }

    # remove hash elements from set, stop if the result is the empty Set
    method SUB-MAP-FROM-SET(\aelems, \map) {
        nqp::stmts(
          (my $elems := nqp::clone(aelems)),
          nqp::if(
            (my $storage := nqp::getattr(nqp::decont(map),Map,'$!storage'))
             && (my $iter  := nqp::iterator($storage)),
            nqp::if(
              nqp::eqaddr(map.keyof,Str(Any)),
              nqp::while(                     # normal Map
                $iter && nqp::elems($elems),
                nqp::if(
                  nqp::iterval(nqp::shift($iter)),
                  nqp::deletekey($elems,nqp::iterkey_s($iter).WHICH)
                )
              ),
              nqp::while(                     # object hash
                $iter && nqp::elems($elems),
                nqp::if(
                  nqp::getattr(nqp::iterval(nqp::shift($iter)),Pair,'$!value'),
                  nqp::deletekey($elems,nqp::iterkey_s($iter))
                )
              )
            )
          ),
          $elems
        )
    }

    # remove iterator elements from set using Pair semantics, stops pulling
    # from the iterator as soon as the result is the empty set.
    method SUB-PAIRS-FROM-SET(\elems, \iterator) {
        nqp::stmts(
          (my $elems := nqp::clone(elems)),
          nqp::until(
            nqp::eqaddr(                            # end of iterator?
              (my $pulled := iterator.pull-one),
              IterationEnd
            ) || nqp::not_i(nqp::elems($elems)),    # nothing left to remove?
            nqp::if(
              nqp::istype($pulled,Pair),
              nqp::if(                              # must check for thruthiness
                nqp::getattr($pulled,Pair,'$!value'),
                nqp::deletekey($elems,nqp::getattr($pulled,Pair,'$!key').WHICH)
              ),
              nqp::deletekey($elems,$pulled.WHICH)  # attempt to remove
            )
          ),
          $elems
        )
    }

#--- Bag/BagHash related methods

    # Calculate total of value of a Bag(Hash).  Takes a (possibly
    # uninitialized) IterationSet in Bag format.
    method BAG-TOTAL(Mu \elems) {
        nqp::if(
          elems && nqp::elems(elems),
          nqp::stmts(
            (my Int $total := 0),
            (my $iter := nqp::iterator(elems)),
            nqp::while(
              $iter,
              $total := nqp::add_I(
                $total,
                nqp::getattr(nqp::iterval(nqp::shift($iter)),Pair,'$!value'),
                Int
              )
            ),
            $total
          ),
          0
        )
    }

    # Return random iterator item from a given Bag(Hash).  Takes an
    # initialized IterationSet with at least 1 element in Bag format,
    # and the total value of values in the Bag.
    method BAG-ROLL(\elems, \total) {
        nqp::stmts(
          (my Int $rand := total.rand.Int),
          (my Int $seen := 0),
          (my $iter := nqp::iterator(elems)),
          nqp::while(
            $iter &&
              nqp::isle_I(
                ($seen := nqp::add_I(
                  $seen,
                  nqp::getattr(nqp::iterval(nqp::shift($iter)),Pair,'$!value'),
                  Int
                )),
                $rand
              ),
            nqp::null
          ),
          $iter
        )
    }

    # Return random object from a given BagHash.  Takes an initialized
    # IterationSet with at least 1 element in Bag format, and the total
    # value of values in the Bag.  Decrements the count of the iterator
    # found, completely removes it when going to 0.
    method BAG-GRAB(\elems, \total) {
        nqp::stmts(
          (my $iter := Rakudo::QuantHash.BAG-ROLL(elems,total)),
          nqp::if(
            (my $value := nqp::getattr(nqp::iterval($iter),Pair,'$!value')) == 1,
            nqp::stmts(              # going to 0, so remove
              (my $object := nqp::getattr(nqp::iterval($iter),Pair,'$!key')),
              nqp::deletekey(elems,nqp::iterkey_s($iter)),
              $object
            ),
            nqp::stmts(
              nqp::bindattr(
                nqp::iterval($iter),
                Pair,
                '$!value',
                $value - 1
              ),
              nqp::getattr(nqp::iterval($iter),Pair,'$!key')
            )
          )
        )
    }

    method BAGGY-CLONE-RAW(Mu \baggy) {
        nqp::if(
          baggy && nqp::elems(baggy),
          nqp::stmts(                             # something to coerce
            (my $elems := nqp::clone(baggy)),
            (my $iter := nqp::iterator($elems)),
            nqp::while(
              $iter,
              nqp::bindkey(
                $elems,
                nqp::iterkey_s(nqp::shift($iter)),
                nqp::p6bindattrinvres(
                  nqp::clone(nqp::iterval($iter)),
                  Pair,
                  '$!value',
                  nqp::getattr(nqp::iterval($iter),Pair,'$!value')
                )
              )
            ),
            $elems
          ),
          baggy
        )
    }

    method ADD-BAG-TO-BAG(\elems,Mu \bag) {
        nqp::stmts(
          nqp::if(
            bag && nqp::elems(bag),
            nqp::stmts(
              (my $iter := nqp::iterator(bag)),
              nqp::while(
                $iter,
                nqp::if(
                  nqp::existskey(elems,nqp::iterkey_s(nqp::shift($iter))),
                  nqp::stmts(
                    (my $pair := nqp::atkey(elems,nqp::iterkey_s($iter))),
                    nqp::bindattr($pair,Pair,'$!value',
                      nqp::getattr($pair,Pair,'$!value')
                        + nqp::getattr(nqp::iterval($iter),Pair,'$!value')
                    )
                  ),
                  nqp::bindkey(elems,nqp::iterkey_s($iter),
                    nqp::clone(nqp::iterval($iter))
                  )
                )
              )
            )
          ),
          elems
        )
    }

    method ADD-ITERATOR-TO-BAG(\elems,Mu \iterator) {
        nqp::stmts(
          nqp::until(
            nqp::eqaddr((my $pulled := iterator.pull-one),IterationEnd),
            nqp::if(
              nqp::existskey(elems,(my $WHICH := $pulled.WHICH)),
              nqp::stmts(
                (my $pair := nqp::atkey(elems,$WHICH)),
                nqp::bindattr($pair,Pair,'$!value',
                  nqp::add_i(nqp::getattr($pair,Pair,'$!value'),1)
                )
              ),
              nqp::bindkey(elems,$WHICH,Pair.new($pulled,1))
            )
          ),
          elems
        )
    }

    # Add to given IterationSet with baggy semantics the keys of given Map
    method ADD-MAP-TO-BAG(\elems, \map) {
        nqp::stmts(
          nqp::if(
            (my $raw := nqp::getattr(nqp::decont(map),Map,'$!storage'))
              && (my $iter := nqp::iterator($raw)),
            nqp::if(
              nqp::eqaddr(map.keyof,Str(Any)),
              nqp::while(              # ordinary Map
                $iter,
                nqp::if(
                  nqp::istype(
                    (my $value := nqp::iterval(nqp::shift($iter)).Int),
                    Int
                  ),
                  nqp::if(             # a valid Int
                    $value > 0,
                    nqp::if(           # and a positive one at that
                      nqp::existskey(
                        elems,
                        (my $which := nqp::iterkey_s($iter).WHICH)
                      ),
                      nqp::stmts(      # seen before, add value
                        (my $pair := nqp::atkey(elems,$which)),
                        nqp::bindattr(
                          $pair,
                          Pair,
                          '$!value',
                          nqp::getattr($pair,Pair,'$!value') + $value
                        )
                      ),
                      nqp::bindkey(    # new, create new Pair
                        elems,
                        $which,
                        Pair.new(nqp::iterkey_s($iter),$value)
                      )
                    )
                  ),
                  $value.throw         # huh?  let the world know
                )
              ),
              nqp::while(              # object hash
                $iter,
                nqp::if(
                  nqp::istype(
                    ($value := nqp::getattr(
                      nqp::iterval(nqp::shift($iter)),Pair,'$!value'
                    ).Int),
                    Int
                  ),
                  nqp::if(             # a valid Int
                    $value > 0,
                    nqp::if(           # and a positive one at that
                      nqp::existskey(elems,nqp::iterkey_s($iter)),
                      nqp::stmts(      # seen before, add value
                        ($pair := nqp::atkey(elems,nqp::iterkey_s($iter))),
                        nqp::bindattr(
                          $pair,
                          Pair,
                          '$!value',
                          nqp::getattr($pair,Pair,'$!value') + $value
                        )
                      ),
                      nqp::bindkey(    # new, create new Pair
                        elems,
                        nqp::iterkey_s($iter),
                        nqp::p6bindattrinvres(
                          nqp::clone(nqp::iterval($iter)),
                          Pair,
                          '$!value',
                          $value
                        )
                      )
                    )
                  ),
                  $value.throw         # huh?  let the world know
                )
              )
            )
          ),
          elems
        )
    }

    # Coerce the given Map to an IterationSet with baggy semantics.
    method COERCE-MAP-TO-BAG(\map) {
        nqp::if(
          (my $storage := nqp::getattr(nqp::decont(map),Map,'$!storage'))
            && (my $iter := nqp::iterator($storage)),
          nqp::if(                   # something to coerce
            nqp::eqaddr(map.keyof,Str(Any)),
            nqp::stmts(              # ordinary Map
              (my $elems := nqp::create(Rakudo::Internals::IterationSet)),
              nqp::while(
                $iter,
                nqp::if(
                  nqp::istype(
                    (my $value := nqp::iterval(nqp::shift($iter)).Int),
                    Int
                  ),
                  nqp::if(           # a valid Int
                    $value > 0,
                    nqp::bindkey(    # and a positive one at that
                      $elems,
                      nqp::iterkey_s($iter).WHICH,
                      Pair.new(nqp::iterkey_s($iter),$value)
                    )
                  ),
                  $value.throw       # huh?  let the world know
                )
              ),
              $elems
            ),
            nqp::stmts(              # object hash
              # once object hashes have IterationSets inside them, we can
              # make this an nqp::clone for more performance, which would
              # pre-populate the IterationSet with the right keys off the
              # bat.
              ($elems := nqp::create(Rakudo::Internals::IterationSet)),
              nqp::while(
                $iter,
                nqp::if(
                  nqp::istype(
                    ($value := nqp::getattr(
                      nqp::iterval(nqp::shift($iter)),Pair,'$!value'
                    ).Int),
                    Int
                  ),
                  nqp::if(           # a valid Int
                    $value > 0,
                    nqp::bindkey(    # and a positive one at that
                      $elems,
                      nqp::iterkey_s($iter),
                      nqp::p6bindattrinvres(
                        nqp::clone(nqp::iterval($iter)),
                        Pair,
                        '$!value',
                        $value
                      )
                    )
                  ),
                  $value.throw       # huh?  let the world know
                )
              ),
              $elems
            )
          ),
          nqp::create(Rakudo::Internals::IterationSet)  # nothing to coerce
        )
    }

    # Add to given IterationSet with baggy semantics the values of the given
    # iterator while checking for Pairs with numeric values.
    method ADD-PAIRS-TO-BAG(\elems,Mu \iterator) {
        nqp::stmts(
          nqp::until(
            nqp::eqaddr(
              (my $pulled := nqp::decont(iterator.pull-one)),
              IterationEnd
            ),
            nqp::if(
              nqp::istype($pulled,Pair),
              nqp::if(               # we have a Pair
                nqp::istype(
                  (my $value :=
                    nqp::decont(nqp::getattr($pulled,Pair,'$!value')).Int),
                  Int
                ),
                nqp::if(             # is a (coerced) Int
                  $value > 0,
                  nqp::if(           # and a positive one at that
                    nqp::existskey(
                      elems,
                      (my $which := nqp::getattr($pulled,Pair,'$!key').WHICH)
                    ),
                    nqp::stmts(      # seen before, add value
                      (my $pair := nqp::atkey(elems,$which)),
                      nqp::bindattr(
                        $pair,
                        Pair,
                        '$!value',
                        nqp::getattr($pair,Pair,'$!value') + $value
                      )
                    ),
                    nqp::bindkey(    # new, create new Pair
                      elems,
                      $which,
                      nqp::p6bindattrinvres(
                        nqp::clone($pulled),
                        Pair,
                        '$!value',
                        $value
                      )
                    )
                  )
                ),
                $value.throw         # value cannot be made Int, so throw
              ),
              nqp::if(               # not a Pair
                nqp::existskey(
                  elems,
                  ($which := $pulled.WHICH)
                ),
                nqp::stmts(
                  ($pair := nqp::atkey(elems,$which)),
                  nqp::bindattr(     # seen before, so increment
                    $pair,
                    Pair,
                    '$!value',
                    nqp::getattr($pair,Pair,'$!value') + 1
                  )
                ),
                nqp::bindkey(        # new, create new Pair
                  elems,$which,Pair.new($pulled,1))
              )
            )
          ),
          elems                      # we're done, return what we got so far
        )
    }

    # Take the given IterationSet with baggy semantics, and add the other
    # IterationSet with setty semantics to it.  Return the given IterationSet.
    method ADD-SET-TO-BAG(\elems,Mu \set) {
        nqp::stmts(
          nqp::if(
            set && nqp::elems(set),
            nqp::stmts(
              (my $iter := nqp::iterator(set)),
              nqp::while(
                $iter,
                nqp::if(
                  nqp::existskey(elems,nqp::iterkey_s(nqp::shift($iter))),
                  nqp::stmts(
                    (my $pair := nqp::atkey(elems,nqp::iterkey_s($iter))),
                    nqp::bindattr($pair,Pair,'$!value',
                      nqp::getattr($pair,Pair,'$!value') + 1
                    )
                  ),
                  nqp::bindkey(elems,nqp::iterkey_s($iter),
                    Pair.new(nqp::iterval($iter), 1)
                  )
                )
              )
            )
          ),
          elems
        )
    }

    method MULTIPLY-BAG-TO-BAG(\elems,Mu \bag) {
        nqp::stmts(
          (my $iter := nqp::iterator(elems)),
          nqp::if(
            bag && nqp::elems(bag),
            nqp::while(
              $iter,
              nqp::if(
                nqp::existskey(bag,nqp::iterkey_s(nqp::shift($iter))),
                nqp::stmts(
                  (my $pair := nqp::iterval($iter)),
                  nqp::bindattr($pair,Pair,'$!value',
                    nqp::mul_i(
                      nqp::getattr($pair,Pair,'$!value'),
                      nqp::getattr(
                        nqp::atkey(bag,nqp::iterkey_s($iter)),
                        Pair,
                        '$!value'
                      )
                    )
                  )
                ),
                nqp::deletekey(elems,nqp::iterkey_s($iter))
              )
            ),
            nqp::while(   # nothing to match against, so reset
              $iter,
              nqp::deletekey(elems,nqp::iterkey_s(nqp::shift($iter)))
            )
          ),
          elems
        )
    }

    method MULTIPLY-SET-TO-BAG(\elems,Mu \set) {
        nqp::stmts(
          (my $iter := nqp::iterator(elems)),
          nqp::if(
            set && nqp::elems(set),
            nqp::while(
              $iter,
              nqp::unless(
                nqp::existskey(set,nqp::iterkey_s(nqp::shift($iter))),
                nqp::deletekey(elems,nqp::iterkey_s($iter))
              )
            ),
            nqp::while(   # nothing to match against, so reset
              $iter,
              nqp::deletekey(elems,nqp::iterkey_s(nqp::shift($iter)))
            )
          ),
          elems
        )
    }

    # set difference Baggy IterSet from Bag IterSet, both assumed to have elems
    method SUB-BAGGY-FROM-BAG(\aelems, \belems) {
        nqp::stmts(
          (my $elems := nqp::create(Rakudo::Internals::IterationSet)),
          (my $iter  := nqp::iterator(aelems)),
          nqp::while(
            $iter,
            nqp::if(
              (my $value :=
                nqp::getattr(nqp::iterval(nqp::shift($iter)),Pair,'$!value')
                 - nqp::getattr(
                     nqp::ifnull(nqp::atkey(belems,nqp::iterkey_s($iter)),$p0),
                     Pair,
                     '$!value'
                   )
              ) > 0,
              nqp::bindkey(
                $elems,
                nqp::iterkey_s($iter),
                nqp::p6bindattrinvres(
                  nqp::clone(nqp::iterval($iter)),Pair,'$!value',$value
                )
              )
            )
          ),
          $elems
        )
    }

    # set difference Setty IterSet from Bag IterSet, both assumed to have elems
    method SUB-SETTY-FROM-BAG(\aelems, \belems) {
        nqp::stmts(
          (my $elems := nqp::create(Rakudo::Internals::IterationSet)),
          (my $iter  := nqp::iterator(aelems)),
          nqp::while(
            $iter,
            nqp::if(
              (my $value :=
                nqp::getattr(nqp::iterval(nqp::shift($iter)),Pair,'$!value')
                 - nqp::existskey(belems,nqp::iterkey_s($iter))
              ) > 0,
              nqp::bindkey(
                $elems,
                nqp::iterkey_s($iter),
                nqp::p6bindattrinvres(
                  nqp::clone(nqp::iterval($iter)),Pair,'$!value',$value
                )
              )
            )
          ),
          $elems
        )
    }

    # set difference of a Baggy and a QuantHash
    method DIFFERENCE-BAGGY-QUANTHASH(\a, \b) {
        nqp::if(
          (my $araw := a.RAW-HASH) && nqp::elems($araw),
          nqp::if(
            (my $braw := b.RAW-HASH) && nqp::elems($braw),
            nqp::create(Bag).SET-SELF(
              nqp::if(
                nqp::istype(b,Setty),
                self.SUB-SETTY-FROM-BAG($araw, $braw),
                self.SUB-BAGGY-FROM-BAG($araw, $braw)
              )
            ),
            a.Bag
          ),
          nqp::if(
            nqp::istype(b,Failure),
            b.throw,
            bag()
          )
        )
    }

#--- Mix/MixHash related methods

    # Calculate total of values of a Mix(Hash).  Takes a (possibly
    # uninitialized) IterationSet in Mix format.
    method MIX-TOTAL(Mu \elems) {
        nqp::if(
          elems && nqp::elems(elems),
          nqp::stmts(
            (my $total := 0),
            (my $iter := nqp::iterator(elems)),
            nqp::while(
              $iter,
              $total := $total
                + nqp::getattr(nqp::iterval(nqp::shift($iter)),Pair,'$!value')
            ),
            $total
          ),
          0
        )
    }

    # Calculate total of positive value of a Mix(Hash).  Takes a
    # (possibly uninitialized) IterationSet in Mix format.
    method MIX-TOTAL-POSITIVE(Mu \elems) {
        nqp::if(
          elems && nqp::elems(elems),
          nqp::stmts(
            (my $total := 0),
            (my $iter := nqp::iterator(elems)),
            nqp::while(
              $iter,
              nqp::if(
                0 < (my $value :=
                  nqp::getattr(nqp::iterval(nqp::shift($iter)),Pair,'$!value')),
                ($total := $total + $value)
              )
            ),
            $total
          ),
          0
        )
    }

    # Return random iterator item from a given Mix(Hash).  Takes an
    # initialized IterationSet with at least 1 element in Mix format,
    # and the total value of values in the Mix.
    method MIX-ROLL(\elems, \total) {
        nqp::stmts(
          (my      $rand := total.rand),
          (my Real $seen := 0),
          (my $iter := nqp::iterator(elems)),
          nqp::while(
            $iter && (
              0 > (my $value :=                      # negative values ignored
                nqp::getattr(nqp::iterval(nqp::shift($iter)),Pair,'$!value'))
              || $rand > ($seen := $seen + $value)   # positive values add up
            ),
            nqp::null
          ),
          $iter
        )
    }

    # Given an IterationSet in baggy/mixy format considered to contain the
    # final result, add the other IterationSet using Mix semantics and return
    # the first IterationSet.
    method ADD-MIX-TO-MIX(\elems, Mu \mix) {
        nqp::stmts(
          nqp::if(
            mix && nqp::elems(mix),
            nqp::stmts(
              (my $iter := nqp::iterator(mix)),
              nqp::while(
                $iter,
                nqp::if(
                  nqp::isnull((my $pair :=
                    nqp::atkey(elems,nqp::iterkey_s(nqp::shift($iter)))
                  )),
                  nqp::bindkey(                 # doesn't exist on left, create
                    elems,
                    nqp::iterkey_s($iter),
                    nqp::p6bindattrinvres(
                      nqp::clone(nqp::iterval($iter)),
                      Pair,
                      '$!value',
                      nqp::getattr(nqp::iterval($iter),Pair,'$!value')
                    )
                  ),
                  nqp::if(                      # exists on left, update
                    (my $value := nqp::getattr($pair,Pair,'$!value')
                      + nqp::getattr(nqp::iterval($iter),Pair,'$!value')),
                    nqp::bindattr($pair,Pair,'$!value',$value), # valid for Mix
                    nqp::deletekey(elems,nqp::iterkey_s($iter)) # bye bye
                  )
                )
              )
            )
          ),
          elems
        )
    }

    # Add to given IterationSet with mixy semantics the keys of given Map
    method ADD-MAP-TO-MIX(\elems, \map) {
        nqp::stmts(
          nqp::if(
            (my $raw := nqp::getattr(nqp::decont(map),Map,'$!storage'))
              && (my $iter := nqp::iterator($raw)),
            nqp::if(
              nqp::eqaddr(map.keyof,Str(Any)),
              nqp::while(              # normal Map
                $iter,
                nqp::if(
                  nqp::istype(
                    (my $value := nqp::iterval(nqp::shift($iter)).Real),
                    Real
                  ),
                  nqp::if(             # a valid Real
                    $value,
                    nqp::if(           # and not 0
                      nqp::existskey(
                        elems,
                        (my $which := nqp::iterkey_s($iter).WHICH)
                      ),
                      nqp::if(         # seen before: add value, remove if sum 0
                        ($value := nqp::getattr(
                          (my $pair := nqp::atkey(elems,$which)),
                          Pair,
                          '$!value'
                        ) + $value),
                        nqp::bindattr($pair,Pair,'$!value',$value), # okidoki
                        nqp::deletekey(elems,$which)                # alas, bye
                      ),
                      nqp::bindkey(    # new, create new Pair
                        elems,
                        $which,
                        Pair.new(nqp::iterkey_s($iter),$value)
                      )
                    )
                  ),
                  $value.throw         # huh?  let the world know
                )
              ),
              nqp::while(              # object hash
                $iter,
                nqp::if(
                  nqp::istype(
                    ($value := nqp::getattr(
                      nqp::iterval(nqp::shift($iter)),Pair,'$!value'
                    ).Real),
                    Real
                  ),
                  nqp::if(             # a valid Real
                    $value,
                    nqp::if(           # and not 0
                      nqp::existskey(elems,nqp::iterkey_s($iter)),
                      nqp::if(         # seen before: add value, remove if sum 0
                        ($value := nqp::getattr(
                          ($pair := nqp::atkey(elems,nqp::iterkey_s($iter))),
                          Pair,
                          '$!value'
                        ) + $value),
                        nqp::bindattr($pair,Pair,'$!value',$value), # okidoki
                        nqp::deletekey(elems,nqp::iterkey_s($iter)) # alas, bye
                      ),
                      nqp::bindkey(    # new, create new Pair
                        elems,
                        nqp::iterkey_s($iter),
                        nqp::p6bindattrinvres(
                          nqp::clone(nqp::iterval($iter)),
                          Pair,
                          '$!value',
                          nqp::getattr(nqp::iterval($iter),Pair,'$!value')
                        )
                      )
                    )
                  ),
                  $value.throw         # huh?  let the world know
                )
              )
            )
          ),
          elems
        )
    }

    # Add to given IterationSet with mixy semantics the values of the given
    # iterator while checking for Pairs with numeric values.
    method ADD-PAIRS-TO-MIX(\elems,Mu \iterator) is raw {
        nqp::stmts(
          nqp::until(
            nqp::eqaddr(
              (my $pulled := nqp::decont(iterator.pull-one)),
              IterationEnd
            ),
            nqp::if(
              nqp::istype($pulled,Pair),
              nqp::if(               # got a Pair
                (my $value :=
                  nqp::decont(nqp::getattr($pulled,Pair,'$!value'))),
                nqp::if(             # non-zero value
                  nqp::istype($value,Num) && nqp::isnanorinf($value),
                  X::OutOfRange.new( # NaN or -Inf or Inf, we're done
                    what  => 'Value',
                    got   => $value,
                    range => '-Inf^..^Inf'
                  ).throw,
                  nqp::stmts(        # apparently valid
                    nqp::unless(
                      nqp::istype(($value := $value.Real),Real),
                      $value.throw   # not a Real value, so throw Failure
                    ),
                    nqp::if(         # valid Real value
                      nqp::existskey(
                        elems,
                        (my $which := nqp::getattr($pulled,Pair,'$!key').WHICH)
                      ),
                      nqp::if( # seen before, add value
                        ($value := nqp::getattr(
                          (my $pair := nqp::atkey(elems,$which)),
                          Pair,
                          '$!value'
                        ) + $value),
                        nqp::bindattr($pair,Pair,'$!value',$value),  # non-zero
                        nqp::deletekey(elems,$which)                 # zero
                      ),
                      nqp::bindkey(  # new, create new Pair
                        elems,
                        $which,
                        nqp::p6bindattrinvres(
                          nqp::clone($pulled),
                          Pair,
                          '$!value',
                          $value
                        )
                      )
                    )
                  )
                )
              ),
              nqp::if(               # not a Pair
                nqp::existskey(
                  elems,
                  ($which := $pulled.WHICH)
                ),
                nqp::stmts(
                  ($pair := nqp::atkey(elems,$which)),
                  nqp::bindattr(     # seen before, so increment
                    $pair,
                    Pair,
                    '$!value',
                    nqp::getattr($pair,Pair,'$!value') + 1
                  )
                ),
                nqp::bindkey(        # new, create new Pair
                  elems,$which,Pair.new($pulled,1))
              )
            )
          ),
          elems                      # we're done, return what we got so far
        )
    }

    # Take the given IterationSet with mixy semantics, and add the other
    # IterationSet with setty semantics to it.  Return the given IterationSet.
    method ADD-SET-TO-MIX(\elems,Mu \set) {
        nqp::stmts(
          nqp::if(
            set && nqp::elems(set),
            nqp::stmts(
              (my $iter := nqp::iterator(set)),
              nqp::while(
                $iter,
                nqp::if(
                  nqp::existskey(elems,nqp::iterkey_s(nqp::shift($iter))),
                  nqp::if(
                    (my $value := nqp::getattr(
                      (my $pair := nqp::atkey(elems,nqp::iterkey_s($iter))),
                      Pair,
                      '$!value'
                    ) + 1),
                    nqp::bindattr($pair,Pair,'$!value',$value),   # still valid
                    nqp::deletekey(elems,nqp::iterkey_s($iter))   # not, byebye
                  ),
                  nqp::bindkey(elems,nqp::iterkey_s($iter),       # new key
                    Pair.new(nqp::iterval($iter), 1)
                  )
                )
              )
            )
          ),
          elems
        )
    }

    # Coerce the given Map to an IterationSet with mixy semantics.
    method COERCE-MAP-TO-MIX(\map) {
        nqp::if(
          (my $storage := nqp::getattr(nqp::decont(map),Map,'$!storage'))
            && (my $iter := nqp::iterator($storage)),
          nqp::if(                   # something to coerce
            nqp::eqaddr(map.keyof,Str(Any)),
            nqp::stmts(              # ordinary Map
              (my $elems := nqp::create(Rakudo::Internals::IterationSet)),
              nqp::while(
                $iter,
                nqp::if(
                  nqp::istype(
                    (my $value := nqp::iterval(nqp::shift($iter)).Real),
                    Real
                  ),
                  nqp::if(           # a valid Real
                    $value,
                    nqp::bindkey(    # and not 0
                      $elems,
                      nqp::iterkey_s($iter).WHICH,
                      Pair.new(nqp::iterkey_s($iter),$value)
                    )
                  ),
                  $value.throw       # huh?  let the world know
                )
              ),
              $elems
            ),
            nqp::stmts(              # object hash
              # once object hashes have IterationSets inside them, we can
              # make this an nqp::clone for more performance, which would
              # pre-populate the IterationSet with the right keys off the
              # bat.
              ($elems := nqp::create(Rakudo::Internals::IterationSet)),
              nqp::while(
                $iter,
                nqp::if(
                  nqp::istype(
                    ($value := nqp::getattr(
                      nqp::iterval(nqp::shift($iter)),Pair,'$!value'
                    ).Real),
                    Real
                  ),
                  nqp::if(           # a valid Real
                    $value,
                    nqp::bindkey(    # and not 0
                      $elems,
                      nqp::iterkey_s($iter),
                      nqp::p6bindattrinvres(
                        nqp::clone(nqp::iterval($iter)),
                        Pair,
                        '$!value',
                        $value
                      )
                    )
                  ),
                  $value.throw       # huh?  let the world know
                )
              ),
              $elems
            )
          ),
          nqp::create(Rakudo::Internals::IterationSet) # nothing to coerce
        )
    }

    method MULTIPLY-MIX-TO-MIX(\elems,Mu \mix --> Nil) {
        nqp::stmts(
          (my $iter := nqp::iterator(elems)),
          nqp::if(
            mix && nqp::elems(mix),
            nqp::while(
              $iter,
              nqp::if(
                nqp::existskey(mix,nqp::iterkey_s(nqp::shift($iter))),
                nqp::stmts(
                  (my $pair := nqp::iterval($iter)),
                  nqp::bindattr($pair,Pair,'$!value',
                    nqp::getattr($pair,Pair,'$!value')
                    * nqp::getattr(
                        nqp::atkey(mix,nqp::iterkey_s($iter)),
                        Pair,
                        '$!value'
                      )
                  )
                ),
                nqp::deletekey(elems,nqp::iterkey_s($iter))
              )
            ),
            nqp::while(   # nothing to match against, so reset
              $iter,
              nqp::deletekey(elems,nqp::iterkey_s(nqp::shift($iter)))
            )
          )
        )
    }
    method MIX-CLONE-ALL-POSITIVE(\elems) {
        nqp::stmts(
          (my $iter := nqp::iterator(my $clone := nqp::clone(elems))),
          nqp::while(
            $iter,
            nqp::stmts(
              nqp::shift($iter),
              nqp::bindkey(
                $clone,
                nqp::iterkey_s($iter),
                nqp::p6bindattrinvres(
                  nqp::clone(nqp::iterval($iter)),
                  Pair,
                  '$!value',
                  abs(nqp::getattr(nqp::iterval($iter),Pair,'$!value'))
                )
              )
            )
          ),
          $clone
        )
    }
    method MIX-ALL-POSITIVE(\elems) {
        nqp::stmts(
          (my $iter := nqp::iterator(elems)),
          nqp::while(
            $iter,
            nqp::unless(
              nqp::getattr(nqp::iterval(nqp::shift($iter)),Pair,'$!value') > 0,
              return False
            )
          ),
          True
        )
    }
    method MIX-ALL-NEGATIVE(\elems) {
        nqp::stmts(
          (my $iter := nqp::iterator(elems)),
          nqp::while(
            $iter,
            nqp::unless(
              nqp::getattr(nqp::iterval(nqp::shift($iter)),Pair,'$!value') < 0,
              return False
            )
          ),
          True
        )
    }

    method MIX-IS-SUBSET($a,$b) {
        nqp::if(
          nqp::eqaddr(nqp::decont($a),nqp::decont($b)),
          True,                     # X is always a subset of itself
          nqp::if(
            (my $araw := $a.RAW-HASH) && (my $iter := nqp::iterator($araw)),
            nqp::if(                # elems in A
              (my $braw := $b.RAW-HASH) && nqp::elems($braw),
              nqp::stmts(           # elems in A and B
                nqp::while(         # check all values in A with B
                  $iter,
                  nqp::unless(
                    nqp::getattr(nqp::iterval(nqp::shift($iter)),Pair,'$!value')
                      <=            # value in A should be less or equal than B
                    nqp::getattr(
                      nqp::ifnull(nqp::atkey($braw,nqp::iterkey_s($iter)),$p0),
                      Pair,
                      '$!value'
                    ),
                    return False
                  )
                ),

                ($iter := nqp::iterator($braw)),
                nqp::while(         # check all values in B with A
                  $iter,
                  nqp::unless(
                    nqp::getattr(nqp::iterval(nqp::shift($iter)),Pair,'$!value')
                      >=            # value in B should be more or equal than A
                    nqp::getattr(
                      nqp::ifnull(nqp::atkey($araw,nqp::iterkey_s($iter)),$p0),
                      Pair,
                      '$!value'
                    ),
                    return False
                  )
                ),
                True                # all checks worked out, so ok
              ),
              # nothing in B, all elems in A should be < 0
              Rakudo::QuantHash.MIX-ALL-NEGATIVE($araw)
            ),
            nqp::if(
              ($braw := $b.RAW-HASH) && nqp::elems($braw),
              # nothing in A, all elems in B should be >= 0
              Rakudo::QuantHash.MIX-ALL-POSITIVE($braw),
              True                  # nothing in A nor B
            )
          )
        )
    }

    # Return whether first Baggy is a proper subset of the second Baggy,
    # using Mixy semantics
    method MIX-IS-PROPER-SUBSET($a,$b) {
        nqp::if(
          nqp::eqaddr(nqp::decont($a),nqp::decont($b)),
          False,                    # X is never a true subset of itself
          nqp::if(
            (my $araw := $a.RAW-HASH) && (my $iter := nqp::iterator($araw)),
            nqp::if(                # elems in A
              (my $braw := $b.RAW-HASH) && nqp::elems($braw),
              nqp::stmts(           # elems in A and B
                (my int $less),
                nqp::while(         # check all values in A with B
                  $iter,
                  nqp::if(
                    (my $left := nqp::getattr(
                      nqp::iterval(nqp::shift($iter)),
                      Pair,
                      '$!value'
                    ))
                      >             # value in A should be <= than B
                    (my $right := nqp::getattr(
                      nqp::ifnull(nqp::atkey($braw,nqp::iterkey_s($iter)),$p0),
                      Pair,
                      '$!value'
                    )),
                    (return False), # too many on left, we're done
                    nqp::unless($less,$less = $left < $right)
                  )
                ),

                ($iter := nqp::iterator($braw)),
                nqp::while(         # check all values in B with A
                  $iter,
                  nqp::if(
                    ($left := nqp::getattr(
                      nqp::ifnull(
                        nqp::atkey($araw,nqp::iterkey_s(nqp::shift($iter))),
                        $p0
                      ),
                      Pair,
                      '$!value'
                    ))
                      >             # value in A should be <= than B
                    ($right := nqp::getattr(
                      nqp::iterval($iter),Pair,'$!value'
                    )),
                    (return False),
                    nqp::unless($less,$less = $left < $right)
                  )
                ),
                nqp::p6bool($less)  # all checks worked out so far
              ),
              # nothing in B, all elems in A should be < 0
              Rakudo::QuantHash.MIX-ALL-NEGATIVE($araw)
            ),
            nqp::if(                # nothing in A
              ($braw := $b.RAW-HASH) && nqp::elems($braw),
              # something in B, all elems in B should be > 0
              Rakudo::QuantHash.MIX-ALL-POSITIVE($braw),
              False                 # nothing in A nor B
            )
          )
        )
    }

    # set difference QuantHash IterSet from Mix IterSet, both assumed to have
    # elems.  3rd parameter is 1 for Setty, 0 for Baggy semantics
    method SUB-QUANTHASH-FROM-MIX(\aelems, \belems, \issetty) {
        nqp::stmts(
          (my $elems := nqp::create(Rakudo::Internals::IterationSet)),
          (my $iter  := nqp::iterator(belems)),
          nqp::while(                   # subtract all righthand keys
            $iter,
            nqp::bindkey(
              $elems,
              nqp::iterkey_s(nqp::shift($iter)),
              nqp::if(
                issetty,
                Pair.new(
                  nqp::iterval($iter),
                  nqp::getattr(
                    nqp::ifnull(nqp::atkey(aelems,nqp::iterkey_s($iter)),$p0),
                    Pair,
                    '$!value'
                  ) - 1
                ),
                nqp::p6bindattrinvres(
                  nqp::clone(nqp::iterval($iter)),
                  Pair,
                  '$!value',
                  nqp::getattr(
                    nqp::ifnull(nqp::atkey(aelems,nqp::iterkey_s($iter)),$p0),
                    Pair,
                    '$!value'
                  ) - nqp::getattr(nqp::iterval($iter),Pair,'$!value')
                )
              )
            )
          ),
          ($iter := nqp::iterator(aelems)),
          nqp::while(                   # vivify all untouched lefthand keys
            $iter,
            nqp::if(
              nqp::existskey($elems,nqp::iterkey_s(nqp::shift($iter))),
              nqp::unless(              # was touched
                nqp::getattr(
                  nqp::atkey($elems,nqp::iterkey_s($iter)),
                  Pair,
                  '$!value'
                ),
                nqp::deletekey($elems,nqp::iterkey_s($iter)) # but no value
              ),
              nqp::bindkey(             # not touched, add it
                $elems,
                nqp::iterkey_s($iter),
                nqp::p6bindattrinvres(
                  nqp::clone(nqp::iterval($iter)),
                  Pair,
                  '$!value',
                  nqp::getattr(nqp::iterval($iter),Pair,'$!value')
                )
              )
            )
          ),
          $elems
        )
    }

    # set difference of a Mixy and a QuantHash
    method DIFFERENCE-MIXY-QUANTHASH(\a, \b) {
        nqp::if(
          (my $araw := a.RAW-HASH) && nqp::elems($araw),
          nqp::if(
            (my $braw := b.RAW-HASH) && nqp::elems($braw),
            nqp::create(Mix).SET-SELF(
              self.SUB-QUANTHASH-FROM-MIX($araw, $braw, nqp::istype(b,Setty)),
            ),
            a.Mix
          ),
          nqp::if(
            nqp::istype(b,Failure),
            b.throw,
            nqp::if(
              ($braw := b.RAW-HASH) && nqp::elems($braw),
              nqp::stmts(
                (my $elems := nqp::clone($braw)),
                (my $iter  := nqp::iterator($braw)),
                nqp::while(
                  $iter,
                  nqp::bindkey(    # clone with negated value
                    $elems,
                    nqp::iterkey_s(nqp::shift($iter)),
                    nqp::p6bindattrinvres(
                      nqp::clone(nqp::iterval($iter)),
                      Pair,
                      '$!value',
                      - nqp::getattr(nqp::iterval($iter),Pair,'$!value')
                    )
                  )
                ),
                nqp::create(Mix).SET-SELF($elems)
              ),
              mix()
            )
          )
        )
    }
}

#line 1 SETTING::src/core/Rakudo/Sorting.pm
my class Rakudo::Sorting {

    # Return new IterationBuffer with the two given values
    sub IB2(Mu \one,Mu \two --> IterationBuffer) {
        nqp::stmts(
          (my $buf := nqp::create(IterationBuffer)),
          nqp::bindpos($buf,0,one),
          nqp::bindpos($buf,1,two),
          $buf
        )
    }

    # https://en.wikipedia.org/wiki/Merge_sort#Bottom-up_implementation
    # The parameter is the HLL List to be sorted *in place* using simple cmp.
    method MERGESORT-REIFIED-LIST(\list) {
        nqp::if(
          nqp::isgt_i((my int $n = nqp::elems(
            # $A has the items to sort; $B is a work array
            my $A := nqp::getattr(list,List,'$!reified')
          )),2),
          nqp::stmts(     # we actually need to sort
            (my $B := nqp::setelems(nqp::create(IterationBuffer),$n)),

            # Each 1-element run in $A is already "sorted"
            # Make successively longer sorted runs of length 2, 4, 8, 16...
            # until $A is wholly sorted
            (my int $width = 1),
            nqp::while(
              nqp::islt_i($width,$n),
              nqp::stmts(
                (my int $l = 0),

                # $A is full of runs of length $width
                nqp::while(
                  nqp::islt_i($l,$n),

                  nqp::stmts(
                    (my int $left  = $l),
                    (my int $right = nqp::add_i($l,$width)),
                    nqp::if(nqp::isge_i($right,$n),($right = $n)),
                    (my int $end = nqp::add_i($l,nqp::add_i($width,$width))),
                    nqp::if(nqp::isge_i($end,$n),($end = $n)),

                    (my int $i = $left),
                    (my int $j = $right),
                    (my int $k = nqp::sub_i($left,1)),

                    # Merge two runs: $A[i       .. i+width-1] and
                    #                 $A[i+width .. i+2*width-1]
                    # to $B or copy $A[i..n-1] to $B[] ( if(i+width >= n) )
                    nqp::while(
                      nqp::islt_i(($k = nqp::add_i($k,1)),$end),
                      nqp::if(
                        nqp::islt_i($i,$right) && (
                          nqp::isge_i($j,$end)
                            || nqp::iseq_i(
                                 nqp::decont(  # for some reason we need this
                                   nqp::atpos($A,$i) cmp nqp::atpos($A,$j)
                                     || nqp::cmp_i($i,$j)
                                 ), # apparently code gen with || isn't right
                                 -1
                               )
                        ),
                        nqp::stmts(
                          (nqp::bindpos($B,$k,nqp::atpos($A,$i))),
                          ($i = nqp::add_i($i,1))
                        ),
                        nqp::stmts(
                          (nqp::bindpos($B,$k,nqp::atpos($A,$j))),
                          ($j = nqp::add_i($j,1))
                        )
                      )
                    ),
                    ($l = nqp::add_i($l,nqp::add_i($width,$width)))
                  )
                ),

                # Now work array $B is full of runs of length 2*width.
                # Copy array B to array A for next iteration.  A more
                # efficient implementation would swap the roles of A and B.
                (my $temp := $B),($B := $A),($A := $temp),   # swap
                # Now array $A is full of runs of length 2*width.

                ($width = nqp::add_i($width,$width))
              )
            ),
            nqp::p6bindattrinvres(list,List,'$!reified',$A)
          ),
          nqp::if(
            nqp::islt_i($n,2)
              || nqp::isle_i(nqp::atpos($A,0) cmp nqp::atpos($A,1),0),
            list,  # nothing to be done, we already have the result
            nqp::p6bindattrinvres(list,List,'$!reified',  # need to swap
              IB2(nqp::atpos($A,1),nqp::atpos($A,0)))
          )
        )
    }

    # Takes the HLL List to be sorted *in place* using the comparator
    method MERGESORT-REIFIED-LIST-WITH(\list, &comparator) {
        nqp::if(
          nqp::isgt_i((my int $n = nqp::elems(
            # $A has the items to sort; $B is a work array
            my $A := nqp::getattr(list,List,'$!reified')
          )),2),
          nqp::stmts(     # we actually need to sort
            (my $B := nqp::setelems(nqp::create(IterationBuffer),$n)),

            # Each 1-element run in $A is already "sorted"
            # Make successively longer sorted runs of length 2, 4, 8, 16...
            # until $A is wholly sorted
            (my int $width = 1),
            nqp::while(
              nqp::islt_i($width,$n),
              nqp::stmts(
                (my int $l = 0),

                # $A is full of runs of length $width
                nqp::while(
                  nqp::islt_i($l,$n),

                  nqp::stmts(
                    (my int $left  = $l),
                    (my int $right = nqp::add_i($l,$width)),
                    nqp::if(nqp::isge_i($right,$n),($right = $n)),
                    (my int $end = nqp::add_i($l,nqp::add_i($width,$width))),
                    nqp::if(nqp::isge_i($end,$n),($end = $n)),

                    (my int $i = $left),
                    (my int $j = $right),
                    (my int $k = nqp::sub_i($left,1)),

                    # Merge two runs: $A[i       .. i+width-1] and
                    #                 $A[i+width .. i+2*width-1]
                    # to $B or copy $A[i..n-1] to $B[] ( if(i+width >= n) )
                    nqp::while(
                      nqp::islt_i(($k = nqp::add_i($k,1)),$end),
                      nqp::if(
                        nqp::islt_i($i,$right) && (
                          nqp::isge_i($j,$end)
                            || nqp::iseq_i(
                                 nqp::decont(  # for some reason we need this
                                   comparator(
                                     nqp::atpos($A,$i),nqp::atpos($A,$j))
                                      || nqp::cmp_i($i,$j)
                                 ), # apparently code gen with || isn't right
                                 -1
                               )
                        ),
                        nqp::stmts(
                          (nqp::bindpos($B,$k,nqp::atpos($A,$i))),
                          ($i = nqp::add_i($i,1))
                        ),
                        nqp::stmts(
                          (nqp::bindpos($B,$k,nqp::atpos($A,$j))),
                          ($j = nqp::add_i($j,1))
                        )
                      )
                    ),
                    ($l = nqp::add_i($l,nqp::add_i($width,$width)))
                  )
                ),

                # Now work array $B is full of runs of length 2*width.
                # Copy array B to array A for next iteration. A more
                # efficient implementation would swap the roles of A and B.
                (my $temp := $B),($B := $A),($A := $temp),   # swap
                # Now array $A is full of runs of length 2*width.

                ($width = nqp::add_i($width,$width))
              )
            ),
            nqp::p6bindattrinvres(list,List,'$!reified',$A)
          ),
          nqp::if(
            nqp::islt_i($n,2)
              || nqp::iseq_i(
                  comparator(nqp::atpos($A,0),nqp::atpos($A,1)),-1),
            list,  # nothing to be done, we already have the result
            nqp::p6bindattrinvres(list,List,'$!reified',  # need to swap
              IB2(nqp::atpos($A,1),nqp::atpos($A,0)))
          )
        )
    }
    # Takes the HLL List to be sorted *in place* using the mapper
    method MERGESORT-REIFIED-LIST-AS(\list,&mapper) {
        nqp::if(
          nqp::isgt_i((my int $n = nqp::elems(
            my $O := nqp::getattr(list,List,'$!reified')    # Original
          )),2),
          nqp::stmts(     # we actually need to sort
            (my $S :=                                       # the Schwartz
              nqp::setelems(nqp::create(IterationBuffer),$n)),
            (my $A := nqp::setelems(nqp::list_i,$n)),       # indexes to sort
            (my $B := nqp::setelems(nqp::list_i,$n)),       # work array
            (my int $s = -1),
            nqp::while(  # set up the Schwartz and the initial indexes
              nqp::islt_i(($s = nqp::add_i($s,1)),$n),
              nqp::bindpos($S,nqp::bindpos_i($A,$s,$s),
                mapper(nqp::atpos($O,$s)))
            ),

            # Each 1-element run in $A is already "sorted"
            # Make successively longer sorted runs of length 2, 4, 8, 16...
            # until $A is wholly sorted
            (my int $width = 1),
            nqp::while(
              nqp::islt_i($width,$n),
              nqp::stmts(
                (my int $l = 0),

                # $A is full of runs of length $width
                nqp::while(
                  nqp::islt_i($l,$n),

                  nqp::stmts(
                    (my int $left  = $l),
                    (my int $right = nqp::add_i($l,$width)),
                    nqp::if(nqp::isge_i($right,$n),($right = $n)),
                    (my int $end = nqp::add_i($l,nqp::add_i($width,$width))),
                    nqp::if(nqp::isge_i($end,$n),($end = $n)),

                    (my int $i = $left),
                    (my int $j = $right),
                    (my int $k = nqp::sub_i($left,1)),

                    # Merge two runs: $A[i       .. i+width-1] and
                    #                 $A[i+width .. i+2*width-1]
                    # to $B or copy $A[i..n-1] to $B[] ( if(i+width >= n) )
                    nqp::while(
                      nqp::islt_i(($k = nqp::add_i($k,1)),$end),
                      nqp::if(
                        nqp::islt_i($i,$right) && (
                          nqp::isge_i($j,$end)
                            || (nqp::iseq_i(
                                 nqp::decont(
                                   nqp::atpos($S,nqp::atpos_i($A,$i))
                                     cmp nqp::atpos($S,nqp::atpos_i($A,$j))
                                     || nqp::cmp_i($i,$j)
                                 ),
                                 -1
                               ))
                        ),
                        nqp::stmts(
                          (nqp::bindpos_i($B,$k,nqp::atpos_i($A,$i))),
                          ($i = nqp::add_i($i,1))
                        ),
                        nqp::stmts(
                          (nqp::bindpos_i($B,$k,nqp::atpos_i($A,$j))),
                          ($j = nqp::add_i($j,1))
                        )
                      )
                    ),
                    ($l = nqp::add_i($l,nqp::add_i($width,$width)))
                  )
                ),

                # Now work array $B is full of runs of length 2*width.
                # Copy array B to array A for next iteration. A more
                # efficient implementation would swap the roles of A and B.
                (my $temp := $B),($B := $A),($A := $temp),   # swap
                # Now array $A is full of runs of length 2*width.

                ($width = nqp::add_i($width,$width))
              )
            ),
            ($s = -1),
            nqp::while(   # repurpose the Schwartz for the result
              nqp::islt_i(($s = nqp::add_i($s,1)),$n),
              nqp::bindpos($S,$s,nqp::atpos($O,nqp::atpos_i($A,$s)))
            ),
            nqp::p6bindattrinvres(list,List,'$!reified',$S)
          ),

          nqp::p6bindattrinvres(nqp::create(List),List,'$!reified',
            nqp::if(
              nqp::islt_i($n,2)
                || nqp::iseq_i(
                    mapper(nqp::atpos($O,0)) cmp mapper(nqp::atpos($O,1)),-1),
              $O,  # nothing to be done, we already have the result
              IB2(nqp::atpos($O,1),nqp::atpos($O,0))  # need to swap
            )
          )
        )
    }

    # https://en.wikipedia.org/wiki/Merge_sort#Bottom-up_implementation
    # Sort a native str array (or nqp::list_s) and return the result.
    # Uses the given str array as one of the buffers for performance reasons.
    # Please nqp::clone first if you want to keep the original intact.
    method MERGESORT-str(Mu \sortable) {
        nqp::if(
          nqp::isgt_i((my int $n = nqp::elems(sortable)),2),

          # $A has the items to sort; $B is a work array
          nqp::stmts(
            (my Mu $A := sortable),
            (my Mu $B := nqp::setelems(nqp::list_s,$n)),

            # Each 1-element run in $A is already "sorted"
            # Make successively longer sorted runs of length 2, 4, 8, 16...
            # until $A is wholly sorted
            (my int $width = 1),
            nqp::while(
              nqp::islt_i($width,$n),
              nqp::stmts(
                (my int $l = 0),

                # $A is full of runs of length $width
                nqp::while(
                  nqp::islt_i($l,$n),

                  nqp::stmts(
                    (my int $left  = $l),
                    (my int $right = nqp::add_i($l,$width)),
                    nqp::if(nqp::isge_i($right,$n),($right = $n)),
                    (my int $end =
                      nqp::add_i($l,nqp::add_i($width,$width))),
                    nqp::if(nqp::isge_i($end,$n),($end = $n)),

                    (my int $i = $left),
                    (my int $j = $right),
                    (my int $k = nqp::sub_i($left,1)),

                    # Merge two runs: $A[i       .. i+width-1] and
                    #                 $A[i+width .. i+2*width-1]
                    # to $B or copy $A[i..n-1] to $B[] ( if(i+width >= n) )
                    nqp::while(
                      nqp::islt_i(($k = nqp::add_i($k,1)),$end),
                      nqp::if(
                        nqp::islt_i($i,$right) && (
                          nqp::isge_i($j,$end)
                            || nqp::islt_s(
                                 nqp::atpos_s($A,$i),
                                 nqp::atpos_s($A,$j)
                               )
                        ),
                        nqp::stmts(
                          (nqp::bindpos_s($B,$k,nqp::atpos_s($A,$i))),
                          ($i = nqp::add_i($i,1))
                        ),
                        nqp::stmts(
                          (nqp::bindpos_s($B,$k,nqp::atpos_s($A,$j))),
                          ($j = nqp::add_i($j,1))
                        )
                      )
                    ),
                    ($l = nqp::add_i($l,nqp::add_i($width,$width)))
                  )
                ),

                # Now work array $B is full of runs of length 2*width.
                # Copy array B to array A for next iteration.  A more
                # efficient implementation would swap the roles of A and B.
                (my Mu $temp := $B),($B := $A),($A := $temp),   # swap
                # Now array $A is full of runs of length 2*width.

                ($width = nqp::add_i($width,$width))
              )
            ),
            $A
          ),
          nqp::if(
            nqp::islt_i($n,2)
              || nqp::isle_s(nqp::atpos_s(sortable,0),nqp::atpos_s(sortable,1)),
            nqp::clone(sortable),  # we already have the result
            nqp::stmts(
              (my $R := nqp::setelems(nqp::list_s,2)),
              nqp::bindpos_s($R,0,nqp::atpos_s(sortable,1)),
              nqp::bindpos_s($R,1,nqp::atpos_s(sortable,0)),
              $R
            )
          )
        )
    }

    # https://en.wikipedia.org/wiki/Merge_sort#Bottom-up_implementation
    # Sort a native int array (or nqp::list_i) and return the result.
    # Uses the given int array as one of the buffers for performance reasons.
    # Please nqp::clone first if you want to keep the original intact.
    method MERGESORT-int(Mu \sortable) {
        nqp::if(
          nqp::isgt_i((my int $n = nqp::elems(sortable)),2),

          # $A has the items to sort; $B is a work array
          nqp::stmts(
            (my Mu $A := sortable),
            (my Mu $B := nqp::setelems(nqp::list_i,$n)),

            # Each 1-element run in $A is already "sorted"
            # Make successively longer sorted runs of length 2, 4, 8, 16...
            # until $A is wholly sorted
            (my int $width = 1),
            nqp::while(
              nqp::islt_i($width,$n),
              nqp::stmts(
                (my int $l = 0),

                # $A is full of runs of length $width
                nqp::while(
                  nqp::islt_i($l,$n),

                  nqp::stmts(
                    (my int $left  = $l),
                    (my int $right = nqp::add_i($l,$width)),
                    nqp::if(nqp::isge_i($right,$n),($right = $n)),
                    (my int $end =
                      nqp::add_i($l,nqp::add_i($width,$width))),
                    nqp::if(nqp::isge_i($end,$n),($end = $n)),

                    (my int $i = $left),
                    (my int $j = $right),
                    (my int $k = nqp::sub_i($left,1)),

                    # Merge two runs: $A[i       .. i+width-1] and
                    #                 $A[i+width .. i+2*width-1]
                    # to $B or copy $A[i..n-1] to $B[] ( if(i+width >= n) )
                    nqp::while(
                      nqp::islt_i(($k = nqp::add_i($k,1)),$end),
                      nqp::if(
                        nqp::islt_i($i,$right) && (
                          nqp::isge_i($j,$end)
                            || nqp::islt_i(
                                 nqp::atpos_i($A,$i),
                                 nqp::atpos_i($A,$j)
                               )
                        ),
                        nqp::stmts(
                          (nqp::bindpos_i($B,$k,nqp::atpos_i($A,$i))),
                          ($i = nqp::add_i($i,1))
                        ),
                        nqp::stmts(
                          (nqp::bindpos_i($B,$k,nqp::atpos_i($A,$j))),
                          ($j = nqp::add_i($j,1))
                        )
                      )
                    ),
                    ($l = nqp::add_i($l,nqp::add_i($width,$width)))
                  )
                ),

                # Now work array $B is full of runs of length 2*width.
                # Copy array B to array A for next iteration.  A more
                # efficient implementation would swap the roles of A and B.
                (my Mu $temp := $B),($B := $A),($A := $temp),   # swap
                # Now array $A is full of runs of length 2*width.

                ($width = nqp::add_i($width,$width))
              )
            ),
            $A
          ),
          nqp::if(
            nqp::islt_i($n,2)
              || nqp::isle_i(nqp::atpos_i(sortable,0),nqp::atpos_i(sortable,1)),
            nqp::clone(sortable),  # we already have the result
            nqp::stmts(
              (my $R := nqp::setelems(nqp::list_i,2)),
              nqp::bindpos_i($R,0,nqp::atpos_i(self,1)),
              nqp::bindpos_i($R,1,nqp::atpos_i(self,0)),
              $R
            )
          )
        )
    }

    # https://en.wikipedia.org/wiki/Merge_sort#Bottom-up_implementation
    # Sort a native num array (or nqp::list_n) and return the result.
    # Uses the given num array as one of the buffers for performance reasons.
    # Please nqp::clone first if you want to keep the original intact.
    method MERGESORT-num(Mu \sortable) {
        nqp::if(
          nqp::isgt_i((my int $n = nqp::elems(sortable)),2),

          # $A has the items to sort; $B is a work array
          nqp::stmts(
            (my Mu $A := sortable),
            (my Mu $B := nqp::setelems(nqp::list_n,$n)),

            # Each 1-element run in $A is already "sorted"
            # Make successively longer sorted runs of length 2, 4, 8, 16...
            # until $A is wholly sorted
            (my int $width = 1),
            nqp::while(
              nqp::islt_i($width,$n),
              nqp::stmts(
                (my int $l = 0),

                # $A is full of runs of length $width
                nqp::while(
                  nqp::islt_i($l,$n),

                  nqp::stmts(
                    (my int $left  = $l),
                    (my int $right = nqp::add_i($l,$width)),
                    nqp::if(nqp::isge_i($right,$n),($right = $n)),
                    (my int $end =
                      nqp::add_i($l,nqp::add_i($width,$width))),
                    nqp::if(nqp::isge_i($end,$n),($end = $n)),

                    (my int $i = $left),
                    (my int $j = $right),
                    (my int $k = nqp::sub_i($left,1)),

                    # Merge two runs: $A[i       .. i+width-1] and
                    #                 $A[i+width .. i+2*width-1]
                    # to $B or copy $A[i..n-1] to $B[] ( if(i+width >= n) )
                    nqp::while(
                      nqp::islt_i(($k = nqp::add_i($k,1)),$end),
                      nqp::if(
                        nqp::islt_i($i,$right) && (
                          nqp::isge_i($j,$end)
                            || nqp::islt_n(
                                 nqp::atpos_n($A,$i),
                                 nqp::atpos_n($A,$j)
                               )
                        ),
                        nqp::stmts(
                          (nqp::bindpos_n($B,$k,nqp::atpos_n($A,$i))),
                          ($i = nqp::add_i($i,1))
                        ),
                        nqp::stmts(
                          (nqp::bindpos_n($B,$k,nqp::atpos_n($A,$j))),
                          ($j = nqp::add_i($j,1))
                        )
                      )
                    ),
                    ($l = nqp::add_i($l,nqp::add_i($width,$width)))
                  )
                ),

                # Now work array $B is full of runs of length 2*width.
                # Copy array B to array A for next iteration.  A more
                # efficient implementation would swap the roles of A and B.
                (my Mu $temp := $B),($B := $A),($A := $temp),   # swap
                # Now array $A is full of runs of length 2*width.

                ($width = nqp::add_i($width,$width))
              )
            ),
            $A
          ),
          nqp::if(
            nqp::islt_i($n,2)
              || nqp::isle_n(nqp::atpos_n(sortable,0),nqp::atpos_n(sortable,1)),
            nqp::clone(self),  # we already have the result
            nqp::stmts(
              (my $R := nqp::setelems(nqp::list_n,2)),
              nqp::bindpos_n($R,0,nqp::atpos_n(sortable,1)),
              nqp::bindpos_n($R,1,nqp::atpos_n(sortable,0)),
              $R
            )
          )
        )
    }
}

#line 1 SETTING::src/core/HyperConfiguration.pm
# Configuration for hyper/race, controlling how we parallelize (number of
# items at a time, and number of threads).
my class HyperConfiguration {
    has int $.batch;
    has Int $.degree;
}

#line 1 SETTING::src/core/Iterable.pm
# Iterable is done by anything that we should be able to get an iterator
# from. Things that are Iterable will flatten in flattening contexts, so a
# default implementation of .flat is provided by this role. As itemization is
# what defeats flattening, this role also provides a default .item method.
# Additionally, as .lazy and .eager are about iterator behavior, they are
# provided by this role. Overriding those is not likely to be needed, and
# discouraged to maintain predictable semantics. Finally, both .hyper() and
# .race() are methods to enter the hyper and race paradigm and implemented
# here, so they can use any Iterable as a source.
my class HyperSeq { ... }
my class RaceSeq { ... }
my role Rakudo::Internals::HyperIteratorBatcher { ... }
my class X::Invalid::Value { ... }
my role Iterable {
    method iterator() { ... }

    method item() {
        nqp::p6bindattrinvres(nqp::create(Scalar), Scalar, '$!value', self)
    }

    method flat(Iterable:D:) {
        Seq.new(class :: does Iterator {
            has Iterator $!source;
            has Iterator $!nested;

            method new(\source) {
                nqp::p6bindattrinvres(nqp::create(self),self,'$!source',source)
            }

            method pull-one() is raw {
                nqp::if(
                  $!nested,
                  nqp::if(
                    nqp::eqaddr((my $got := $!nested.pull-one),IterationEnd),
                    nqp::stmts(
                      ($!nested := Iterator),
                      self.pull-one
                    ),
                    $got
                  ),
                  nqp::if(
                    nqp::iscont($got := $!source.pull-one),
                    $got,
                    nqp::if(
                      nqp::istype($got,Iterable),
                      nqp::stmts(
                        ($!nested := $got.flat.iterator),
                        self.pull-one
                      ),
                      $got
                    )
                  )
                )
            }

            method push-all($target --> IterationEnd) {
                nqp::stmts(
                  nqp::if(
                    $!nested,
                    nqp::stmts(
                      $!nested.push-all($target),
                      ($!nested := Iterator)
                    )
                  ),
                  nqp::until(
                    nqp::eqaddr((my $got := $!source.pull-one), IterationEnd),
                    nqp::if(
                      nqp::iscont($got),
                      $target.push($got),
                      nqp::if(
                        nqp::istype($got,Iterable),
                        $got.flat.iterator.push-all($target),
                        $target.push($got)
                      )
                    )
                  )
                )
            }
            method is-lazy() { $!source.is-lazy }
        }.new(self.iterator))
    }

    method lazy-if($flag) { $flag ?? self.lazy !! self }

    method lazy() {
        # Return a Seq with an iterator wrapping this Iterable, claiming to
        # be lazy, and implicitly preventing working ahead (by hiding any
        # push-at-least-n of the source iterator).
        Seq.new(class :: does Iterator {
            has $!iterable;
            has $!iterator;

            method new(\iterable) {
                nqp::p6bindattrinvres(
                  nqp::create(self),self,'$!iterable',iterable
                )
            }

            method pull-one() is raw {
                $!iterator := $!iterable.iterator unless $!iterator.DEFINITE;
                $!iterator.pull-one
            }

            method push-exactly($target, int $n) {
                $!iterator := $!iterable.iterator unless $!iterator.DEFINITE;
                $!iterator.push-exactly($target, $n);
            }

            method is-lazy() { True }
        }.new(self))
    }

    method !valid-hyper-race($method,$batch,$degree --> Nil) {
        $batch <= 0
          ?? X::Invalid::Value.new(
               :$method,:name<batch>,:value($batch)).throw
          !! $degree <= 0
            ?? X::Invalid::Value.new(
                 :$method,:name<degree>,:value($degree)).throw
            !! Nil
    }

    method hyper(Int(Cool) :$batch = 64, Int(Cool) :$degree = 4) {
        self!valid-hyper-race('hyper', $batch, $degree);
        HyperSeq.new:
            configuration => HyperConfiguration.new(:$degree, :$batch),
            work-stage-head => Rakudo::Internals::HyperIteratorBatcher.new(
                iterator => self.iterator
            )
    }

    method race(Int(Cool) :$batch = 64, Int(Cool) :$degree = 4) {
        self!valid-hyper-race('race', $batch, $degree);
        RaceSeq.new:
            configuration => HyperConfiguration.new(:$degree, :$batch),
            work-stage-head => Rakudo::Internals::HyperIteratorBatcher.new(
                iterator => self.iterator
            )
    }

    sub MIXIFY(\iterable, \type) {
        nqp::if(
          (my $iterator := iterable.flat.iterator).is-lazy,
          Failure.new(X::Cannot::Lazy.new(:action<coerce>,:what(type.^name))),
          nqp::create(type).SET-SELF(
            Rakudo::QuantHash.ADD-PAIRS-TO-MIX(
              nqp::create(Rakudo::Internals::IterationSet),$iterator
            )
          )
        )
    }
    multi method Mix(Iterable:D:)     { MIXIFY(self, Mix)     }
    multi method MixHash(Iterable:D:) { MIXIFY(self, MixHash) }

    sub BAGGIFY(\iterable, \type) {
        nqp::if(
          (my $iterator := iterable.flat.iterator).is-lazy,
          Failure.new(X::Cannot::Lazy.new(:action<coerce>,:what(type.^name))),
          nqp::create(type).SET-SELF(
            Rakudo::QuantHash.ADD-PAIRS-TO-BAG(
              nqp::create(Rakudo::Internals::IterationSet),$iterator
            )
          )
        )
    }
    multi method Bag(Iterable:D:)     { BAGGIFY(self, Bag)     }
    multi method BagHash(Iterable:D:) { BAGGIFY(self, BagHash) }

    sub SETIFY(\iterable, \type) {
        nqp::if(
          (my $iterator := iterable.flat.iterator).is-lazy,
          Failure.new(X::Cannot::Lazy.new(:action<coerce>,:what(type.^name))),
          nqp::create(type).SET-SELF(
            Rakudo::QuantHash.ADD-PAIRS-TO-SET(
              nqp::create(Rakudo::Internals::IterationSet),$iterator
            )
          )
        )
    }
    multi method Set(Iterable:D:)     { SETIFY(self,Set)     }
    multi method SetHash(Iterable:D:) { SETIFY(self,SetHash) }
}





#line 1 SETTING::src/core/Any-iterable-methods.pm
# Now that Iterable is defined, we add extra methods into Any for the list
# operations. (They can't go into Any right away since we need Attribute to
# define the various roles, and Attribute inherits from Any. We will do a
# re-compose of Attribute to make sure it gets the list methods at the end
# of this file. Note the general pattern for these list-y methods is that
# they check if they have an Iterable already, and if not obtain one to
# work on by doing a .list coercion.
use MONKEY-TYPING;
augment class Any {

    proto method map(|) is nodal { * }
    multi method map(Hash \h) {
        die "Cannot map a {self.^name} to a {h.^name}.
Did you mean to add a stub (\{...\}) or did you mean to .classify?"
    }

    multi method map(\SELF: &block;; :$label, :$item) {
        sequential-map(($item ?? (SELF,) !! SELF).iterator, &block, $label);
    }

    my class IterateOneWithPhasers does SlippyIterator {
        has &!block;
        has $!source;
        has $!label;
        has Int $!NEXT;         # SHOULD BE int, but has Int performs better
        has Int $!did-init;     # SHOULD BE int, but has Int performs better
        has Int $!did-iterate;  # SHOULD BE int, but has Int performs better

        method !SET-SELF(\block,\source,\label) {
            nqp::stmts(
              (&!block  := block),
              ($!source := source),
              ($!label  := label),
              ($!NEXT = block.has-phaser('NEXT')),
              self
            )
        }
        method new(\bl,\sou,\la) { nqp::create(self)!SET-SELF(bl,sou,la) }

        method is-lazy() { $!source.is-lazy }

        method pull-one() is raw {
            my int $stopped;
            my $value;
            my $result;

            nqp::unless(
              $!did-init,
              nqp::stmts(
                ($!did-init = 1),
                nqp::if(
                  &!block.has-phaser('FIRST'),
                  nqp::p6setfirstflag(&!block)
                )
              )
            );

            if $!slipping && nqp::not_i(nqp::eqaddr(($result := self.slip-one),IterationEnd)) {
                # $result will be returned at the end
            }
            elsif nqp::eqaddr(($value := $!source.pull-one),IterationEnd) {
                $result := IterationEnd
            }
            else {
                nqp::until(
                  $stopped,
                  nqp::handle(
                    nqp::stmts(
                      ($stopped = 1),
                      ($result := &!block($value)),
                      ($!did-iterate = 1),
                      nqp::if(
                        nqp::istype($result, Slip),
                        nqp::if(
                          nqp::eqaddr(($result := self.start-slip($result)), IterationEnd),
                          nqp::if(
                            nqp::not_i(nqp::eqaddr(($value := $!source.pull-one),IterationEnd)),
                            ($stopped = 0)
                          ),
                        )
                      ),
                      nqp::if($!NEXT, &!block.fire_phasers('NEXT')),
                    ),
                    'LABELED', $!label,
                    'NEXT', nqp::stmts(
                       ($!did-iterate = 1),
                       nqp::if($!NEXT, &!block.fire_phasers('NEXT')),
                       nqp::eqaddr(($value := $!source.pull-one), IterationEnd)
                         ?? ($result := IterationEnd)
                         !! ($stopped = 0)
                    ),
                    'REDO', ($stopped = 0),
                    'LAST', nqp::stmts(
                      ($!did-iterate = 1),
                      ($result := IterationEnd)
                    )
                  ),
                  :nohandler
                )
            }
            nqp::if(
              $!did-iterate && nqp::eqaddr($result,IterationEnd),
              &!block.fire_if_phasers('LAST')
            );
            $result
        }

        method push-all($target --> IterationEnd) {
            nqp::unless(
              $!did-init,
              nqp::stmts(
                ($!did-init = 1),
                nqp::if(
                  &!block.has-phaser('FIRST'),
                  nqp::p6setfirstflag(&!block)
                )
              )
            );

            my int $stopped;
            my int $done;
            my $pulled;
            my $value;

            nqp::if(
              $!slipping,
              nqp::until(
                nqp::eqaddr(($value := self.slip-one),IterationEnd),
                $target.push($value)
              )
            );

            until $done
                || nqp::eqaddr(($value := $!source.pull-one),IterationEnd) {
                nqp::stmts(
                  ($stopped = 0),
                  nqp::until(
                    $stopped,
                    nqp::stmts(
                      ($stopped = 1),
                      nqp::handle(
                        nqp::stmts(  # doesn't sink
                          ($pulled := &!block($value)),
                          ($!did-iterate = 1),
                          nqp::if($!NEXT, &!block.fire_phasers('NEXT')),
                          nqp::if(
                            nqp::istype($pulled,Slip),
                            self.slip-all($pulled,$target),
                            $target.push($pulled)
                          )
                        ),
                        'LABELED', $!label,
                        'NEXT', nqp::stmts(
                          ($!did-iterate = 1),
                          nqp::if($!NEXT, &!block.fire_phasers('NEXT')),
                          nqp::eqaddr(
                            ($value := $!source.pull-one),
                            IterationEnd
                          )
                            ?? ($done = 1)
                            !! ($stopped = 0)),
                        'REDO', ($stopped = 0),
                        'LAST', ($done = $!did-iterate = 1)
                      )
                    ),
                    :nohandler
                  )
                )
            }
            nqp::if($!did-iterate,&!block.fire_if_phasers('LAST'))
        }

        method sink-all(--> IterationEnd) {
            nqp::unless(
              $!did-init,
              nqp::stmts(
                ($!did-init = 1),
                nqp::if(
                  &!block.has-phaser('FIRST'),
                  nqp::p6setfirstflag(&!block)
                )
              )
            );

            nqp::if(
              $!slipping,
              nqp::until(
                nqp::eqaddr(self.slip-one,IterationEnd),
                nqp::null
              )
            );

            my int $stopped;
            my int $done;
            my $value;
            until $done
                || nqp::eqaddr(($value := $!source.pull-one()),IterationEnd) {
                nqp::stmts(
                  ($stopped = 0),
                  nqp::until(
                    $stopped,
                    nqp::stmts(
                      ($stopped = 1),
                      nqp::handle(
                        nqp::stmts(  # doesn't sink
                          (&!block($value)),
                          ($!did-iterate = 1),
                          nqp::if($!NEXT, &!block.fire_phasers('NEXT')),
                        ),
                        'LABELED', $!label,
                        'NEXT', nqp::stmts(
                          ($!did-iterate = 1),
                          nqp::if($!NEXT, &!block.fire_phasers('NEXT')),
                          nqp::eqaddr(
                            ($value := $!source.pull-one),
                            IterationEnd
                          )
                            ?? ($done = 1)
                            !! ($stopped = 0)),
                        'REDO', ($stopped = 0),
                        'LAST', ($done = $!did-iterate = 1)
                      )
                    ),
                    :nohandler
                  )
                )
            }
            nqp::if($!did-iterate,&!block.fire_if_phasers('LAST'))
        }
    }

    my class IterateOneNotSlippingWithoutPhasers does Iterator {
        has &!block;
        has $!source;
        has $!label;

        method new(&block,$source,$label) {
            my $iter := nqp::create(self);
            nqp::bindattr($iter, self, '&!block', &block);
            nqp::bindattr($iter, self, '$!source', $source);
            nqp::bindattr($iter, self, '$!label', nqp::decont($label));
            $iter
        }

        method is-lazy() { $!source.is-lazy }

        method pull-one() is raw {
            if nqp::eqaddr((my $pulled := $!source.pull-one),IterationEnd) {
                IterationEnd
            }
            else {
                my $result;
                my int $stopped;
                nqp::stmts(
                  nqp::until(
                    $stopped,
                    nqp::stmts(
                      ($stopped = 1),
                      nqp::handle(
                        ($result := &!block($pulled)),
                        'LABELED', $!label,
                        'NEXT', nqp::if(
                          nqp::eqaddr(
                            ($pulled := $!source.pull-one),
                            IterationEnd
                          ),
                          ($result := IterationEnd),
                          ($stopped = 0)
                        ),
                        'REDO', ($stopped = 0),
                        'LAST', ($result := IterationEnd)
                      ),
                    ),
                    :nohandler
                  ),
                  $result
                )
            }
        }

        method push-all($target --> IterationEnd) {
            my $pulled;
            my int $stopped;
            nqp::until(
              nqp::eqaddr(($pulled := $!source.pull-one),IterationEnd),
               nqp::stmts(
                ($stopped = 0),
                nqp::until(
                  $stopped,
                  nqp::stmts(
                    ($stopped = 1),
                    nqp::handle(
                      $target.push(&!block($pulled)),
                      'LABELED', $!label,
                      'REDO', ($stopped = 0),
                      'NEXT', nqp::null, # need NEXT for next LABEL support
                      'LAST', return
                    )
                  ),
                  :nohandler
                )
              )
            )
        }

        method sink-all(--> IterationEnd) {
            my $pulled;
            my int $stopped;
            nqp::until(
              nqp::eqaddr(($pulled := $!source.pull-one),IterationEnd),
              nqp::stmts(
                ($stopped = 0),
                nqp::until(
                  $stopped,
                  nqp::stmts(
                    ($stopped = 1),
                    nqp::handle(
                      &!block($pulled),
                      'LABELED', $!label,
                      'REDO', ($stopped = 0),
                      'NEXT', nqp::null, # need NEXT for next LABEL support
                      'LAST', return
                    )
                  ),
                  :nohandler
                )
              )
            )
        }
    }

    my class IterateOneWithoutPhasers does SlippyIterator {
        has &!block;
        has $!source;
        has $!label;

        method new(&block,$source,$label) {
            my $iter := nqp::create(self);
            nqp::bindattr($iter, self, '&!block', &block);
            nqp::bindattr($iter, self, '$!source', $source);
            nqp::bindattr($iter, self, '$!label', nqp::decont($label));
            $iter
        }

        method is-lazy() { $!source.is-lazy }

        method pull-one() is raw {
            my int $redo = 1;
            my $value;
            my $result;

            if $!slipping && nqp::not_i(nqp::eqaddr(
              ($result := self.slip-one),
              IterationEnd
            )) {
                # $result will be returned at the end
            }
            elsif nqp::eqaddr(
              ($value := $!source.pull-one),
              IterationEnd
            ) {
                $result := $value
            }
            else {
              nqp::while(
                $redo,
                nqp::stmts(
                  $redo = 0,
                  nqp::handle(
                    nqp::if(
                      nqp::istype(($result := &!block($value)),Slip),
                      nqp::if(
                        nqp::eqaddr(
                          ($result := self.start-slip($result)), IterationEnd),
                        nqp::if(
                          nqp::not_i(nqp::eqaddr(
                            ($value := $!source.pull-one),
                            IterationEnd
                          )),
                          $redo = 1
                        )
                      )
                    ),
                    'LABELED',
                    $!label,
                    'NEXT',
                    nqp::if(
                      nqp::eqaddr(
                        ($value := $!source.pull-one),IterationEnd
                      ),
                      ($result := IterationEnd),
                      ($redo = 1)
                    ),
                    'REDO',
                    ($redo = 1),
                    'LAST',
                    ($result := IterationEnd)
                  ),
                ),
              :nohandler);
            }
            $result
        }

        method push-all($target --> IterationEnd) {
            nqp::stmts(
              (my $value),
              nqp::if(
                $!slipping,
                nqp::until(
                  nqp::eqaddr(($value := self.slip-one),IterationEnd),
                  $target.push($value)
                )
              ),
              nqp::until(
                nqp::eqaddr(($value := $!source.pull-one),IterationEnd),
                nqp::stmts(
                  (my int $redo = 1),
                  nqp::while(
                    $redo,
                    nqp::stmts(
                      ($redo = 0),
                      nqp::handle(
                        nqp::if(
                          nqp::istype((my $result := &!block($value)),Slip),
                          self.slip-all($result,$target),
                          $target.push($result)
                        ),
                        'LABELED', $!label,
                        'REDO', ($redo = 1),
                        'LAST', return,
                        'NEXT', nqp::null, # need NEXT for next LABEL support
                      )
                    ),
                    :nohandler
                  )
                )
              )
            )
        }

        method sink-all(--> IterationEnd) {
            nqp::stmts(
              nqp::if(
                $!slipping,
                nqp::until(
                  nqp::eqaddr(self.slip-one,IterationEnd),
                  nqp::null
                )
              ),
              nqp::until(
                nqp::eqaddr((my $value := $!source.pull-one()),IterationEnd),
                nqp::stmts(
                  (my int $redo = 1),
                  nqp::while(
                    $redo,
                    nqp::stmts(
                      ($redo = 0),
                      nqp::handle(  # doesn't sink
                        &!block($value),
                        'LABELED', $!label,
                        'NEXT', nqp::null,  # need NEXT for next LABEL support
                        'REDO', ($redo = 1),
                        'LAST', return
                      ),
                    :nohandler
                    )
                  )
                )
              )
            )
        }
    }

    my class IterateTwoWithoutPhasers does SlippyIterator {
        has &!block;
        has $!source;
        has $!label;

        method new(&block,$source,$label) {
            my $iter := nqp::create(self);
            nqp::bindattr($iter, self, '&!block', &block);
            nqp::bindattr($iter, self, '$!source', $source);
            nqp::bindattr($iter, self, '$!label', nqp::decont($label));
            $iter
        }

        method is-lazy() { $!source.is-lazy }

        method pull-one() is raw {
            my int $redo = 1;
            my $value;
            my $value2;
            my $result;

            if $!slipping && nqp::not_i(nqp::eqaddr(
              ($result := self.slip-one),
              IterationEnd
            )) {
                # $result will be returned at the end
            }
            elsif nqp::eqaddr(
              ($value := $!source.pull-one),
              IterationEnd
            ) {
                $result := IterationEnd;
            }
            else {
              nqp::while(
                $redo,
                nqp::stmts(
                  $redo = 0,
                  nqp::handle(
                    nqp::stmts(
                      nqp::if(
                        nqp::eqaddr(($value2 := $!source.pull-one),IterationEnd),
                        nqp::if(                                 # don't have 2 params
                          nqp::istype(($result := &!block($value)),Slip),
                          ($result := self.start-slip($result))  # don't care if empty
                        ),
                        nqp::if(
                          nqp::istype(($result := &!block($value,$value2)),Slip),
                          nqp::if(
                            nqp::eqaddr(($result := self.start-slip($result)),IterationEnd),
                            nqp::unless(
                              nqp::eqaddr(($value := $!source.pull-one),IterationEnd),
                              ($redo = 1)
                            )
                          )
                        )
                      )
                    ),
                    'LABELED',
                    $!label,
                    'NEXT',
                    nqp::if(
                      nqp::eqaddr(
                        ($value := $!source.pull-one),IterationEnd
                      ),
                      ($result := IterationEnd),
                      ($redo = 1)
                    ),
                    'REDO',
                    ($redo = 1),
                    'LAST',
                    ($result := IterationEnd)
                  ),
                ),
              :nohandler);
            }
            $result
        }

        method push-all($target --> IterationEnd) {
            nqp::stmts(
              (my $value),
              nqp::if(
                $!slipping,
                nqp::until(
                  nqp::eqaddr(($value := self.slip-one),IterationEnd),
                  $target.push($value)
                )
              ),
              nqp::until(
                nqp::eqaddr(($value := $!source.pull-one),IterationEnd),
                nqp::stmts(
                  (my int $redo = 1),
                  nqp::while(
                    $redo,
                    nqp::stmts(
                      ($redo = 0),
                      nqp::handle(
                        nqp::if(
                          nqp::eqaddr(
                            (my $value2 := $!source.pull-one),
                            IterationEnd
                          ),
                          nqp::stmts(
                            (my $result := &!block($value)),
                            nqp::if(
                              nqp::istype($result,Slip),
                              self.slip-all($result,$target),
                              $target.push($result)
                            ),
                            return
                          ),
                          nqp::if(
                            nqp::istype(
                              ($result := &!block($value,$value2)),
                              Slip
                            ),
                            self.slip-all($result,$target),
                            $target.push($result)
                          )
                        ),
                        'LABELED', $!label,
                        'REDO', ($redo = 1),
                        'LAST', return,
                        'NEXT', nqp::null, # need NEXT for next LABEL support
                      )
                    ),
                    :nohandler
                  )
                )
              )
            )
        }

        method sink-all(--> IterationEnd) {
            nqp::stmts(
              nqp::if(
                $!slipping,
                nqp::until(
                  nqp::eqaddr(self.slip-one,IterationEnd),
                  nqp::null,
                )
              ),
              nqp::until(
                nqp::eqaddr((my $value := $!source.pull-one()),IterationEnd),
                nqp::stmts(
                  (my int $redo = 1),
                  nqp::while(
                    $redo,
                    nqp::stmts(
                      ($redo = 0),
                      nqp::handle(  # doesn't sink
                        nqp::if(
                          nqp::eqaddr(
                            (my $value2 := $!source.pull-one),
                            IterationEnd
                          ),
                          nqp::stmts(
                            (&!block($value)),
                            return
                          ),
                          (&!block($value,$value2))
                        ),
                        'LABELED', $!label,
                        'NEXT', nqp::null,  # need NEXT for next LABEL support
                        'REDO', ($redo = 1),
                        'LAST', return
                      )
                    ),
                  :nohandler
                  )
                )
              )
            )
        }
    }

    my class IterateMoreWithPhasers does SlippyIterator {
        has &!block;
        has $!source;
        has $!count;
        has $!label;
        has $!value-buffer;
        has $!did-init;
        has $!did-iterate;
        has $!NEXT;
        has $!CAN_FIRE_PHASERS;

        method new(&block, $source, $count, $label) {
            my $iter := nqp::create(self);
            nqp::bindattr($iter, self, '&!block', &block);
            nqp::bindattr($iter, self, '$!source', $source);
            nqp::bindattr($iter, self, '$!count', $count);
            nqp::bindattr($iter, self, '$!label', nqp::decont($label));
            $iter
        }

        method is-lazy() { $!source.is-lazy }

        method pull-one() is raw {
            $!value-buffer.DEFINITE
                ?? nqp::setelems($!value-buffer, 0)
                !! ($!value-buffer := IterationBuffer.new);
            my int $redo = 1;
            my $result;

            if !$!did-init && nqp::can(&!block, 'fire_phasers') {
                $!did-init         = 1;
                $!CAN_FIRE_PHASERS = 1;
                $!NEXT             = &!block.has-phaser('NEXT');
                nqp::p6setfirstflag(&!block)
                  if &!block.has-phaser('FIRST');
            }

            if $!slipping && !(($result := self.slip-one()) =:= IterationEnd) {
                # $result will be returned at the end
            }
            elsif $!source.push-exactly($!value-buffer, $!count) =:= IterationEnd
                    && nqp::elems($!value-buffer) == 0 {
                $result := IterationEnd
            }
            else {
                nqp::while(
                  $redo,
                  nqp::stmts(
                    $redo = 0,
                    nqp::handle(
                      nqp::stmts(
                        ($result := nqp::p6invokeflat(&!block, $!value-buffer)),
                        ($!did-iterate = 1),
                        nqp::if(
                          nqp::istype($result, Slip),
                          nqp::stmts(
                            ($result := self.start-slip($result)),
                            nqp::if(
                              nqp::eqaddr($result, IterationEnd),
                              nqp::stmts(
                                (nqp::setelems($!value-buffer, 0)),
                                ($redo = 1
                                  unless nqp::eqaddr(
                                    $!source.push-exactly($!value-buffer, $!count),
                                    IterationEnd)
                                  && nqp::elems($!value-buffer) == 0)
                              )
                            )
                          )
                        ),
                        nqp::if($!NEXT, &!block.fire_phasers('NEXT')),
                      ),
                      'LABELED', $!label,
                      'NEXT', nqp::stmts(
                        ($!did-iterate = 1),
                        nqp::if($!NEXT, &!block.fire_phasers('NEXT')),
                          (nqp::setelems($!value-buffer, 0)),
                          nqp::eqaddr($!source.push-exactly($!value-buffer, $!count), IterationEnd)
                          && nqp::elems($!value-buffer) == 0
                            ?? ($result := IterationEnd)
                            !! ($redo = 1)),
                      'REDO', $redo = 1,
                      'LAST', nqp::stmts(
                        ($!did-iterate = 1),
                        ($result := IterationEnd)
                      )
                    )
                  ),
                :nohandler);
            }
            &!block.fire_if_phasers('LAST')
              if $!CAN_FIRE_PHASERS
              && $!did-iterate
              && nqp::eqaddr($result, IterationEnd);
            $result
        }
    }

    sub sequential-map(\source, &block, $label) {
        # We want map to be fast, so we go to some effort to build special
        # case iterators that can ignore various interesting cases.
        my $count = &block.count;

        Seq.new(
          nqp::istype(&block,Block) && &block.has-phasers
            ?? $count < 2 || $count === Inf
              ?? IterateOneWithPhasers.new(&block,source,$label)
              !! IterateMoreWithPhasers.new(&block,source,$count,$label)
            !! $count < 2 || $count === Inf
              ?? nqp::istype(Slip,&block.returns)
                ?? IterateOneWithoutPhasers.new(&block,source,$label)
                !! IterateOneNotSlippingWithoutPhasers.new(&block,source,$label)
              !! $count == 2
                ?? IterateTwoWithoutPhasers.new(&block,source,$label)
                !! IterateMoreWithPhasers.new(&block,source,$count,$label)
        )
    }

    proto method flatmap (|) is nodal { * }
    multi method flatmap(&block, :$label) {
        self.map(&block, :$label).flat
    }

    method !grep-k(Callable:D $test) {
        Seq.new(class :: does Iterator {
            has  Mu $!iter;
            has  Mu $!test;
            has int $!index;
            method !SET-SELF(\list,Mu \test) {
                $!iter  = list.iterator;
                $!test := test;
                $!index = -1;
                self
            }
            method new(\list,Mu \test) { nqp::create(self)!SET-SELF(list,test) }
            method pull-one() is raw {
                $!index = $!index + 1
                  until ($_ := $!iter.pull-one) =:= IterationEnd || $!test($_);
                $_ =:= IterationEnd
                  ?? IterationEnd
                  !! nqp::p6box_i($!index = $!index + 1)
            }
            method push-all($target --> IterationEnd) {
                until ($_ := $!iter.pull-one) =:= IterationEnd {
                    $!index = $!index + 1;
                    $target.push(nqp::p6box_i($!index)) if $!test($_);
                }
            }
        }.new(self, $test))
    }
    method !grep-kv(Callable:D $test) {
        Seq.new(class :: does Iterator {
            has  Mu $!iter;
            has  Mu $!test;
            has int $!index;
            has Mu $!value;
            method !SET-SELF(\list,Mu \test) {
                $!iter  = list.iterator;
                $!test := test;
                $!index = -1;
                self
            }
            method new(\list,Mu \test) { nqp::create(self)!SET-SELF(list,test) }
            method pull-one() is raw {
                if $!value.DEFINITE {
                    my \tmp  = $!value;
                    $!value := nqp::null;
                    tmp
                }
                else {
                    $!index = $!index + 1
                      until ($_ := $!iter.pull-one) =:= IterationEnd
                        || $!test($_);
                    if $_ =:= IterationEnd {
                        IterationEnd;
                    }
                    else {
                        $!value := $_;
                        nqp::p6box_i($!index = $!index + 1)
                    }
                }
            }
            method push-all($target --> IterationEnd) {
                nqp::until(
                  nqp::eqaddr(($_ := $!iter.pull-one),IterationEnd),
                  nqp::stmts(
                    $!index = nqp::add_i($!index,1);
                    nqp::if(
                      $!test($_),
                      nqp::stmts(  # doesn't sink
                        $target.push(nqp::p6box_i($!index));
                        $target.push($_);
                      )
                    )
                  )
                );
            }
        }.new(self, $test))
    }
    method !grep-p(Callable:D $test) {
        Seq.new(class :: does Iterator {
            has  Mu $!iter;
            has  Mu $!test;
            has int $!index;
            method !SET-SELF(\list,Mu \test) {
                $!iter  = list.iterator;
                $!test := test;
                $!index = -1;
                self
            }
            method new(\list,Mu \test) { nqp::create(self)!SET-SELF(list,test) }
            method pull-one() is raw {
                $!index = $!index + 1
                  until ($_ := $!iter.pull-one) =:= IterationEnd || $!test($_);
                $_ =:= IterationEnd
                  ?? IterationEnd
                  !! Pair.new($!index = $!index + 1,$_)
            }
            method push-all($target --> IterationEnd) {
                until ($_ := $!iter.pull-one) =:= IterationEnd {
                    $!index = $!index + 1;
                    $target.push(Pair.new($!index,$_)) if $!test($_);
                }
            }
        }.new(self, $test))
    }

    role Grepper does Iterator {
        has Mu $!iter;
        has Mu $!test;
        method SET-SELF(\list,Mu \test) {
            $!iter  = list.iterator;
            $!test := test;
            self
        }
        method new(\list,Mu \test) { nqp::create(self).SET-SELF(list,test) }
        method is-lazy() { $!iter.is-lazy }
    }
    method !grep-callable(Callable:D $test) {
        nqp::if(
          $test.count == 1,
          sequential-map(
            self.iterator,
            { nqp::if($test($_),$_,Empty) },
            Any)
          ,
          nqp::stmts(
            (my role CheatArity {
                has $!arity;
                has $!count;

                method set-cheat($new-arity, $new-count --> Nil) {
                    $!arity = $new-arity;
                    $!count = $new-count;
                }

                method arity(Code:D:) { $!arity }
                method count(Code:D:) { $!count }
            }),
            (my &tester = -> |c {
                #note "*cough* {c.perl} -> {$test(|c).perl}";
                next unless $test(|c);
                c.list
            } but CheatArity),
            &tester.set-cheat($test.arity, $test.count),
            self.map(&tester)
          )
        )
    }
    method !grep-accepts(Mu $test) {
        Seq.new(class :: does Grepper {
            method pull-one() is raw {
                nqp::until(
                  nqp::eqaddr(($_ := $!iter.pull-one),IterationEnd)
                    || $!test.ACCEPTS($_),
                  nqp::null
                );
                $_
            }
            method push-all($target --> IterationEnd) {
                nqp::until(
                  nqp::eqaddr(($_ := $!iter.pull-one),IterationEnd),
                  nqp::if(  # doesn't sink
                    $!test.ACCEPTS($_),
                    $target.push($_)
                  )
                );
            }
        }.new(self, $test))
    }

    method !first-result(\index,\value,$what,%a) is raw {
        nqp::stmts(
          (my $storage := nqp::getattr(%a,Map,'$!storage')),
          nqp::if(
            nqp::elems($storage),                       # some adverb
            nqp::if(
              nqp::iseq_i(nqp::elems($storage),1),      # one adverb
              nqp::if(
                nqp::atkey($storage,"k"),               # :k
                nqp::p6box_i(index),
                nqp::if(
                  nqp::atkey($storage,"p"),             # :p
                  Pair.new(index,value),
                  nqp::if(
                    nqp::atkey($storage,"v"),           # :v
                    value,
                    nqp::if(
                      nqp::atkey($storage,"kv"),        # :kv
                      (index,value),
                      nqp::stmts(                       # no truthy or different
                        (my str $key =
                          nqp::iterkey_s(nqp::shift(nqp::iterator($storage)))),
                        nqp::if(
                          (nqp::iseq_s($key,"k")        # :!k || :!p || :!kv
                            || nqp::iseq_s($key,"p")
                            || nqp::iseq_s($key,"kv")),
                          value,
                          nqp::if(
                            nqp::iseq_s($key,"v"),      # :!v
                            Failure.new("Specified a negated :v adverb"),
                            Failure.new(X::Adverb.new(  # :foo ??
                              :$what,
                              :source(try { self.VAR.name } // self.WHAT.perl),
                              :unexpected(%a.keys)))
                          )
                        )
                      )
                    )
                  )
                )
              ),
              Failure.new(X::Adverb.new(                # multiple adverbs ??
                :$what,
                :source(try { self.VAR.name } // self.WHAT.perl),
                :nogo(%a.keys.grep: /k|v|p/)
                :unexpected(%a.keys.grep: { !.match(/k|v|p/) } )))
            ),
            value                                       # no adverb
          )
        )
    }

    proto method grep(|) is nodal { * }
    multi method grep(Bool:D $t) {
        X::Match::Bool.new( type => '.grep').throw
    }
    multi method grep(Mu $t) {
        my $storage := nqp::getattr(%_,Map,'$!storage');
        if nqp::iseq_i(nqp::elems($storage),0) {
            nqp::istype($t,Regex:D)
              ?? self!grep-accepts: $t
              !! nqp::istype($t,Callable:D)
                   ?? self!grep-callable: $t
                   !! self!grep-accepts: $t
        }
        elsif nqp::iseq_i(nqp::elems($storage),1) {
            if nqp::atkey($storage,"k") {
                nqp::istype($t,Regex:D)
                  ?? self!grep-k: { $t.ACCEPTS($_) }
                  !! nqp::istype($t,Callable:D)
                       ?? self!grep-k: $t
                       !! self!grep-k: { $t.ACCEPTS($_) }
            }
            elsif nqp::atkey($storage,"kv") {
                nqp::istype($t,Regex:D)
                  ?? self!grep-kv: { $t.ACCEPTS($_) }
                  !! nqp::istype($t,Callable:D)
                       ?? self!grep-kv: $t
                       !! self!grep-kv: { $t.ACCEPTS($_) }
            }
            elsif nqp::atkey($storage,"p") {
                nqp::istype($t,Regex:D)
                  ?? self!grep-p: { $t.ACCEPTS($_) }
                  !! nqp::istype($t,Callable:D)
                       ?? self!grep-p: $t
                       !! self!grep-p: { $t.ACCEPTS($_) }
            }
            elsif nqp::atkey($storage,"v") {
                nqp::istype($t,Regex:D)
                  ?? self!grep-accepts: $t
                  !! nqp::istype($t,Callable:D)
                       ?? self!grep-callable: $t
                       !! self!grep-accepts: $t
            }
            else {
                my str $key =
                  nqp::iterkey_s(nqp::shift(nqp::iterator($storage)));
                if nqp::iseq_s($key,"k") || nqp::iseq_s($key,"kv") || nqp::iseq_s($key,"p") {
                    nqp::istype($t,Regex:D)
                      ?? self!grep-accepts: $t
                      !! nqp::istype($t,Callable:D)
                           ?? self!grep-callable: $t
                           !! self!grep-accepts: $t
                }
                else {
                    nqp::iseq_s($key,"k")
                      ?? die "Specified a negated :v adverb"
                      !! X::Adverb.new(
                           :what<grep>,
                           :source(try { self.VAR.name } // self.WHAT.perl),
                           :unexpected($key)
                         ).throw
                }
            }
        }
        else {
            X::Adverb.new(
              :what<grep>,
              :source(try { self.VAR.name } // self.WHAT.perl),
              :nogo(%_.keys.grep: /k|v|kv|p/)
              :unexpected(%_.keys.grep: { !.match(/k|v|kv|p/) } )
            ).throw
        }
    }

    proto method first(|) is nodal { * }
    multi method first(Bool:D $t) {
        Failure.new(X::Match::Bool.new( type => '.first' ))
    }
    # need to handle Regex differently, since it is also Callable
    multi method first(Regex:D $test, :$end, *%a) is raw {
        $end
          ?? self!first-accepts-end($test,%a)
          !! self!first-accepts($test,%a)
    }
    multi method first(Callable:D $test, :$end, *%a is copy) is raw {
        if $end {
            nqp::stmts(
              (my $elems = self.elems),
              nqp::if(
                ($elems && nqp::not_i($elems == Inf)),
                nqp::stmts(
                  (my int $index = $elems),
                  nqp::while(
                    nqp::isge_i(($index = nqp::sub_i($index,1)),0),
                    nqp::if(
                      $test(self.AT-POS($index)),
                      return self!first-result(
                        $index,self.AT-POS($index),'first :end',%a)
                    )
                  ),
                  Nil
                ),
                Nil
              )
            )
        }
        else {
            nqp::stmts(
              (my $iter := self.iterator),
              (my int $index),
              nqp::until(
                (nqp::eqaddr(($_ := $iter.pull-one),IterationEnd)
                  || $test($_)),
                ($index = nqp::add_i($index,1))
              ),
              nqp::if(
                nqp::eqaddr($_,IterationEnd),
                Nil,
                self!first-result($index,$_,'first',%a)
              )
            )
        }
    }
    multi method first(Mu $test = True, :$end, *%a) is raw {
        $end
          ?? self!first-accepts-end($test,%a)
          !! self!first-accepts($test,%a)
    }
    method !first-accepts(Mu $test,%a) is raw {
        nqp::stmts(
          (my $iter := self.iterator),
          (my int $index),
          nqp::until(
            (nqp::eqaddr(($_ := $iter.pull-one),IterationEnd)
              || $test.ACCEPTS($_)),
            ($index = nqp::add_i($index,1))
          ),
          nqp::if(
            nqp::eqaddr($_,IterationEnd),
            Nil,
            self!first-result($index,$_,'first',%a)
          )
        )
    }
    method !first-accepts-end(Mu $test,%a) is raw {
        nqp::stmts(
          (my $elems = self.elems),
          nqp::if(
            ($elems && nqp::not_i($elems == Inf)),
            nqp::stmts(
              (my int $index = $elems),
              nqp::while(
                nqp::isge_i(($index = nqp::sub_i($index,1)),0),
                nqp::if(
                  $test.ACCEPTS(self.AT-POS($index)),
                  return self!first-result(
                    $index,self.AT-POS($index),'first :end',%a)
                )
              ),
              Nil
            ),
            Nil
          )
        )
    }
    method !iterator-and-first($action,\first) is raw {
        nqp::if(
          self.is-lazy,
          X::Cannot::Lazy.new(:$action).throw,
          nqp::stmts(
            (my $iterator := self.iterator),
            nqp::until(
              nqp::eqaddr((my $pulled := $iterator.pull-one),IterationEnd),
              nqp::if(
                nqp::isconcrete($pulled),
                nqp::stmts(
                  (first = $pulled),
                  (return $iterator)
                )
              )
            ),
            Mu
          )
        )
    }

    proto method min (|) is nodal { * }
    multi method min() {
        nqp::stmts(
          nqp::if(
            (my $iter := self!iterator-and-first(".min",my $min)),
            nqp::until(
              nqp::eqaddr((my $pulled := $iter.pull-one),IterationEnd),
              nqp::if(
                (nqp::isconcrete($pulled) && $pulled cmp $min < 0),
                $min = $pulled
              )
            )
          ),
          nqp::if(nqp::defined($min),$min,Inf)
        )
    }
    multi method min(&by) {
        nqp::stmts(
          (my $cmp := nqp::if(
            nqp::iseq_i(&by.arity,2),&by,{ &by($^a) cmp &by($^b) })),
          nqp::if(
            (my $iter := self!iterator-and-first(".min",my $min)),
            nqp::until(
              nqp::eqaddr((my $pulled := $iter.pull-one),IterationEnd),
              nqp::if(
                (nqp::isconcrete($pulled) && $cmp($pulled,$min) < 0),
                $min = $pulled
              )
            )
          ),
          nqp::if(nqp::defined($min),$min,Inf)
        )
    }

    proto method max (|) is nodal { * }
    multi method max() {
        nqp::stmts(
          nqp::if(
            (my $iter := self!iterator-and-first(".max",my $max)),
            nqp::until(
              nqp::eqaddr((my $pulled := $iter.pull-one),IterationEnd),
              nqp::if(
                (nqp::isconcrete($pulled) && $pulled cmp $max > 0),
                $max = $pulled
              )
            )
          ),
          nqp::if(nqp::defined($max),$max,-Inf)
        )
    }
    multi method max(&by) {
        nqp::stmts(
          (my $cmp := nqp::if(
            nqp::iseq_i(&by.arity,2),&by,{ &by($^a) cmp &by($^b) })),
          nqp::if(
            (my $iter := self!iterator-and-first(".max",my $max)),
            nqp::until(
              nqp::eqaddr((my $pulled := $iter.pull-one),IterationEnd),
              nqp::if(
                (nqp::isconcrete($pulled) && $cmp($pulled,$max) > 0),
                $max = $pulled
              )
            )
          ),
          nqp::if(nqp::defined($max),$max,-Inf)
        )
    }

    method !minmax-range-init(\value,\mi,\exmi,\ma,\exma --> Nil) {
        mi   = value.min;
        exmi = value.excludes-min;
        ma   = value.max;
        exma = value.excludes-max;
    }
    method !minmax-range-check(\value,\mi,\exmi,\ma,\exma --> Nil) {
        nqp::stmts(
          nqp::if(
            ((value.min cmp mi) < 0),
            nqp::stmts(
              (mi   = value.min),
              (exmi = value.excludes-min)
            )
          ),
          nqp::if(
            ((value.max cmp ma) > 0),
            nqp::stmts(
              (ma   = value.max),
              (exma = value.excludes-max)
            )
          )
        )
    }
    method !cmp-minmax-range-check(\value,$cmp,\mi,\exmi,\ma,\exma --> Nil) {
        nqp::stmts(                     # $cmp sigillless confuses the optimizer
          nqp::if(
            ($cmp(value.min,mi) < 0),
            nqp::stmts(
              (mi   = value.min),
              (exmi = value.excludes-min)
            )
          ),
          nqp::if(
            ($cmp(value.max,ma) > 0),
            nqp::stmts(
              (ma   = value.max),
              (exma = value.excludes-max)
            )
          )
        )
    }

    proto method minmax (|) is nodal { * }
    multi method minmax() {
        nqp::stmts(
          nqp::if(
            (my $iter := self!iterator-and-first(".minmax",my $pulled)),
            nqp::stmts(
              nqp::if(
                nqp::istype($pulled,Range),
                self!minmax-range-init($pulled,
                  my $min,my int $excludes-min,my $max,my int $excludes-max),
                nqp::if(
                  nqp::istype($pulled,Positional),
                  self!minmax-range-init($pulled.minmax, # recurse for min/max
                    $min,$excludes-min,$max,$excludes-max),
                  ($min = $max = $pulled)
                )
              ),
              nqp::until(
                nqp::eqaddr(($pulled := $iter.pull-one),IterationEnd),
                nqp::if(
                  nqp::isconcrete($pulled),
                  nqp::if(
                    nqp::istype($pulled,Range),
                    self!minmax-range-check($pulled,
                       $min,$excludes-min,$max,$excludes-max),
                    nqp::if(
                      nqp::istype($pulled,Positional),
                      self!minmax-range-check($pulled.minmax,
                         $min,$excludes-min,$max,$excludes-max),
                      nqp::if(
                        (($pulled cmp $min) < 0),
                        ($min = $pulled),
                        nqp::if(
                          (($pulled cmp $max) > 0),
                          ($max = $pulled)
                        )
                      )
                    )
                  )
                )
              )
            )
          ),
          nqp::if(
            nqp::defined($min),
            Range.new($min,$max,:$excludes-min,:$excludes-max),
            Range.new(Inf,-Inf)
          )
        )
    }
    multi method minmax(&by) {
        nqp::stmts(
          nqp::if(
            (my $iter := self!iterator-and-first(".minmax",my $pulled)),
            nqp::stmts(
              (my $cmp = nqp::if(
                nqp::iseq_i(&by.arity,2),&by,{ &by($^a) cmp &by($^b) })
              ),
              nqp::if(
                nqp::istype($pulled,Range),
                self!minmax-range-init($pulled,
                  my $min,my int $excludes-min,my $max,my int $excludes-max),
                nqp::if(
                  nqp::istype($pulled,Positional),
                  self!minmax-range-init($pulled.minmax(&by), # recurse min/max
                    $min,$excludes-min,$max,$excludes-max),
                  ($min = $max = $pulled)
                )
              ),
              nqp::until(
                nqp::eqaddr(($pulled := $iter.pull-one),IterationEnd),
                nqp::if(
                  nqp::isconcrete($pulled),
                  nqp::if(
                    nqp::istype($pulled,Range),
                    self!cmp-minmax-range-check($pulled,
                       $cmp,$min,$excludes-min,$max,$excludes-max),
                    nqp::if(
                      nqp::istype($pulled,Positional),
                      self!cmp-minmax-range-check($pulled.minmax(&by),
                         $cmp,$min,$excludes-min,$max,$excludes-max),
                      nqp::if(
                        ($cmp($pulled,$min) < 0),
                        ($min = $pulled),
                        nqp::if(
                          ($cmp($pulled,$max) > 0),
                          ($max = $pulled)
                        )
                      )
                    )
                  )
                )
              )
            )
          ),
          nqp::if(
            nqp::defined($min),
            Range.new($min,$max,:$excludes-min,:$excludes-max),
            Range.new(Inf,-Inf)
          )
        )
    }

    proto method sort(|) is nodal { * }
    multi method sort() {
        nqp::if(
          nqp::eqaddr(
            self.iterator.push-until-lazy(my $list := IterationBuffer.new),
            IterationEnd
          ),
          Seq.new(
            Rakudo::Iterator.ReifiedList(
              Rakudo::Sorting.MERGESORT-REIFIED-LIST(
                nqp::p6bindattrinvres(nqp::create(List),List,'$!reified',$list)
              )
            )
          ),
          X::Cannot::Lazy.new(:action<sort>).throw
        )
    }
    multi method sort(&by) {
        nqp::stmts(
          nqp::unless(
            nqp::eqaddr(
              self.iterator.push-until-lazy(my $list := IterationBuffer.new),
              IterationEnd
            ),
            X::Cannot::Lazy.new(:action<sort>).throw
          ),
          Seq.new(
            Rakudo::Iterator.ReifiedList(
              nqp::if(
                nqp::eqaddr(&by,&infix:<cmp>),
                Rakudo::Sorting.MERGESORT-REIFIED-LIST(
                  nqp::p6bindattrinvres(
                    nqp::create(List),List,'$!reified',$list)
                ),
                nqp::if(
                  &by.count < 2,
                  Rakudo::Sorting.MERGESORT-REIFIED-LIST-AS(
                    nqp::p6bindattrinvres(
                      nqp::create(List),List,'$!reified',$list),
                    &by
                  ),
                  Rakudo::Sorting.MERGESORT-REIFIED-LIST-WITH(
                    nqp::p6bindattrinvres(
                      nqp::create(List),List,'$!reified',$list),
                    &by
                  )
                )
              )
            )
          )
        )
    }

    method collate {
        self.sort(&[coll]);
    }
    sub find-reducer-for-op(&op) {
        nqp::if(
          nqp::iseq_s(&op.prec("prec"),"f="),
          &METAOP_REDUCE_LISTINFIX,
          nqp::if(
            nqp::iseq_i(nqp::chars(my str $assoc = &op.prec("assoc")),0),
            &METAOP_REDUCE_LEFT,
            ::(nqp::concat('&METAOP_REDUCE_',nqp::uc($assoc)))
          )
        )
    }

    proto method reduce(|) { * }
    multi method reduce(&with) is nodal {
        return unless self.DEFINITE;
        my $reducer := find-reducer-for-op(&with);
        $reducer(&with)(self) if $reducer;
    }

    proto method produce(|) { * }
    multi method produce(&with) is nodal {
        return unless self.DEFINITE;
        my $reducer := find-reducer-for-op(&with);
        $reducer(&with,1)(self) if $reducer;
    }

    proto method unique(|) is nodal {*}
    multi method unique() {
        Seq.new(class :: does Iterator {
            has $!iter;
            has $!seen;
            method !SET-SELF(\list) {
                nqp::stmts(
                  ($!iter := list.iterator),
                  ($!seen := nqp::hash),
                  self
                )
            }
            method new(\list) { nqp::create(self)!SET-SELF(list) }
            method pull-one() is raw {
                nqp::stmts(
                  nqp::until(
                    nqp::eqaddr((my $pulled := $!iter.pull-one),IterationEnd)
                      || (nqp::not_i(nqp::existskey(
                        $!seen,
                        (my $needle := $pulled.WHICH)
                      )) && nqp::bindkey($!seen,$needle,1)),
                    nqp::null
                  ),
                  $pulled
                )
            }
            method push-all($target --> IterationEnd) {
                nqp::until(
                  nqp::eqaddr((my $pulled := $!iter.pull-one),IterationEnd),
                  nqp::unless(
                    nqp::existskey($!seen,(my $needle := $pulled.WHICH)),
                    nqp::stmts(
                      nqp::bindkey($!seen,$needle,1),
                      $target.push($pulled)
                    )
                  )
                )
            }
            method is-lazy() { $!iter.is-lazy }
            method sink-all(--> IterationEnd) { $!iter.sink-all }
        }.new(self))
    }
    multi method unique( :&as!, :&with! ) {
        nqp::if(
          nqp::eqaddr(&with,&[===]), # use optimized version
          self.unique(:&as),
          Seq.new(
            Rakudo::Iterator.UniqueRepeatedAsWith(self.iterator,&as,&with,1)
          )
        )
    }
    multi method unique( :&as! ) {
        Seq.new(class :: does Iterator {
            has Mu $!iter;
            has &!as;
            has $!seen;
            method !SET-SELF(\list, &!as) {
                $!iter  = list.iterator;
                $!seen := nqp::hash();
                self
            }
            method new(\list, &as) { nqp::create(self)!SET-SELF(list, &as) }
            method pull-one() is raw {
                nqp::stmts(
                  nqp::until(
                    nqp::eqaddr((my $value := $!iter.pull-one),IterationEnd),
                    nqp::unless(
                      nqp::existskey($!seen,my $needle := &!as($value).WHICH),
                      nqp::stmts(
                        nqp::bindkey($!seen,$needle,1),
                        return-rw $value
                      )
                    )
                  ),
                  IterationEnd
                )
            }
            method push-all($target --> IterationEnd) {
                nqp::until(
                  nqp::eqaddr((my $value := $!iter.pull-one),IterationEnd),
                  nqp::unless(
                    nqp::existskey($!seen,my $needle := &!as($value).WHICH),
                    nqp::stmts(  # doesn't sink
                      nqp::bindkey($!seen,$needle,1),
                      $target.push($value)
                    )
                  )
                )
            }
        }.new(self, &as))
    }
    multi method unique( :&with! ) {
        nqp::if(
          nqp::eqaddr(&with,&[===]), # use optimized version
          self.unique,
          Seq.new(Rakudo::Iterator.UniqueRepeatedWith(self.iterator,&with,1))
        )
    }

    proto method repeated(|) is nodal {*}
    multi method repeated() {
        Seq.new(class :: does Iterator {
            has Mu $!iter;
            has $!seen;
            method !SET-SELF(\list) {
                $!iter = list.iterator;
                $!seen := nqp::hash();
                self
            }
            method new(\list) { nqp::create(self)!SET-SELF(list) }
            method pull-one() is raw {
                my Mu $value;
                my str $needle;
                nqp::until(
                  nqp::eqaddr(($value := $!iter.pull-one),IterationEnd),
                  nqp::existskey($!seen,$needle = nqp::unbox_s($value.WHICH))
                    ?? return-rw $value
                    !! nqp::bindkey($!seen, $needle, 1)
                );
                IterationEnd
            }
            method push-all($target --> IterationEnd) {
                my Mu $value;
                my str $needle;
                nqp::until( # doesn't sink
                  nqp::eqaddr(($value := $!iter.pull-one),IterationEnd),
                  nqp::existskey($!seen,$needle = nqp::unbox_s($value.WHICH))
                    ?? $target.push($value)
                    !! nqp::bindkey($!seen, $needle, 1)
                );
            }
            method is-lazy() { $!iter.is-lazy }
        }.new(self))
    }
    multi method repeated( :&as!, :&with! ) {
        nqp::if(
          nqp::eqaddr(&with,&[===]), # use optimized version
          self.repeated(:&as),
          Seq.new(
            Rakudo::Iterator.UniqueRepeatedAsWith(self.iterator,&as,&with,0)
          )
        )
    }
    multi method repeated( :&as! ) {
        Seq.new(class :: does Iterator {
            has Mu $!iter;
            has &!as;
            has $!seen;
            method !SET-SELF(\list, &!as) {
                $!iter  = list.iterator;
                $!seen := nqp::hash();
                self
            }
            method new(\list, &as) { nqp::create(self)!SET-SELF(list, &as) }
            method pull-one() is raw {
                my Mu $value;
                my str $needle;
                nqp::until(
                  nqp::eqaddr(($value := $!iter.pull-one),IterationEnd),
                  nqp::existskey($!seen,$needle = nqp::unbox_s(&!as($value).WHICH))
                    ?? return-rw $value
                    !! nqp::bindkey($!seen, $needle, 1)
                );
                IterationEnd
            }
            method push-all($target --> IterationEnd) {
                my Mu $value;
                my str $needle;
                nqp::until(  # doesn't sink
                  nqp::eqaddr(($value := $!iter.pull-one),IterationEnd),
                  nqp::existskey($!seen,$needle = nqp::unbox_s(&!as($value).WHICH))
                    ?? $target.push($value)
                    !! nqp::bindkey($!seen, $needle, 1)
                );
            }
            method is-lazy() { $!iter.is-lazy }
        }.new(self, &as))
    }
    multi method repeated( :&with! ) {
        nqp::if(
          nqp::eqaddr(&with,&[===]), # use optimized version
          self.repeated,
          Seq.new(Rakudo::Iterator.UniqueRepeatedWith(self.iterator,&with,0))
        )
    }

    proto method squish(|) is nodal {*}
    multi method squish( :&as!, :&with = &[===] ) {
        Seq.new(class :: does Iterator {
            has Mu $!iter;
            has &!as;
            has &!with;
            has $!last_as;
            has int $!first;
            method !SET-SELF(\list, &!as, &!with) {
                $!iter  = list.iterator;
                $!first = 1;
                self
            }
            method new(\list, &as, &with) {
                nqp::create(self)!SET-SELF(list, &as, &with)
            }
            method pull-one() is raw {
                my Mu $value := $!iter.pull-one;
                unless nqp::eqaddr($value,IterationEnd) {
                    my $which := &!as($value);
                    if $!first {
                        $!first = 0;
                    }
                    else {
                        until !with($!last_as, $which) or ($value := $!iter.pull-one) =:= IterationEnd {
                            $!last_as = $which;
                            $which := &!as($value);
                        }
                    }
                    $!last_as = $which;
                }
                $value;
            }
            method push-all($target --> IterationEnd) {
                my Mu $value := $!iter.pull-one;
                unless nqp::eqaddr($value,IterationEnd) {
                    my $which;
                    my $last_as := $!last_as;
                    nqp::if(
                      $!first,
                      nqp::stmts(  # doesn't sink
                        ($target.push($value)),
                        ($which := &!as($value)),
                        ($last_as := $which),
                        ($value := $!iter.pull-one)
                      )
                    );
                    nqp::until(
                      nqp::eqaddr($value,IterationEnd),
                      nqp::stmts(
                        nqp::unless(  # doesn't sink
                          with($last_as,$which := &!as($value)),
                          $target.push($value)
                        ),
                        ($last_as := $which),
                        ($value := $!iter.pull-one)
                      )
                    );
                }
            }
            method is-lazy() { $!iter.is-lazy }
        }.new(self, &as, &with))
    }
    multi method squish( :&with = &[===] ) {
        Seq.new(class :: does Iterator {
            has Mu $!iter;
            has &!with;
            has Mu $!last;
            has int $!first;
            method !SET-SELF(\list, &!with) {
                $!iter  = list.iterator;
                $!first = 1;
                self
            }
            method new(\list, &with) { nqp::create(self)!SET-SELF(list, &with) }
            method pull-one() is raw {
                my Mu $value := $!iter.pull-one;
                unless nqp::eqaddr($value,IterationEnd) {
                    if $!first {
                        $!first = 0;
                    }
                    else {
                        my $ov = $value;
                        until !with($!last, $value)
                           or ($value := $!iter.pull-one) =:= IterationEnd {
                            $!last = $ov;
                            $ov = $value;
                        }
                    }
                    $!last = $value
                }
                $value;
            }
            method push-all($target --> IterationEnd) {
                my Mu $value := $!iter.pull-one;
                unless nqp::eqaddr($value,IterationEnd) {
                    my $last_val = $!last;
                    nqp::if(
                      $!first,
                      nqp::stmts(  # doesn't sink
                        ($target.push($value)),
                        ($last_val := $value),
                        ($value := $!iter.pull-one)
                      )
                    );
                    nqp::until(
                      nqp::eqaddr($value,IterationEnd),
                      nqp::stmts(
                        nqp::unless(  # doesn't sink
                          with($last_val, $value),
                          $target.push($value)
                        ),
                        ($last_val := $value),
                        ($value := $!iter.pull-one)
                      )
                    );
                }
            }
            method is-lazy() { $!iter.is-lazy }
        }.new(self, &with))
    }

    proto method pairup(|) is nodal { * }
    multi method pairup(Any:U:) { () }
    multi method pairup(Any:D:) {
        my \iter := self.iterator;
        gather {
            nqp::until(
              nqp::eqaddr((my $pulled := iter.pull-one),IterationEnd),
              nqp::if(
                nqp::istype($pulled,Pair),
                (take nqp::p6bindattrinvres(
                  nqp::clone($pulled),
                  Pair,
                  '$!value',
                  nqp::clone(nqp::decont(nqp::getattr($pulled,Pair,'$!value')))
                )),
                nqp::if(
                  nqp::istype($pulled,Map) && nqp::not_i(nqp::iscont($pulled)),
                  (take Slip.from-iterator($pulled.iterator)),
                  nqp::if(
                    nqp::eqaddr((my $value := iter.pull-one),IterationEnd),
                    X::Pairup::OddNumber.new.throw,
                    take Pair.new($pulled,$value)
                  )
                )
              )
            )
        }
    }

    proto method head(|) { * }
    multi method head(Any:D:) is raw {
        nqp::if(
          nqp::eqaddr((my $pulled := self.iterator.pull-one),IterationEnd),
          Nil,
          $pulled
        )
    }
    multi method head(Any:D: Callable:D $w) {
        Seq.new(
           Rakudo::Iterator.AllButLastNValues(self.iterator,-($w(0).Int))
        )
    }
    multi method head(Any:D: $n) {
        Seq.new(Rakudo::Iterator.NextNValues(self.iterator,$n))
    }

    proto method tail(|) { * }
    multi method tail(Any:D:) is raw {
        nqp::if(
          nqp::eqaddr((my $pulled :=
            Rakudo::Iterator.LastValue(self.iterator,'tail')),
            IterationEnd
          ),
          Nil,
          $pulled
        )
    }
    multi method tail(Any:D: $n) {
        Seq.new(
          nqp::if(
            nqp::istype($n,Callable)
              && nqp::isgt_i((my $skip := -($n(0).Int)),0),
            nqp::stmts(
              (my $iterator := self.iterator).skip-at-least($skip),
              $iterator
            ),
            Rakudo::Iterator.LastNValues(self.iterator,$n,'tail')
          )
        )
    }

    proto method minpairs(|) { * }
    multi method minpairs(Any:D:) {
        my @found;
        for self.pairs {
            my $value := .value;
            state $min = $value;
            nqp::if(
                nqp::iseq_i( (my $cmp := $value cmp $min), -1 ),
                nqp::stmts((@found = $_), ($min = $value)),
                nqp::if(
                    nqp::iseq_i($cmp, 0),
                    @found.push($_)
                )
            )
        }
        Seq.new(@found.iterator)
    }

    proto method maxpairs(|) { * }
    multi method maxpairs(Any:D:) {
        my @found;
        for self.pairs {
            my $value := .value;
            state $max = $value;
            nqp::if(
                nqp::iseq_i( (my $cmp := $value cmp $max), 1 ),
                nqp::stmts((@found = $_), ($max = $value)),
                nqp::if(
                    nqp::iseq_i($cmp, 0),
                    @found.push($_)
                )
            )
        }
        Seq.new(@found.iterator)
    }

    proto method batch(|) is nodal { * }
    multi method batch(Any:D: Int:D :$elems!) {
        Seq.new(Rakudo::Iterator.Batch(self.iterator,$elems,1))
    }
    multi method batch(Any:D: Int:D $batch) {
        Seq.new(Rakudo::Iterator.Batch(self.iterator,$batch,1))
    }

    proto method rotor(|) is nodal { * }
    multi method rotor(Any:D: Int:D $batch, :$partial) {
        Seq.new(Rakudo::Iterator.Batch(self.iterator,$batch,$partial))
    }
    multi method rotor(Any:D: *@cycle, :$partial) {
        Seq.new(Rakudo::Iterator.Rotor(self.iterator,@cycle,$partial))
    }

    proto method skip(|) { * }
    multi method skip()         { Seq.new(self.iterator).skip }
    multi method skip(Int() $n) { Seq.new(self.iterator).skip($n) }
}

BEGIN Attribute.^compose;

proto sub infix:<min>(|) is pure { * }
multi sub infix:<min>(Mu:D \a, Mu:U) { a }
multi sub infix:<min>(Mu:U, Mu:D \b) { b }
multi sub infix:<min>(Mu:D \a, Mu:D \b) { (a cmp b) < 0 ?? a !! b }
multi sub infix:<min>(Int:D \a, Int:D \b) { nqp::if(nqp::islt_i(nqp::cmp_I(nqp::decont(a), nqp::decont(b)), 0), a, b) }
multi sub infix:<min>(int   \a, int   \b) { nqp::if(nqp::islt_i(nqp::cmp_i(a, b), 0), a, b) }
multi sub infix:<min>(Num:D \a, Num:D \b) { nqp::if(nqp::islt_i(nqp::cmp_n(a, b), 0), a, b) }
multi sub infix:<min>(num   \a, num   \b) { nqp::if(nqp::islt_i(nqp::cmp_n(a, b), 0), a, b) }
multi sub infix:<min>(+args is raw) { args.min }
sub min(+args, :&by = &infix:<cmp>) { args.min(&by) }

proto sub infix:<max>(|) is pure { * }
multi sub infix:<max>(Mu:D \a, Mu:U) { a }
multi sub infix:<max>(Mu:U, Mu:D \b) { b }
multi sub infix:<max>(Mu:D \a, Mu:D \b) { (a cmp b) > 0 ?? a !! b }
multi sub infix:<max>(Int:D \a, Int:D \b) { nqp::if(nqp::isgt_i(nqp::cmp_I(nqp::decont(a), nqp::decont(b)), 0), a, b) }
multi sub infix:<max>(int   \a, int   \b) { nqp::if(nqp::isgt_i(nqp::cmp_i(a, b), 0), a, b) }
multi sub infix:<max>(Num:D \a, Num:D \b) { nqp::if(nqp::isgt_i(nqp::cmp_n(a, b), 0), a, b) }
multi sub infix:<max>(num   \a, num   \b) { nqp::if(nqp::isgt_i(nqp::cmp_n(a, b), 0), a, b) }
multi sub infix:<max>(+args) { args.max }
sub max(+args, :&by = &infix:<cmp>) { args.max(&by) }

proto sub infix:<minmax>(|) is pure { * }
multi sub infix:<minmax>(+args) { args.minmax }
sub minmax(+args, :&by = &infix:<cmp>) { args.minmax(&by) }

proto sub map(|) {*}
multi sub map(&code, +values) { my $laze = values.is-lazy; values.map(&code).lazy-if($laze) }

proto sub grep(|) {*}
multi sub grep(Mu $test, +values, *%a) {
    my $laze = values.is-lazy;
    values.grep($test,|%a).lazy-if($laze)
}
multi sub grep(Bool:D $t, |) { X::Match::Bool.new(:type<grep>).throw }

proto sub first(|) {*}
multi sub first(Bool:D $t, |) { Failure.new(X::Match::Bool.new(:type<first>)) }
multi sub first(Mu $test, +values, *%a) { values.first($test,|%a) }

proto sub join(|) { * }
multi sub join($sep = '', *@values) { @values.join($sep) }

proto sub reduce (|) { * }
multi sub reduce (&with, +list)  { list.reduce(&with) }

proto sub produce (|) { * }
multi sub produce (&with, +list)  { list.produce(&with) }

proto sub unique(|) { * }
multi sub unique(+values, |c) { my $laze = values.is-lazy; values.unique(|c).lazy-if($laze) }

proto sub squish(|) { * }
multi sub squish(+values, |c) { my $laze = values.is-lazy; values.squish(|c).lazy-if($laze) }

proto sub repeated(|) { * }
multi sub repeated(+values, |c) { my $laze = values.is-lazy; values.repeated(|c).lazy-if($laze) }

proto sub sort(|) {*}
multi sub sort(&by, @values) { @values.sort(&by) }
multi sub sort(&by, +values) { values.sort(&by) }
multi sub sort(@values)      { @values.sort }
multi sub sort(+values)      { values.sort }

#line 1 SETTING::src/core/SLICE.pm
#===============================================================================
#
# This file has been generated by tools/build/makeSLICE.pl6
# on 2016-08-08T14:40:48.554014Z.
#
# Please do *NOT* make changes to this file, as they will be lost
# whenever this file is generated again.
#
#===============================================================================

# internal 1 element list access with adverbs
sub SLICE_ONE_LIST(\SELF,$one,$key,$value,%adv) {
    my Mu $d := nqp::clone(nqp::getattr(%adv,Map,'$!storage'));
    nqp::bindkey($d,nqp::unbox_s($key),nqp::decont($value));

    sub HANDLED($key) {
        nqp::if(
          nqp::existskey($d,nqp::unbox_s($key)),
          nqp::stmts(
            (my $value := nqp::atkey($d,$key)),
            nqp::deletekey($d,$key),
            $value
          ),
          Nil
        )
    }

    my @nogo;
    my \result = do {

        if HANDLED('delete') {            # :delete:*
            if nqp::elems($d) == 0 {          # :delete
                SELF.DELETE-POS($one);
            }
            elsif nqp::existskey($d,'exists') { # :delete:exists(0|1):*
                my $exists   := HANDLED('exists');
                my $wasthere := SELF.EXISTS-POS($one);
                SELF.DELETE-POS($one);
                if nqp::elems($d) == 0 {          # :delete:exists(0|1)
                    !( $wasthere ?^ $exists )
                }
                elsif nqp::existskey($d,'kv') {   # :delete:exists(0|1):kv(0|1)
                    my $kv := HANDLED('kv');
                    if nqp::elems($d) == 0 {
                        !$kv || $wasthere
                          ?? ( $one, !( $wasthere ?^ $exists ) )
                          !! ();
                    }
                    else {
                        @nogo = <delete exists kv>;
                    }
                }
                elsif nqp::existskey($d,'p') {    # :delete:exists(0|1):p(0|1)
                    my $p := HANDLED('p');
                    if nqp::elems($d) == 0 {
                        !$p || $wasthere
                          ?? Pair.new($one, !($wasthere ?^ $exists) )
                          !! ();
                    }
                    else {
                        @nogo = <delete exists p>;
                    }
                }
                else {
                    @nogo = <delete exists>;
                }
            }
            elsif nqp::existskey($d,'kv') {    # :delete:kv(0|1)
                my $kv := HANDLED('kv');
                if nqp::elems($d) == 0 {
                    !$kv || SELF.EXISTS-POS($one)
                      ?? ( $one, SELF.DELETE-POS($one) )
                      !! ();
                }
                else {
                    @nogo = <delete kv>;
                }
            }
            elsif nqp::existskey($d,'p') {     # :delete:p(0|1)
                my $p := HANDLED('p');
                if nqp::elems($d) == 0 {
                    !$p || SELF.EXISTS-POS($one)
                      ?? Pair.new($one, SELF.DELETE-POS($one))
                      !! ();
                }
                else {
                    @nogo = <delete p>;
                }
            }
            elsif nqp::existskey($d,'k') {     # :delete:k(0|1)
                my $k := HANDLED('k');
                if nqp::elems($d) == 0 {
                    !$k || SELF.EXISTS-POS($one)
                      ?? do { SELF.DELETE-POS($one); $one }
                      !! ();
                }
                else {
                    @nogo = <delete k>;
                }
            }
            elsif nqp::existskey($d,'v') {     # :delete:v(0|1)
                my $v := HANDLED('v');
                if nqp::elems($d) == 0 {
                    !$v || SELF.EXISTS-POS($one)
                      ?? SELF.DELETE-POS($one)
                      !! ();
                }
                else {
                    @nogo = <delete v>;
                }
            }
            else {
                @nogo = <delete>;
            }
        }
        elsif nqp::existskey($d,'exists') {  # :!delete?:exists(0|1):*
            my $exists  := HANDLED('exists');
            my $wasthere = SELF.EXISTS-POS($one);
            if nqp::elems($d) == 0 {           # :!delete?:exists(0|1)
                !( $wasthere ?^ $exists )
            }
            elsif nqp::existskey($d,'kv') {    # :!delete?:exists(0|1):kv(0|1)
                my $kv := HANDLED('kv');
                if nqp::elems($d) == 0 {
                    !$kv || $wasthere
                      ?? ( $one, !( $wasthere ?^ $exists ) )
                      !! ();
                }
                else {
                    @nogo = <exists kv>;
                }
            }
            elsif nqp::existskey($d,'p') {     # :!delete?:exists(0|1):p(0|1)
                my $p := HANDLED('p');
                if nqp::elems($d) == 0 {
                    !$p || $wasthere
                      ?? Pair.new($one, !( $wasthere ?^ $exists ))
                      !! ();
                }
                else {
                    @nogo = <exists p>;
                }
            }
            else {
                @nogo = <exists>;
            }
        }
        elsif nqp::existskey($d,'kv') {      # :!delete?:kv(0|1):*
            my $kv := HANDLED('kv');
            if nqp::elems($d) == 0 {           # :!delete?:kv(0|1)
                !$kv || SELF.EXISTS-POS($one)
                  ?? ($one, SELF.AT-POS($one))
                  !! ();
            }
            else {
                @nogo = <kv>;
            }
        }
        elsif nqp::existskey($d,'p') {       # :!delete?:p(0|1):*
            my $p := HANDLED('p');
            if nqp::elems($d) == 0 {           # :!delete?:p(0|1)
                !$p || SELF.EXISTS-POS($one)
                  ?? Pair.new($one, SELF.AT-POS($one))
                  !! ();
            }
            else {
                @nogo = <p>;
            }
        }
        elsif nqp::existskey($d,'k') {       # :!delete?:k(0|1):*
            my $k := HANDLED('k');
            if nqp::elems($d) == 0 {           # :!delete?:k(0|1)
                !$k || SELF.EXISTS-POS($one)
                  ?? $one
                  !! ();
            }
            else {
                @nogo = <k>;
            }
        }
        elsif nqp::existskey($d,'v') {       # :!delete?:v(0|1):*
            my $v := HANDLED('v');             # :!delete?:v(0|1)
            if nqp::elems($d) == 0 {
                !$v || SELF.EXISTS-POS($one)
                  ?? SELF.AT-POS($one)
                  !! ();
            }
            else {
                @nogo = <v>;
            }
        }
        elsif nqp::elems($d) == 0 {           # :!delete
            SELF.AT-POS($one);
        }
    }

    @nogo || nqp::elems($d)
      ?? SLICE_HUH( SELF, @nogo, $d, %adv )
      !! result;
} #SLICE_ONE_LIST

# internal >1 element list access with adverbs
sub SLICE_MORE_LIST(\SELF,$more,$key,$value,%adv) {
    my Mu $d := nqp::clone(nqp::getattr(%adv,Map,'$!storage'));
    nqp::bindkey($d,nqp::unbox_s($key),nqp::decont($value));

    sub HANDLED($key) {
        nqp::if(
          nqp::existskey($d,nqp::unbox_s($key)),
          nqp::stmts(
            (my $value := nqp::atkey($d,$key)),
            nqp::deletekey($d,$key),
            $value
          ),
          Nil
        )
    }

    my @nogo;
    my \result = do {

        if HANDLED('delete') {            # :delete:*
            if nqp::elems($d) == 0 {          # :delete
                $more.cache.flatmap( { SELF.DELETE-POS($_) } ).eager.list;
            }
            elsif nqp::existskey($d,'exists') { # :delete:exists(0|1):*
                my $exists := HANDLED('exists');
                my $wasthere; # no need to initialize every iteration of map
                if nqp::elems($d) == 0 {          # :delete:exists(0|1)
                    $more.cache.flatmap( {
                        SELF.DELETE-POS($_) if $wasthere = SELF.EXISTS-POS($_);
                        !( $wasthere ?^ $exists );
                    } ).eager.list;
                }
                elsif nqp::existskey($d,'kv') { # :delete:exists(0|1):kv(0|1):*
                    my $kv := HANDLED('kv');
                    if nqp::elems($d) == 0 {      # :delete:exists(0|1):kv(0|1)
                        $more.cache.flatmap( {
                            SELF.DELETE-POS($_) if $wasthere = SELF.EXISTS-POS($_);
                            next unless !$kv || $wasthere;
                            ($_, !( $wasthere ?^ $exists ));
                        } ).flat.eager.list;
                    }
                    else {
                        @nogo = <delete exists kv>;
                    }
                }
                elsif nqp::existskey($d,'p') {  # :delete:exists(0|1):p(0|1):*
                    my $p := HANDLED('p');
                    if nqp::elems($d) == 0 {      # :delete:exists(0|1):p(0|1)
                        $more.cache.flatmap( {
                            SELF.DELETE-POS($_) if $wasthere = SELF.EXISTS-POS($_);
                            next unless !$p || $wasthere;
                            Pair.new($_,!($wasthere ?^ $exists));
                        } ).eager.list;
                    }
                    else {
                        @nogo = <delete exists p>;
                    }
                }
                else {
                    @nogo = <delete exists>;
                }
            }
            elsif nqp::existskey($d,'kv') {     # :delete:kv(0|1):*
                my $kv := HANDLED('kv');
                if nqp::elems($d) == 0 {          # :delete:kv(0|1)
                    $kv
                      ?? $more.cache.flatmap( {
                             next unless SELF.EXISTS-POS($_);
                             ( $_, SELF.DELETE-POS($_) );
                         } ).flat.eager.list
                      !! $more.cache.flatmap( {
                             ( $_, SELF.DELETE-POS($_) )
                         } ).flat.eager.list;
                }
                else {
                    @nogo = <delete kv>;
                }
            }
            elsif nqp::existskey($d,'p') {      # :delete:p(0|1):*
                my $p := HANDLED('p');
                if nqp::elems($d) == 0 {          # :delete:p(0|1)
                    $p
                      ?? $more.cache.flatmap( {
                             next unless SELF.EXISTS-POS($_);
                             Pair.new($_, SELF.DELETE-POS($_));
                         } ).eager.list
                      !! $more.cache.flatmap( {
                             Pair.new($_, SELF.DELETE-POS($_))
                         } ).eager.list;
                }
                else {
                    @nogo = <delete p>;
                }
            }
            elsif nqp::existskey($d,'k') {     # :delete:k(0|1):*
                my $k := HANDLED('k');
                if nqp::elems($d) == 0 {          # :delete:k(0|1)
                    $k
                      ?? $more.cache.flatmap( {
                             nqp::if(
                               SELF.EXISTS-POS($_),
                               nqp::stmts(
                                 SELF.DELETE-POS($_),
                                 $_
                               ),
                               next
                             )
                         } ).eager.list
                      !! $more.cache.flatmap( {
                             SELF.DELETE-POS($_); $_
                         } ).eager.list;
                }
                else {
                    @nogo = <delete k>;
                }
            }
            elsif nqp::existskey($d,'v') {      # :delete:v(0|1):*
                my $v := HANDLED('v');
                if nqp::elems($d) == 0 {          # :delete:v(0|1)
                    $v
                      ?? $more.cache.flatmap( {
                             next unless SELF.EXISTS-POS($_);
                             SELF.DELETE-POS($_);
                     } ).eager.list
                      !! $more.cache.flatmap( {
                             SELF.DELETE-POS($_)
                     } ).eager.list;
                }
                else {
                    @nogo = <delete v>;
                }
            }
            else {
                @nogo = <delete>;
            }
        }
        elsif nqp::existskey($d,'exists') { # :!delete?:exists(0|1):*
            my $exists := HANDLED('exists');
            if nqp::elems($d) == 0 {          # :!delete?:exists(0|1)
                $more.cache.flatmap({ !( SELF.EXISTS-POS($_) ?^ $exists ) }).eager.list;
            }
            elsif nqp::existskey($d,'kv') {   # :!delete?:exists(0|1):kv(0|1):*
                my $kv := HANDLED('kv');
                if nqp::elems($d) == 0 {        # :!delete?:exists(0|1):kv(0|1)
                    $kv
                      ?? $more.cache.flatmap( {
                             next unless SELF.EXISTS-POS($_);
                             ( $_, $exists );
                         } ).flat.eager.list
                      !! $more.cache.flatmap( {
                             ( $_, !( SELF.EXISTS-POS($_) ?^ $exists ) )
                         } ).flat.eager.list;
                }
                else {
                    @nogo = <exists kv>;
                }
            }
            elsif nqp::existskey($d,'p') {  # :!delete?:exists(0|1):p(0|1):*
                my $p := HANDLED('p');
                if nqp::elems($d) == 0 {      # :!delete?:exists(0|1):p(0|1)
                    $p
                      ?? $more.cache.flatmap( {
                             next unless SELF.EXISTS-POS($_);
                             Pair.new( $_, $exists );
                         } ).eager.list
                      !! $more.cache.flatmap( {
                             Pair.new( $_, !( SELF.EXISTS-POS($_) ?^ $exists ) )
                         } ).eager.list;
                }
                else {
                    @nogo = <exists p>;
                }
            }
            else {
                @nogo = <exists>;
            }
        }
        elsif nqp::existskey($d,'kv') {     # :!delete?:kv(0|1):*
            my $kv := HANDLED('kv');
            if nqp::elems($d) == 0 {          # :!delete?:kv(0|1)
                $kv
                  ?? $more.cache.flatmap( {
                         next unless SELF.EXISTS-POS($_);
                         $_, SELF.AT-POS($_);
                     } ).flat.eager.list
                  !! $more.cache.flatmap( {
                         $_, SELF.AT-POS($_)
                     } ).flat.eager.list;
            }
            else {
                @nogo = <kv>;
            }
        }
        elsif nqp::existskey($d,'p') {      # :!delete?:p(0|1):*
            my $p := HANDLED('p');
            if nqp::elems($d) == 0 {          # :!delete?:p(0|1)
                $p
                  ?? $more.cache.flatmap( {
                         next unless SELF.EXISTS-POS($_);
                         Pair.new($_, SELF.AT-POS($_));
                     } ).eager.list
                  !! $more.cache.flatmap( {
                         Pair.new( $_, SELF.AT-POS($_) )
                     } ).eager.list;
            }
            else {
                @nogo = <p>
            }
        }
        elsif nqp::existskey($d,'k') {      # :!delete?:k(0|1):*
            my $k := HANDLED('k');
            if nqp::elems($d) == 0 {          # :!delete?:k(0|1)
                $k
                  ?? $more.cache.flatmap( {
                         next unless SELF.EXISTS-POS($_);
                         $_;
                     } ).eager.list
                  !! $more.cache.flat.eager.list;
            }
            else {
                @nogo = <k>;
            }
        }
        elsif nqp::existskey($d,'v') {      # :!delete?:v(0|1):*
            my $v := HANDLED('v');
            if nqp::elems($d) == 0 {          # :!delete?:v(0|1)
                $v
                  ??  $more.cache.flatmap( {
                          next unless SELF.EXISTS-POS($_);
                          SELF.AT-POS($_);
                      } ).eager.list
                  !!  $more.cache.flatmap( {
                          SELF.AT-POS($_)
                      } ).eager.list;
            }
            else {
                @nogo = <v>;
            }
        }
        elsif nqp::elems($d) == 0 {         # :!delete
            $more.cache.flatmap( { SELF.AT-POS($_) } ).eager.list;
        }
    }

    @nogo || nqp::elems($d)
      ?? SLICE_HUH( SELF, @nogo, $d, %adv )
      !! result;
} #SLICE_MORE_LIST


# internal 1 element hash access with adverbs
sub SLICE_ONE_HASH(\SELF,$one,$key,$value,%adv) {
    my Mu $d := nqp::clone(nqp::getattr(%adv,Map,'$!storage'));
    nqp::bindkey($d,nqp::unbox_s($key),nqp::decont($value));

    sub HANDLED($key) {
        nqp::if(
          nqp::existskey($d,nqp::unbox_s($key)),
          nqp::stmts(
            (my $value := nqp::atkey($d,$key)),
            nqp::deletekey($d,$key),
            $value
          ),
          Nil
        )
    }

    my @nogo;
    my \result = do {

        if HANDLED('delete') {            # :delete:*
            if nqp::elems($d) == 0 {          # :delete
                SELF.DELETE-KEY($one);
            }
            elsif nqp::existskey($d,'exists') { # :delete:exists(0|1):*
                my $exists   := HANDLED('exists');
                my $wasthere := SELF.EXISTS-KEY($one);
                SELF.DELETE-KEY($one);
                if nqp::elems($d) == 0 {          # :delete:exists(0|1)
                    !( $wasthere ?^ $exists )
                }
                elsif nqp::existskey($d,'kv') {   # :delete:exists(0|1):kv(0|1)
                    my $kv := HANDLED('kv');
                    if nqp::elems($d) == 0 {
                        !$kv || $wasthere
                          ?? ( $one, !( $wasthere ?^ $exists ) )
                          !! ();
                    }
                    else {
                        @nogo = <delete exists kv>;
                    }
                }
                elsif nqp::existskey($d,'p') {    # :delete:exists(0|1):p(0|1)
                    my $p := HANDLED('p');
                    if nqp::elems($d) == 0 {
                        !$p || $wasthere
                          ?? Pair.new($one, !($wasthere ?^ $exists) )
                          !! ();
                    }
                    else {
                        @nogo = <delete exists p>;
                    }
                }
                else {
                    @nogo = <delete exists>;
                }
            }
            elsif nqp::existskey($d,'kv') {    # :delete:kv(0|1)
                my $kv := HANDLED('kv');
                if nqp::elems($d) == 0 {
                    !$kv || SELF.EXISTS-KEY($one)
                      ?? ( $one, SELF.DELETE-KEY($one) )
                      !! ();
                }
                else {
                    @nogo = <delete kv>;
                }
            }
            elsif nqp::existskey($d,'p') {     # :delete:p(0|1)
                my $p := HANDLED('p');
                if nqp::elems($d) == 0 {
                    !$p || SELF.EXISTS-KEY($one)
                      ?? Pair.new($one, SELF.DELETE-KEY($one))
                      !! ();
                }
                else {
                    @nogo = <delete p>;
                }
            }
            elsif nqp::existskey($d,'k') {     # :delete:k(0|1)
                my $k := HANDLED('k');
                if nqp::elems($d) == 0 {
                    !$k || SELF.EXISTS-KEY($one)
                      ?? do { SELF.DELETE-KEY($one); $one }
                      !! ();
                }
                else {
                    @nogo = <delete k>;
                }
            }
            elsif nqp::existskey($d,'v') {     # :delete:v(0|1)
                my $v := HANDLED('v');
                if nqp::elems($d) == 0 {
                    !$v || SELF.EXISTS-KEY($one)
                      ?? SELF.DELETE-KEY($one)
                      !! ();
                }
                else {
                    @nogo = <delete v>;
                }
            }
            else {
                @nogo = <delete>;
            }
        }
        elsif nqp::existskey($d,'exists') {  # :!delete?:exists(0|1):*
            my $exists  := HANDLED('exists');
            my $wasthere = SELF.EXISTS-KEY($one);
            if nqp::elems($d) == 0 {           # :!delete?:exists(0|1)
                !( $wasthere ?^ $exists )
            }
            elsif nqp::existskey($d,'kv') {    # :!delete?:exists(0|1):kv(0|1)
                my $kv := HANDLED('kv');
                if nqp::elems($d) == 0 {
                    !$kv || $wasthere
                      ?? ( $one, !( $wasthere ?^ $exists ) )
                      !! ();
                }
                else {
                    @nogo = <exists kv>;
                }
            }
            elsif nqp::existskey($d,'p') {     # :!delete?:exists(0|1):p(0|1)
                my $p := HANDLED('p');
                if nqp::elems($d) == 0 {
                    !$p || $wasthere
                      ?? Pair.new($one, !( $wasthere ?^ $exists ))
                      !! ();
                }
                else {
                    @nogo = <exists p>;
                }
            }
            else {
                @nogo = <exists>;
            }
        }
        elsif nqp::existskey($d,'kv') {      # :!delete?:kv(0|1):*
            my $kv := HANDLED('kv');
            if nqp::elems($d) == 0 {           # :!delete?:kv(0|1)
                !$kv || SELF.EXISTS-KEY($one)
                  ?? ($one, SELF.AT-KEY($one))
                  !! ();
            }
            else {
                @nogo = <kv>;
            }
        }
        elsif nqp::existskey($d,'p') {       # :!delete?:p(0|1):*
            my $p := HANDLED('p');
            if nqp::elems($d) == 0 {           # :!delete?:p(0|1)
                !$p || SELF.EXISTS-KEY($one)
                  ?? Pair.new($one, SELF.AT-KEY($one))
                  !! ();
            }
            else {
                @nogo = <p>;
            }
        }
        elsif nqp::existskey($d,'k') {       # :!delete?:k(0|1):*
            my $k := HANDLED('k');
            if nqp::elems($d) == 0 {           # :!delete?:k(0|1)
                !$k || SELF.EXISTS-KEY($one)
                  ?? $one
                  !! ();
            }
            else {
                @nogo = <k>;
            }
        }
        elsif nqp::existskey($d,'v') {       # :!delete?:v(0|1):*
            my $v := HANDLED('v');             # :!delete?:v(0|1)
            if nqp::elems($d) == 0 {
                !$v || SELF.EXISTS-KEY($one)
                  ?? SELF.AT-KEY($one)
                  !! ();
            }
            else {
                @nogo = <v>;
            }
        }
        elsif nqp::elems($d) == 0 {           # :!delete
            SELF.AT-KEY($one);
        }
    }

    @nogo || nqp::elems($d)
      ?? SLICE_HUH( SELF, @nogo, $d, %adv )
      !! result;
} #SLICE_ONE_HASH

# internal >1 element hash access with adverbs
sub SLICE_MORE_HASH(\SELF,$more,$key,$value,%adv) {
    my Mu $d := nqp::clone(nqp::getattr(%adv,Map,'$!storage'));
    nqp::bindkey($d,nqp::unbox_s($key),nqp::decont($value));

    sub HANDLED($key) {
        nqp::if(
          nqp::existskey($d,nqp::unbox_s($key)),
          nqp::stmts(
            (my $value := nqp::atkey($d,$key)),
            nqp::deletekey($d,$key),
            $value
          ),
          Nil
        )
    }

    my @nogo;
    my \result = do {

        if HANDLED('delete') {            # :delete:*
            if nqp::elems($d) == 0 {          # :delete
                $more.cache.flatmap( { SELF.DELETE-KEY($_) } ).eager.list;
            }
            elsif nqp::existskey($d,'exists') { # :delete:exists(0|1):*
                my $exists := HANDLED('exists');
                my $wasthere; # no need to initialize every iteration of map
                if nqp::elems($d) == 0 {          # :delete:exists(0|1)
                    $more.cache.flatmap( {
                        SELF.DELETE-KEY($_) if $wasthere = SELF.EXISTS-KEY($_);
                        !( $wasthere ?^ $exists );
                    } ).eager.list;
                }
                elsif nqp::existskey($d,'kv') { # :delete:exists(0|1):kv(0|1):*
                    my $kv := HANDLED('kv');
                    if nqp::elems($d) == 0 {      # :delete:exists(0|1):kv(0|1)
                        $more.cache.flatmap( {
                            SELF.DELETE-KEY($_) if $wasthere = SELF.EXISTS-KEY($_);
                            next unless !$kv || $wasthere;
                            ($_, !( $wasthere ?^ $exists ));
                        } ).flat.eager.list;
                    }
                    else {
                        @nogo = <delete exists kv>;
                    }
                }
                elsif nqp::existskey($d,'p') {  # :delete:exists(0|1):p(0|1):*
                    my $p := HANDLED('p');
                    if nqp::elems($d) == 0 {      # :delete:exists(0|1):p(0|1)
                        $more.cache.flatmap( {
                            SELF.DELETE-KEY($_) if $wasthere = SELF.EXISTS-KEY($_);
                            next unless !$p || $wasthere;
                            Pair.new($_,!($wasthere ?^ $exists));
                        } ).eager.list;
                    }
                    else {
                        @nogo = <delete exists p>;
                    }
                }
                else {
                    @nogo = <delete exists>;
                }
            }
            elsif nqp::existskey($d,'kv') {     # :delete:kv(0|1):*
                my $kv := HANDLED('kv');
                if nqp::elems($d) == 0 {          # :delete:kv(0|1)
                    $kv
                      ?? $more.cache.flatmap( {
                             next unless SELF.EXISTS-KEY($_);
                             ( $_, SELF.DELETE-KEY($_) );
                         } ).flat.eager.list
                      !! $more.cache.flatmap( {
                             ( $_, SELF.DELETE-KEY($_) )
                         } ).flat.eager.list;
                }
                else {
                    @nogo = <delete kv>;
                }
            }
            elsif nqp::existskey($d,'p') {      # :delete:p(0|1):*
                my $p := HANDLED('p');
                if nqp::elems($d) == 0 {          # :delete:p(0|1)
                    $p
                      ?? $more.cache.flatmap( {
                             next unless SELF.EXISTS-KEY($_);
                             Pair.new($_, SELF.DELETE-KEY($_));
                         } ).eager.list
                      !! $more.cache.flatmap( {
                             Pair.new($_, SELF.DELETE-KEY($_))
                         } ).eager.list;
                }
                else {
                    @nogo = <delete p>;
                }
            }
            elsif nqp::existskey($d,'k') {     # :delete:k(0|1):*
                my $k := HANDLED('k');
                if nqp::elems($d) == 0 {          # :delete:k(0|1)
                    $k
                      ?? $more.cache.flatmap( {
                             nqp::if(
                               SELF.EXISTS-KEY($_),
                               nqp::stmts(
                                 SELF.DELETE-KEY($_),
                                 $_
                               ),
                               next
                             )
                         } ).eager.list
                      !! $more.cache.flatmap( {
                             SELF.DELETE-KEY($_); $_
                         } ).eager.list;
                }
                else {
                    @nogo = <delete k>;
                }
            }
            elsif nqp::existskey($d,'v') {      # :delete:v(0|1):*
                my $v := HANDLED('v');
                if nqp::elems($d) == 0 {          # :delete:v(0|1)
                    $v
                      ?? $more.cache.flatmap( {
                             next unless SELF.EXISTS-KEY($_);
                             SELF.DELETE-KEY($_);
                     } ).eager.list
                      !! $more.cache.flatmap( {
                             SELF.DELETE-KEY($_)
                     } ).eager.list;
                }
                else {
                    @nogo = <delete v>;
                }
            }
            else {
                @nogo = <delete>;
            }
        }
        elsif nqp::existskey($d,'exists') { # :!delete?:exists(0|1):*
            my $exists := HANDLED('exists');
            if nqp::elems($d) == 0 {          # :!delete?:exists(0|1)
                $more.cache.flatmap({ !( SELF.EXISTS-KEY($_) ?^ $exists ) }).eager.list;
            }
            elsif nqp::existskey($d,'kv') {   # :!delete?:exists(0|1):kv(0|1):*
                my $kv := HANDLED('kv');
                if nqp::elems($d) == 0 {        # :!delete?:exists(0|1):kv(0|1)
                    $kv
                      ?? $more.cache.flatmap( {
                             next unless SELF.EXISTS-KEY($_);
                             ( $_, $exists );
                         } ).flat.eager.list
                      !! $more.cache.flatmap( {
                             ( $_, !( SELF.EXISTS-KEY($_) ?^ $exists ) )
                         } ).flat.eager.list;
                }
                else {
                    @nogo = <exists kv>;
                }
            }
            elsif nqp::existskey($d,'p') {  # :!delete?:exists(0|1):p(0|1):*
                my $p := HANDLED('p');
                if nqp::elems($d) == 0 {      # :!delete?:exists(0|1):p(0|1)
                    $p
                      ?? $more.cache.flatmap( {
                             next unless SELF.EXISTS-KEY($_);
                             Pair.new( $_, $exists );
                         } ).eager.list
                      !! $more.cache.flatmap( {
                             Pair.new( $_, !( SELF.EXISTS-KEY($_) ?^ $exists ) )
                         } ).eager.list;
                }
                else {
                    @nogo = <exists p>;
                }
            }
            else {
                @nogo = <exists>;
            }
        }
        elsif nqp::existskey($d,'kv') {     # :!delete?:kv(0|1):*
            my $kv := HANDLED('kv');
            if nqp::elems($d) == 0 {          # :!delete?:kv(0|1)
                $kv
                  ?? $more.cache.flatmap( {
                         next unless SELF.EXISTS-KEY($_);
                         $_, SELF.AT-KEY($_);
                     } ).flat.eager.list
                  !! $more.cache.flatmap( {
                         $_, SELF.AT-KEY($_)
                     } ).flat.eager.list;
            }
            else {
                @nogo = <kv>;
            }
        }
        elsif nqp::existskey($d,'p') {      # :!delete?:p(0|1):*
            my $p := HANDLED('p');
            if nqp::elems($d) == 0 {          # :!delete?:p(0|1)
                $p
                  ?? $more.cache.flatmap( {
                         next unless SELF.EXISTS-KEY($_);
                         Pair.new($_, SELF.AT-KEY($_));
                     } ).eager.list
                  !! $more.cache.flatmap( {
                         Pair.new( $_, SELF.AT-KEY($_) )
                     } ).eager.list;
            }
            else {
                @nogo = <p>
            }
        }
        elsif nqp::existskey($d,'k') {      # :!delete?:k(0|1):*
            my $k := HANDLED('k');
            if nqp::elems($d) == 0 {          # :!delete?:k(0|1)
                $k
                  ?? $more.cache.flatmap( {
                         next unless SELF.EXISTS-KEY($_);
                         $_;
                     } ).eager.list
                  !! $more.cache.flat.eager.list;
            }
            else {
                @nogo = <k>;
            }
        }
        elsif nqp::existskey($d,'v') {      # :!delete?:v(0|1):*
            my $v := HANDLED('v');
            if nqp::elems($d) == 0 {          # :!delete?:v(0|1)
                $v
                  ??  $more.cache.flatmap( {
                          next unless SELF.EXISTS-KEY($_);
                          SELF.AT-KEY($_);
                      } ).eager.list
                  !!  $more.cache.flatmap( {
                          SELF.AT-KEY($_)
                      } ).eager.list;
            }
            else {
                @nogo = <v>;
            }
        }
        elsif nqp::elems($d) == 0 {         # :!delete
            $more.cache.flatmap( { SELF.AT-KEY($_) } ).eager.list;
        }
    }

    @nogo || nqp::elems($d)
      ?? SLICE_HUH( SELF, @nogo, $d, %adv )
      !! result;
} #SLICE_MORE_HASH


#line 1 SETTING::src/core/Whatever.pm
my class X::Cannot::Capture { ... }
my class X::Cannot::New     { ... }

my class Whatever {
    multi method ACCEPTS(Whatever:D: $ --> True) { }
    multi method perl(Whatever:D: --> '*') { }
    multi method Str(Whatever:D: --> '*') { }
    method Capture() { die X::Cannot::Capture.new: :what(self) }
}

my class HyperWhatever {
    multi method new(HyperWhatever:) { X::Cannot::New.new(class => self).throw }
    multi method ACCEPTS(HyperWhatever:D: $ --> True) { }
    multi method perl(HyperWhatever:D:) { '**' }
    method Capture() { die X::Cannot::Capture.new: :what(self) }
}

sub HYPERWHATEVER (&c) { sub (*@_) { map &c, @_ } }

#line 1 SETTING::src/core/hash_slice.pm
# all sub postcircumfix {} candidates here please

proto sub postcircumfix:<{ }>(|) is nodal { * }

# %h<key>
multi sub postcircumfix:<{ }>( \SELF, \key ) is raw {
    SELF.AT-KEY(key);
}
multi sub postcircumfix:<{ }>(\SELF, \key, Mu \ASSIGN) is raw {
    SELF.ASSIGN-KEY(key, ASSIGN);
}
multi sub postcircumfix:<{ }>(\SELF, \key, Mu :$BIND! is raw) is raw {
    SELF.BIND-KEY(key, $BIND);
}
multi sub postcircumfix:<{ }>( \SELF, \key, :$delete!, *%other ) is raw {
    nqp::if(
      $delete && nqp::not_i(nqp::elems(nqp::getattr(%other,Map,'$!storage'))),
      SELF.DELETE-KEY(key),
      SLICE_ONE_HASH( SELF, key, 'delete', $delete, %other )
    )
}
multi sub postcircumfix:<{ }>( \SELF, \key, :$exists!, *%other ) is raw {
    nqp::if(
      $exists && nqp::not_i(nqp::elems(nqp::getattr(%other,Map,'$!storage'))),
      SELF.EXISTS-KEY(key),
      SLICE_ONE_HASH( SELF, key, 'exists', $exists, %other )
    )
}
multi sub postcircumfix:<{ }>( \SELF, \key, :$kv!, *%other ) is raw {
    $kv && nqp::not_i(nqp::elems(nqp::getattr(%other,Map,'$!storage')))
      ?? (SELF.EXISTS-KEY(key) ?? (key,SELF.AT-KEY(key)) !! ())
      !! SLICE_ONE_HASH( SELF, key, 'kv', $kv, %other );
}
multi sub postcircumfix:<{ }>( \SELF, \key, :$p!, *%other ) is raw {
    $p && nqp::not_i(nqp::elems(nqp::getattr(%other,Map,'$!storage')))
      ?? (SELF.EXISTS-KEY(key) ?? Pair.new(key,SELF.AT-KEY(key)) !! ())
      !! SLICE_ONE_HASH( SELF, key, 'p', $p, %other );
}
multi sub postcircumfix:<{ }>( \SELF, \key, :$k!, *%other ) is raw {
    $k && nqp::not_i(nqp::elems(nqp::getattr(%other,Map,'$!storage')))
      ?? (SELF.EXISTS-KEY(key) ?? key !! ())
      !! SLICE_ONE_HASH( SELF, key, 'k', $k, %other );
}
multi sub postcircumfix:<{ }>( \SELF, \key, :$v!, *%other ) is raw {
    $v && nqp::not_i(nqp::elems(nqp::getattr(%other,Map,'$!storage')))
      ?? (SELF.EXISTS-KEY(key) ?? nqp::decont(SELF.AT-KEY(key)) !! ())
      !! SLICE_ONE_HASH( SELF, key, 'v', $v, %other );
}

# %h<a b c>
multi sub postcircumfix:<{ }>( \SELF, Iterable \key ) is raw {
    nqp::iscont(key)
      ?? SELF.AT-KEY(key)
      !! key.flatmap({ SELF{$_} }).eager.list;
}
multi sub postcircumfix:<{ }>(\SELF, Iterable \key, Mu \ASSIGN) is raw {
    nqp::iscont(key)
      ?? SELF.ASSIGN-KEY(key, ASSIGN)
      !! (key.flatmap({ SELF{$_} }).eager.list = ASSIGN)
}
multi sub postcircumfix:<{ }>(\SELF, Iterable \key, :$BIND!) is raw {
    X::Bind::Slice.new(type => SELF.WHAT).throw;
}
multi sub postcircumfix:<{ }>(\SELF,Iterable \key, :$delete!,*%other) is raw {
    nqp::iscont(key)
        ?? SLICE_ONE_HASH(  SELF, key, 'delete', $delete, %other )
        !! SLICE_MORE_HASH( SELF, key, 'delete', $delete, %other )
}
multi sub postcircumfix:<{ }>(\SELF,Iterable \key, :$exists!,*%other) is raw {
    nqp::iscont(key)
        ?? SLICE_ONE_HASH(  SELF, key, 'exists', $exists, %other )
        !! SLICE_MORE_HASH( SELF, key, 'exists', $exists, %other )
}
multi sub postcircumfix:<{ }>(\SELF, Iterable \key, :$kv!, *%other) is raw {
    nqp::iscont(key)
        ?? SLICE_ONE_HASH(  SELF, key, 'kv', $kv, %other )
        !! SLICE_MORE_HASH( SELF, key, 'kv', $kv, %other )
}
multi sub postcircumfix:<{ }>(\SELF, Iterable \key, :$p!, *%other) is raw {
    nqp::iscont(key)
        ?? SLICE_ONE_HASH(  SELF, key, 'p', $p, %other )
        !! SLICE_MORE_HASH( SELF, key, 'p', $p, %other )
}
multi sub postcircumfix:<{ }>(\SELF, Iterable \key, :$k!, *%other) is raw {
    nqp::iscont(key)
        ?? SLICE_ONE_HASH(  SELF, key, 'k', $k, %other )
        !! SLICE_MORE_HASH( SELF, key, 'k', $k, %other )
}
multi sub postcircumfix:<{ }>(\SELF, Iterable \key, :$v!, *%other) is raw {
    nqp::iscont(key)
        ?? SLICE_ONE_HASH(  SELF, key, 'v', $v, %other )
        !! SLICE_MORE_HASH( SELF, key, 'v', $v, %other )
}

# %h{*}
multi sub postcircumfix:<{ }>( \SELF, Whatever ) is raw {
    SELF{SELF.keys.list};
}
multi sub postcircumfix:<{ }>(\SELF, Whatever, Mu \ASSIGN) is raw {
    die "Cannot assign to *, as the order of keys is non-deterministic";
}
multi sub postcircumfix:<{ }>(\SELF, Whatever, :$BIND!) is raw {
    X::Bind::Slice.new(type => SELF.WHAT).throw;
}
multi sub postcircumfix:<{ }>(\SELF, Whatever, :$delete!, *%other) is raw {
    SLICE_MORE_HASH( SELF, SELF.keys.list, 'delete', $delete, %other );
}
multi sub postcircumfix:<{ }>(\SELF, Whatever, :$exists!, *%other) is raw {
    SLICE_MORE_HASH( SELF, SELF.keys.list, 'exists', $exists, %other );
}
multi sub postcircumfix:<{ }>(\SELF, Whatever, :$kv!, *%other) is raw {
    SLICE_MORE_HASH( SELF, SELF.keys.list, 'kv', $kv, %other );
}
multi sub postcircumfix:<{ }>(\SELF, Whatever, :$p!, *%other) is raw {
    SLICE_MORE_HASH( SELF, SELF.keys.list, 'p', $p, %other );
}
multi sub postcircumfix:<{ }>(\SELF, Whatever, :$k!, *%other) is raw {
    SLICE_MORE_HASH( SELF, SELF.keys.list, 'k', $k, %other );
}
multi sub postcircumfix:<{ }>(\SELF, Whatever, :$p!, *%other) is raw {
    SLICE_MORE_HASH( SELF, SELF.keys.list, 'p', $p, %other );
}
multi sub postcircumfix:<{ }>(\SELF, Whatever, :$v!, *%other) is raw {
    nqp::elems(nqp::getattr(%other,Map,'$!storage'))
      ?? SLICE_MORE_HASH( SELF, SELF.keys.list, 'v', $v, %other )
      !! SELF{SELF.keys.list};
}

# %h{}
multi sub postcircumfix:<{ }>(\SELF, :$BIND!) is raw {
    X::Bind::ZenSlice.new(type => SELF.WHAT).throw;
}
multi sub postcircumfix:<{ }>(\SELF, :$delete!, *%other) is raw {
    SLICE_MORE_HASH( SELF, SELF.keys.list, 'delete', $delete, %other );
}
multi sub postcircumfix:<{ }>(\SELF, :$exists!, *%other) is raw {
    SLICE_MORE_HASH( SELF, SELF.keys.list, 'exists', $exists, %other );
}
multi sub postcircumfix:<{ }>(\SELF, :$kv!, *%other) is raw {
    SLICE_MORE_HASH( SELF, SELF.keys.list, 'kv', $kv, %other );
}
multi sub postcircumfix:<{ }>(\SELF, :$p!, *%other) is raw {
    SLICE_MORE_HASH( SELF, SELF.keys.list, 'p', $p, %other );
}
multi sub postcircumfix:<{ }>(\SELF, :$k!, *%other) is raw {
    SLICE_MORE_HASH( SELF, SELF.keys.list, 'k', $k, %other );
}
multi sub postcircumfix:<{ }>(\SELF, :$p!, *%other) is raw {
    SLICE_MORE_HASH( SELF, SELF.keys.list, 'p', $p, %other );
}
multi sub postcircumfix:<{ }>(\SELF, :$v!, *%other) is raw {
    nqp::elems(nqp::getattr(%other,Map,'$!storage'))
      ?? SLICE_MORE_HASH( SELF, SELF.keys.list, 'v', $v, %other )
      !! SELF{SELF.keys.list};
}
multi sub postcircumfix:<{ }>( \SELF, *%other ) is raw {
    SELF.ZEN-KEY(|%other);
}


proto sub postcircumfix:<{; }>(|) is nodal { * }

sub MD-HASH-SLICE-ONE-POSITION(\SELF, \indices, \idx, int $dim, \target) {
    my int $next-dim = $dim + 1;
    if $next-dim < indices.elems {
        if nqp::istype(idx, Iterable) && !nqp::iscont(idx) {
            for idx {
                MD-HASH-SLICE-ONE-POSITION(SELF, indices, $_, $dim, target)
            }
        }
        elsif nqp::istype(idx, Str) {
            MD-HASH-SLICE-ONE-POSITION(SELF.AT-KEY(idx), indices, indices.AT-POS($next-dim), $next-dim, target)
        }
        elsif nqp::istype(idx, Whatever) {
            for SELF.keys {
                MD-HASH-SLICE-ONE-POSITION(SELF.AT-KEY($_), indices, indices.AT-POS($next-dim), $next-dim, target)
            }
        }
        else  {
            MD-HASH-SLICE-ONE-POSITION(SELF.AT-KEY(idx), indices, indices.AT-POS($next-dim), $next-dim, target)
        }
    }
    else {
        if nqp::istype(idx, Iterable) && !nqp::iscont(idx) {
            for idx {
                MD-HASH-SLICE-ONE-POSITION(SELF, indices, $_, $dim, target)
            }
        }
        elsif nqp::istype(idx, Str) {
            nqp::push(target, SELF.AT-KEY(idx))
        }
        elsif nqp::istype(idx, Whatever) {
            for SELF.keys {
                nqp::push(target, SELF.AT-KEY($_))
            }
        }
        else {
            nqp::push(target, SELF.AT-KEY(idx))
        }
    }
}

multi sub postcircumfix:<{; }>(\SELF, @indices) {
    my \target = IterationBuffer.new;
    MD-HASH-SLICE-ONE-POSITION(SELF, @indices, @indices.AT-POS(0), 0, target);
    nqp::p6bindattrinvres(nqp::create(List), List, '$!reified', target)
}

multi sub postcircumfix:<{; }>(\SELF, @indices, :$exists!) {
    sub recurse-at-key(\SELF, \indices) {
        my \idx     := indices[0];
        my \exists  := SELF.EXISTS-KEY(idx);
        nqp::if(
            nqp::istype(idx, Iterable),
            idx.map({ |recurse-at-key(SELF, ($_, |indices.skip.cache)) }).List,
            nqp::if(
                nqp::iseq_I(indices.elems, 1),
                exists,
                nqp::if(
                    exists,
                    recurse-at-key(SELF{idx}, indices.skip.cache),
                    nqp::stmts(
                        (my \times := indices.map({ .elems }).reduce(&[*])),
                        nqp::if(
                            nqp::iseq_I(times, 1),
                            False,
                            (False xx times).List
                        )
                    ).head
                )
            )
        );
    }

    recurse-at-key(SELF, @indices)
}

#line 1 SETTING::src/core/Scalar.pm
my class Scalar { # declared in BOOTSTRAP
    # class Scalar is Any
    #     has Mu $!descriptor;
    #     has Mu $!value;
    #     has Mu $!whence;

    method new(|) { X::Cannot::New.new(class => self.WHAT).throw }

    multi method WHICH(Scalar:D:) {
        'Scalar|' ~ nqp::objectid($!descriptor);
    }
    method name() {
        my $d := $!descriptor;
        nqp::isnull($d) ?? Nil !! $d.name()
    }
    method of() {
        my $d := $!descriptor;
        nqp::isnull($d) ?? Mu !! $d.of;
    }
    method default() {
        my $d := $!descriptor;
        nqp::isnull($d) ?? Any !! $d.default;
    }
    method dynamic() {
        my $d := $!descriptor;
        nqp::isnull($d) ?? False !! nqp::p6bool($d.dynamic);
    }
}

# Also compose native reference classes declared in BOOTSTRAP.
my class IntLexRef  { }
my class NumLexRef  { }
my class StrLexRef  { }
my class IntAttrRef { }
my class NumAttrRef { }
my class StrAttrRef { }
my class IntPosRef  { }
my class NumPosRef  { }
my class StrPosRef  { }

#line 1 SETTING::src/core/Code.pm
my class Code does Callable { # declared in BOOTSTRAP
    # class Code is Any
    #     has Code $!do;              # Low level code object
    #     has Signature $!signature;  # Signature object
    #     has @!compstuff;            # Place for the compiler to hang stuff

    multi method ACCEPTS(Code:D $self: Mu $topic is raw) {
        $self.count ?? $self($topic) !! $self()
    }

    method arity(Code:D:) { nqp::getattr_i($!signature,Signature,'$!arity') }

    method count(Code:D:) { nqp::getattr($!signature,Signature,'$!count') }

    method signature(Code:D:) { $!signature }

    proto method prec(|) { * }
    multi method prec() { my % }
    multi method prec(Str:D $) { '' }

    multi method Str(Code:D:) {
        warn( self.WHAT.perl ~ " object coerced to string (please use .gist or .perl to do that)"); self.name
    }

    method outer(Code:D:) {
        nqp::ifnull(nqp::getcodeobj(nqp::p6staticouter($!do)), Mu)
    }

    # returns an identifier for this code object
    # that is the same even for cloned closures
    method static_id(Code:D:) {
        nqp::p6box_i(nqp::where(nqp::getstaticcode($!do)));
    }

    multi method new(Code:) { X::Cannot::New.new(class => self).throw }

    method file(Code:D:) {
        nqp::getcodelocation($!do)<file>;
    }

    method line(Code:D:) {
        nqp::getcodelocation($!do)<line>;
    }

    multi method perl(Code:D:) { '{ ... }' }
}

#line 1 SETTING::src/core/WhateverCode.pm
my class WhateverCode is Code {

    # helper method for array slicing
    method pos(WhateverCode:D $self: \list) {
      nqp::if(
        nqp::iseq_i(
          nqp::getattr(
            nqp::getattr($self,Code,'$!signature'),
            Signature,
            '$!count'
          ),1),
        $self(nqp::if(nqp::isconcrete(list),list.elems,0)),
        $self(|(nqp::if(nqp::isconcrete(list),list.elems,0)
          xx nqp::getattr(
            nqp::getattr($self,Code,'$!signature'),
            Signature,
            '$!count'
          )
        ))
      )
    }
}

#line 1 SETTING::src/core/Block.pm
my class Block { # declared in BOOTSTRAP
    # class Block is Code
    #     has Mu $!phasers;
    #     has Mu $!why;

    method of(Block:D:)      { nqp::getattr(self,Code,'$!signature').returns }
    method returns(Block:D:) { nqp::getattr(self,Code,'$!signature').returns }

    method add_phaser(Str:D \name, &block --> Nil) {
        $!phasers := nqp::hash
          unless nqp::attrinited(self,Block,'$!phasers');

        my str $name = name;
        nqp::bindkey($!phasers,$name,nqp::create(IterationBuffer))
          unless nqp::existskey($!phasers,$name);

        if nqp::iseq_s($name,'LEAVE') || nqp::iseq_s($name,'KEEP') || nqp::iseq_s($name,'UNDO') {
            nqp::unshift(nqp::atkey($!phasers,$name),&block);
            self.add_phaser('!LEAVE-ORDER', &block);
        }
        elsif nqp::iseq_s($name,'NEXT') || nqp::iseq_s($name,'!LEAVE-ORDER') || nqp::iseq_s($name,'POST') {
            nqp::unshift(nqp::atkey($!phasers,$name),&block);
        }
        else {
            nqp::push(nqp::atkey($!phasers,$name),&block);
        }
    }

    method fire_if_phasers(Str $name --> Nil) {
        nqp::if(
          nqp::attrinited(self,Block,'$!phasers')
            && nqp::existskey($!phasers,$name),
          nqp::stmts(
            (my $iter := nqp::iterator(nqp::atkey($!phasers,$name))),
            nqp::while($iter,nqp::shift($iter)(),:nohandler)
          )
        )
    }

    method fire_phasers(Str $name --> Nil) {
        nqp::stmts(
          (my $iter := nqp::iterator(nqp::atkey($!phasers,$name))),
          nqp::while($iter,nqp::shift($iter)(),:nohandler)
        )
    }

    method has-phasers() { nqp::attrinited(self,Block,'$!phasers') }

    method has-phaser(Str:D \name) {
        nqp::attrinited(self,Block,'$!phasers')
          && nqp::existskey($!phasers,nqp::unbox_s(name))
    }

    method phasers(Str:D $name) {
        nqp::attrinited(self,Block,'$!phasers')
          && nqp::existskey($!phasers,nqp::unbox_s($name))
          ?? nqp::p6bindattrinvres(nqp::create(List),List,'$!reified',
               nqp::atkey($!phasers,nqp::unbox_s($name)))
          !! ()
    }

    method assuming(Block:D $self: |primers) {
        my $sig = nqp::getattr(nqp::decont($self), Code, '$!signature');

        # A ::() that does not throw.  Also does not need to deal
        # with chunks or sigils.
        my sub soft_indirect_name_lookup($name) {
            my @parts    = $name.split('::');

            my Mu $thing := ::.EXISTS-KEY(@parts[0]);
            return False unless $thing;
            $thing := ::.AT-KEY(@parts.shift);
            for @parts {
                return False unless $thing.WHO.EXISTS-KEY($_);
                $thing := $thing.WHO{$_};
            }
            True;
        }

        # sub strip-parm
        # This is mostly a stripped-down version of Parameter.perl, removing
        # where clauses, turning "= { ... }" from defaults into just
        # "?", removing type captures, subsignatures, and undeclared types
        # (e.g. types set to or parameterized by captured types.)
        my sub strip_parm (Parameter:D $parm, :$make_optional = False) {
            my $type = $parm.type.^name;
            my $perl = $type;
            my $rest = '';
            my $sigil = $parm.sigil;
            my $elide_agg_cont= so ($sigil eqv '@'
                                    or $sigil eqv '%'
                                    or $type ~~ /^^ Callable >> /);

            $perl = '' if $elide_agg_cont;
            unless $type eq "Any" {
                my int $FIRST = 1; # broken FIRST workaround
                while ($type ~~ / (.*?) \[ (.*) \] $$/) {
#                   FIRST {  # seems broken in setting
                    if $FIRST { # broken FIRST workaround
                        $perl = $elide_agg_cont
                          ?? ~$1
                          !! ~$/;
                        $FIRST = 0;
                    }
                    $type = ~$1;
                    unless soft_indirect_name_lookup(~$0) {
                        $perl = '';
                        last
                    };
                }
                $perl = '' unless soft_indirect_name_lookup($type);
            }
            $perl ~= $parm.modifier if $perl ne '';

            my $name = $parm.name;
            if !$name and $parm.raw {
                $name = '$';
            } elsif !$name or !$name.starts-with($sigil) {
                $name = $sigil ~ $parm.twigil ~ ($name // '');
            }

            if $parm.slurpy {
                $name = '*' ~ $name;
            } elsif $parm.named {
                my @names := $parm.named_names;
                $name = ':' ~ $_ ~ '(' ~ $name ~ ')'for @names;
                $name ~= '!' unless ($parm.optional or $make_optional);
                $name ~= '?' if ($make_optional);
            } elsif $parm.optional or $parm.default {
                $name ~= '?';
            }

            if $parm.rw {
                $rest ~= ' is rw';
            } elsif $parm.copy {
                $rest ~= ' is copy';
            }
            if $parm.raw {
                $rest ~= ' is raw' unless $name.starts-with('\\');
            }
            if $name or $rest {
                $perl ~= ($perl ?? ' ' !! '') ~ $name;
            }
            $perl ~ $rest;
        }

        # If we have only one parameter and it is a capture with a
        # subsignature, we might as will jump down into it.
        while +$sig.params == 1
              and $sig.params[0].capture
              and $sig.params[0].sub_signature {
            $sig = $sig.params[0].sub_signature;
        }

        my @plist = (); # Positionals in the returned closure's signature
        my @clist = (); # The positional args used to call the original code
        my @tlist = (); # Positional params to verify binding primers against
        my @alist = (); # Primers as positional arguments after processing

        # Find a name safe to use across slurpies, captures and sigilless
        my $safename = '_';
        $safename ~= '_' while $sig.params.first:
            { $_.name.defined and $_.name eq $safename and
              ($_.slurpy or $_.sigil eq '\\' or $_.sigil eq '|') };
        my $capwrap = $safename ~ '_';
        $capwrap ~= '_' while $sig.params.first:
            { $_.name.defined and $_.name eq $capwrap and
                  ($_.slurpy or $_.sigil eq '\\' or $_.sigil eq '|') };


        # Look for slurpies and captures
        my $slurp_p = $sig.params.first: {.slurpy and .sigil eq '@'};
        my $slurp_n = $sig.params.first: {.slurpy and .sigil eq '%'};
        $slurp_p //= ();
        $slurp_n //= ();

        # This gets sticky.  A bare capture will take anything
        # you throw at it.  A capture with a subsignature, not always.
        # Both will raise Signature.count to Inf, unfortunately,
        # and neither counts towards Signature.arity.  That might
        # eventually change as it is LTA.
        #
        # We have no real use for any captures defined in the original
        # signature, but if there is one, we must emulate its slurpylike
        # effects.  We cannot tell if it actually has slurpylike
        # effects without looking at subsignatures, recursively,
        # but really Signature should be able to tell us that.
        #
        # Until then, we will add slurpy behaviors, assuming we
        # do not already have them, if we see a capture.
        my $need_cap = ($sig.count == Inf and not ($slurp_p and $slurp_n));
        if $need_cap {
            $need_cap = False;
            for $sig.params.grep(*.capture) {
                $need_cap = True;
                last;
            }
        }
        # For now this is how we fabricate parameters.
        my &safeparms = EVAL
            sprintf('sub (|%s) { }', $safename);
        if ($need_cap) {
            $slurp_p ||= &safeparms.signature.params[0];
            $slurp_n ||= &safeparms.signature.params[0];
        }
        # Normal Positionals
        my Int $idx = -1;
        for $sig.params.grep(*.positional) -> $parm {
            $idx++;
            unless $idx < primers.list.elems {
                @plist.push($parm);
                @clist.push($capwrap ~ '[' ~ @plist.end ~ ']');
                next;
            }
            given primers.list[$idx] {
                when Whatever { @plist.push($parm);
                                @clist.push($capwrap ~ '[' ~ @plist.end ~ ']');
                              }
                when Nil      { @alist.push($parm.type);
                                @clist.push($parm.type.^name);
                                @tlist.push($parm);
                              }
                default       { @alist.push($_);
                                @clist.push("primers.list[$idx]");
                                @tlist.push($parm);
                              }
            }
        }
        my $widx = @plist.end;
        @tlist.push($slurp_p) if $slurp_p;
        @plist.push($slurp_p) if $slurp_p and not $slurp_p.capture;

        $idx++;
        my $cidx = 0;

        # Even if we prime above the arity, do it anyway, for errors.
        while ($idx < primers.list.elems) {
            given primers.list[$idx] {
                when Whatever {
                    @clist.push($capwrap ~ '[' ~ ++$widx ~ ']');
                }
                when Nil {
                    my $t = "Any";
                    if $slurp_p {
                        unless $slurp_p.capture {
                            $t = $slurp_p.type.of.^name
                        }
                    }
                    @alist.push($t);
                    @clist.push($t);
                }
                default {
                    @alist.push($_);
                    @clist.push("primers.list[$idx]");
                }
            }
            $idx++;
        }
        if $slurp_p {
            @clist.push('|' ~ $capwrap ~ '[' ~ ++$widx ~ '..*-1]' );
            # If it is a true slurpy we already pushed it to $plist
            $slurp_p = () unless $slurp_p.capture;
        }

        # Normal Nameds.
        # I noted this:
        # perl6 -e 'sub a (*%A, :$a?, *%B) { %A.say; %B.say }; a(:a(1));'
        # {:a(1)}<>
        # {}<>
        # I am going to treat that as a feature and preserve the behavior.
        # So we will care for ordering of the named parameters in the
        # user-facing signature as well, for introspection purposes.
        my %ahash = primers.hash;
        my @phash = $sig.params.grep: *.named;
        my @thash = $sig.params.grep: {
            .named and (
                .slurpy or
                any(%ahash.keys) eq any(.named_names.list)
            )
        }
        @phash .= map: {
            my @names = .named_names.list;
            my $p = strip_parm($_);
            if not .optional and any(%ahash.keys) eq any(@names) {
                # Make mandatory parameters optional once they have
                # been supplied at least once.
                $p = strip_parm($_, :make_optional);
            }
            $p;
        }
        if ($slurp_n and $slurp_n.capture and !($slurp_n === $slurp_p)) {
            @phash.push(strip_parm($slurp_n));
        }
        my $error = False;
        EVAL(sprintf('anon sub trybind (%s) { }(|@alist, |%%ahash);',
                     (flat @tlist.map(&strip_parm),
                           @thash.map(&strip_parm)).join(", "))
             );

        my $f;
        my $primed_sig = (flat @plist.map(&strip_parm), @phash,
                          ($slurp_p ?? strip_parm($slurp_p) !! ())).join(", ");
        $primed_sig ~= ' --> ' ~ $sig.returns.^name;

        $f = EVAL sprintf(
            '{ my $res = (my proto __PRIMED_ANON (%s) { {*} });
               my multi __PRIMED_ANON (|%s(%s)) {
                   my %%chash := %s.hash;
                   $self(%s%s |{ %%ahash, %%chash }); # |{} workaround RT#77788
               };
               $res }()',
            $primed_sig, $capwrap, $primed_sig, $capwrap,
            (flat @clist).join(", "),
            (@clist ?? ',' !! '')
        );

        $error ~~ Exception ?? $f but Failure.new($error) !! $f;
    }

    multi method perl(Block:D:) {
        "-> {self.signature.perl.substr(2,*-1)} \{ #`({self.WHICH}) ... \}"
    }

    method WHY() {
        if nqp::isnull($!why) {
            nextsame
        } else {
            $!why.set_docee(self);
            $!why
        }
    }

    method set_why($why --> Nil) {
        $!why := $why;
    }

    # helper method for array slicing
    method pos(Block:D $self: \list) {
      nqp::if(
        (nqp::istype(
          (my $n := nqp::getattr(
            nqp::getattr($self,Code,'$!signature'),Signature,'$!count')
          ),Num) && nqp::isnanorinf($n)) || nqp::iseq_i(nqp::unbox_i($n),1),
        $self(nqp::if(nqp::isconcrete(list),list.elems,0)),
        $self(|(nqp::if(nqp::isconcrete(list),list.elems,0) xx $n))
      )
    }
}

#line 1 SETTING::src/core/Variable.pm
# for our tantrums
my class X::Comp::NYI { ... };
my class X::Comp::Trait::Unknown { ... };
my class X::Comp::Trait::NotOnNative { ... };
my class X::Comp::Trait::Scope { ... };

# Variable traits come here, not in traits.pm, since we declare Variable
# in the setting rather than BOOTSTRAP.

my class Variable {
    has str $.name;
    has str $.scope;
    has $.var is rw;
    has $.block;
    has $.slash;

    # make throwing easier
    submethod throw ( |c ) {
        $*W.throw( self.slash, |c );
    }

    submethod willdo(&block, $caller-levels = 3) {
        $caller-levels == 3
            ?? -> { block(nqp::atkey(nqp::ctxcaller(nqp::ctxcaller(nqp::ctxcaller(nqp::ctx()))), self.name)) }
            !! -> { block(nqp::atkey(nqp::ctxcaller(nqp::ctx()), self.name)) }
    }

    submethod native(Mu $what) {
        my $name := $what.perl;
        $name.starts-with('array') || $name eq 'Mu'
          ?? $name
          !! $name.ends-with('LexRef')
            ?? $name.substr(0,3).lc
            !! '';
    }
}

# "is" traits
multi sub trait_mod:<is>(Variable:D $v, |c ) {
    $v.throw( 'X::Comp::Trait::Unknown',
      type      => 'is',
      subtype   => c.hash.keys[0],
      declaring => ' variable',
      expected  => <TypeObject default dynamic>,
    );
}
multi sub trait_mod:<is>(Variable:D $v, Mu :$default!) {
    my $var  := $v.var;
    my $what := $var.VAR.WHAT;

    my $descriptor;
    {
        $descriptor := nqp::getattr($var, $what.^mixin_base, '$!descriptor');
        CATCH {
            my $native = $v.native($what);
            $native
              ?? nqp::istype($default,Whatever)
                ?? $v.throw('X::Comp::NYI',
                     :feature("is default(*) on native $native"))
                !! $v.throw( 'X::Comp::Trait::NotOnNative',
                     :type<is>, :subtype<default>,
                     :native($native eq 'Mu' ?? ''!! $native ))  # yuck
              !! $v.throw('X::Comp::NYI',
                     :feature("is default on shaped $what.perl()"))
        }
    }

    my $of := $descriptor.of;
    $v.throw( 'X::Parameter::Default::TypeCheck',
      :expected($var.WHAT), :got($default =:= Nil ?? 'Nil' !! $default) )
      unless nqp::istype($default, $of) or $default =:= Nil or $of =:= Mu;
    $descriptor.set_default(nqp::decont($default));

    # make sure we start with the default if a scalar
    $var = $default if nqp::istype($what, Scalar);
}
multi sub trait_mod:<is>(Variable:D $v, :$dynamic!) {
    my $var  := $v.var;
    my $what := $var.VAR.WHAT;
    {
        nqp::getattr($var,$what.^mixin_base,'$!descriptor').set_dynamic($dynamic);
        CATCH {
            my $native = $v.native($what);
            $native
              ?? $v.throw( 'X::Comp::Trait::NotOnNative',
                   :type<is>, :subtype<dynamic>,
                   :native($native eq 'Mu' ?? ''!! $native ))  # yuck
              !! $v.throw('X::Comp::NYI',
                     :feature("is dynamic on shaped $what.perl()"))
        }
    }
}
multi sub trait_mod:<is>(Variable:D $v, :$export!) {
    if $v.scope ne 'our' {
        $v.throw( 'X::Comp::Trait::Scope',
          type      => 'is',
          subtype   => 'export',
          declaring => 'variable',
          scope     => $v.scope,
          supported => ['our'],
        );
    }
    my $var  := $v.var;
    my @tags = flat 'ALL', (nqp::istype($export,Pair) ?? $export.key() !!
                            nqp::istype($export,Positional) ?? @($export)>>.key !!
                            'DEFAULT');
    Rakudo::Internals.EXPORT_SYMBOL($var.VAR.name, @tags, $var);
}

# does trait
multi sub trait_mod:<does>(Variable:D $v, Mu:U $role) {
    if $role.HOW.archetypes.composable() {
        $v.var.VAR does $role;
    }
    elsif $role.HOW.archetypes.composalizable() {
        $v.var.VAR does $role.HOW.composalize($role);
    }
    else {
        X::Composition::NotComposable.new(
            target-name => 'a variable',
            composer    => $role,
        ).throw;
    }
}

# phaser traits
multi sub trait_mod:<will>(Variable:D $v, $block, |c ) {
    $v.throw( 'X::Comp::Trait::Unknown',
      type      => 'will',
      subtype   => c.hash.keys[0],
      declaring => ' variable',
      expected  => ('begin check final init end',
                    'enter leave keep undo',
                    'first next last pre post',
                    'compose'),
    );
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$begin! ) {
    $block($v.var); # no need to delay execution
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$check! ) {
    $*W.add_phaser($v.slash, 'CHECK', $block);
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$final! ) {
    $v.throw( 'X::Comp::NYI',
      feature => "Variable trait 'will final {...}'",
    );
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$init! ) {
    $v.throw( 'X::Comp::NYI',
      feature => "Variable trait 'will init {...}'",
    );
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$end! ) {
    $*W.add_object($block);
    $*W.add_phaser($v.slash, 'END', $block);
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$enter! ) {
    $v.block.add_phaser('ENTER', $v.willdo($block, 1) );
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$leave! ) {
    $v.block.add_phaser('LEAVE', $v.willdo($block) );
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$keep! ) {
    $v.block.add_phaser('KEEP', $v.willdo($block));
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$undo! ) {
    $v.block.add_phaser('UNDO', $v.willdo($block));
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$first! ) {
    $v.block.add_phaser('FIRST', $v.willdo($block, 1));
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$next! ) {
    $v.block.add_phaser('NEXT', $block);
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$last! ) {
    $v.block.add_phaser('LAST', $block);
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$pre! ) {
    $v.block.add_phaser('PRE', $v.willdo($block, 1));
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$post! ) {
    $v.throw( 'X::Comp::NYI',
      feature => "Variable trait 'will post {...}'",
    );
}
multi sub trait_mod:<will>(Variable:D $v, $block, :$compose! ) {
    $v.throw( 'X::Comp::NYI',
      feature => "Variable trait 'will compose {...}'",
    );
}

#line 1 SETTING::src/core/Routine.pm
my class X::Routine::Unwrap { ... }

my role HardRoutine {
    method soft(--> False) { }
}
my role SoftRoutine {
    method soft(--> True) { }
}

my class Routine { # declared in BOOTSTRAP
    # class Routine is Block
    #     has @!dispatchees;
    #     has Mu $!dispatcher_cache;
    #     has Mu $!dispatcher;
    #     has int $!rw;
    #     has Mu $!inline_info;
    #     has int $!yada;
    #     has Mu $!package;
    #     has int $!onlystar;
    #     has @!dispatch_order;
    #     has Mu $!dispatch_cache;

    method onlystar() { nqp::p6bool($!onlystar) }

    method candidates() {
        self.is_dispatcher ??
            nqp::hllize(@!dispatchees) !!
            (self,)
    }

    method cando(Capture $c) {
        my $disp;
        if self.is_dispatcher {
            $disp := self;
        }
        else {
            $disp := nqp::create(self);
            nqp::bindattr($disp, Routine, '@!dispatchees', nqp::list(self));
        }
        # Call this lexical sub to get rid of 'self' in the signature.
        sub checker(|) {
            nqp::hllize($disp.find_best_dispatchee(nqp::usecapture(), 1))
        }
        checker(|$c);
    }

    method multi() {
        self.dispatcher.defined
    }

    multi method perl(Routine:D:) {
        my $perl = ( self.^name ~~ m/^\w+/ ).lc;
        if self.name() -> $n {
            $perl ~= " $n";
        }
        $perl ~= ' ' ~ substr(self.signature().perl,1); # lose colon prefix
        $perl ~= ' { #`(' ~ self.WHICH ~ ') ... }';
        $perl
    }

    method soft( --> Nil ) { }

    method wrap(&wrapper) {
        my class WrapHandle {
            has $!dispatcher;
            has $!wrapper;
            method restore() {
                nqp::p6bool($!dispatcher.remove($!wrapper));
            }
        }
        my role Wrapped {
            has $!dispatcher;
            method UNSHIFT_WRAPPER(&wrapper) {
                # Add candidate.
                $!dispatcher := WrapDispatcher.new()
                    unless nqp::isconcrete($!dispatcher);
                $!dispatcher.add(&wrapper);

                # Return a handle.
                my $handle := nqp::create(WrapHandle);
                nqp::bindattr($handle, WrapHandle, '$!dispatcher', $!dispatcher);
                nqp::bindattr($handle, WrapHandle, '$!wrapper', &wrapper);
                $handle
            }
            method CALL-ME(|c) is raw {
                $!dispatcher.enter(|c);
            }
            method soft(--> True) { }
        }

        # We can't wrap a hardened routine (that is, one that's been
        # marked inlinable).
        if nqp::istype(self, HardRoutine) {
            die "Cannot wrap a HardRoutine, since it may have been inlined; " ~
                "use the 'soft' pragma to avoid marking routines as hard.";
        }

        # If we're not wrapped already, do the initial dispatcher
        # creation.
        unless nqp::istype(self, Wrapped) {
            my $orig = self.clone();
            self does Wrapped;
            self.UNSHIFT_WRAPPER($orig);
        }

        # Add this wrapper.
        self.UNSHIFT_WRAPPER(&wrapper);
    }

    method unwrap($handle) {
        $handle.can('restore') && $handle.restore() ||
            X::Routine::Unwrap.new.throw
    }

    method yada() {
        nqp::p6bool(nqp::getattr_i(self, Routine, '$!yada'))
    }

    method package() { $!package }

    method leave(*@) {
        X::NYI.new(:feature("{self.^name}.leave()")).throw;
    }
}

#line 1 SETTING::src/core/Sub.pm
my class Sub { # declared in BOOTSTRAP
    # class Sub is Routine

}

#line 1 SETTING::src/core/Macro.pm
my class Macro is Routine {
}

#line 1 SETTING::src/core/Method.pm
my class Method { # declared in BOOTSTRAP
    # class Method is Routine

    multi method gist(Method:D:) { self.name }
}

#line 1 SETTING::src/core/Submethod.pm
my class Submethod { # declared in BOOTSTRAP
    # class Submethod is Routine

    multi method gist(Submethod:D:) { self.name }
}

#line 1 SETTING::src/core/Junction.pm
my class Junction { # declared in BOOTSTRAP
    # class Junction is Mu
    #     has Mu $!storage;              # elements of Junction
    #     has str $!type;                # type of Junction

    method !SET-SELF(\type,\values) {
        nqp::stmts(
          ($!type = type),
          nqp::if(
            nqp::iseq_s($!type,"any")
              || nqp::iseq_s($!type,"all")
              || nqp::iseq_s($!type,"none")
              || nqp::iseq_s($!type,"one"),
            nqp::stmts(
              ($!storage := nqp::if(
                nqp::isconcrete(
                  $_ := nqp::getattr(values.eager.list,List,'$!reified')),
                $_,
                nqp::create(IterationBuffer))),
              self
            ),
            Failure.new("Junction can only have 'any', 'all', 'none', 'one' type")
          )
        )
    }

    # Swap 2 Junctions in place if they need to be for an infix operation
    # on the two Junctions.  Returns a truthy (0|1)value if the Junctions
    # were of the same type and can be merged.
    method INFIX-TWO(Junction:U: Junction:D \a, Junction:D \b) {
        nqp::if(
          nqp::iseq_s(
            (my $atype := nqp::getattr(nqp::decont(a),Junction,'$!type')),
            (my $btype := nqp::getattr(nqp::decont(b),Junction,'$!type'))
          ),
          nqp::isne_s($atype,"one"),             # same
          nqp::if(                               # not same
            (nqp::iseq_s($btype,"all") || nqp::iseq_s($btype,"none"))
              && (nqp::iseq_s($atype,"any") || nqp::iseq_s($atype,"one")),
            nqp::stmts(                          # need to be swapped
              (my $tmp := nqp::decont(a)),
              (a = b),
              (b = $tmp),
              0                                  # not same, now swapped
            )
          )
        )
    }

    proto method new(|) { * }
    multi method new(Junction: \values, Str :$type!) {
        nqp::create(Junction)!SET-SELF($type,values)
    }
    multi method new(Junction: Str:D \type, \values) {
        nqp::create(Junction)!SET-SELF(type,values)
    }

    method defined(Junction:D:) {
        nqp::p6bool(
          nqp::stmts(
            (my int $elems = nqp::elems($!storage)),
            (my int $i),
            nqp::if(
              nqp::iseq_s($!type,'any'),
              nqp::stmts(
                nqp::while(
                  nqp::islt_i($i,$elems)
                    && nqp::isfalse(nqp::atpos($!storage,$i).defined),
                  ($i = nqp::add_i($i,1))
                ),
                nqp::islt_i($i,$elems)
              ),
              nqp::if(
                nqp::iseq_s($!type,'all'),
                nqp::stmts(
                  nqp::while(
                    nqp::islt_i($i,$elems)
                      && nqp::atpos($!storage,$i).defined,
                    ($i = nqp::add_i($i,1))
                  ),
                  nqp::iseq_i($i,$elems)
                ),
                nqp::if(
                  nqp::iseq_s($!type,'none'),
                  nqp::stmts(
                    nqp::while(
                      nqp::islt_i($i,$elems)
                        && nqp::isfalse(nqp::atpos($!storage,$i).defined),
                      ($i = nqp::add_i($i,1))
                    ),
                    nqp::iseq_i($i,$elems)
                  ),
                  nqp::stmts(    # $!type eq 'one'
                    (my int $seen = 0),
                    ($i = nqp::sub_i($i,1)),  # increment in condition
                    nqp::while(
                      nqp::islt_i(($i = nqp::add_i($i,1)),$elems)
                        && nqp::isle_i($seen,1),
                      nqp::if(
                        nqp::atpos($!storage,$i).defined,
                        ($seen = nqp::add_i($seen,1))
                      )
                    ),
                    nqp::iseq_i($seen,1)
                  )
                )
              )
            )
          )
        )
    }

    multi method Bool(Junction:D:) {
        nqp::p6bool(
          nqp::stmts(
            (my int $elems = nqp::elems($!storage)),
            (my int $i),
            nqp::if(
              nqp::iseq_s($!type,'any'),
              nqp::stmts(
                nqp::while(
                  nqp::islt_i($i,$elems)
                    && nqp::isfalse(nqp::atpos($!storage,$i)),
                  ($i = nqp::add_i($i,1))
                ),
                nqp::islt_i($i,$elems)
              ),
              nqp::if(
                nqp::iseq_s($!type,'all'),
                nqp::stmts(
                  nqp::while(
                    nqp::islt_i($i,$elems)
                      && nqp::atpos($!storage,$i),
                    ($i = nqp::add_i($i,1))
                  ),
                  nqp::iseq_i($i,$elems)
                ),
                nqp::if(
                  nqp::iseq_s($!type,'none'),
                  nqp::stmts(
                    nqp::while(
                      nqp::islt_i($i,$elems)
                        && nqp::isfalse(nqp::atpos($!storage,$i)),
                      ($i = nqp::add_i($i,1))
                    ),
                    nqp::iseq_i($i,$elems)
                  ),
                  nqp::stmts(    # $!type eq 'one'
                    (my int $seen = 0),
                    ($i = nqp::sub_i($i,1)),  # increment in condition
                    nqp::while(
                      nqp::islt_i(($i = nqp::add_i($i,1)),$elems)
                        && nqp::isle_i($seen,1),
                      nqp::if(
                        nqp::atpos($!storage,$i),
                        ($seen = nqp::add_i($seen,1))
                      )
                    ),
                    nqp::iseq_i($seen,1)
                  )
                )
              )
            )
          )
        )
    }

    multi method ACCEPTS(Junction:U: Mu:D \topic) {
        nqp::p6bool(nqp::istype(topic, Junction));
    }
    multi method ACCEPTS(Junction:U: Any \topic) {
        nqp::p6bool(nqp::istype(topic, Junction));
    }
    multi method ACCEPTS(Junction:D: Mu \topic) {
        nqp::p6bool(
          nqp::stmts(
            (my int $elems = nqp::elems($!storage)),
            (my int $i),
            nqp::if(
              nqp::iseq_s($!type,'any'),
              nqp::stmts(
                nqp::while(
                  nqp::islt_i($i,$elems)
                    && nqp::isfalse(nqp::atpos($!storage,$i).ACCEPTS(topic)),
                  ($i = nqp::add_i($i,1))
                ),
                nqp::islt_i($i,$elems)
              ),
              nqp::if(
                nqp::iseq_s($!type,'all'),
                nqp::stmts(
                  nqp::while(
                    nqp::islt_i($i,$elems)
                      && nqp::atpos($!storage,$i).ACCEPTS(topic),
                    ($i = nqp::add_i($i,1))
                  ),
                  nqp::iseq_i($i,$elems)
                ),
                nqp::if(
                  nqp::iseq_s($!type,'none'),
                  nqp::stmts(
                    nqp::while(
                      nqp::islt_i($i,$elems)
                        && nqp::isfalse(
                             nqp::atpos($!storage,$i).ACCEPTS(topic)
                           ),
                      ($i = nqp::add_i($i,1))
                    ),
                    nqp::iseq_i($i,$elems)
                  ),
                  nqp::stmts(    # $!type eq 'one'
                    (my int $seen),
                    ($i = nqp::sub_i($i,1)),  # increment in condition
                    nqp::while(
                      nqp::islt_i(($i = nqp::add_i($i,1)),$elems)
                        && nqp::isle_i($seen,1),
                      nqp::if(
                        nqp::atpos($!storage,$i).ACCEPTS(topic),
                        ($seen = nqp::add_i($seen,1))
                      )
                    ),
                    nqp::iseq_i($seen,1)
                  )
                )
              )
            )
          )
        )
    }

    multi method Str(Junction:D:) {
        nqp::stmts(
          (my $storage := nqp::bindattr(
            (my $junction := nqp::clone(self)),
            Junction,
            '$!storage',
            nqp::clone(nqp::getattr(self,Junction,'$!storage'))
          )),
          (my int $elems = nqp::elems($storage)),
          (my int $i = -1),
          nqp::while(
            nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
            nqp::unless(
              nqp::istype(nqp::atpos($storage,$i),Str),
              nqp::bindpos($storage,$i,nqp::atpos($storage,$i).Str)
            )
          ),
          $junction
        )
    }

    multi method gist(Junction:D:) {
        my int $elems = nqp::elems($!storage);
        my int $i     = -1;
        my $gists    := nqp::setelems(nqp::list_s,$elems);
        nqp::bindpos_s($gists,$i,nqp::atpos($!storage,$i).gist)
          while nqp::islt_i(++$i,$elems);
        $!type ~ '(' ~ nqp::join(', ',$gists) ~ ')'
    }

    multi method perl(Junction:D:) {
        my int $elems = nqp::elems($!storage);
        my int $i     = -1;
        my $perls    := nqp::setelems(nqp::list_s,$elems);
        nqp::bindpos_s($perls,$i,nqp::atpos($!storage,$i).perl)
          while nqp::islt_i(++$i,$elems);
        $!type ~ '(' ~ nqp::join(', ',$perls) ~ ')'
    }

    method CALL-ME(|c) {
        self.AUTOTHREAD(
            -> $obj, |c { $obj(|c) },
            self, |c);
    }

    method sink(Junction:D: --> Nil) {
        my int $elems = nqp::elems($!storage);
        my int $i     = -1;
        nqp::atpos($!storage,$i).sink while nqp::islt_i(++$i,$elems);
    }

    method AUTOTHREAD(&call, |args) {
        my Mu $positionals := nqp::getattr(nqp::decont(args),Capture,'@!list');

        sub thread_junction(int $pos) {
            my $junction := nqp::decont(nqp::atpos($positionals, $pos));
            my $storage := nqp::getattr($junction,Junction,'$!storage');
            my int $elems = nqp::elems($storage);
            my $result   := nqp::setelems(nqp::list,$elems);
            my int $i     = -1;
            nqp::while(
              nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
              # Next line is Officially Naughty, since captures are
              # meant to be immutable. But hey, it's our capture to
              # be naughty with...
              nqp::stmts(
                nqp::bindpos($positionals,$pos,nqp::atpos($storage,$i)),
                nqp::bindpos($result,$i,call(|args))
              )
            );
            nqp::p6bindattrinvres(
              nqp::clone($junction),Junction,'$!storage',$result)
        }

        # Look for a junctional arg in the positionals.
        # we have to autothread the first all or none junction before
        # doing any one or any junctions.
        my int $first_any_one = -1;
        my int $elems = nqp::elems($positionals);
        my int $i     = -1;
        while nqp::islt_i(++$i,$elems) {

            # Junctional positional argument?
            my Mu $arg := nqp::atpos($positionals, $i);
            if nqp::istype($arg,Junction) {
                my str $type = nqp::getattr_s(nqp::decont($arg),Junction,'$!type');
                nqp::iseq_s($type,'any') || nqp::iseq_s($type,'one')
                  ?? $first_any_one == -1
                    ?? ($first_any_one = $i)
                    !! Nil
                  !! return thread_junction($i);
            }
        }
        return thread_junction($first_any_one) if $first_any_one >= 0;

        # Otherwise, look for one in the nameds.
        my Mu $nameds := nqp::getattr(nqp::decont(args), Capture, '%!hash');
        my $iter := nqp::iterator($nameds);
        while $iter {
            if nqp::istype(nqp::iterval(nqp::shift($iter)),Junction) {
                my $junction := nqp::decont(nqp::iterval($iter));
                my $storage  := nqp::getattr($junction,Junction,'$!storage');
                my int $elems = nqp::elems($storage);
                my $result   := nqp::setelems(nqp::list,$elems);
                my int $i     = -1;

                while nqp::islt_i(++$i,$elems) {
                    # also naughty, like above
                    nqp::bindkey($nameds,nqp::iterkey_s($iter),nqp::atpos($storage,$i));
                    nqp::bindpos($result,$i,call(|args));
                }

                my $threaded := nqp::clone(nqp::decont($junction));
                nqp::bindattr($threaded,Junction,'$!storage',$result);
                return $threaded;
            }
        }

        # If we get here, wasn't actually anything to autothread.
        call(|args);
    }
}

proto sub any(|) is pure { * }
#multi sub any(@values) { @values.any }  # this breaks S02-literals/radix.t
multi sub any(+values) {  values.any }

proto sub all(|) is pure { * }
multi sub all(@values) { @values.all }
multi sub all(+values) {  values.all }

proto sub one(|) is pure { * }
multi sub one(@values) { @values.one }
multi sub one(+values) {  values.one }

proto sub none(|) is pure { * }
multi sub none(@values) { @values.none }
multi sub none(+values) {  values.none }

sub infix:<|>(+values) is pure { values.any }
sub infix:<&>(+values) is pure { values.all }
sub infix:<^>(+values) is pure { values.one }

multi sub infix:<~>(Str:D $a, Junction:D $b) {
    nqp::if(
      $a,
      nqp::stmts(                                # something to concat with
        (my $storage := nqp::bindattr(
          (my $junction := nqp::clone($b)),
          Junction,
          '$!storage',
          nqp::clone(nqp::getattr($b,Junction,'$!storage'))
        )),
        (my int $elems = nqp::elems($storage)),
        (my int $i = -1),
        nqp::while(
          nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
          nqp::bindpos($storage,$i,
            nqp::if(
              nqp::istype((my $val := nqp::atpos($storage,$i)),Junction),
              infix:<~>($a,$val),
              nqp::concat($a,nqp::if(nqp::istype($val,Str),$val,$val.Str))
            )
          )
        ),
        $junction
      ),
      $b.Str                                     # nothing to concat with
    )
}

multi sub infix:<~>(Junction:D $a, Str:D $b) {
    nqp::if(
      $b,
      nqp::stmts(                                # something to concat with
        (my $storage := nqp::bindattr(
          (my $junction := nqp::clone($a)),
          Junction,
          '$!storage',
          nqp::clone(nqp::getattr($a,Junction,'$!storage'))
        )),
        (my int $elems = nqp::elems($storage)),
        (my int $i = -1),
        nqp::while(
          nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
          nqp::bindpos($storage,$i,
            nqp::if(
              nqp::istype((my $val := nqp::atpos($storage,$i)),Junction),
              infix:<~>($val,$b),
              nqp::concat(nqp::if(nqp::istype($val,Str),$val,$val.Str),$b)
            )
          )
        ),
        $junction
      ),
      $a.Str                                     # nothing to concat with
    )
}

multi sub infix:<~>(Junction:D \a, Junction:D \b) {
    nqp::stmts(                                  # basic setup
      (my int $mergable = Junction.INFIX-TWO(my $a = a, my $b = b)),
      (my $astor := nqp::getattr(nqp::decont($a),Junction,'$!storage')),
      (my $bstor := nqp::getattr(nqp::decont($b),Junction,'$!storage')),
      (my int $aelems = nqp::elems($astor)),
      (my int $belems = nqp::elems($bstor)),
      (my int $i = -1),
      (my $seen := nqp::hash),
      (my $outer := nqp::bindattr(               # outer eigenstates
        (my $junction := nqp::clone(nqp::decont($a))),
        Junction,
        '$!storage',
        nqp::if(
          $mergable,
          nqp::list,
          nqp::setelems(nqp::list,$aelems)
        )
      )),
      nqp::while(                                # outer loop
        nqp::islt_i(($i = nqp::add_i($i,1)),$aelems),
        nqp::stmts(
          (my $aval := nqp::if(
            nqp::istype(nqp::atpos($astor,$i),Str),
            nqp::atpos($astor,$i),
            nqp::atpos($astor,$i).Str
          )),
          (my int $j = -1),
          nqp::if(
            $mergable,
            nqp::while(                          # merge eigenstates
              nqp::islt_i(($j = nqp::add_i($j,1)),$belems),
              nqp::unless(
                nqp::existskey(
                  $seen,
                  (my $concat := nqp::concat(
                    $aval,
                    nqp::if(
                      nqp::istype(nqp::atpos($bstor,$j),Str),
                      nqp::atpos($bstor,$j),
                      nqp::atpos($bstor,$j).Str,
                    )
                  ))
                ),
                nqp::bindkey(                    # new one, remember
                  $seen,
                  nqp::push($outer,$concat),
                  1
                )
              )
            ),
            nqp::stmts(                          # cannot merge eigenstates
              (my $inner := nqp::bindattr(
                nqp::bindpos($outer,$i,nqp::clone(nqp::decont($b))),
                Junction,
                '$!storage',
                nqp::setelems(nqp::list,$belems)
              )),
              nqp::while(
                nqp::islt_i(($j = nqp::add_i($j,1)),$belems),
                nqp::bindpos(
                  $inner,
                  $j,
                  nqp::concat(
                    $aval,
                    nqp::if(
                      nqp::istype(nqp::atpos($bstor,$j),Str),
                      nqp::atpos($bstor,$j),
                      nqp::atpos($bstor,$j).Str,
                    )
                  )
                )
              )
            )
          )
        )
      ),
      $junction
    )
}

nqp::p6setautothreader( -> |c {
    Junction.AUTOTHREAD(|c)
} );
Mu.HOW.setup_junction_fallback(Junction, -> $name, |c {
    Junction.AUTOTHREAD(
        -> \obj, |c { obj."$name"(|c) },
        |c);
} );

#line 1 SETTING::src/core/Cool.pm
my class Cool { # declared in BOOTSTRAP
    # class Cool is Any

    ## numeric methods

    method abs()  { self.Numeric.abs }
    method conj()  { self.Numeric.conj }
    method sqrt()  { self.Numeric.sqrt }
    method sign()  { self.Real.sign }
    method rand() { self.Num.rand }
    method sin()  { self.Numeric.sin }
    method asin() { self.Numeric.asin }
    method cos()  { self.Numeric.cos }
    method acos() { self.Numeric.acos }
    method tan()  { self.Numeric.tan }
    method atan() { self.Numeric.atan }
    method atan2($y = 1e0) { self.Numeric.atan2($y.Numeric) }
    method sec()  { self.Numeric.sec }
    method asec() { self.Numeric.asec }
    method cosec()  { self.Numeric.cosec }
    method acosec() { self.Numeric.acosec }
    method cotan()  { self.Numeric.cotan }
    method acotan() { self.Numeric.acotan }
    method sinh()  { self.Numeric.sinh }
    method asinh() { self.Numeric.asinh }
    method cosh()  { self.Numeric.cosh }
    method acosh() { self.Numeric.acosh }
    method tanh()  { self.Numeric.tanh }
    method atanh() { self.Numeric.atanh }
    method sech()  { self.Numeric.sech }
    method asech() { self.Numeric.asech }
    method cosech()  { self.Numeric.cosech }
    method acosech() { self.Numeric.acosech }
    method cotanh()  { self.Numeric.cotanh }
    method acotanh() { self.Numeric.acotanh }
    method cis()     { self.Numeric.cis }

    proto method log(|) {*}
    multi method log(Cool:D: )      { self.Numeric.log          }
    multi method log(Cool:D: $base) { self.Numeric.log($base.Numeric) }

    proto method exp(|) {*}
    multi method exp(Cool:D: )      { self.Numeric.exp          }
    multi method exp(Cool:D: $base) { self.Numeric.exp($base.Numeric) }

    proto method round(|) { * }
    multi method round()      { self.Numeric.round()      }
    multi method round($base) { self.Numeric.round($base) }

    method roots(Cool $n)   { self.Numeric.roots($n)    }
    method log10()          { self.Numeric.log10        }
    method unpolar($n)      { self.Numeric.unpolar($n.Numeric) }

    method floor()          { self.Numeric.floor        }
    method ceiling()        { self.Numeric.ceiling      }
    method truncate()       { self.Numeric.truncate     }

    ## string methods

    method chars(--> Int:D) {
        self.Str.chars
    }
    method codes() {
        self.Str.codes
    }

    method fmt($format = '%s') {
        Rakudo::Internals.initialize-sprintf-handler;
        nqp::p6box_s(
            nqp::sprintf(nqp::unbox_s($format.Stringy), nqp::list(self))
        )
    }

    method substr($from, $length?)           { substr(   self,$from,$length) }
    method substr-rw(\SELF: $from, $length?) { substr-rw(SELF,$from,$length) }

    method uc() {
        self.Str.uc
    }

    method lc() {
        self.Str.lc
    }

    method tc() {
        self.Str.tc
    }

    method fc() {
        self.Str.fc
    }

    method tclc() {
        self.Str.tclc
    }

    method wordcase()   { self.Str.wordcase }

    method uniname()        { uniname(self) }
    method uninames()       { uninames(self) }
    method unival()         { unival(self) }
    method univals()        { univals(self) }
    method uniprop(|c)      { uniprop(self, |c) }
    method uniprop-int(|c)  { uniprop-int(self, |c) }
    method uniprop-bool(|c) { uniprop-bool(self, |c) }
    method uniprop-str(|c)  { uniprop-str(self, |c) }
    method uniprops(|c)     { uniprops(self, |c) }
    method unimatch(|c)     { unimatch(self, |c) }

    method chomp(Cool:D:) { self.Str.chomp }

    proto method chop(|)                { * }
    multi method chop(Cool:D:)          { self.Str.chop }
    multi method chop(Cool:D: Int() $n) { self.Str.chop($n) }

    method ord(--> Int:D) {
        self.Str.ord
    }
    method chr() {
        self.Int.chr;
    }
    method chrs(Cool:D:) { chrs(self.list) }
    method ords(Cool:D:) { self.Str.ords }


    method flip() {
        self.Str.flip
    }
    method trans(|c) { self.Str.trans(|c) }

    method starts-with(Cool:D: |c) {
        self.Str.starts-with(|c)
    }

    method ends-with(Cool:D: |c) {
        self.Str.ends-with(|c)
    }

    method substr-eq(Cool:D: |c) {
        self.Str.substr-eq(|c)
    }

    method contains(Cool:D: |c) {
        self.Str.contains(|c)
    }

    method indices(Cool:D: |c) {
        self.Str.indices(|c)
    }

    method index(Cool:D: |c) {
        self.Str.index(|c)
    }

    method rindex(Cool:D: |c) {
        self.Str.rindex(|c)
    }

    method split(Cool: |c) {
        self.Stringy.split(|c);
    }

    method match(Cool:D: |c) {
        $/ := nqp::getlexcaller('$/');
        self.Stringy.match(|c)
    }

    method comb(|c) { self.Str.comb(|c) }
    method lines(Cool:D: |c) { self.Str.lines(|c) }
    method words(Cool:D: |c) { self.Str.words(|c) }

    method subst(|c) {
        $/ := nqp::getlexcaller('$/');
        self.Stringy.subst(|c);
    }

    # `$value-to-subst-mutate` will show up in errors when called on non-rw
    # container, so use more descriptive name instead of just `$self`
    method subst-mutate(Cool:D $value-to-subst-mutate is rw: |c) {
        $/ := nqp::getlexcaller('$/');
        my $str   = $value-to-subst-mutate.Str;
        my $match = $str.subst-mutate(|c);
        $value-to-subst-mutate = $str;
        $match
    }

    proto method IO(|) { * }
    multi method IO(Cool:D:) { IO::Path.new(self) }
    multi method IO(Cool:U:) { IO::Path }

    method sprintf(*@args) { sprintf(self, @args) };
    method printf (*@args) {  printf(self, @args) };
    method samecase(Cool:D: Cool $pattern) { self.Stringy.samecase($pattern) }

    method path() { self.Stringy.IO }
    method trim         () { self.Stringy.trim          };
    method trim-leading () { self.Stringy.trim-leading  };
    method trim-trailing() { self.Stringy.trim-trailing };

    method EVAL(*%opts) {
        EVAL(self, context => CALLER::, |%opts);
    }

    multi method Real() {
        nqp::if(
            nqp::istype((my $numeric := self.Numeric), Failure),
            $numeric,
            $numeric.Real
        )
    }

    proto method Int(|) { * }
    multi method Int()  {
        nqp::if(
            nqp::istype((my $numeric := self.Numeric), Failure),
            $numeric,
            $numeric.Int
        )
    }

    proto method UInt(|) { * }
    multi method UInt()  {
        my $got := self.Int;
        $got < 0
          ?? Failure.new(X::OutOfRange.new(
               :what('Coercion to UInt'),
               :$got,
               :range<0..^Inf>))
          !! $got
    }

    method Num()  {
        nqp::if(
            nqp::istype((my $numeric := self.Numeric), Failure),
            $numeric,
            $numeric.Num
        )
    }

    method Rat()  {
        nqp::if(
            nqp::istype((my $numeric := self.Numeric), Failure),
            $numeric,
            $numeric.Rat
        )
    }

    method FatRat()  {
        nqp::if(
            nqp::istype((my $numeric := self.Numeric), Failure),
            $numeric,
            $numeric.FatRat
        )
    }

    method Complex()  {
        nqp::if(
            nqp::istype((my $numeric := self.Numeric), Failure),
            $numeric,
            $numeric.Complex
        )
    }
}
Metamodel::ClassHOW.exclude_parent(Cool);

proto sub chop(|) { * }
multi sub chop(Cool:D $s --> Str:D) { $s.chop }
multi sub chop(Cool:D $s, Int() $n --> Str:D) { $s.chop($n) }

sub chomp(Cool:D $s --> Str:D) { $s.chomp }

sub flip(Cool $s --> Str:D)      { $s.flip }
sub index(Cool $s,$needle,$pos=0)  { $s.index($needle,$pos) }
sub lc(Cool $s)                    { $s.lc }
sub ord(Cool $s)                   { $s.ord }
sub uc(Cool $s)                    { $s.uc }
sub tc(Cool $s)                    { $s.tc }
sub fc(Cool $s)                    { $s.fc }
sub tclc(Cool $s)                  { $s.tclc }

sub indices(Cool $s, |c) {
    $s.indices(|c);
}

proto sub rindex($, $, $?) is pure { * };
multi sub rindex(Cool $s, Cool $needle, Cool $pos) { $s.rindex($needle, $pos) };
multi sub rindex(Cool $s, Cool $needle)            { $s.rindex($needle) };

proto sub ords($) is pure     { * }
multi sub ords(Cool $s)       { ords($s.Stringy) }

proto sub comb($, $, $?)            { * }
multi sub comb(Regex $matcher, Cool $input, $limit = *) { $input.comb($matcher, $limit) }
multi sub comb(Str $matcher, Cool $input, $limit = *) { $input.comb($matcher, $limit) }
multi sub comb(Int:D $matcher, Cool $input, $limit = *) { $input.comb($matcher, $limit) }

proto sub wordcase($) is pure { * }
multi sub wordcase(Str:D $x) {$x.wordcase }
multi sub wordcase(Cool $x)  {$x.Str.wordcase }

sub sprintf(Cool $format, *@args) {
    CATCH {
        when X::Cannot::Lazy {
            X::Cannot::Lazy.new(:action('(s)printf')).throw
        }
        default {
            Rakudo::Internals.HANDLE-NQP-SPRINTF-ERRORS($_).throw
        }
    }
    Rakudo::Internals.initialize-sprintf-handler;
    @args.elems;
    nqp::p6box_s(
        nqp::sprintf(nqp::unbox_s($format.Stringy),
            nqp::clone(nqp::getattr(@args||[], List, '$!reified'))
        )
    )
}

sub printf(Cool $format, *@args)          { print sprintf $format, @args }
sub samecase(Cool $string, Cool $pattern) { $string.samecase($pattern) }
sub split($pat, Cool $target, |c)         { $target.split($pat, |c) }

proto sub chars($) is pure {*}
multi sub chars(Cool $x)  { $x.Str.chars }
multi sub chars(Str:D $x) { nqp::p6box_i(nqp::chars($x)) }
multi sub chars(str $x --> int) { nqp::chars($x) }

# These probably belong in a separate unicodey file

proto sub uniname(|) {*}
multi sub uniname(Str:D $str)  { $str ?? uniname($str.ord) !! Nil }
multi sub uniname(Int:D $code) { nqp::getuniname($code) }

proto sub uninames(|) {*}
multi sub uninames(Str:D $str) { $str.NFC.map: { uniname($_) } }













proto sub uniprop(|) {*}
multi sub uniprop(Str:D $str, |c) { $str ?? uniprop($str.ord, |c) !! Nil }
multi sub uniprop(Int:D $code) {
    nqp::getuniprop_str($code,nqp::unipropcode('General_Category'));
}
multi sub uniprop(Int:D $code, Stringy:D $propname) {
    # prop-mappings can be removed when MoarVM bug #448 is fixed...
    ## The code below was generated by tools/build/makeUNIPROP.pl6
    my constant $prop-mappings = nqp::hash(
      'OGr_Ext','Other_Grapheme_Extend','tc','Titlecase_Mapping',
      'cjkIRG_MSource','kIRG_MSource','Dash','Dash','Pat_Syn','Pattern_Syntax',
      'IDST','IDS_Trinary_Operator','IDC','ID_Continue','Dia','Diacritic',
      'Cased','Cased','hst','Hangul_Syllable_Type','QMark','Quotation_Mark',
      'Radical','Radical','NFD_QC','NFD_Quick_Check','jt','Joining_Type',
      'cf','Case_Folding','cjkIRG_TSource','kIRG_TSource','sc','Script',
      'SD','Soft_Dotted','CWCM','Changes_When_Casemapped',
      'cjkOtherNumeric','kOtherNumeric','scf','Simple_Case_Folding',
      'sfc','Simple_Case_Folding','isc','ISO_Comment','na1','Unicode_1_Name',
      'Lower','Lowercase','Join_C','Join_Control','JSN','Jamo_Short_Name',
      'bc','Bidi_Class','jg','Joining_Group','dm','Decomposition_Mapping',
      'lc','Lowercase_Mapping','cjkIRG_USource','kIRG_USource',
      'NFKC_CF','NFKC_Casefold','slc','Simple_Lowercase_Mapping',
      'InSC','Indic_Syllabic_Category','XO_NFC','Expands_On_NFC',
      'XO_NFD','Expands_On_NFD','cjkAccountingNumeric','kAccountingNumeric',
      'Upper','Uppercase','WSpace','White_Space','space','White_Space',
      'cjkIRG_VSource','kIRG_VSource','STerm','Sentence_Terminal',
      'NFKD_QC','NFKD_Quick_Check','CWT','Changes_When_Titlecased','Math','Math',
      'uc','Uppercase_Mapping','NFKC_QC','NFKC_Quick_Check','SB','Sentence_Break',
      'stc','Simple_Titlecase_Mapping','Alpha','Alphabetic',
      'CE','Composition_Exclusion','NChar','Noncharacter_Code_Point',
      'OAlpha','Other_Alphabetic','XIDC','XID_Continue','age','Age',
      'cjkPrimaryNumeric','kPrimaryNumeric','OIDS','Other_ID_Start',
      'UIdeo','Unified_Ideograph','FC_NFKC','FC_NFKC_Closure','CI','Case_Ignorable',
      'Hyphen','Hyphen','nv','Numeric_Value','CWKCF','Changes_When_NFKC_Casefolded',
      'XO_NFKD','Expands_On_NFKD','InPC','Indic_Positional_Category',
      'dt','Decomposition_Type','cjkIICore','kIICore','Bidi_M','Bidi_Mirrored',
      'CWU','Changes_When_Uppercased','IDS','ID_Start','Gr_Ext','Grapheme_Extend',
      'XIDS','XID_Start','XO_NFKC','Expands_On_NFKC','OUpper','Other_Uppercase',
      'OMath','Other_Math','Gr_Link','Grapheme_Link','Bidi_C','Bidi_Control',
      'DI','Default_Ignorable_Code_Point','CWCF','Changes_When_Casefolded',
      'cjkIRG_GSource','kIRG_GSource','WB','Word_Break','NFC_QC','NFC_Quick_Check',
      'cjkIRG_JSource','kIRG_JSource','ODI','Other_Default_Ignorable_Code_Point',
      'LOE','Logical_Order_Exception','bpb','Bidi_Paired_Bracket',
      'PCM','Prepended_Concatenation_Mark','OLower','Other_Lowercase',
      'OIDC','Other_ID_Continue','VS','Variation_Selector','Ext','Extender',
      'Comp_Ex','Full_Composition_Exclusion','IDSB','IDS_Binary_Operator',
      'nt','Numeric_Type','cjkCompatibilityVariant','kCompatibilityVariant',
      'suc','Simple_Uppercase_Mapping','Term','Terminal_Punctuation',
      'lb','Line_Break','cjkIRG_HSource','kIRG_HSource','ea','East_Asian_Width',
      'AHex','ASCII_Hex_Digit','cjkIRG_KSource','kIRG_KSource',
      'Pat_WS','Pattern_White_Space','Hex','Hex_Digit',
      'cjkIRG_KPSource','kIRG_KPSource','bpt','Bidi_Paired_Bracket_Type',
      'gc','General_Category','GCB','Grapheme_Cluster_Break',
      'Gr_Base','Grapheme_Base','na','Name','scx','Script_Extensions',
      'Ideo','Ideographic','Name_Alias','Name_Alias','blk','Block','Dep','Deprecated',
      'CWL','Changes_When_Lowercased','bmg','Bidi_Mirroring_Glyph',
      'cjkRSUnicode','kRSUnicode','Unicode_Radical_Stroke','kRSUnicode',
      'URS','kRSUnicode','ccc','Canonical_Combining_Class',
    );
    my constant $prefs = nqp::hash(
      'Other_Grapheme_Extend','B','Titlecase_Mapping','tc','Dash','B',
      'Emoji_Modifier_Base','B','Emoji_Modifier','B','Pattern_Syntax','B',
      'IDS_Trinary_Operator','B','ID_Continue','B','Diacritic','B','Cased','B',
      'Hangul_Syllable_Type','S','Quotation_Mark','B','Radical','B',
      'NFD_Quick_Check','S','Joining_Type','S','Case_Folding','S','Script','S',
      'Soft_Dotted','B','Changes_When_Casemapped','B','Simple_Case_Folding','S',
      'ISO_Comment','S','Lowercase','B','Join_Control','B','Bidi_Class','S',
      'Joining_Group','S','Decomposition_Mapping','S','Lowercase_Mapping','lc',
      'NFKC_Casefold','S','Simple_Lowercase_Mapping','S',
      'Indic_Syllabic_Category','S','Expands_On_NFC','B','Expands_On_NFD','B',
      'Uppercase','B','White_Space','B','Sentence_Terminal','B',
      'NFKD_Quick_Check','S','Changes_When_Titlecased','B','Math','B',
      'Uppercase_Mapping','uc','NFKC_Quick_Check','S','Sentence_Break','S',
      'Simple_Titlecase_Mapping','S','Alphabetic','B','Composition_Exclusion','B',
      'Noncharacter_Code_Point','B','Other_Alphabetic','B','XID_Continue','B',
      'Age','S','Other_ID_Start','B','Unified_Ideograph','B','FC_NFKC_Closure','S',
      'Case_Ignorable','B','Hyphen','B','Numeric_Value','nv',
      'Changes_When_NFKC_Casefolded','B','Expands_On_NFKD','B',
      'Indic_Positional_Category','S','Decomposition_Type','S','Bidi_Mirrored','B',
      'Changes_When_Uppercased','B','ID_Start','B','Grapheme_Extend','B',
      'XID_Start','B','Expands_On_NFKC','B','Other_Uppercase','B','Other_Math','B',
      'Grapheme_Link','B','Bidi_Control','B','Default_Ignorable_Code_Point','B',
      'Changes_When_Casefolded','B','Word_Break','S','NFC_Quick_Check','S',
      'Other_Default_Ignorable_Code_Point','B','Logical_Order_Exception','B',
      'Prepended_Concatenation_Mark','B','Other_Lowercase','B',
      'Other_ID_Continue','B','Variation_Selector','B','Extender','B',
      'Full_Composition_Exclusion','B','IDS_Binary_Operator','B','Numeric_Type','S',
      'kCompatibilityVariant','S','Simple_Uppercase_Mapping','S',
      'Terminal_Punctuation','B','Line_Break','S','East_Asian_Width','S',
      'ASCII_Hex_Digit','B','Pattern_White_Space','B','Hex_Digit','B',
      'Bidi_Paired_Bracket_Type','S','General_Category','S',
      'Grapheme_Cluster_Break','S','Grapheme_Base','B','Name','na','Ideographic','B',
      'Block','S','Emoji_Presentation','B','Emoji','B','Deprecated','B',
      'Changes_When_Lowercased','B','Bidi_Mirroring_Glyph','bmg',
      'Canonical_Combining_Class','S',
    );
    ## End generated code
    $propname := nqp::atkey($prop-mappings, $propname) if nqp::existskey($prop-mappings,$propname);
    my $prop := nqp::unipropcode($propname);
    given nqp::atkey($prefs, $propname) {
        when 'S'   { nqp::getuniprop_str($code,$prop) }
        when 'I'   { nqp::getuniprop_int($code,$prop) }
        when 'B'   { nqp::p6bool(nqp::getuniprop_bool($code,$prop)) }
        when 'lc'  { nqp::lc( nqp::chr( nqp::unbox_i($code) ) ) }
        when 'tc'  { nqp::tc( nqp::chr( nqp::unbox_i($code) ) ) }
        when 'uc'  { nqp::uc( nqp::chr( nqp::unbox_i($code) ) ) }
        when 'na'  { nqp::getuniname($code) }
        when 'nv'  { unival($code) }
        when 'bmg' {
            my int $bmg-ord = nqp::getuniprop_int($code, $prop);
            $bmg-ord ?? nqp::chr($bmg-ord) !! '';
        }
        default {
            my $result = nqp::getuniprop_str($code,$prop);
            if $result ne '' { nqp::bindkey($prefs, $propname, 'S'); $result }
            else             { nqp::bindkey($prefs, $propname, 'I'); nqp::getuniprop_int($code,$prop) }
        }
    }
}
# Unicode functions
proto sub uniprop-int(|) {*}
multi sub uniprop-int(Str:D $str, Stringy:D $propname) {
    $str ?? uniprop-int($str.ord, $propname) !! Nil }
multi sub uniprop-int(Int:D $code, Stringy:D $propname) {
    nqp::getuniprop_int($code,nqp::unipropcode($propname));
}

proto sub uniprop-bool(|) {*}
multi sub uniprop-bool(Str:D $str, Stringy:D $propname) {
    $str ?? uniprop-bool($str.ord, $propname) !! Nil
}
multi sub uniprop-bool(Int:D $code, Stringy:D $propname) {
    nqp::p6bool(nqp::getuniprop_bool($code,nqp::unipropcode($propname)));
}

proto sub uniprop-str(|) {*}
multi sub uniprop-str(Str:D $str, Stringy:D $propname) {
    $str ?? uniprop-str($str.ord, $propname) !! Nil
}
multi sub uniprop-str(Int:D $code, Stringy:D $propname) {
    nqp::getuniprop_str($code,nqp::unipropcode($propname));
}
proto sub uniprops(|) {*}
multi sub uniprops(Str:D $str, Stringy:D $propname = "General_Category") {
    $str.ords.map: { uniprop($_, $propname) }
}

proto sub unival(|) {*}
multi sub unival(Str:D $str) { $str ?? unival($str.ord) !! Nil }
multi sub unival(Int:D $code) {
    state $nuprop = nqp::unipropcode("Numeric_Value_Numerator");
    state $deprop = nqp::unipropcode("Numeric_Value_Denominator");
    my $nu = nqp::getuniprop_str($code, $nuprop);
    my $de = nqp::getuniprop_str($code, $deprop);
    !$de || $de eq '1' ?? $nu.Int !! $nu / $de;
}

proto sub univals(|) {*}
multi sub univals(Str:D $str) { $str.ords.map: { unival($_) } }

proto sub unimatch(|) {*}
multi sub unimatch(Str:D $str, |c) { $str ?? unimatch($str.ord, |c) !! Nil }
# This multi below can be removed when MoarVM bug #448 is fixed
multi sub unimatch(Int:D $code, Stringy:D $pvalname, Stringy:D $propname) {
    uniprop($code, $propname) eq $pvalname;
}
multi sub unimatch(Int:D $code, Stringy:D $pvalname, Stringy:D $propname = $pvalname) {
    my $prop := nqp::unipropcode($propname);
    nqp::p6bool(nqp::matchuniprop($code,$prop,nqp::unipvalcode($prop,$pvalname)));
}


#line 1 SETTING::src/core/Enumeration.pm
# Method that we have on enumeration types.
my role Enumeration {
    has $.key;
    has $.value;
    has int $!index;

    method enums() { self.^enum_values.Map }

    multi method kv(::?CLASS:D:) { ($!key, $!value) }
    method pair(::?CLASS:D:) { $!key => $!value }

    multi method gist(::?CLASS:D:) { $!key                     }
    multi method perl(::?CLASS:D:) { self.^name ~ '::' ~ $!key }

    multi method pick(::?CLASS:U:)       { self.^enum_value_list.pick     }
    multi method pick(::?CLASS:U: \n)    { self.^enum_value_list.pick(n)  }
    multi method pick(::?CLASS:D: *@pos) { self xx +?( @pos[0] // 1 )     }
    multi method roll(::?CLASS:U:)       { self.^enum_value_list.roll     }
    multi method roll(::?CLASS:U: \n)    { self.^enum_value_list.roll(n)  }
    multi method roll(::?CLASS:D: *@pos) { self xx +?( @pos[0] // 1 )     }

    multi method Numeric(::?CLASS:D:) { $!value.Numeric }
    multi method Int(::?CLASS:D:)     { $!value.Int }
    multi method Real(::?CLASS:D:)    { $!value.Real }

    multi method WHICH(::?CLASS:D:) {
        nqp::box_s(
          nqp::concat(self.^name,nqp::concat("|",$!index)),
          ObjAt
        )
    }

    # Make sure we always accept any element of the enumeration
    multi method ACCEPTS(::?CLASS:D: ::?CLASS:U $ --> True) { }
    multi method ACCEPTS(::?CLASS:D: ::?CLASS:D \v) { self === v }

    method CALL-ME(|) {
        my $x := nqp::atpos(nqp::p6argvmarray(), 1).AT-POS(0);
        nqp::istype($x, ::?CLASS)
            ?? $x
            !! self.^enum_from_value($x)
    }

    method pred(::?CLASS:D:) {
        nqp::if(
          nqp::getattr_i(self,::?CLASS,'$!index'),
          nqp::atpos(
            nqp::getattr(self.^enum_value_list,List,'$!reified'),
            nqp::sub_i(nqp::getattr_i(self,::?CLASS,'$!index'),1)
          ),
          self
        )
    }
    method succ(::?CLASS:D:) {
        nqp::stmts(
          (my $values := nqp::getattr(self.^enum_value_list,List,'$!reified')),
          nqp::if(
            nqp::islt_i(
              nqp::getattr_i(self,::?CLASS,'$!index'),
              nqp::sub_i(nqp::elems($values),1),
            ),
            nqp::atpos(
               $values,
               nqp::add_i(nqp::getattr_i(self,::?CLASS,'$!index'),1)
            ),
            self
          )
        )
    }
}

# Methods that we also have if the base type of an enumeration is
# Numeric.
my role NumericEnumeration {
    multi method Str(::?CLASS:D:) {
        self.key
    }
}
my role StringyEnumeration {
    multi method Str(::?CLASS:D:) {
        self.value
    }
}

sub ENUM_VALUES(*@args) {
    my Mu $prev = -1;
    my %res;
    for @args {
        if .^isa(Pair) {
            %res{.key} = $prev = .value;
        }
        else {
            %res{$_} = $prev.=succ;
        }
    }
    nqp::p6bindattrinvres(
      nqp::create(Map),Map,'$!storage',nqp::getattr(%res,Map,'$!storage')
    )
}

Metamodel::EnumHOW.set_composalizer(-> $type, $name, %enum_values {
    my Mu $r := Metamodel::ParametricRoleHOW.new_type(:name($name));
    $r.^add_attribute(Attribute.new(
        :name('$!' ~ $name), :type(nqp::decont($type)),
        :has_accessor(1), :package($r)));
    for %enum_values.kv -> $key, $value {
        my $meth = method () { self."$name"() == $value }
        $meth.set_name($key);
        $r.^add_method($key, $meth);
    }
    $r.^set_body_block( -> |c {nqp::list($r,nqp::hash('$?CLASS',c<$?CLASS>))});
    $r.^compose;
    $r
});

# We use this one because, for example, Int:D === Int:D, has an optimization
# that simply unboxes the values. That's no good for us, since two different
# Enumertaion:Ds could have the same Int:D value.
multi infix:<===> (Enumeration:D \a, Enumeration:D \b) {
    nqp::p6bool(nqp::eqaddr(nqp::decont(a), nqp::decont(b)))
}

#line 1 SETTING::src/core/Numeric.pm
# for our tantrums
my class X::Numeric::DivideByZero { ... }

my role Numeric {
    multi method Numeric(Numeric:D:) { self }

    multi method ACCEPTS(Numeric:D: Any:D \a) {
        (try my \numeric = a.Numeric).defined
                ?? (self.isNaN && numeric.isNaN or numeric == self)
                !! False
    }

    proto method log(|) {*}
    multi method log(Numeric:D: Cool $base) { self.log / $base.Numeric.log }
    multi method log(Numeric:D: Numeric $base) { self.log / $base.log         }

    method log10() { self.log / 10e0.log }

    proto method exp(|) {*}
    multi method exp(Numeric:D: $base) {
        $base ** self;
    }
    method roots(Cool $n) { self.Complex.roots($n.Int) }

    method FatRat(Numeric:D:) { self.Rat.FatRat }
    multi method Bool(Numeric:D:) { self != 0 }

    multi method gist(Numeric:D:) { self.Str }
    multi method DUMP(Numeric:D:) { self.perl }

    method succ() { self + 1 }
    method pred() { self - 1 }
}

multi sub infix:<eqv>(Numeric:D \a, Numeric:D \b) {
    nqp::p6bool( # RT #127951
        nqp::eqaddr(a,b) || (
            nqp::eqaddr(a.WHAT,b.WHAT)
            && nqp::if(nqp::istype(a, Num), (a === b), (a == b))
    )) # for Nums use === to properly handle signed zeros and NaNs
}

## arithmetic operators

proto sub prefix:<+>($?) is pure { * }
multi sub prefix:<+>(\a) { a.Numeric }

proto sub prefix:<->($?) is pure { * }
multi sub prefix:<->(\a) { -a.Numeric }

proto sub abs($) is pure { * }
multi sub abs(\a) { abs a.Numeric }

proto sub sign($) is pure {*}
multi sub sign(Numeric \x) { x.sign }
multi sub sign(Cool \x)    { x.Numeric.sign }

proto sub log($, $?) is pure {*}
multi sub log(Numeric $x) { $x.log }
multi sub log(Numeric $x, Numeric $base) { $x.log($base) }
multi sub log(Cool $x)    { $x.Numeric.log }
multi sub log(Cool $x, Cool $base) { $x.Numeric.log($base.Numeric) }

proto sub log10($, $?) is pure {*}
multi sub log10(Numeric $x) { $x.log(10e0) }
multi sub log10(Cool    $x) { $x.Numeric.log(10e0) }

proto sub exp($, $?) is pure {*}
multi sub exp(Numeric $x) { $x.exp }
multi sub exp(Numeric $x, Numeric $base) { $x.exp($base) }

proto sub sin($) is pure {*}
multi sub sin(Numeric \x) { x.sin }
multi sub sin(Cool \x)    { x.Numeric.sin }

proto sub asin($) is pure {*}
multi sub asin(Numeric \x) { x.asin }
multi sub asin(Cool \x)    { x.Numeric.asin }

proto sub cos($) is pure {*}
multi sub cos(Numeric \x) { x.cos }
multi sub cos(Cool \x)    { x.Numeric.cos }

proto sub acos($) is pure {*}
multi sub acos(Numeric \x) { x.acos }
multi sub acos(Cool \x)    { x.Numeric.acos }

proto sub tan($) is pure {*}
multi sub tan(Numeric \x) { x.tan }
multi sub tan(Cool \x)    { x.Numeric.tan }

proto sub atan($) is pure {*}
multi sub atan(Numeric \x) { x.atan }
multi sub atan(Cool \x)    { x.Numeric.atan }

proto sub sec($) is pure {*}
multi sub sec(Numeric \x)  { x.sec }
multi sub sec(Cool \x)     { x.Numeric.sec }

proto sub asec($) is pure {*}
multi sub asec(Numeric \x)  { x.asec }
multi sub asec(Cool \x)     { x.Numeric.asec }

proto sub cosec($) is pure {*}
multi sub cosec(Numeric \x)  { x.cosec }
multi sub cosec(Cool \x)     { x.Numeric.cosec }

proto sub acosec(|) is pure {*}
multi sub acosec(Numeric \x)  { x.acosec }
multi sub acosec(Cool \x)     { x.Numeric.acosec }

proto sub cotan($) is pure {*}
multi sub cotan(Numeric \x)  { x.cotan }
multi sub cotan(Cool \x)     { x.Numeric.cotan }

proto sub acotan($) is pure {*}
multi sub acotan(Numeric \x)  { x.acotan }
multi sub acotan(Cool \x)     { x.Numeric.acotan }

proto sub sinh($) is pure {*}
multi sub sinh(Numeric \x) { x.sinh }
multi sub sinh(Cool \x)    { x.Numeric.sinh }

proto sub asinh($) is pure {*}
multi sub asinh(Numeric \x) { x.asinh }
multi sub asinh(Cool \x)    { x.Numeric.asinh }

proto sub cosh($) is pure {*}
multi sub cosh(Numeric \x) { x.cosh }
multi sub cosh(Cool \x)    { x.Numeric.cosh }

proto sub acosh($) is pure {*}
multi sub acosh(Numeric \x) { x.acosh }
multi sub acosh(Cool \x)    { x.Numeric.acosh }

proto sub tanh($) is pure {*}
multi sub tanh(Numeric \x) { x.tanh }
multi sub tanh(Cool \x)    { x.Numeric.tanh }

proto sub atanh($) is pure {*}
multi sub atanh(Numeric \x) { x.atanh }
multi sub atanh(Cool \x)    { x.Numeric.atanh }

proto sub sech($) is pure {*}
multi sub sech(Numeric \x) { x.sech }
multi sub sech(Cool \x)    { x.Numeric.sech }

proto sub asech($) is pure {*}
multi sub asech(Numeric \x) { x.asech }
multi sub asech(Cool \x)    { x.Numeric.asech }

proto sub cosech($) is pure {*}
multi sub cosech(Numeric \x) { x.cosech }
multi sub cosech(Cool \x)    { x.Numeric.cosech }

proto sub acosech($) is pure {*}
multi sub acosech(Numeric \x) { x.acosech }
multi sub acosech(Cool \x)    { x.Numeric.acosech }

proto sub cotanh($) is pure {*}
multi sub cotanh(Numeric \x) { x.cotanh }
multi sub cotanh(Cool \x)    { x.Numeric.cotanh }

proto sub acotanh($) is pure {*}
multi sub acotanh(Numeric \x) { x.acotanh }
multi sub acotanh(Cool \x)    { x.Numeric.acotanh }

proto sub sqrt($) is pure {*}
multi sub sqrt(Numeric \x) { x.sqrt }
multi sub sqrt(Cool \x)    { x.Numeric.sqrt }

proto sub roots($, $) is pure { * }
multi sub roots($x, Cool $n) { $x.Numeric.Complex.roots($n.Int) }
multi sub roots($x, Numeric $n) { $x.Numeric.Complex.roots($n.Int) }

proto sub floor($) is pure   { * }
multi sub floor($a)          { $a.Numeric.floor }
multi sub floor(Numeric $a)  { $a.floor }

proto sub ceiling($) is pure   { * }
multi sub ceiling($a)          { $a.Numeric.ceiling }
multi sub ceiling(Numeric $a)  { $a.ceiling }

proto sub round($, $?) is pure      { * }
multi sub round($a)                 { $a.Numeric.round }
multi sub round(Numeric $a)         { $a.round }
multi sub round(Numeric $a, $scale) { $a.round($scale) }

proto sub infix:<+>(Mu $?, Mu $?) is pure   { * }
multi sub infix:<+>($x = 0)      { $x.Numeric }
multi sub infix:<+>(\a, \b)    { a.Numeric + b.Numeric }

proto sub infix:<->(Mu $?, Mu $?) is pure   { * }
multi sub infix:<->($x = 0)      { -$x.Numeric }
multi sub infix:<->(\a, \b)    { a.Numeric - b.Numeric }

proto sub infix:<*>(Mu $?, Mu $?) is pure   { * }
multi sub infix:<*>($x = 1)      { $x.Numeric }
multi sub infix:<*>(\a, \b)    { a.Numeric * b.Numeric }

sub infix:<>(|c) is pure { infix:<*>(|c) }

proto sub infix:</>(Mu $?, Mu $?) is pure { * }
multi sub infix:</>() { Failure.new("No zero-arg meaning for infix:</>") }
multi sub infix:</>($x)          { $x.Numeric }
multi sub infix:</>(\a, \b)    { a.Numeric / b.Numeric }

sub infix:<>(|c) is pure { infix:</>(|c) }

proto sub infix:<div>(Mu $?, Mu $?) is pure  { * }
# rest of infix:<div> is in Int.pm

proto sub infix:<%>(Mu $?, Mu $?) is pure   { * }
multi sub infix:<%>() { Failure.new("No zero-arg meaning for infix:<%>") }
multi sub infix:<%>($x)          { $x }
multi sub infix:<%>(\a, \b)    { a.Real % b.Real }

proto sub infix:<%%>(Mu $?, Mu $?) is pure  { * }
multi sub infix:<%%>() { Failure.new("No zero-arg meaning for infix:<%%>") }
multi sub infix:<%%>($)         { Bool::True }
multi sub infix:<%%>(Int:D \a, Int:D \b) {
    nqp::if(
      nqp::isbig_I(nqp::decont(a)) || nqp::isbig_I(nqp::decont(b)),
      nqp::if(
        b,
        nqp::p6bool(nqp::not_i(nqp::mod_I(nqp::decont(a),nqp::decont(b),Int))),
        Failure.new(
          X::Numeric::DivideByZero.new(using => 'infix:<%%>', numerator => a)
        )
      ),
      nqp::if(
        nqp::isne_i(b,0),
        nqp::p6bool(nqp::not_i(nqp::mod_i(nqp::decont(a),nqp::decont(b)))),
        Failure.new(
          X::Numeric::DivideByZero.new(using => 'infix:<%%>', numerator => a)
        )
      )
    )
}
multi sub infix:<%%>(\a, \b) {
    nqp::if(
      b,
      (a.Real % b.Real == 0),
      Failure.new(
        X::Numeric::DivideByZero.new(using => 'infix:<%%>', numerator => a)
      )
    )
}

proto sub infix:<lcm>(Mu $?, Mu $?) is pure  { * }
multi sub infix:<lcm>(Int $x = 1) { $x }
multi sub infix:<lcm>(\a, \b)   { a.Int lcm b.Int }

proto sub infix:<gcd>(Mu $?, Mu $?) is pure { * }
multi sub infix:<gcd>() { Failure.new('No zero-arg meaning for infix:<gcd>') }
multi sub infix:<gcd>(Int $x)    { $x }
multi sub infix:<gcd>(\a, \b)  { a.Int gcd b.Int }

proto sub infix:<**>(Mu $?, Mu $?) is pure  { * }
multi sub infix:<**>($x = 1)     { $x.Numeric }
multi sub infix:<**>(\a, \b)   { a.Numeric ** b.Numeric }

proto sub postfix:<>(Mu $, Mu $) is pure  { * }
multi sub postfix:<>(\a, \b)  { a ** b }

## relational operators

proto sub infix:<=>(Mu $, Mu $?) is pure { * }
multi sub infix:<=>(\a, \b)  { a.Real <=> b.Real }

proto sub infix:<==>(Mu $?, Mu $?) is pure { * }
multi sub infix:<==>($?)        { Bool::True }
multi sub infix:<==>(\a, \b)   { a.Numeric == b.Numeric }

proto sub infix:<>(Mu $?, Mu $?, *%) { * }  # note, can't be pure due to dynvar
multi sub infix:<>($?) { Bool::True }
multi sub infix:<>(\a, \b, :$tolerance = $*TOLERANCE)    {
    # If operands are non-0, scale the tolerance to the larger of the abs values.
    # We test b first since $value  0 is the usual idiom and falsifies faster.
    if b && a && $tolerance {
        abs(a - b) < (a.abs max b.abs) * $tolerance;
    }
    else {  # interpret tolerance as absolute
        abs(a.Num - b.Num) < $tolerance;
    }
}
sub infix:<=~=>(|c) { infix:<>(|c) }

proto sub infix:<!=>(Mu $?, Mu $?) is pure  { * }
multi sub infix:<!=>($?)                    { Bool::True }
multi sub infix:<!=>(Mu \a, Mu \b)          { not a == b }
proto sub infix:<> (Mu $?, Mu $?) is pure  { * }
multi sub infix:<> ($?)                    { Bool::True }
multi sub infix:<> (Mu \a, Mu \b)          { not a == b }

proto sub infix:<(Mu $?, Mu $?) is pure   { * }
multi sub infix:<($?)         { Bool::True }
multi sub infix:<(\a, \b)    { a.Real < b.Real }

proto sub infix:<=(Mu $?, Mu $?) is pure { * }
multi sub infix:<=($?)                   { Bool::True }
multi sub infix:<=(\a, \b)               { a.Real <= b.Real }
proto sub infix: (Mu $?, Mu $?) is pure { * }
multi sub infix: ($?)                   { Bool::True }
multi sub infix: (\a, \b)               { a.Real   b.Real }

proto sub infix:>(Mu $?, Mu $?) is pure   { * }
multi sub infix:>($?)         { Bool::True }
multi sub infix:>(\a, \b)    { a.Real > b.Real }

proto sub infix:>=(Mu $?, Mu $?) is pure  { * }
multi sub infix:>=($?)                    { Bool::True }
multi sub infix:>=(\a, \b)                { a.Real >= b.Real }
proto sub infix: (Mu $?, Mu $?) is pure  { * }
multi sub infix: ($?)                    { Bool::True }
multi sub infix: (\a, \b)                { a.Real   b.Real }


## bitwise operators

proto sub infix:<+&>(Mu $?, Mu $?) is pure { * }
multi sub infix:<+&>()           { +^0 }
multi sub infix:<+&>($x)         { $x }
multi sub infix:<+&>($x, $y)     { $x.Numeric.Int +& $y.Numeric.Int }

proto sub infix:<+|>(Mu $?, Mu $?) is pure { * }
multi sub infix:<+|>()           { 0 }
multi sub infix:<+|>($x)         { $x }
multi sub infix:<+|>($x, $y)     { $x.Numeric.Int +| $y.Numeric.Int }

proto sub infix:<+^>(Mu $?, Mu $?) is pure { * }
multi sub infix:<+^>()           { 0 }
multi sub infix:<+^>($x)         { $x }
multi sub infix:<+^>($x, $y)     { $x.Numeric.Int +^ $y.Numeric.Int }

proto sub infix:+<(Mu $?, Mu $?) is pure { * }
multi sub infix:+<() { Failure.new("No zero-arg meaning for infix:+<") }
multi sub infix:+<($x)         { $x }
multi sub infix:+<($x,$y)      { $x.Numeric.Int +< $y.Numeric.Int }

proto sub infix:+>(Mu $?, Mu $?) is pure { * }
multi sub infix:+>() { Failure.new("No zero-arg meaning for infix:+>") }
multi sub infix:+>($x)         { $x }
multi sub infix:+>($x,$y)      { $x.Numeric.Int +> $y.Numeric.Int }

proto sub prefix:<+^>(Mu $) is pure { * }
multi sub prefix:<+^>($x)        { +^ $x.Numeric.Int }

#line 1 SETTING::src/core/Real.pm
my class Complex { ... }

my role Real does Numeric {
    method Rat(Real:D: Real $epsilon = 1.0e-6) { self.Bridge.Rat($epsilon) }
    method abs()  { self < 0 ?? -self !! self }
    method sign(Real:D:) { self > 0 ?? 1 !! self < 0 ?? -1 !! +self }
    method conj(Real:D:) { self }
    method sqrt() { self.Bridge.sqrt }
    method rand() { self.Bridge.rand }
    method sin()  { self.Bridge.sin }
    method asin() { self.Bridge.asin }
    method cos()  { self.Bridge.cos }
    method acos() { self.Bridge.acos }
    method tan()  { self.Bridge.tan }
    method atan() { self.Bridge.atan }
    proto method atan2(|) {*}
    multi method atan2(Real $x = 1e0) { self.Bridge.atan2($x.Bridge) }
    multi method atan2(Cool $x = 1e0) { self.Bridge.atan2($x.Numeric.Bridge) }
    method sec() { self.Bridge.sec }
    method asec() { self.Bridge.asec }
    method cosec() { self.Bridge.cosec }
    method acosec() { self.Bridge.acosec }
    method cotan()  { self.Bridge.cotan }
    method acotan() { self.Bridge.acotan }
    method sinh() { self.Bridge.sinh }
    method asinh() { self.Bridge.asinh }
    method cosh() { self.Bridge.cosh }
    method acosh() { self.Bridge.acosh }
    method tanh() { self.Bridge.tanh }
    method atanh() { self.Bridge.atanh }
    method sech() { self.Bridge.sech }
    method asech() { self.Bridge.asech }
    method cosech() { self.Bridge.cosech }
    method acosech() { self.Bridge.acosech }
    method cotanh() { self.Bridge.cotanh }
    method acotanh() { self.Bridge.acotanh }
    method floor() { self.Bridge.floor }
    method ceiling() { self.Bridge.ceiling }

    proto method round(|) { * }
    multi method round(Real:D:) {
        (self + 1/2).floor; # Rat NYI here, so no .5
    }
    multi method round(Real:D: Real() $scale) {
        (self / $scale + 1/2).floor * $scale;
    }

    method unpolar(Real $angle) {
        Complex.new(self * $angle.cos, self * $angle.sin);
    }
    method cis() {
        Complex.new(self.cos, self.sin);
    }
    method Complex() { Complex.new(self.Num, 0e0) }
    proto method log(|) {*}
    multi method log(Real:D: )           { self.Bridge.log               }
    multi method log(Real:D: Real $base) { self.Bridge.log($base.Bridge) }
    proto method exp(|) {*}
    multi method exp(Real:D: )           { self.Bridge.exp               }
    method truncate(Real:D:) {
        self == 0 ?? 0 !! self < 0  ?? self.ceiling !! self.floor
    }
    method isNaN { Bool::False }

    method polymod(Real:D: +@mods) {
        my $more = self;
        my $lazy = @mods.is-lazy;
        fail X::OutOfRange.new(
          :what('invocant to polymod'), :got($more), :range<0..Inf>
        ) if $more < 0;
        gather {
            for @mods -> $mod {
                last if $lazy and not $more;
                Failure.new(X::Numeric::DivideByZero.new:
                  using => 'polymod', numerator => $more
                ) unless $mod;
                take my $rem = $more % $mod;
                $more -= $rem;
                $more /= $mod;
            }
            take $more if ($lazy and $more) or not $lazy;
        }
    }

    method base(Int:D $base, $digits? is copy) {
        $digits = Nil if nqp::istype($digits, Whatever);
        fail X::OutOfRange.new(
                :what('digits argument to base'), :got($digits),
                :range<0..1073741824>
            ) if $digits.defined and $digits < 0;
        my $prec = $digits // 1e8.log($base.Num).Int;
        my Int $int_part = self.Int.self; # .self blows up Failures
        my $frac = abs(self - $int_part);
        my @frac_digits;
        my @conversion := <0 1 2 3 4 5 6 7 8 9
                           A B C D E F G H I J
                           K L M N O P Q R S T
                           U V W X Y Z>;
        for ^$prec {
            last unless $digits // $frac;
            $frac = $frac * $base;
            push @frac_digits, $frac.Int;
            $frac = $frac - $frac.Int;
        }
        if 2 * $frac >= 1 {
            if @frac_digits {
                for @frac_digits-1 ... 0 -> $x {
                    last if ++@frac_digits[$x] < $base;
                    @frac_digits[$x] = 0;
                    $int_part++ if $x == 0
                }
            }
            else {
                $int_part++;
            }
        }
        my Str $r = $int_part.base($base);
        $r ~= '.' ~ @conversion[@frac_digits].join if @frac_digits;
        # if $int_part is 0, $int_part.base doesn't see the sign of self
        $int_part == 0 && self < 0 ?? '-' ~ $r !! $r;
    }

    method Real(Real:D:) { self }
    method Bridge(Real:D:) { self.Num }
    method Int(Real:D:) { self.Bridge.Int }
    method Num(Real:D:) { self.Bridge.Num }
    multi method Str(Real:D:) { self.Bridge.Str }
}

proto sub cis($) {*}
multi sub cis(Real $a) { $a.cis }

multi sub infix:<+>(Real \a, Real \b)   { a.Bridge + b.Bridge }

multi sub infix:<->(Real \a, Real \b)   { a.Bridge - b.Bridge }

multi sub infix:<*>(Real \a, Real \b)   { a.Bridge * b.Bridge }

multi sub infix:</>(Real \a, Real \b)   { a.Bridge / b.Bridge }

multi sub infix:<%>(Real \a, Real \b)   { a.Bridge % b.Bridge }

multi sub infix:<**>(Real \a, Real \b)  { a.Bridge ** b.Bridge }

multi sub infix:<=>(Real \a, Real \b) { a.Bridge <=> b.Bridge }

multi sub infix:<==>(Real \a, Real \b)  { a.Bridge == b.Bridge }

multi sub infix:<(Real \a, Real \b)   { a.Bridge < b.Bridge }

multi sub infix:<=(Real \a, Real \b)  { a.Bridge <= b.Bridge }
multi sub infix: (Real \a, Real \b)  { a.Bridge   b.Bridge }

multi sub infix:>(Real \a, Real \b)   { a.Bridge > b.Bridge }

multi sub infix:>=(Real \a, Real \b)  { a.Bridge >= b.Bridge }
multi sub infix: (Real \a, Real \b)  { a.Bridge   b.Bridge }

multi sub prefix:<->(Real:D \a)            { -a.Bridge }

# NOTE: According to the spec, infix:<mod> is "Not coercive,
# so fails on differing types."  Thus no casts here.
proto sub infix:<mod>($, $) is pure {*}
multi sub infix:<mod>(Real $a, Real $b) {
    $a - ($a div $b) * $b;
}

multi sub abs(Real \a) {
    a < 0 ?? -a !! a;
}

proto sub truncate($) {*}
multi sub truncate(Real:D $x) { $x.truncate }
multi sub truncate(Cool:D $x) { $x.Numeric.truncate }


proto sub atan2($, $?)    { * }
multi sub atan2(Real \a, Real \b = 1e0) { a.Bridge.atan2(b.Bridge) }
# should really be (Cool, Cool), and then (Cool, Real) and (Real, Cool)
# candidates, but since Int both conforms to Cool and Real, we'd get lots
# of ambiguous dispatches. So just go with (Any, Any) for now.
multi sub atan2(     \a,      \b = 1e0) { a.Numeric.atan2(b.Numeric) }

proto sub unpolar($, $) {*}
multi sub unpolar(Real $mag, Real $angle) { $mag.unpolar($angle) }

#line 1 SETTING::src/core/Int.pm
my class Rat { ... }
my class X::Cannot::Capture       { ... }
my class X::Numeric::DivideByZero { ... }
my class X::NYI::BigInt { ... }

my class Int { ... }
my subset UInt of Int where {not .defined or $_ >= 0};

my class Int does Real { # declared in BOOTSTRAP
    # class Int is Cool
    #     has bigint $!value is box_target;

    multi method WHICH(Int:D:) {
        nqp::box_s(
          nqp::concat(
            nqp::if(
              nqp::eqaddr(self.WHAT,Int),
              'Int|',
              nqp::concat(nqp::unbox_s(self.^name), '|')
            ),
            nqp::tostr_I(self)
          ),
          ObjAt
        )
    }

    proto method new(|) {*}
    multi method new(      \value) { self.new: value.Int }
    multi method new(int   \value) {
        # rebox the value, so we get rid of any potential mixins
        nqp::div_I(nqp::decont(value), 1, self)
    }
    multi method new(Int:D \value = 0) {
        # rebox the value, so we get rid of any potential mixins
        nqp::div_I(nqp::decont(value), 1, self)
    }

    multi method perl(Int:D:) {
        self.Str;
    }
    multi method Bool(Int:D:) {
        nqp::p6bool(nqp::bool_I(self));
    }

    method Capture() { die X::Cannot::Capture.new: :what(self) }

    method Int() { self }

    multi method Str(Int:D:) {
        nqp::p6box_s(nqp::tostr_I(self));
    }

    method Num(Int:D:) {
        nqp::p6box_n(nqp::tonum_I(self));
    }

    method Rat(Int:D: $?) {
        Rat.new(self, 1);
    }
    method FatRat(Int:D: $?) {
        FatRat.new(self, 1);
    }

    method abs(Int:D:) {
        nqp::abs_I(self, Int)
    }

    method Bridge(Int:D:) {
        nqp::p6box_n(nqp::tonum_I(self));
    }

    method chr(Int:D:) {
        nqp::if(
          nqp::isbig_I(self),
            die("chr codepoint %i (0x%X) is too large".sprintf(self, self)),
          nqp::p6box_s(nqp::chr(nqp::unbox_i(self)))
        )
    }

    method sqrt(Int:D:) { nqp::p6box_n(nqp::sqrt_n(nqp::tonum_I(self))) }

    proto method base(|) { * }
    multi method base(Int:D: Int:D $base) {
        2 <= $base <= 36
          ?? nqp::p6box_s(nqp::base_I(self,nqp::unbox_i($base)))
          !! Failure.new(X::OutOfRange.new(
               what => "base argument to base", :got($base), :range<2..36>))
    }
    multi method base(Int:D: Int(Cool) $base, $digits?) {
        2 <= $base <= 36
          ?? $digits && ! nqp::istype($digits, Whatever)
            ?? $digits < 0
              ?? Failure.new(X::OutOfRange.new(
                   :what('digits argument to base'),:got($digits),:range<0..1073741824>))
              !!  nqp::p6box_s(nqp::base_I(self,nqp::unbox_i($base)))
                    ~ '.'
                    ~ '0' x $digits
            !! nqp::p6box_s(nqp::base_I(self,nqp::unbox_i($base)))
          !! Failure.new(X::OutOfRange.new(
               :what('base argument to base'),:got($base),:range<2..36>))
    }

    # If self is Int, we assume mods are Ints also.  (div fails otherwise.)
    # If do-not-want, user should cast invocant to proper domain.
    method polymod(Int:D: +@mods) {
        fail X::OutOfRange.new(
          :what('invocant to polymod'), :got(self), :range<0..^Inf>
        ) if self < 0;

        gather {
            my $more = self;
            if @mods.is-lazy {
                for @mods -> $mod {
                    $more
                      ?? $mod
                        ?? take $more mod $mod
                        !! Failure.new(X::Numeric::DivideByZero.new:
                             using => 'polymod', numerator => $more)
                      !! last;
                    $more = $more div $mod;
                }
                take $more if $more;
            }
            else {
                for @mods -> $mod {
                    $mod
                      ?? take $more mod $mod
                      !! Failure.new(X::Numeric::DivideByZero.new:
                           using => 'polymod', numerator => $more);
                    $more = $more div $mod;
                }
                take $more;
            }
        }
    }

    method expmod(Int:D: Int:D \base, Int:D \mod) {
        nqp::expmod_I(self, nqp::decont(base), nqp::decont(mod), Int);
    }
    method is-prime(Int:D: --> Bool:D) {
        nqp::p6bool(nqp::isprime_I(self, nqp::unbox_i(100)));
    }

    method floor(Int:D:) { self }
    method ceiling(Int:D:) { self }
    proto method round(|) {*}
    multi method round(Int:D:) { self }
    multi method round(Int:D: Real(Cool) $scale) { (self / $scale + 1/2).floor * $scale }

    method lsb(Int:D:) {
        return Nil if self == 0;
        my $lsb = 0;
        my $x = self.abs;
        while $x +& 0xff == 0 { $lsb += 8; $x +>= 8; }
        while $x +& 0x01 == 0 { $lsb++; $x +>= 1; }
        $lsb;
    }

    method msb(Int:D:) {
        return Nil if self == 0;
        return 0 if self == -1;
        my $msb = 0;
        my $x = self;
        $x = ($x + 1) * -2 if $x < 0;   # handle negative conversions
        while $x > 0xff   { $msb += 8; $x +>= 8; }
        if    $x > 0x0f   { $msb += 4; $x +>= 4; }
        if    $x +& 0x8   { $msb += 3; }
        elsif $x +& 0x4   { $msb += 2; }
        elsif $x +& 0x2   { $msb += 1; }
        $msb;
    }

    method narrow(Int:D:) { self }

    method Range(Int:U:) {
        given self {
            when int  { $?BITS == 64 ??  int64.Range !!  int32.Range }
            when uint { $?BITS == 64 ?? uint64.Range !! uint32.Range }

            when int64  { Range.new(-9223372036854775808, 9223372036854775807) }
            when int32  { Range.new(         -2147483648, 2147483647         ) }
            when int16  { Range.new(              -32768, 32767              ) }
            when int8   { Range.new(                -128, 127                ) }
            # Bring back in a future Perl 6 version, or just put on the type object
            #when int4   { Range.new(                  -8, 7                  ) }
            #when int2   { Range.new(                  -2, 1                  ) }
            #when int1   { Range.new(                  -1, 0                  ) }

            when uint64 { Range.new( 0, 18446744073709551615 ) }
            when uint32 { Range.new( 0, 4294967295           ) }
            when uint16 { Range.new( 0, 65535                ) }
            when uint8  { Range.new( 0, 255                  ) }
            when byte   { Range.new( 0, 255                  ) }
            # Bring back in a future Perl 6 version, or just put on the type object
            #when uint4  { Range.new( 0, 15                   ) }
            #when uint2  { Range.new( 0, 3                    ) }
            #when uint1  { Range.new( 0, 1                    ) }

            default {  # some other kind of Int
                .^name eq 'UInt'
                  ?? Range.new(    0, Inf, :excludes-max )
                  !! Range.new( -Inf, Inf, :excludes-min, :excludes-max )
            }
        }
    }
}

multi sub prefix:<++>(Int:D $a is rw) {
    $a = nqp::add_I(nqp::decont($a), 1, Int);
}
multi sub prefix:<++>(int $a is rw) {
    $a = nqp::add_i($a, 1);
}
multi sub prefix:<-->(Int:D $a is rw) {
    $a = nqp::sub_I(nqp::decont($a), 1, Int);
}
multi sub prefix:<-->(int $a is rw) {
    $a = nqp::sub_i($a, 1);
}
multi sub postfix:<++>(Int:D $a is rw) {
    my \b := nqp::decont($a);
    $a = nqp::add_I(b, 1, Int);
    b
}
multi sub postfix:<++>(int $a is rw) {
    my int $b = $a;
    $a = nqp::add_i($b, 1);
    $b
}
multi sub postfix:<-->(Int:D $a is rw) {
    my \b := nqp::decont($a);
    $a = nqp::sub_I(b, 1, Int);
    b
}
multi sub postfix:<-->(int $a is rw) {
    my int $b = $a;
    $a = nqp::sub_i($b, 1);
    $b
}

multi sub prefix:<->(Int:D \a --> Int:D) {
    nqp::neg_I(nqp::decont(a), Int);
}
multi sub prefix:<->(int $a --> int) {
    nqp::neg_i($a)
}

multi sub abs(Int:D \a --> Int:D) {
    nqp::abs_I(nqp::decont(a), Int);
}
multi sub abs(int $a --> int) {
    nqp::abs_i($a)
}

multi sub infix:<+>(Int:D \a, Int:D \b --> Int:D) {
    nqp::add_I(nqp::decont(a), nqp::decont(b), Int);
}
multi sub infix:<+>(int $a, int $b --> int) {
    nqp::add_i($a, $b)
}

multi sub infix:<->(Int:D \a, Int:D \b --> Int:D) {
    nqp::sub_I(nqp::decont(a), nqp::decont(b), Int);
}
multi sub infix:<->(int $a, int $b --> int) {
    nqp::sub_i($a, $b)
}

multi sub infix:<*>(Int:D \a, Int:D \b --> Int:D) {
    nqp::mul_I(nqp::decont(a), nqp::decont(b), Int);
}
multi sub infix:<*>(int $a, int $b --> int) {
    nqp::mul_i($a, $b);
}

multi sub infix:<div>(Int:D \a, Int:D \b) {
    b
      ?? nqp::div_I(nqp::decont(a), nqp::decont(b), Int)
      !! Failure.new(X::Numeric::DivideByZero.new(:using<div>, :numerator(a)))
}
multi sub infix:<div>(int $a, int $b --> int) {
    # relies on opcode or hardware to detect division by 0
    nqp::div_i($a, $b)
}

multi sub infix:<%>(Int:D \a, Int:D \b --> Int:D) {
    nqp::if(
      nqp::isbig_I(nqp::decont(a)) || nqp::isbig_I(nqp::decont(b)),
      nqp::if(
        b,
        nqp::mod_I(nqp::decont(a),nqp::decont(b),Int),
        Failure.new(X::Numeric::DivideByZero.new(:using<%>, :numerator(a)))
      ),
      nqp::if(
        nqp::isne_i(b,0),
        nqp::mod_i(    # quick fix RT #128318
          nqp::add_i(nqp::mod_i(nqp::decont(a),nqp::decont(b)),b),
          nqp::decont(b)
        ),
        Failure.new(X::Numeric::DivideByZero.new(:using<%>, :numerator(a)))
      )
    )
}
multi sub infix:<%>(int $a, int $b --> int) {
    # relies on opcode or hardware to detect division by 0
    nqp::mod_i(nqp::add_i(nqp::mod_i($a,$b),$b),$b) # quick fix RT #128318
}

multi sub infix:<**>(Int:D \a, Int:D \b) {
    my $power := nqp::pow_I(nqp::decont(a), nqp::decont(b >= 0 ?? b !! -b), Num, Int);
    # when a**b is too big nqp::pow_I returns Inf
    nqp::istype($power, Num)
        ?? Failure.new(
            b >= 0 ?? X::Numeric::Overflow.new !! X::Numeric::Underflow.new
        ) !! b >= 0 ?? $power
            !! ($power := 1 / $power) == 0 && a != 0
                ?? Failure.new(X::Numeric::Underflow.new)
                    !! $power;
}

multi sub infix:<**>(int $a, int $b --> int) {
    nqp::pow_i($a, $b);
}

multi sub infix:<lcm>(Int:D \a, Int:D \b --> Int:D) {
    nqp::lcm_I(nqp::decont(a), nqp::decont(b), Int);
}
multi sub infix:<lcm>(int $a, int $b --> int) {
    nqp::lcm_i($a, $b)
}

multi sub infix:<gcd>(Int:D \a, Int:D \b --> Int:D) {
    nqp::gcd_I(nqp::decont(a), nqp::decont(b), Int);
}
multi sub infix:<gcd>(int $a, int $b --> int) {
    nqp::gcd_i($a, $b)
}

multi sub infix:<===>(Int:D \a, Int:D \b) {
    nqp::p6bool(
      nqp::eqaddr(a.WHAT,b.WHAT)
      && nqp::iseq_I(nqp::decont(a), nqp::decont(b))
    )
}
multi sub infix:<===>(int $a, int $b) {
    # hey, the optimizer is smart enough to figure that one out for us, no?
    $a == $b
}

multi sub infix:<==>(Int:D \a, Int:D \b) {
    nqp::p6bool(nqp::iseq_I(nqp::decont(a), nqp::decont(b)))
}
multi sub infix:<==>(int $a, int $b) {
    nqp::p6bool(nqp::iseq_i($a, $b))
}

multi sub infix:<!=>(int $a, int $b) { nqp::p6bool(nqp::isne_i($a, $b)) }
multi sub infix:<> (int $a, int $b) { nqp::p6bool(nqp::isne_i($a, $b)) }

multi sub infix:<(Int:D \a, Int:D \b) {
    nqp::p6bool(nqp::islt_I(nqp::decont(a), nqp::decont(b)))
}
multi sub infix:<(int $a, int $b) {
    nqp::p6bool(nqp::islt_i($a, $b))
}

multi sub infix:<=(Int:D \a, Int:D \b) {
    nqp::p6bool(nqp::isle_I(nqp::decont(a), nqp::decont(b)))
}
multi sub infix:<=(int $a, int $b) {
    nqp::p6bool(nqp::isle_i($a, $b))
}
multi sub infix:(Int:D \a, Int:D \b) {
    nqp::p6bool(nqp::isle_I(nqp::decont(a), nqp::decont(b)))
}
multi sub infix:(int $a, int $b) {
    nqp::p6bool(nqp::isle_i($a, $b))
}

multi sub infix:>(Int:D \a, Int:D \b) {
    nqp::p6bool(nqp::isgt_I(nqp::decont(a), nqp::decont(b)))
}
multi sub infix:>(int $a, int $b) {
    nqp::p6bool(nqp::isgt_i($a, $b))
}

multi sub infix:>=(Int:D \a, Int:D \b) {
    nqp::p6bool(nqp::isge_I(nqp::decont(a), nqp::decont(b)))
}
multi sub infix:>=(int $a, int $b) {
    nqp::p6bool(nqp::isge_i($a, $b))
}
multi sub infix:(Int:D \a, Int:D \b) {
    nqp::p6bool(nqp::isge_I(nqp::decont(a), nqp::decont(b)))
}
multi sub infix:(int $a, int $b) {
    nqp::p6bool(nqp::isge_i($a, $b))
}

multi sub infix:<+|>(Int:D \a, Int:D \b) {
    nqp::bitor_I(nqp::decont(a), nqp::decont(b), Int)
}
#multi sub infix:<+|>(int $a, int $b) { RT#128655
#    nqp::bitor_i($a, $b)
#}

multi sub infix:<+&>(Int:D \a, Int:D \b) {
    nqp::bitand_I(nqp::decont(a), nqp::decont(b), Int)
}
#multi sub infix:<+&>(int $a, int $b) { RT#128655
#    nqp::bitand_i($a, $b)
#}

multi sub infix:<+^>(Int:D \a, Int:D \b) {
    nqp::bitxor_I(nqp::decont(a), nqp::decont(b), Int)
}
#multi sub infix:<+^>(int $a, int $b) { RT#128655
#    nqp::bitxor_i($a, $b);
#}

multi sub infix:+<(Int:D \a, Int:D \b --> Int:D) {
    nqp::bitshiftl_I(nqp::decont(a), nqp::unbox_i(b), Int)
}
#multi sub infix:+<(int $a, int $b) { RT#128655
#    nqp::bitshiftl_i($a, $b);
#}

multi sub infix:+>(Int:D \a, Int:D \b --> Int:D) {
    nqp::bitshiftr_I(nqp::decont(a), nqp::unbox_i(b), Int)
}
#multi sub infix:+>(int $a, int $b) { RT#128655
#    nqp::bitshiftr_i($a, $b)
#}

multi sub prefix:<+^>(Int:D \a) {
    nqp::bitneg_I(nqp::decont(a), Int);
}
#multi sub prefix:<+^>(int $a) { RT#128655
#    nqp::bitneg_i($a);
#}

proto sub chr($) is pure  {*}
multi sub chr(Int:D  \x --> Str:D) { x.chr     }
multi sub chr(Cool \x --> Str:D) { x.Int.chr }
multi sub chr(int $x --> str) {
    nqp::chr($x);
}

proto sub is-prime($) is pure  {*}
multi sub is-prime(Int:D \i) {
    nqp::p6bool(nqp::isprime_I(nqp::decont(i), nqp::unbox_i(100)));
}
multi sub is-prime(\i) {
    i == i.floor
     && nqp::p6bool(nqp::isprime_I(nqp::decont(i.Int), nqp::unbox_i(100)));
}

proto sub expmod($, $, $) is pure  {*}
multi sub expmod(Int:D \base, Int:D \exp, Int:D \mod) {
    nqp::expmod_I(nqp::decont(base), nqp::decont(exp), nqp::decont(mod), Int);
}
multi sub expmod(\base, \exp, \mod) {
    nqp::expmod_I(nqp::decont(base.Int), nqp::decont(exp.Int), nqp::decont(mod.Int), Int);
}

proto sub lsb($) {*}
multi sub lsb(Int:D \i) { i.lsb }

proto sub msb($) {*}
multi sub msb(Int:D \i) { i.msb }

#line 1 SETTING::src/core/Bool.pm
# enum Bool declared in BOOTSTRAP
BEGIN {
    Bool.^add_method('Bool',    my proto method Bool(|)    { * });
    Bool.^add_method('gist',    my proto method gist(|)    { * });
    Bool.^add_method('Numeric', my proto method Numeric(|) { * });
    Bool.^add_method('Int',     my proto method Int(|)     { * });
    Bool.^add_method('ACCEPTS', my proto method ACCEPTS(|) { * });
    Bool.^add_method('pick',    my proto method pick(|) { * });
    Bool.^add_method('roll',    my proto method roll(|) { * });
    Bool.^add_method('perl',    my proto method perl(|) { * });
}
BEGIN {
    Bool.^add_multi_method('Bool',    my multi method Bool(Bool:D:)    { self });
    Bool.^add_multi_method('gist',    my multi method gist(Bool:D:)    { self ?? 'True' !! 'False' });
    Bool.^add_multi_method('Str',     my multi method Str(Bool:D:)     { self ?? 'True' !! 'False' });
    Bool.^add_multi_method('Numeric', my multi method Numeric(Bool:D:) { self ?? 1 !! 0 });
    Bool.^add_multi_method('Int',     my multi method Int(Bool:D:)     { self ?? 1 !! 0 });
    Bool.^add_multi_method('Real',    my multi method Real(Bool:D:)    { self ?? 1 !! 0 });
    Bool.^add_multi_method('ACCEPTS', my multi method ACCEPTS(Bool:D: Mu \topic ) { self });
    Bool.^add_multi_method('perl', my multi method perl(Bool:D:) { self ?? 'Bool::True' !! 'Bool::False' });

    Bool.^add_multi_method('pick', my multi method pick(Bool:U:)    { nqp::p6bool(nqp::isge_n(nqp::rand_n(2e0), 1e0)) });
    Bool.^add_multi_method('roll', my multi method roll(Bool:U:)    { nqp::p6bool(nqp::isge_n(nqp::rand_n(2e0), 1e0)) });
}
BEGIN {
    Bool.^add_multi_method('Bool',    my multi method Bool(Bool:U:)    { Bool::False });
    Bool.^add_multi_method('ACCEPTS', my multi method ACCEPTS(Bool:U: \topic ) { nqp::istype(topic, Bool) });
    Bool.^add_multi_method('gist',    my multi method gist(Bool:U:)    { '(Bool)' });
    Bool.^add_multi_method('perl', my multi method perl(Bool:U:) { 'Bool' });

    Bool.^add_multi_method('pick', my multi method pick(Bool:U: $n) { self.^enum_value_list.pick($n) });
    Bool.^add_multi_method('roll', my multi method roll(Bool:U: $n) { self.^enum_value_list.roll($n) });

    Bool.^add_method('pred',  my method pred() { Bool::False });
    Bool.^add_method('succ',  my method succ() { Bool::True });

    Bool.^add_method('enums', my method enums() { self.^enum_values.Map });

    Bool.^compose;
}

multi sub prefix:<++>(Bool $a is rw)  { $a = True; }
multi sub prefix:<-->(Bool $a is rw)  { $a = False; }
multi sub postfix:<++>(Bool:U $a is rw --> False) { $a = True }
multi sub postfix:<-->(Bool:U $a is rw) { $a = False; }

multi sub postfix:<++>(Bool:D $a is rw) {
    if $a {
        True
    }
    else {
        $a = True;
        False
    }
}
multi sub postfix:<-->(Bool:D $a is rw) {
    if $a {
        $a = False;
        True
    }
    else {
        False
    }
}

proto sub prefix:<?>(Mu $) is pure { * }
multi sub prefix:<?>(Bool:D \a) { a }
multi sub prefix:<?>(Bool:U \a) { Bool::False }
multi sub prefix:<?>(Mu \a) { a.Bool }

proto sub prefix:<so>(Mu $) is pure { * }
multi sub prefix:<so>(Bool:D \a) { a }
multi sub prefix:<so>(Bool:U \a) { Bool::False }
multi sub prefix:<so>(Mu \a) { a.Bool }

proto sub prefix:<!>(Mu $) is pure { * }
multi sub prefix:<!>(Bool \a) { nqp::p6bool(nqp::not_i(nqp::istrue(a))) }
multi sub prefix:<!>(Mu \a) { nqp::p6bool(nqp::not_i(nqp::istrue(a))) }

proto sub prefix:<not>(Mu $) is pure { * }
multi sub prefix:<not>(Bool \a) { nqp::p6bool(nqp::not_i(nqp::istrue(a))) }
multi sub prefix:<not>(Mu \a) { nqp::p6bool(nqp::not_i(nqp::istrue(a))) }

proto sub prefix:<?^>(Mu $) is pure { * }
multi sub prefix:<?^>(Mu \a) { not a }

proto sub infix:<?&>(Mu $?, Mu $?) is pure { * }
multi sub infix:<?&>(Mu $x = Bool::True) { $x.Bool }
multi sub infix:<?&>(Mu \a, Mu \b)       { a.Bool && b.Bool }

proto sub infix:<?|>(Mu $?, Mu $?) is pure { * }
multi sub infix:<?|>(Mu $x = Bool::False) { $x.Bool }
multi sub infix:<?|>(Mu \a, Mu \b)        { a.Bool || b.Bool }

proto sub infix:<?^>(Mu $?, Mu $?) is pure { * }
multi sub infix:<?^>(Mu $x = Bool::False) { $x.Bool }
multi sub infix:<?^>(Mu \a, Mu \b)        { nqp::p6bool(nqp::ifnull(nqp::xor(a.Bool,b.Bool), 0)) }

# These operators are normally handled as macros in the compiler;
# we define them here for use as arguments to functions.
proto sub infix:<&&>(|)                   { * }
multi sub infix:<&&>(Mu $x = Bool::True)  { $x }
multi sub infix:<&&>(Mu \a, &b)           { a && b() }
multi sub infix:<&&>(Mu \a, Mu \b)        { a && b }

proto sub infix:<||>(|)                   { * }
multi sub infix:<||>(Mu $x = Bool::False) { $x }
multi sub infix:<||>(Mu \a, &b)           { a || b() }
multi sub infix:<||>(Mu \a, Mu \b)        { a || b }

proto sub infix:<^^>(|)                   { * }
multi sub infix:<^^>(Mu $x = Bool::False) { $x }
multi sub infix:<^^>(Mu \a, &b)           { a ^^ b() }
multi sub infix:<^^>(Mu \a, Mu \b)        { a ^^ b }
multi sub infix:<^^>(+@a) {
    my Mu $a = shift @a;
    while @a {
        my Mu $b := shift @a;
        $b := $b() if $b ~~ Callable;
        next unless $b;
        return Nil if $a;
        $a := $b;
    }
    $a;
}

proto sub infix:<//>(|)                   { * }
multi sub infix:<//>(Mu $x = Any)         { $x }
multi sub infix:<//>(Mu \a, &b)           { a // b }
multi sub infix:<//>(Mu \a, Mu \b)        { a // b }

proto sub infix:<and>(|)                  { * }
multi sub infix:<and>(Mu $x = Bool::True) { $x }
multi sub infix:<and>(Mu \a, &b)          { a && b }
multi sub infix:<and>(Mu \a, Mu \b)       { a && b }

proto sub infix:<or>(|)                   { * }
multi sub infix:<or>(Mu $x = Bool::False) { $x }
multi sub infix:<or>(Mu \a, &b)           { a || b }
multi sub infix:<or>(Mu \a, Mu \b)        { a || b }

proto sub infix:<xor>(|)                  { * }
multi sub infix:<xor>(Mu $x = Bool::False) { $x }
multi sub infix:<xor>(Mu \a, &b)          { a ^^ b }
multi sub infix:<xor>(Mu \a, Mu \b)       { a ^^ b }
multi sub infix:<xor>(|c)                 { &infix:<^^>(|c); }

#line 1 SETTING::src/core/Order.pm
## Order enumeration, for cmp and <=>
my enum Order (:Less(-1), :Same(0), :More(1));
role Rational { ... }

sub ORDER(int $i) {
    nqp::iseq_i($i,0) ?? Same !! nqp::islt_i($i,0) ?? Less !! More
}

proto sub infix:<cmp>(Mu $, Mu $) is pure { * }
multi sub infix:<cmp>(\a, \b) {
    nqp::eqaddr(a,b)
      ?? Same
      !! a.Stringy cmp b.Stringy
}
multi sub infix:<cmp>(Real:D \a, \b) {
     a === -Inf
       ?? Less
       !! a === Inf
         ?? More
         !! a.Stringy cmp b.Stringy
}
multi sub infix:<cmp>(\a, Real:D \b) {
     b === Inf
       ?? Less
       !! b === -Inf
         ?? More
         !! a.Stringy cmp b.Stringy
}

multi sub infix:<cmp>(Real:D \a, Real:D \b) {
       (nqp::istype(a, Rational) && nqp::isfalse(a.denominator))
    || (nqp::istype(b, Rational) && nqp::isfalse(b.denominator))
    ?? a.Bridge cmp b.Bridge
    !! a === -Inf || b === Inf
        ?? Less
        !! a === Inf || b === -Inf
            ?? More
            !! a.Bridge cmp b.Bridge
}
multi sub infix:<cmp>(Int:D \a, Rational:D \b) {
    a.isNaN || b.isNaN ?? a.Num cmp b.Num !! a <=> b
}
multi sub infix:<cmp>(Rational:D \a, Int:D \b) {
    a.isNaN || b.isNaN ?? a.Num cmp b.Num !! a <=> b
}
multi sub infix:<cmp>(Int:D \a, Int:D \b) {
    ORDER(nqp::cmp_I(nqp::decont(a), nqp::decont(b)))
}
multi sub infix:<cmp>(int $a, int $b) {
    ORDER(nqp::cmp_i($a, $b))
}

multi sub infix:<=>(Int:D \a, Int:D \b) {
    ORDER(nqp::cmp_I(nqp::decont(a), nqp::decont(b)))
}
multi sub infix:<=>(int $a, int $b) {
    ORDER(nqp::cmp_i($a, $b))
}

#line 1 SETTING::src/core/UInt64.pm
my Int $UINT64_UPPER = nqp::pow_I(2, 64, Num, Int);
subset UInt64 of Int where { 0 <= $_ < $UINT64_UPPER }

#line 1 SETTING::src/core/Num.pm
my class X::Cannot::Capture        { ... }
my class X::Numeric::DivideByZero  { ... }
my class X::Numeric::CannotConvert { ... }
my role Rational { ... }

my class Num does Real { # declared in BOOTSTRAP
    # class Num is Cool
    #     has num $!value is box_target;

    multi method WHICH(Num:D:) {
        nqp::box_s(
          nqp::concat(
            nqp::if(
              nqp::eqaddr(self.WHAT,Num),
              'Num|',
              nqp::concat(nqp::unbox_s(self.^name), '|')
            ),
            nqp::unbox_n(self)
          ),
          ObjAt
        )
    }
    method Capture() { die X::Cannot::Capture.new: :what(self) }
    method Num() { self }
    method Bridge(Num:D:) { self }
    method Range(Num:U:) { Range.new(-Inf,Inf) }

    method Int(Num:D:) {
        nqp::isnanorinf(nqp::unbox_n(self))
          ?? X::Numeric::CannotConvert.new(:source(self), :target(Int)).fail
          !! nqp::fromnum_I(nqp::unbox_n(self),Int)
    }

    multi method new() { nqp::box_n(0e0, self) }
    multi method new($n) { nqp::box_n($n.Num, self) }

    multi method perl(Num:D:) {
        my str $res = self.Str;
        nqp::isnanorinf(nqp::unbox_n(self))
          || nqp::isge_i(nqp::index($res,'e'),0)
          || nqp::isge_i(nqp::index($res,'E'),0)
          ?? $res
          !! nqp::concat($res,'e0')
    }

    method Rat(Num:D: Real $epsilon = 1.0e-6, :$fat) {
        return Rational[Num,Int].new(self,0)
          if nqp::isnanorinf(nqp::unbox_n(self));

        my Num $num = self;
        $num = -$num if (my int $signum = $num < 0);
        my num $r = $num - floor($num);

        # basically have an Int
        if nqp::iseq_n($r,0e0) {
            $fat
              ?? FatRat.new(nqp::fromnum_I(self,Int),1)
              !!    Rat.new(nqp::fromnum_I(self,Int),1)
        }

        # find convergents of the continued fraction.
        else {
            my Int $q = nqp::fromnum_I($num, Int);
            my Int $a = 1;
            my Int $b = $q;
            my Int $c = 0;
            my Int $d = 1;

            while nqp::isne_n($r,0e0) && abs($num - ($b / $d)) > $epsilon {
                my num $modf_arg = 1e0 / $r;
                $q = nqp::fromnum_I($modf_arg, Int);
                $r = $modf_arg - floor($modf_arg);

                my $orig_b = $b;
                $b = $q * $b + $a;
                $a = $orig_b;

                my $orig_d = $d;
                $d = $q * $d + $c;
                $c = $orig_d;
            }

            # Note that this result has less error than any Rational with a
            # smaller denominator but it is not (necessarily) the Rational
            # with the smallest denominator that has less than $epsilon error.
            # However, to find that Rational would take more processing.
            $fat
              ?? FatRat.new($signum ?? -$b !! $b, $d)
              !!    Rat.new($signum ?? -$b !! $b, $d)
        }
    }
    method FatRat(Num:D: Real $epsilon = 1.0e-6) {
        self.Rat($epsilon, :fat);
    }

    multi method atan2(Num:D: Num:D $x = 1e0) {
        nqp::p6box_n(nqp::atan2_n(nqp::unbox_n(self), nqp::unbox_n($x)));
    }

    multi method Str(Num:D:) {
        nqp::p6box_s(nqp::unbox_n(self));
    }

    method succ(Num:D:) { self + 1e0 }

    method pred(Num:D:) { self - 1e0 }

    method isNaN(Num:D: ) {
        self != self;
    }

    method abs(Num:D: ) {
        nqp::p6box_n(nqp::abs_n(nqp::unbox_n(self)));
    }

    multi method exp(Num:D: ) {
        nqp::p6box_n(nqp::exp_n(nqp::unbox_n(self)));
    }

    proto method log(|) {*}
    multi method log(Num:D: ) {
        nqp::p6box_n(nqp::log_n(nqp::unbox_n(self)));
    }
    multi method log(Num:D: Num \base) {
        self.log() / base.log();
    }

    proto method sqrt(|) {*}
    multi method sqrt(Num:D: ) {
        nqp::p6box_n(nqp::sqrt_n(nqp::unbox_n(self)));
    }

    method rand(Num:D: ) {
        nqp::p6box_n(nqp::rand_n(nqp::unbox_n(self)));
    }

    method ceiling(Num:D: ) {
        nqp::isnanorinf(nqp::unbox_n(self))
            ?? self
            !! nqp::fromnum_I(nqp::ceil_n(nqp::unbox_n(self)), Int);
    }
    method floor(Num:D: ) {
        nqp::isnanorinf(nqp::unbox_n(self))
            ?? self
            !! nqp::fromnum_I(nqp::floor_n(nqp::unbox_n(self)), Int);
    }

    proto method sin(|) {*}
    multi method sin(Num:D: ) {
        nqp::p6box_n(nqp::sin_n(nqp::unbox_n(self)));
    }
    proto method asin(|) {*}
    multi method asin(Num:D: ) {
        nqp::p6box_n(nqp::asin_n(nqp::unbox_n(self)));
    }
    proto method cos(|) {*}
    multi method cos(Num:D: ) {
        nqp::p6box_n(nqp::cos_n(nqp::unbox_n(self)));
    }
    proto method acos(|) {*}
    multi method acos(Num:D: ) {
        nqp::p6box_n(nqp::acos_n(nqp::unbox_n(self)));
    }
    proto method tan(|) {*}
    multi method tan(Num:D: ) {
        nqp::p6box_n(nqp::tan_n(nqp::unbox_n(self)));
    }
    proto method atan(|) {*}
    multi method atan(Num:D: ) {
        nqp::p6box_n(nqp::atan_n(nqp::unbox_n(self)));
    }
    proto method sec(|) {*}
    multi method sec(Num:D: ) {
        nqp::p6box_n(nqp::sec_n(nqp::unbox_n(self)));
    }
    proto method asec(|) {*}
    multi method asec(Num:D: ) {
        nqp::p6box_n(nqp::asec_n(nqp::unbox_n(self)));
    }
    method cosec(Num:D:) {
        nqp::p6box_n(nqp::div_n(1e0, nqp::sin_n(nqp::unbox_n(self))));
    }
    method acosec(Num:D:) {
        nqp::p6box_n(nqp::asin_n(nqp::div_n(1e0, nqp::unbox_n(self))));
    }
    method cotan(Num:D:) {
        nqp::p6box_n(nqp::div_n(1e0, nqp::tan_n(nqp::unbox_n(self))));
    }
    method acotan(Num:D:) {
        nqp::p6box_n(nqp::atan_n(nqp::div_n(1e0, nqp::unbox_n(self))));
    }
    proto method sinh(|) {*}
    multi method sinh(Num:D: ) {
        nqp::p6box_n(nqp::sinh_n(nqp::unbox_n(self)));
    }
    proto method asinh(|) {*}
    multi method asinh(Num:D: ) {
        nqp::isnanorinf(self)
            ?? self
            !! (self + (self * self + 1e0).sqrt).log;
    }
    proto method cosh(|) {*}
    multi method cosh(Num:D: ) {
        nqp::p6box_n(nqp::cosh_n(nqp::unbox_n(self)));
    }
    proto method acosh(|) {*}
    multi method acosh(Num:D: ) {
        self < 1e0
            ?? NaN
            !! (self + (self * self - 1e0).sqrt).log;
    }
    proto method tanh(|) {*}
    multi method tanh(Num:D: ) {
        nqp::p6box_n(nqp::tanh_n(nqp::unbox_n(self)));
    }
    proto method atanh(|) {*}
    multi method atanh(1e0:) {  }
    multi method atanh(Num:D: ) {
        ((1e0 + self) / (1e0 - self)).log / 2e0;
    }
    proto method sech(|) {*}
    multi method sech(Num:D: ) {
        nqp::p6box_n(nqp::sech_n(nqp::unbox_n(self)));
    }
    proto method asech(|) {*}
    multi method asech(Num:D: ) {
        (1e0 / self).acosh;
    }
    proto method cosech(|) {*}
    multi method cosech(Num:D: ) {
        nqp::p6box_n(nqp::div_n(1e0, nqp::sinh_n(nqp::unbox_n(self))));
    }
    proto method acosech(|) {*}
    multi method acosech(Num:D: ) {
        (1e0 / self).asinh;
    }
    proto method cotanh(|) {*}
    multi method cotanh(Num:D: ) {
        nqp::p6box_n(nqp::div_n(1e0, nqp::tanh_n(nqp::unbox_n(self))));
    }
    proto method acotanh(|) {*}
    multi method acotanh(Num:D: ) {
        (1e0 / self).atanh;
    }

    method narrow(Num:D:) {
        my $i := self.Int;
        $i.defined && $i.Num  self
            ?? $i
            !! self
    }
}

my constant tau = 6.28318_53071_79586_476e0;
my constant pi  = 3.14159_26535_89793_238e0;
my constant e   = 2.71828_18284_59045_235e0;

my constant  := pi;
my constant  := tau;

my constant  := e;


multi sub prefix:<++>(Num:D $a is rw) {
    $a = nqp::p6box_n(nqp::add_n(nqp::unbox_n($a), 1e0))
}
multi sub prefix:<++>(Num:U $a is rw) {
    $a = 1e0;
}
multi sub prefix:<++>(num $a is rw --> num) {
    $a = nqp::add_n($a, 1e0)
}
multi sub prefix:<-->(Num:D $a is rw) {
    $a = nqp::p6box_n(nqp::sub_n(nqp::unbox_n($a), 1e0))
}
multi sub prefix:<-->(Num:U $a is rw) {
    $a = -1e0;
}
multi sub prefix:<-->(num $a is rw --> num) {
    $a = nqp::sub_n($a, 1e0)
}
multi sub postfix:<++>(Num:D $a is rw) {
    my $b = $a;
    $a = nqp::p6box_n(nqp::add_n(nqp::unbox_n($a), 1e0));
    $b
}
multi sub postfix:<++>(Num:U $a is rw) {
    $a = 1e0;
    0e0
}
multi sub postfix:<++>(num $a is rw --> num) {
    my num $b = $a;
    $a = nqp::add_n($a, 1e0);
    $b
}
multi sub postfix:<-->(Num:D $a is rw) {
    my $b = $a;
    $a = nqp::p6box_n(nqp::sub_n(nqp::unbox_n($a), 1e0));
    $b
}
multi sub postfix:<-->(Num:U $a is rw) {
    $a = -1e0;
    0e0
}
multi sub postfix:<-->(num $a is rw --> num) {
    my num $b = $a;
    $a = nqp::sub_n($a, 1e0);
    $b
}

multi sub prefix:<->(Num:D \a) {
    nqp::p6box_n(nqp::neg_n(nqp::unbox_n(a)))
}
multi sub prefix:<->(num $a --> num) {
    nqp::neg_n($a);
}

multi sub abs(Num:D \a) {
    nqp::p6box_n(nqp::abs_n(nqp::unbox_n(a)))
}
multi sub abs(num $a --> num) {
    nqp::abs_n($a)
}

multi sub infix:<+>(Num:D \a, Num:D \b) {
    nqp::p6box_n(nqp::add_n(nqp::unbox_n(a), nqp::unbox_n(b)))
}
multi sub infix:<+>(num $a, num $b --> num) {
    nqp::add_n($a, $b)
}

multi sub infix:<->(Num:D \a, Num:D \b) {
    nqp::p6box_n(nqp::sub_n(nqp::unbox_n(a), nqp::unbox_n(b)))
}
multi sub infix:<->(num $a, num $b --> num) {
    nqp::sub_n($a, $b)
}

multi sub infix:<*>(Num:D \a, Num:D \b) {
    nqp::p6box_n(nqp::mul_n(nqp::unbox_n(a), nqp::unbox_n(b)))
}
multi sub infix:<*>(num $a, num $b --> num) {
    nqp::mul_n($a, $b)
}

multi sub infix:</>(Num:D \a, Num:D \b) {
    b
      ?? nqp::p6box_n(nqp::div_n(nqp::unbox_n(a), nqp::unbox_n(b)))
      !! Failure.new(X::Numeric::DivideByZero.new(:using</>, :numerator(a)))
}
multi sub infix:</>(num $a, num $b --> num) {
    $b
      ?? nqp::div_n($a, $b)
      !! Failure.new(X::Numeric::DivideByZero.new(:using</>, :numerator($a)))
}

multi sub infix:<%>(Num:D \a, Num:D \b) {
    b
      ?? nqp::p6box_n(nqp::mod_n(nqp::unbox_n(a), nqp::unbox_n(b)))
      !! Failure.new(X::Numeric::DivideByZero.new(:using<%>, :numerator(a)))
}
multi sub infix:<%>(num $a, num $b --> num) {
    $b
      ?? nqp::mod_n($a, $b)
      !! Failure.new(X::Numeric::DivideByZero.new(:using<%>, :numerator($a)))
}

# (If we get 0 here, must be underflow, since floating overflow provides Inf.)
multi sub infix:<**>(Num:D \a, Num:D \b) {
    nqp::p6box_n(nqp::pow_n(nqp::unbox_n(a), nqp::unbox_n(b)))
      or a == 0e0 || b.abs == Inf
        ?? 0e0
        !! Failure.new(X::Numeric::Underflow.new)
}
multi sub infix:<**>(num $a, num $b --> num) {
    nqp::pow_n($a, $b)
      or $a == 0e0 || $b.abs == Inf
        ?? 0e0
        !! Failure.new(X::Numeric::Underflow.new)
}

# Here we sort NaN in with string "NaN"
multi sub infix:<cmp>(Num:D \a, Num:D \b) {
     ORDER(nqp::cmp_n(nqp::unbox_n(a), nqp::unbox_n(b))) or
         a === b ?? Same # === cares about signed zeros, we don't, so:
            !! nqp::iseq_n(a, 0e0) && nqp::iseq_n(b, 0e0)
                ?? Same !! a.Stringy cmp b.Stringy;
}
multi sub infix:<cmp>(num $a, num $b) {
    ORDER(nqp::cmp_n($a, $b)) or
         $a === $b ?? Same # === cares about signed zeros, we don't, so:
            !! nqp::iseq_n($a, 0e0) && nqp::iseq_n($b, 0e0)
                ?? Same !! $a.Stringy cmp $b.Stringy;
}

# Here we treat NaN as undefined
multi sub infix:<=>(Num:D \a, Num:D \b) {
    ORDER(nqp::cmp_n(nqp::unbox_n(a), nqp::unbox_n(b))) or
         a == b ?? Same !! Nil;
}
multi sub infix:<=>(num $a, num $b) {
    ORDER(nqp::cmp_n($a, $b)) or
         $a == $b ?? Same !! Nil;
}

multi sub infix:<===>(Num:D \a, Num:D \b) {
    nqp::p6bool(
        nqp::eqaddr(a.WHAT,b.WHAT)
        && (
            ( # Both are NaNs
                   nqp::not_i(nqp::isle_n(a, nqp::inf))
                && nqp::not_i(nqp::isle_n(b, nqp::inf))
            )
            || (
                nqp::iseq_n(a, b)
                && ( # if we're dealing with zeros, ensure the signs match
                    nqp::isne_n(a, 0e0)
                    || nqp::if( # 1/-0 = -Inf; 1/0 = +Inf
                        nqp::islt_n(nqp::div_n(1e0,a), 0e0), # a is -0, if true:
                        nqp::islt_n(nqp::div_n(1e0,b), 0e0), #   check b is -0 too
                        nqp::isgt_n(nqp::div_n(1e0,b), 0e0), #   check b is +0 too
                    )
                )
            )
        )
    )
}
multi sub infix:<===>(num \a, num \b --> Bool:D) {
    nqp::p6bool(
        nqp::eqaddr(a.WHAT,b.WHAT)
        && (
            ( # Both are NaNs
                   nqp::not_i(nqp::isle_n(a, nqp::inf))
                && nqp::not_i(nqp::isle_n(b, nqp::inf))
            )
            || (
                nqp::iseq_n(a, b)
                && ( # if we're dealing with zeros, ensure the signs match
                    nqp::isne_n(a, 0e0)
                    || nqp::if( # 1/-0 = -Inf; 1/0 = +Inf
                        nqp::islt_n(nqp::div_n(1e0,a), 0e0), # a is -0, if true:
                        nqp::islt_n(nqp::div_n(1e0,b), 0e0), #   check b is -0 too
                        nqp::isgt_n(nqp::div_n(1e0,b), 0e0), #   check b is +0 too
                    )
                )
            )
        )
    )
}

multi sub infix:<>( Inf,  Inf) { Bool::True }
multi sub infix:<>(-Inf, -Inf) { Bool::True }

multi sub infix:<==>(Num:D \a, Num:D \b --> Bool:D)  {
    nqp::p6bool(nqp::iseq_n(nqp::unbox_n(a), nqp::unbox_n(b)))
}
multi sub infix:<==>(num $a, num $b --> Bool:D)  {
    nqp::p6bool(nqp::iseq_n($a, $b))
}

multi sub infix:<!=>(num $a, num $b --> Bool:D) {
    nqp::p6bool(nqp::isne_n($a, $b))
}
multi sub infix:<>(num $a, num $b --> Bool:D) {
    nqp::p6bool(nqp::isne_n($a, $b))
}

multi sub infix:<(Num:D \a, Num:D \b --> Bool:D) {
    nqp::p6bool(nqp::islt_n(nqp::unbox_n(a), nqp::unbox_n(b)))
}
multi sub infix:<(num $a, num $b --> Bool:D) {
    nqp::p6bool(nqp::islt_n($a, $b))
}

multi sub infix:<=(Num:D \a, Num:D \b --> Bool:D) {
    nqp::p6bool(nqp::isle_n(nqp::unbox_n(a), nqp::unbox_n(b)))
}
multi sub infix:<=(num $a, num $b --> Bool:D) {
    nqp::p6bool(nqp::isle_n($a, $b))
}
multi sub infix:(Num:D \a, Num:D \b --> Bool:D) {
    nqp::p6bool(nqp::isle_n(nqp::unbox_n(a), nqp::unbox_n(b)))
}
multi sub infix:(num $a, num $b --> Bool:D) {
    nqp::p6bool(nqp::isle_n($a, $b))
}

multi sub infix:>(Num:D \a, Num:D \b --> Bool:D) {
    nqp::p6bool(nqp::isgt_n(nqp::unbox_n(a), nqp::unbox_n(b)))
}
multi sub infix:>(num $a, num $b --> Bool:D) {
    nqp::p6bool(nqp::isgt_n($a, $b))
}

multi sub infix:>=(Num:D \a, Num:D \b --> Bool:D) {
    nqp::p6bool(nqp::isge_n(nqp::unbox_n(a), nqp::unbox_n(b)))
}
multi sub infix:>=(num $a, num $b --> Bool:D) {
    nqp::p6bool(nqp::isge_n($a, $b))
}
multi sub infix:(Num:D \a, Num:D \b --> Bool:D) {
    nqp::p6bool(nqp::isge_n(nqp::unbox_n(a), nqp::unbox_n(b)))
}
multi sub infix:(num $a, num $b --> Bool:D) {
    nqp::p6bool(nqp::isge_n($a, $b))
}

sub rand(--> Num:D) {
    nqp::p6box_n(nqp::rand_n(1e0));
}

sub srand(Int $seed --> Int:D) {
    nqp::p6box_i(nqp::srand($seed))
}

multi sub atan2(Num:D $a, Num:D $b = 1e0) {
    nqp::p6box_n(nqp::atan2_n(nqp::unbox_n($a), nqp::unbox_n($b)));
}

multi sub cosec(Num:D \x) {
    nqp::p6box_n(nqp::div_n(1e0, nqp::sin_n(nqp::unbox_n(x))));
}
multi sub acosec(Num:D \x) {
    nqp::p6box_n(nqp::asin_n(nqp::div_n(1e0, nqp::unbox_n(x))));
}

multi sub log(num $x --> num) {
    nqp::log_n($x);
}

multi sub sin(num $x --> num) {
    nqp::sin_n($x);
}
multi sub asin(num $x --> num) {
    nqp::asin_n($x);
}
multi sub cos(num $x --> num) {
    nqp::cos_n($x);
}
multi sub acos(num $x --> num) {
    nqp::acos_n($x);
}
multi sub tan(num $x --> num) {
    nqp::tan_n($x);
}
multi sub atan(num $x --> num) {
    nqp::atan_n($x);
}
multi sub sec(num $x --> num) {
    nqp::sec_n($x);
}
multi sub asec(num $x --> num) {
    nqp::asec_n($x);
}

multi sub cotan(num $x --> num) {
    nqp::div_n(1e0, nqp::tan_n($x));
}
multi sub acotan(num $x --> num) {
    nqp::atan_n(nqp::div_n(1e0, $x));
}
multi sub sinh(num $x --> num) {
    nqp::sinh_n($x);
}
multi sub asinh(num $x --> num) {
    # ln(x + (x+1))
    nqp::isnanorinf($x)
        ?? $x
        !! nqp::log_n(
            nqp::add_n(
                $x,
                nqp::pow_n( nqp::add_n(nqp::mul_n($x,$x), 1e0), .5e0 )
            )
        )
}

multi sub cosh(num $x --> num) {
    nqp::cosh_n($x);
}
multi sub acosh(num $x --> num) {
    # ln(x + (x-1))
    $x < 1e0
        ?? NaN
        !! nqp::log_n(
            nqp::add_n(
                $x,
                nqp::pow_n( nqp::sub_n(nqp::mul_n($x,$x), 1e0), .5e0 )
            )
        )
}
multi sub tanh(num $x --> num) {
    nqp::tanh_n($x);
}
multi sub atanh(num $x --> num) {
    $x == 1e0 ?? Inf !! log((1e0 + $x) / (1e0 - $x)) / 2e0;
}
multi sub sech(num $x --> num) {
    nqp::sech_n($x);
}
multi sub asech(num $x --> num) {
    acosh(1e0 / $x);
}
multi sub cosech(num $x --> num) {
    1e0 / sinh($x)
}
multi sub acosech(num $x --> num) {
    asinh(1e0 / $x);
}
multi sub cotanh(num $x --> num) {
    1e0 / tanh($x);
}
multi sub acotanh(num $x --> num) {
    atanh(1e0 / $x)
}

multi sub floor(num $a --> num) {
    nqp::floor_n($a)
}
multi sub ceiling(num $a --> num) {
    nqp::ceil_n($a)
}
multi sub sqrt(num $a --> num) {
    nqp::sqrt_n($a)
}

#line 1 SETTING::src/core/Buf.pm
my class X::Buf::AsStr          { ... }
my class X::Buf::Pack           { ... }
my class X::Buf::Pack::NonASCII { ... }
my class X::Cannot::Empty       { ... }
my class X::Cannot::Lazy        { ... }
my class X::Experimental        { ... }

my role Blob[::T = uint8] does Positional[T] does Stringy is repr('VMArray') is array_type(T) {
    X::NYI.new(
      feature => "{$?CLASS.^name.comb(/^ \w+ /)}s with native {T.^name}"
    ).throw unless nqp::istype(T,Int);

    # other then *8 not supported yet
    my int $bpe = try {




        (T.^nativesize / 8).Int
    } // 1;

    multi method WHICH(Blob:D:) {
        nqp::box_s(
          nqp::concat(
            nqp::if(
              nqp::eqaddr(self.WHAT,Blob),
              'Blob|',
            nqp::concat(nqp::unbox_s(self.^name), '|')
            ),
            nqp::sha1(self.decode("latin-1"))
          ),
          ObjAt
        )
    }

    multi method new(Blob:) { nqp::create(self) }
    multi method new(Blob: Blob:D $blob) {
        nqp::splice(nqp::create(self),$blob,0,0)
    }
    multi method new(Blob: int @values) {
        nqp::splice(nqp::create(self),@values,0,0)
    }
    multi method new(Blob: @values) {
        @values.is-lazy
          ?? Failure.new(X::Cannot::Lazy.new(:action<new>,:what(self.^name)))
          !! self!push-list("initializ",nqp::create(self),@values)
    }
    multi method new(Blob: *@values) { self.new(@values) }

    proto method allocate(|) { * }
    multi method allocate(Blob:U: Int $elements) {
        nqp::setelems(nqp::create(self),$elements)
    }
    multi method allocate(Blob:U: Int $elements, int $value) {
        my int $elems = $elements;
        my $blob     := nqp::setelems(nqp::create(self),$elems);
        my int $i     = -1;
        nqp::bindpos_i($blob,$i,$value) while nqp::islt_i(++$i,$elems);
        $blob;
    }
    multi method allocate(Blob:U: Int $elements, Int \value) {
        my int $value = value;
        self.allocate($elements,$value)
    }
    multi method allocate(Blob:U: Int $elements, Mu $got) {
        self!fail-typecheck('allocate',$got)
    }
    multi method allocate(Blob:U: Int $elements, int @values) {
        self!spread(nqp::setelems(nqp::create(self),$elements),@values)
    }
    multi method allocate(Blob:U: Int $elements, Blob:D $blob) {
        self!spread(nqp::setelems(nqp::create(self),$elements),$blob)
    }
    multi method allocate(Blob:U: Int $elements, @values) {
        self!spread(nqp::setelems(nqp::create(self),$elements),Blob.new(@values))
    }

    multi method EXISTS-POS(Blob:D: int \pos) {
        nqp::p6bool(
          nqp::islt_i(pos,nqp::elems(self)) && nqp::isge_i(pos,0)
        );
    }
    multi method EXISTS-POS(Blob:D: Int:D \pos) {
        nqp::p6bool(
          nqp::islt_i(pos,nqp::elems(self)) && nqp::isge_i(pos,0)
        );
    }

    multi method AT-POS(Blob:D: int \pos) {
        nqp::if(
          (nqp::isge_i(pos,nqp::elems(self)) || nqp::islt_i(pos,0)),
          self!fail-range(pos),
          nqp::atpos_i(self,pos)
        )
    }
    multi method AT-POS(Blob:D: Int:D \pos) {
        nqp::if(
          (nqp::isge_i(pos,nqp::elems(self)) || nqp::islt_i(pos,0)),
          self!fail-range(pos),
          nqp::atpos_i(self,pos)
        )
    }

    multi method Bool(Blob:D:) { nqp::p6bool(nqp::elems(self)) }
    method Capture(Blob:D:) { self.List.Capture }

    multi method elems(Blob:D:)   { nqp::p6box_i(nqp::elems(self)) }
    multi method elems(Blob:U: --> 1)   { }
    method Numeric(Blob:D:) { nqp::p6box_i(nqp::elems(self)) }
    method Int(Blob:D:)     { nqp::p6box_i(nqp::elems(self)) }

    method bytes(Blob:D:) { nqp::mul_i(nqp::elems(self),$bpe) }

    method chars(Blob:D:)       { X::Buf::AsStr.new(method => 'chars').throw }
    multi method Str(Blob:D:)   { X::Buf::AsStr.new(method => 'Str'  ).throw }
    multi method Stringy(Blob:D:) { X::Buf::AsStr.new(method => 'Stringy' ).throw }

    proto method decode(|) { * }
    multi method decode(Blob:D:) {
        nqp::p6box_s(nqp::decode(self, 'utf8'))
    }
    multi method decode(Blob:D: $encoding) {
        nqp::p6box_s(
          nqp::decode(self, Rakudo::Internals.NORMALIZE_ENCODING($encoding)))
    }

    multi method list(Blob:D:) {
        Seq.new(class :: does Rakudo::Iterator::Blobby {
            method pull-one() is raw {
                nqp::if(
                  nqp::islt_i(($!i = nqp::add_i($!i,1)),nqp::elems($!blob)),
                  nqp::atpos_i($!blob,$!i),
                  IterationEnd
                )
            }
        }.new(self))
    }

    multi method gist(Blob:D:) {
        self.^name ~ ':0x<' ~ self.map( -> \el {
            state $i = 0;
            ++$i == 101 ?? '...'
                !! $i == 102 ?? last()
                    !! nqp::if(nqp::iseq_i( # el.fmt: '%02x'
                        nqp::chars(my str $v = nqp::lc(el.base: 16)),1),
                        nqp::concat('0',$v),$v)
        }) ~ '>'
    }
    multi method perl(Blob:D:) {
        self.^name ~ '.new(' ~ self.join(',') ~ ')';
    }

    method subbuf(Blob:D: $from, $length?) {

        my int $elems = nqp::elems(self);
        X::OutOfRange.new(
          what => "Len element to subbuf",
          got  => $length,
          range => "0..$elems",
        ).fail if $length.DEFINITE && $length < 0;

        my int $pos;
        my int $todo;
        if nqp::istype($from,Range) {
            $from.int-bounds($pos, my int $max);
            $todo = $max - $pos + 1;
        }
        else {
            $pos = nqp::istype($from, Callable) ?? $from($elems) !! $from.Int;
            $todo = $length.DEFINITE
              ?? $length.Int min $elems - $pos
              !! $elems - $pos;
        }

        X::OutOfRange.new(
          what    => 'From argument to subbuf',
          got     => $from.gist,
          range   => "0..$elems",
          comment => "use *-{abs $pos} if you want to index relative to the end",
        ).fail if $pos < 0;
        X::OutOfRange.new(
          what => 'From argument to subbuf',
          got  => $from.gist,
          range => "0..$elems",
        ).fail if $pos > $elems;

        my $subbuf := nqp::create(self);
        if $todo {
            nqp::setelems($subbuf, $todo);
            my int $i = -1;
            --$pos;
            nqp::bindpos_i($subbuf,$i,nqp::atpos_i(self,++$pos))
              while nqp::islt_i(++$i,$todo);
        }
        $subbuf
    }

    method reverse(Blob:D:) {
        my int $elems = nqp::elems(self);
        my int $last  = nqp::sub_i($elems,1);
        my $reversed := nqp::setelems(nqp::create(self),$elems);
        my int $i     = -1;
        nqp::while(
          nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
          nqp::bindpos_i($reversed,nqp::sub_i($last,$i),
            nqp::atpos_i(self,$i))
        );
        $reversed
    }

    method COMPARE(Blob:D: Blob:D \other) {
        my $other := nqp::decont(other);
        my int $elems = nqp::elems(self);
        if nqp::cmp_i($elems,nqp::elems($other)) -> $diff {
            $diff
        }
        else {
            my int $i = -1;
            return nqp::cmp_i(nqp::atpos_i(self,$i),nqp::atpos_i($other,$i))
              if nqp::cmp_i(nqp::atpos_i(self,$i),nqp::atpos_i($other,$i))
              while nqp::islt_i(++$i,$elems);
            0
        }
    }

    method SAME(Blob:D: Blob:D \other) {
        my $other := nqp::decont(other);
        my int $elems = nqp::elems(self);
        return False unless nqp::iseq_i($elems,nqp::elems($other));

        my int $i = -1;
        return False
          unless nqp::iseq_i(nqp::atpos_i(self,$i),nqp::atpos_i($other,$i))
          while nqp::islt_i(++$i,$elems);

        True
    }

    method join(Blob:D: $delim = '') {
        my int $elems = nqp::elems(self);
        my $list     := nqp::setelems(nqp::list_s,$elems);
        my int $i     = -1;

        nqp::bindpos_s($list,$i,
          nqp::tostr_I(nqp::p6box_i(nqp::atpos_i(self,$i))))
          while nqp::islt_i(++$i,$elems);

        nqp::join($delim.Str,$list)
    }

    proto method unpack(|) { * }
    multi method unpack(Blob:D: Str:D $template) {
        nqp::isnull(nqp::getlexcaller('EXPERIMENTAL-PACK')) and X::Experimental.new(
            feature => "the 'unpack' method",
            use     => "pack"
        ).throw;
        self.unpack($template.comb(/<[a..zA..Z]>[\d+|'*']?/))
    }
    multi method unpack(Blob:D: @template) {
        nqp::isnull(nqp::getlexcaller('EXPERIMENTAL-PACK')) and X::Experimental.new(
            feature => "the 'unpack' method",
            use     => "pack"
        ).throw;
        my @bytes = self.list;
        my @fields;
        for @template -> $unit {
            my $directive = substr($unit,0,1);
            my $amount    = substr($unit,1);
            my $pa = $amount eq ''  ?? 1            !!
                     $amount eq '*' ?? @bytes.elems !! +$amount;

            given $directive {
                when 'a' | 'A' | 'Z' {
                    @fields.push: @bytes.splice(0, $pa).map(&chr).join;
                }
                when 'H' {
                    my str $hexstring = '';
                    for ^$pa {
                        my $byte = shift @bytes;
                        $hexstring ~= ($byte +> 4).fmt('%x')
                                    ~ ($byte % 16).fmt('%x');
                    }
                    @fields.push($hexstring);
                }
                when 'x' {
                    splice @bytes, 0, $pa;
                }
                when 'C' {
                    @fields.append: @bytes.splice(0, $pa);
                }
                when 'S' | 'v' {
                    for ^$pa {
                        last if @bytes.elems < 2;
                        @fields.append: shift(@bytes)
                                    + (shift(@bytes) +< 0x08);
                    }
                }
                when 'L' | 'V' {
                    for ^$pa {
                        last if @bytes.elems < 4;
                        @fields.append: shift(@bytes)
                                    + (shift(@bytes) +< 0x08)
                                    + (shift(@bytes) +< 0x10)
                                    + (shift(@bytes) +< 0x18);
                    }
                }
                when 'n' {
                    for ^$pa {
                        last if @bytes.elems < 2;
                        @fields.append: (shift(@bytes) +< 0x08)
                                    + shift(@bytes);
                    }
                }
                when 'N' {
                    for ^$pa {
                        last if @bytes.elems < 4;
                        @fields.append: (shift(@bytes) +< 0x18)
                                    + (shift(@bytes) +< 0x10)
                                    + (shift(@bytes) +< 0x08)
                                    + shift(@bytes);
                    }
                }
                X::Buf::Pack.new(:$directive).throw;
            }
        }

        return |@fields;
    }

    # XXX: the pack.t spectest file seems to require this method
    # not sure if it should be changed to list there...
    method contents(Blob:D:) { self.list }

    method encoding() { Any }

    method !push-list(\action,\to,\from) {
        if nqp::istype(from,List) {
            my Mu $from := nqp::getattr(from,List,'$!reified');
            if nqp::defined($from) {
                my int $elems = nqp::elems($from);
                my int $j     = nqp::elems(to);
                nqp::setelems(to, $j + $elems);  # presize for efficiency
                my int $i = -1;
                my $got;
                nqp::istype(($got := nqp::atpos($from,$i)),Int)
                  ?? nqp::bindpos_i(to,$j++,$got)
                  !! self!fail-typecheck-element(action,$i,$got).throw
                  while nqp::islt_i(++$i,$elems);
            }
        }
        else {
            my $iter := from.iterator;
            my int $i = 0;
            my $got;
            until ($got := $iter.pull-one) =:= IterationEnd {
                nqp::istype($got,Int)
                  ?? nqp::push_i(to,$got)
                  !! self!fail-typecheck-element(action,$i,$got).throw;
                ++$i;
            }
        }
        to
    }
    method !unshift-list(\action,\to,\from) {
        if nqp::istype(from,List) {
            my Mu $from := nqp::getattr(from,List,'$!reified');
            if nqp::defined($from) {
                my int $i = nqp::elems($from);
                nqp::istype((my $got := nqp::atpos($from,$i)),Int)
                  ?? nqp::unshift_i(to,$got)
                  !! self!fail-typecheck-element(action,$i,$got).throw
                  while nqp::isge_i(--$i,0);
            }
            to
        }
        else {
            nqp::splice(to,self!push-list(action,nqp::create(self),from),0,0)
        }
    }
    method !spread(\to,\from) {
        if nqp::elems(from) -> int $values { # something to init with
            my int $elems = nqp::elems(to) - $values;
            my int $i     = -$values;
            nqp::splice(to,from,$i,$values)
              while nqp::isle_i($i = $i + $values,$elems);

            if nqp::isgt_i($i,$elems) {  # something left to init
                --$i;                    # went one too far
                $elems = $elems + $values;
                my int $j = -1;
                nqp::bindpos_i(to,$i,nqp::atpos_i(from,$j = ($j + 1) % $values))
                  while nqp::islt_i(++$i,$elems);
            }
        }
        to
    }
    method !fail-range($got) {
        Failure.new(X::OutOfRange.new(
          :what($*INDEX // 'Index'),
          :$got,
          :range("0..{nqp::elems(self)-1}")
        ))
    }
    method !fail-typecheck-element(\action,\i,\got) {
        self!fail-typecheck(action ~ "ing element #" ~ i,got);
    }
    method !fail-typecheck($action,$got) {
        Failure.new(X::TypeCheck.new(
          operation => $action ~ " to " ~ self.^name,
          got       => $got,
          expected  => T,
        ))
    }
}

constant blob8 = Blob[uint8];
constant blob16 = Blob[uint16];
constant blob32 = Blob[uint32];
constant blob64 = Blob[uint64];

my class utf8 does Blob[uint8] is repr('VMArray') {
    multi method decode(utf8:D: $encoding) {
        my $enc = Rakudo::Internals.NORMALIZE_ENCODING($encoding);
        die "Can not decode a utf-8 buffer as if it were $encoding"
            unless $enc eq 'utf8';
        nqp::p6box_s(nqp::decode(self, 'utf8'))
    }
    method encoding() { 'utf-8' }
    multi method Str(utf8:D:) { self.decode }
    multi method Stringy(utf8:D:) { self.decode }
}

my class utf16 does Blob[uint16] is repr('VMArray') {
    multi method decode(utf16:D: $encoding = 'utf-16') {
        my $enc = Rakudo::Internals.NORMALIZE_ENCODING($encoding);
        die "Can not decode a utf-16 buffer as if it were $encoding"
            unless $enc eq 'utf16';
        nqp::p6box_s(nqp::decode(self, 'utf16'))
    }
    method encoding() { 'utf-16' }
    multi method Str(utf16:D:) { self.decode }
    multi method Stringy(utf16:D:) { self.decode }
}

my class utf32 does Blob[uint32] is repr('VMArray') {
    multi method decode(utf32:D: $encoding = 'utf-32') {
        my $enc = Rakudo::Internals.NORMALIZE_ENCODING($encoding);
        die "Can not decode a utf-32 buffer as if it were $encoding"
            unless $enc eq 'utf32';
        nqp::p6box_s(nqp::decode(self, 'utf32'))
    }
    method encoding() { 'utf-32' }
    multi method Str(utf32:D:) { self.decode }
    multi method Stringy(utf32:D:) { self.decode }
}

my role Buf[::T = uint8] does Blob[T] is repr('VMArray') is array_type(T) {

    multi method WHICH(Buf:D:) { self.Mu::WHICH }

    multi method AT-POS(Buf:D: int \pos) is raw {
        nqp::islt_i(pos,0)
          ?? Failure.new(X::OutOfRange.new(
               :what($*INDEX // 'Index'),:got(pos),:range<0..^Inf>))
          !! nqp::atposref_i(self, pos)
    }
    multi method AT-POS(Buf:D: Int:D \pos) is raw {
        my int $pos = nqp::unbox_i(pos);
        nqp::islt_i($pos,0)
          ?? Failure.new(X::OutOfRange.new(
               :what($*INDEX // 'Index'),:got(pos),:range<0..^Inf>))
          !! nqp::atposref_i(self,$pos)
    }

    multi method ASSIGN-POS(Buf:D: int \pos, Mu \assignee) {
        nqp::islt_i(pos,0)
          ?? Failure.new(X::OutOfRange.new(
               :what($*INDEX // 'Index'),:got(pos),:range<0..^Inf>))
          !! nqp::bindpos_i(self,\pos,assignee)
    }
    multi method ASSIGN-POS(Buf:D: Int:D \pos, Mu \assignee) {
        my int $pos = nqp::unbox_i(pos);
        nqp::islt_i($pos,0)
          ?? Failure.new(X::OutOfRange.new(
               :what($*INDEX // 'Index'),:got(pos),:range<0..^Inf>))
          !! nqp::bindpos_i(self,$pos,assignee)
    }

    multi method list(Buf:D:) {
        Seq.new(class :: does Rakudo::Iterator::Blobby {
            method pull-one() is raw {
                nqp::if(
                  nqp::islt_i(($!i = nqp::add_i($!i,1)),nqp::elems($!blob)),
                  nqp::atposref_i($!blob,$!i),
                  IterationEnd
                )
            }
        }.new(self))
    }

    multi method pop(Buf:D:) {
        nqp::elems(self)
          ?? nqp::pop_i(self)
          !! Failure.new(X::Cannot::Empty.new(:action<pop>,:what(self.^name)))
    }
    multi method shift(Buf:D:) {
        nqp::elems(self)
          ?? nqp::shift_i(self)
          !! Failure.new(X::Cannot::Empty.new(:action<shift>,:what(self.^name)))
    }

    method reallocate(Buf:D: Int $elements) { nqp::setelems(self,$elements) }

    my $empty := nqp::list_i;
    multi method splice(Buf:D \SELF:) { my $buf = SELF; SELF = Buf.new; $buf }
    multi method splice(Buf:D: Int $offset, $size = Whatever) {
        my int $remove = self!remove($offset,$size);
        my $result := $remove
          ?? self.subbuf($offset,$remove)  # until something smarter
          !! nqp::create(self);
        nqp::splice(self,$empty,$offset,$remove);
        $result
    }
    multi method splice(Buf:D: Int $offset, $size, int $got) {
        self!splice-native($offset,$size,$got)
    }
    multi method splice(Buf:D: Int $offset, $size, Int $got) {
        self!splice-native($offset,$size,$got)
    }
    multi method splice(Buf:D: Int $offset, $size, Mu $got) {
        self!fail-typecheck('splice',$got)
    }
    multi method splice(Buf:D: Int $offset, $size, Buf:D $buf) {
        self!splice-native($offset,$size,$buf)
    }
    multi method splice(Buf:D: Int $offset, $size, int @values) {
        self!splice-native($offset,$size,@values)
    }
    multi method splice(Buf:D: Int $offset, $size, @values) {
        self!splice-native($offset,$size,
          self!push-list("splic",nqp::create(self),@values))
    }

    method !remove(\offset,\size) {
        nqp::istype(size,Whatever)
          ?? nqp::elems(self) - offset
          !! nqp::istype(size,Int)
            ?? size
            !! size.Int
    }

    method !splice-native(Buf:D: Int $offset, $size, \x) {
        my int $remove = self!remove($offset,$size);
        my $result := $remove
          ?? self.subbuf($offset,$remove)  # until something smarter
          !! nqp::create(self);
        nqp::splice(
          self,nqp::islist(x) ?? x !! nqp::list_i(x),$offset,$remove);
        $result
    }

    multi method push(Buf:D: int $got) { nqp::push_i(self,$got); self }
    multi method push(Buf:D: Int $got) { nqp::push_i(self,$got); self }
    multi method push(Buf:D: Mu $got) { self!fail-typecheck('push',$got) }
    multi method push(Buf:D: Blob:D $buf) {
        nqp::splice(self,$buf,nqp::elems(self),0)
    }
    multi method push(Buf:D: **@values) { self!pend(@values,'push') }

    multi method append(Buf:D: int $got) { nqp::push_i(self,$got); self }
    multi method append(Buf:D: Int $got) { nqp::push_i(self,$got); self }
    multi method append(Buf:D: Mu $got) { self!fail-typecheck('append',$got) }
    multi method append(Buf:D: Blob:D $buf) {
        nqp::splice(self,$buf,nqp::elems(self),0)
    }
    multi method append(Buf:D: int @values) {
        nqp::splice(self,@values,nqp::elems(self),0)
    }
    multi method append(Buf:D:  @values) { self!pend(@values,'append') }
    multi method append(Buf:D: *@values) { self!pend(@values,'append') }

    multi method unshift(Buf:D: int $got) { nqp::unshift_i(self,$got); self }
    multi method unshift(Buf:D: Int $got) { nqp::unshift_i(self,$got); self }
    multi method unshift(Buf:D: Mu $got) { self!fail-typecheck('unshift',$got) }
    multi method unshift(Buf:D: Blob:D $buf) { nqp::splice(self,$buf,0,0) }
    multi method unshift(Buf:D: **@values) { self!pend(@values,'unshift') }

    multi method prepend(Buf:D: int $got) { nqp::unshift_i(self,$got); self }
    multi method prepend(Buf:D: Int $got) { nqp::unshift_i(self,$got); self }
    multi method prepend(Buf:D: Mu $got) { self!fail-typecheck('prepend',$got) }
    multi method prepend(Buf:D: Blob:D $buf)  { nqp::splice(self,$buf,0,0)    }
    multi method prepend(Buf:D: int @values) { nqp::splice(self,@values,0,0) }
    multi method prepend(Buf:D:  @values) { self!pend(@values,'prepend') }
    multi method prepend(Buf:D: *@values) { self!pend(@values,'prepend') }

    method !pend(Buf:D: @values, $action) {
        @values.is-lazy
          ?? Failure.new(X::Cannot::Lazy.new(:$action,:what(self.^name)))
          !! $action eq 'push' || $action eq 'append'
            ?? self!push-list($action,self,@values)
            !! self!unshift-list($action,self,@values)
    }

    method subbuf-rw($from = 0, $elems = self.elems - $from) is rw {
        my Blob $subbuf = self.subbuf($from, $elems);
        Proxy.new(
            FETCH   => sub ($) { $subbuf },
            STORE   => sub ($, Blob:D $new) {
                nqp::splice(nqp::decont(self),nqp::decont($new),$from,$elems)
            }
        );
    }

}

constant buf8 = Buf[uint8];
constant buf16 = Buf[uint16];
constant buf32 = Buf[uint32];
constant buf64 = Buf[uint64];

proto sub pack(|) { * }
multi sub pack(Str $template, *@items) {
    nqp::isnull(nqp::getlexcaller('EXPERIMENTAL-PACK')) and X::Experimental.new(
        feature => "the 'pack' function",
        use     => "pack"
    ).throw;
    pack($template.comb(/<[a..zA..Z]>[\d+|'*']?/), @items)
}

multi sub pack(@template, *@items) {
    nqp::isnull(nqp::getlexcaller('EXPERIMENTAL-PACK')) and X::Experimental.new(
        feature => "the 'pack' function",
        use     => "pack"
    ).throw;
    my @bytes;
    for @template -> $unit {
        my $directive = substr($unit,0,1);
        my $amount    = substr($unit,1);

        given $directive {
            when 'A' {
                my $ascii = shift @items // '';
                my $data = $ascii.ords.cache;
                if $amount eq '*' {
                    $amount = $data.elems;
                }
                if $amount eq '' {
                    $amount = 1;
                }
                for (@$data, 0x20 xx *).flat[^$amount] -> $byte {
                    X::Buf::Pack::NonASCII.new(:char($byte.chr)).throw if $byte > 0x7f;
                    @bytes.push: $byte;
                }
            }
            when 'a' {
                my $data = shift @items // Buf.new;
                $data.=encode if nqp::istype($data,Str);
                if $amount eq '*' {
                    $amount = $data.elems;
                }
                if $amount eq '' {
                    $amount = 1;
                }
                for (@$data, 0 xx *).flat[^$amount] -> $byte {
                    @bytes.push: $byte;
                }
            }
            when 'H' {
                my $hexstring = shift @items // '';
                if $hexstring.chars % 2 {
                    $hexstring ~= '0';
                }
                @bytes.append: map { :16($_) }, $hexstring.comb(/../);
            }
            when 'x' {
                if $amount eq '*' {
                    $amount = 0;
                }
                elsif $amount eq '' {
                    $amount = 1;
                }
                @bytes.append: 0x00 xx $amount;
            }
            when 'C' {
                my $number = shift(@items);
                @bytes.push: $number % 0x100;
            }
            when 'S' | 'v' {
                my $number = shift(@items);
                @bytes.append: ($number, $number +> 0x08) >>%>> 0x100;
            }
            when 'L' | 'V' {
                my $number = shift(@items);
                @bytes.append: ($number, $number +> 0x08,
                              $number +> 0x10, $number +> 0x18) >>%>> 0x100;
            }
            when 'n' {
                my $number = shift(@items);
                @bytes.append: ($number +> 0x08, $number) >>%>> 0x100;
            }
            when 'N' {
                my $number = shift(@items);
                @bytes.append: ($number +> 0x18, $number +> 0x10,
                              $number +> 0x08, $number) >>%>> 0x100;
            }
            X::Buf::Pack.new(:$directive).throw;
        }
    }

    return Buf.new(@bytes);
}

multi sub infix:<~>(Blob:D \a) { a }
multi sub infix:<~>(Blob:D $a, Blob:D $b) {
    my $res := ($a.WHAT === $b.WHAT ?? $a !! Buf).new;
    my $adc := nqp::decont($a);
    my $bdc := nqp::decont($b);
    my int $alen = nqp::elems($adc);
    my int $blen = nqp::elems($bdc);

    nqp::setelems($res, $alen + $blen);
    nqp::splice($res, $adc, 0, $alen);
    nqp::splice($res, $bdc, $alen, $blen);
}

multi sub prefix:<~^>(Blob:D \a) {
    my $a        := nqp::decont(a);
    my int $elems = nqp::elems($a);

    my $r := nqp::create($a);
    nqp::setelems($a,$elems);

    my int    $i    = -1;
    nqp::bindpos_i($r,$i,nqp::bitneg_i(nqp::atpos_i($a,$i)))
      while nqp::islt_i(++$i,$elems);

    $r
}

multi sub infix:<~&>(Blob:D \a, Blob:D \b) {
    my $a := nqp::decont(a);
    my $b := nqp::decont(b);
    my int $elemsa = nqp::elems($a);
    my int $elemsb = nqp::elems($b);
    my int $do  = $elemsa > $elemsb ?? $elemsb !! $elemsa;
    my int $max = $elemsa > $elemsb ?? $elemsa !! $elemsb;

    my $r := nqp::create($a);
    nqp::setelems($r,$max);

    my int $i = -1;
    nqp::bindpos_i($r,$i,
      nqp::bitand_i(nqp::atpos_i($a,$i),nqp::atpos_i($b,$i)))
      while nqp::islt_i(++$i,$do);

    --$i;    # went one too far
    nqp::bindpos_i($r,$i,0) while nqp::islt_i(++$i,$max);

    $r
}

multi sub infix:<~|>(Blob:D \a, Blob:D \b) {
    my $a := nqp::decont(a);
    my $b := nqp::decont(b);
    my int $elemsa = nqp::elems($a);
    my int $elemsb = nqp::elems($b);
    my int $do  = $elemsa > $elemsb ?? $elemsb !! $elemsa;
    my int $max = $elemsa > $elemsb ?? $elemsa !! $elemsb;
    my $from   := $elemsa > $elemsb ?? $a      !! $b;

    my $r := nqp::create($a);
    nqp::setelems($r,$max);

    my int $i = -1;
    nqp::bindpos_i($r,$i,
      nqp::bitor_i(nqp::atpos_i($a,$i),nqp::atpos_i($b,$i)))
      while nqp::islt_i(++$i,$do);

    $i = $i - 1;    # went one too far
    nqp::bindpos_i($r,$i,nqp::atpos_i($from,$i))
      while nqp::islt_i(++$i,$max);

    $r
}

multi sub infix:<~^>(Blob:D \a, Blob:D \b) {
    my $a := nqp::decont(a);
    my $b := nqp::decont(b);
    my int $elemsa = nqp::elems($a);
    my int $elemsb = nqp::elems($b);
    my int $do  = $elemsa > $elemsb ?? $elemsb !! $elemsa;
    my int $max = $elemsa > $elemsb ?? $elemsa !! $elemsb;
    my $from   := $elemsa > $elemsb ?? $a      !! $b;

    my $r := nqp::create($a);
    nqp::setelems($r,$max);

    my int $i = -1;
    nqp::bindpos_i($r,$i,
      nqp::bitxor_i(nqp::atpos_i($a,$i),nqp::atpos_i($b,$i)))
      while nqp::islt_i(++$i,$do);

    --$i;    # went one too far
    nqp::bindpos_i($r,$i,nqp::atpos_i($from,$i))
      while nqp::islt_i(++$i,$max);

    $r
}

multi sub infix:<eqv>(Blob:D \a, Blob:D \b) {
    nqp::p6bool(nqp::eqaddr(a,b) || (nqp::eqaddr(a.WHAT,b.WHAT) && a.SAME(b)))
}

multi sub infix:<cmp>(Blob:D \a, Blob:D \b) { ORDER(a.COMPARE(b))     }
multi sub infix:<eq> (Blob:D \a, Blob:D \b) {   a =:= b || a.SAME(b)  }
multi sub infix:<ne> (Blob:D \a, Blob:D \b) { !(a =:= b || a.SAME(b)) }
multi sub infix:<lt> (Blob:D \a, Blob:D \b) { a.COMPARE(b) == -1      }
multi sub infix:<gt> (Blob:D \a, Blob:D \b) { a.COMPARE(b) ==  1      }
multi sub infix:<le> (Blob:D \a, Blob:D \b) { a.COMPARE(b) !=  1      }
multi sub infix:<ge> (Blob:D \a, Blob:D \b) { a.COMPARE(b) != -1      }

sub subbuf-rw(Buf:D \b, $from = 0, $elems = b.elems - $from) is rw {
    b.subbuf-rw($from, $elems);
}

#line 1 SETTING::src/core/Uni.pm
my class NFC is repr('VMArray') is array_type(uint32) { ... }
my class NFD is repr('VMArray') is array_type(uint32) { ... }
my class NFKC is repr('VMArray') is array_type(uint32) { ... }
my class NFKD is repr('VMArray') is array_type(uint32) { ... }

my class Uni does Positional[uint32] does Stringy is repr('VMArray') is array_type(uint32) {
    method new(*@codes) {
        my $uni := nqp::create(self);
        my int $n = @codes.elems;
        loop (my int $i = 0; $i < $n; $i = $i + 1) {
            nqp::bindpos_i($uni, $i, @codes.AT-POS($i));
        }
        $uni
    }

    method list(Uni:D:) {
        gather {
            my int $n = nqp::elems(self);
            loop (my int $i = 0; $i < $n; $i = $i + 1) {
                take nqp::atpos_i(self, $i);
            }
        }
    }

    method Uni(Uni:D:) {
        self
    }

    method NFC(Uni:D:) {
        nqp::normalizecodes(self, nqp::const::NORMALIZE_NFC, nqp::create(NFC))
    }

    method NFD(Uni:D:) {
        nqp::normalizecodes(self, nqp::const::NORMALIZE_NFD, nqp::create(NFD))
    }

    method NFKC(Uni:D:) {
        nqp::normalizecodes(self, nqp::const::NORMALIZE_NFKC, nqp::create(NFKC))
    }

    method NFKD(Uni:D:) {
        nqp::normalizecodes(self, nqp::const::NORMALIZE_NFKD, nqp::create(NFKD))
    }

    multi method Str(Uni:D:) {
        nqp::strfromcodes(self)
    }

    multi method Bool(Uni:D:) {
        nqp::p6bool(nqp::elems(self));
    }

    method codes(Uni:D:)   { nqp::elems(self) }
    method elems(Uni:D:)   { nqp::elems(self) }
    method Numeric(Uni:D:) { nqp::elems(self) }
    method Int(Uni:D:)     { nqp::elems(self) }

    multi method EXISTS-POS(Uni:D: int \pos) {
        nqp::p6bool(
          nqp::islt_i(pos,nqp::elems(self)) && nqp::isge_i(pos,0)
        );
    }
    multi method EXISTS-POS(Uni:D: Int:D \pos) {
        pos < nqp::elems(self) && pos >= 0;
    }

    multi method AT-POS(Uni:D: int \pos) {
        nqp::isge_i(pos,nqp::elems(self)) || nqp::islt_i(pos,0)
          ?? Failure.new(X::OutOfRange.new(
               :what($*INDEX // 'Index'),
               :got(pos),
               :range("0..{nqp::elems(self)-1}")))
          !! nqp::atpos_i(self, pos)
    }
    multi method AT-POS(Uni:D: Int:D \pos) {
        my int $pos = nqp::unbox_i(pos);
        nqp::isge_i($pos,nqp::elems(self)) || nqp::islt_i($pos,0)
          ?? Failure.new(X::OutOfRange.new(
               :what($*INDEX // 'Index'),
               :got(pos),
               :range("0..{nqp::elems(self)-1}")))
          !! nqp::atpos_i(self,$pos)
    }

    multi method gist(Uni:D:) {
        self.^name ~ ':0x<' ~ self.list.fmt('%04x', ' ') ~ '>'
    }

    multi method perl(Uni:D:) {
        'Uni.new(' ~ self.list.fmt('0x%04x', ', ') ~ ')' ~
            (self.WHAT === Uni ?? '' !! '.' ~ self.^name);
    }
}

my class NFD is Uni {
    method new(|) {
        die "Cannot create an NFD directly"; # XXX typed, better message
    }

    method NFD() { self }
}

my class NFC is Uni {
    method new(|) {
        die "Cannot create an NFC directly"; # XXX typed, better message
    }

    method NFC() { self }
}

my class NFKD is Uni {
    method new(|) {
        die "Cannot create an NFKD directly"; # XXX typed, better message
    }

    method NFKD() { self }
}

my class NFKC is Uni {
    method NFKC() { self }

    method new(|) {
        die "Cannot create an NFKC directly"; # XXX typed, better message
    }
}

#line 1 SETTING::src/core/Collation.pm
class Collation {
    has int $.collation-level = 85;
    has $!Country = 'International';
    method gist {
        "collation-level => $!collation-level, Country => $!Country, " ~
        "Language => None, primary => {self.primary}, secondary => {self.secondary}, " ~
        "tertiary => {self.tertiary}, quaternary => {self.quaternary}"
    }
    method set (
        Int :$primary    = 1,
        Int :$secondary  = 1,
        Int :$tertiary   = 1,
        Int :$quaternary = 1)
    {
        nqp::isnull(nqp::getlexcaller('EXPERIMENTAL-COLLATION')) and X::Experimental.new(
            feature => 'the $*COLLATION dynamic variable',
            use     => 'collation'
        ).throw;
        my int $i = 0;
        $i += 1   if $primary.sign    ==  1;
        $i += 2   if $primary.sign    == -1;

        $i += 4   if $secondary.sign  ==  1;
        $i += 8   if $secondary.sign  == -1;

        $i += 16  if $tertiary.sign   ==  1;
        $i += 32  if $tertiary.sign   == -1;

        $i += 64  if $quaternary.sign ==  1;
        $i += 128 if $quaternary.sign == -1;
        $!collation-level = $i;
        self;
    }
    method check ($more, $less) {
        # Hopefully the user didn't set collation-level manually to have a level
        # both enabled *and* disabled. But check if this is the case anyway.
        return  0 if $!collation-level +& all($more,$less);
        return  1 if $!collation-level +& $more;
        return -1 if $!collation-level +& $less;
        return  0;
    }
    method primary     { self.check( 1,   2) }
    method secondary   { self.check( 4,   8) }
    method tertiary    { self.check(16,  32) }
    method quaternary  { self.check(64, 128) }
}

Rakudo::Internals.REGISTER-DYNAMIC: '$*COLLATION', {
    PROCESS::<$COLLATION> := Collation.new;
}

#line 1 SETTING::src/core/Encoding/Decoder.pm
role Encoding::Decoder {
    method add-bytes(Blob:D $bytes --> Nil) { ... }
    method consume-available-chars(--> Str:D) { ... }
    method consume-all-chars(--> Str:D) { ... }
    method consume-exactly-chars(int $chars, Bool:D :$eof = False --> Str) { ... }
    method set-line-separators(@seps --> Nil) { ... }
    method consume-line-chars(Bool:D :$chomp = False, Bool:D :$eof = False --> Str) { ... }
    method is-empty(--> Bool) { ... }
    method bytes-available(--> Int:D) { ... }
    method consume-exactly-bytes(int $bytes --> Blob) { ... }
}

#line 1 SETTING::src/core/Encoding/Decoder/Builtin.pm
my class Encoding::Decoder::Builtin is repr('Decoder') does Encoding::Decoder {
    method new(str $encoding, :$translate-nl) {
        nqp::decoderconfigure(nqp::create(self), $encoding,
            $translate-nl ?? nqp::hash('translate_newlines', 1) !! nqp::null())
    }

    method add-bytes(Blob:D $bytes --> Nil) {
        nqp::decoderaddbytes(self, nqp::decont($bytes));
    }

    method consume-available-chars(--> Str:D) {
        nqp::decodertakeavailablechars(self)
    }

    method consume-all-chars(--> Str:D) {
        nqp::decodertakeallchars(self)
    }

    method consume-exactly-chars(int $chars, Bool:D :$eof = False --> Str) {
        my str $result = $eof
            ?? nqp::decodertakecharseof(self, $chars)
            !! nqp::decodertakechars(self, $chars);
        nqp::isnull_s($result) ?? Str !! $result
    }

    method set-line-separators(@seps --> Nil) {
        my $sep-strs := nqp::list_s();
        nqp::push_s($sep-strs, .Str) for @seps;
        nqp::decodersetlineseps(self, $sep-strs);
    }

    method consume-line-chars(Bool:D :$chomp = False, Bool:D :$eof = False --> Str) {
        my str $line = nqp::decodertakeline(self, $chomp, $eof);
        nqp::isnull_s($line) ?? Str !! $line
    }

    method is-empty() {
        nqp::decoderempty(self)
    }

    method bytes-available() {
        nqp::decoderbytesavailable(self)
    }

    method consume-exactly-bytes(int $bytes --> Blob) {
        nqp::ifnull(nqp::decodertakebytes(self, buf8.new, $bytes), Blob)
    }
}

my class Supply { ... }
my class Encoding::Registry { ... }
augment class Rakudo::Internals {
    method BYTE_SUPPLY_DECODER(Supply:D $bin-supply, Str:D $enc, :$translate-nl) {
        supply {
            my $decoder = Encoding::Registry.find($enc).decoder(:$translate-nl);
            whenever $bin-supply {
                $decoder.add-bytes($_);
                my $available = $decoder.consume-available-chars();
                emit $available if $available ne '';
                LAST {
                    # XXX The `with` is required due to a bug where the
                    # LAST phaser is not properly scoped if we don't get
                    # any bytes. Since that means there's nothing to emit
                    # anyway, we'll not worry about this case for now.
                    #
                    # --- or at least that was the the idea before we fixed
                    # that bug: https://irclog.perlgeek.de/perl6/2016-12-07#i_13698178
                    # and tried removing the `with` in 58cdfd8, but then the error
                    # `No such method 'consume-all-chars' for invocant of type 'Any`
                    # started popping up on Proc::Async tests, so...
                    # there may be some other bug affecting this?
                    with $decoder {
                        my $rest = .consume-all-chars();
                        emit $rest if $rest ne '';
                    }
                }
            }
        }
    }
}

#line 1 SETTING::src/core/Encoding/Encoder.pm
role Encoding::Encoder {
    method encode-chars(Str:D --> Blob:D) { ... }
}

#line 1 SETTING::src/core/Encoding/Encoder/Builtin.pm
my class Encoding::Encoder::Builtin does Encoding::Encoder {
    has str $!encoding;
    has Blob $!type;

    method new(Str $encoding, Blob:U $type) {
        nqp::create(self)!setup($encoding, $type)
    }

    method !setup($encoding, $type) {
        $!encoding = $encoding;
        $!type := nqp::can($type.HOW, 'pun') ?? $type.^pun !! $type.WHAT;
        self
    }

    method encode-chars(str $str --> Blob:D) {
        nqp::encode($str, $!encoding, nqp::create($!type))
    }
}

my class Encoding::Encoder::Builtin::Replacement does Encoding::Encoder {
    has str $!encoding;
    has Blob $!type;
    has str $!replacement;

    method new(Str $encoding, Blob:U $type, Str $replacement) {
        nqp::create(self)!setup($encoding, $type, $replacement)
    }

    method !setup($encoding, $type, $replacement) {
        $!encoding = $encoding;
        $!type := nqp::can($type.HOW, 'pun') ?? $type.^pun !! $type.WHAT;
        $!replacement = $replacement;
        self
    }

    method encode-chars(str $str --> Blob:D) {

        nqp::encoderep($str, $!encoding, $!replacement, nqp::create($!type))




    }
}

#line 1 SETTING::src/core/Encoding/Encoder/TranslateNewlineWrapper.pm
my class Encoding::Encoder::TranslateNewlineWrapper does Encoding::Encoder {
    has Encoding::Encoder $!delegate;

    method new(Encoding::Encoder $delegate) {
        nqp::create(self)!setup($delegate)
    }

    method !setup(Encoding::Encoder $delegate) {
        $!delegate := $delegate;
        self
    }

    method encode-chars(Str:D $str --> Blob:D) {
        $!delegate.encode-chars(Rakudo::Internals.TRANSPOSE($str, "\n", "\r\n"))
    }
}

#line 1 SETTING::src/core/Encoding.pm
role Encoding {
    method name(--> Str) { ... }
    method alternative-names() { () }
    method encoder(*%options --> Encoding::Encoder) { ... }
    method decoder(*%options --> Encoding::Decoder) { ... }
}

#line 1 SETTING::src/core/Encoding/Builtin.pm
class Encoding::Builtin does Encoding {
    has Str $.name;
    has $!alternative-names;

    method new() {
        X::Cannot::New.new(class => self.WHAT).throw
    }

    method SET-SELF(\name, \alternatives) {
        nqp::stmts(
          ($!name := name),
          ($!alternative-names := alternatives),
          self
        )
    }

    method alternative-names() { $!alternative-names }

    method decoder(*%options --> Encoding::Decoder) {
        Encoding::Decoder::Builtin.new($!name, |%options)
    }

    my int $is-win = Rakudo::Internals.IS-WIN;
    method encoder(:$replacement, :$translate-nl --> Encoding::Encoder) {
        my $encoder = $replacement.DEFINITE && $replacement !=== False
            ?? Encoding::Encoder::Builtin::Replacement.new($!name,
                    self!buf-type(), self!rep-char($replacement))
            !! Encoding::Encoder::Builtin.new($!name, self!buf-type());
        $translate-nl && $is-win
            ?? Encoding::Encoder::TranslateNewlineWrapper.new($encoder)
            !! $encoder
    }

    my $enc_type := nqp::hash('utf8',utf8,'utf16',utf16,'utf32',utf32);
    method !buf-type() {
        nqp::ifnull(nqp::atkey($enc_type, $!name), blob8)
    }

    method !rep-char($replacement) {
        nqp::istype($replacement, Bool)
            ?? ($!name.starts-with('utf') ?? "\x[FFFD]" !! "?")
            !! $replacement.Str
    }
}

#line 1 SETTING::src/core/Encoding/Registry.pm
my class X::Encoding::Unknown { ... }
my class X::Encoding::AlreadyRegistered { ... }

my class Encoding::Registry {
    my $lock := Lock.new;
    my %lookup;  # access for registering builtins at compile time
    my $lookup := nqp::getattr(%lookup,Map,'$!storage');  # access for runtime

    BEGIN {
        my $lookup := nqp::bindattr(%lookup,Map,'$!storage',nqp::hash);
        my $encodings := nqp::list(
          nqp::list("ascii"),
          nqp::list("iso-8859-1","iso_8859-1:1987","iso_8859-1","iso-ir-100",
            "latin1","latin-1","csisolatin1","l1","ibm819","cp819"),
          nqp::list("utf8","utf-8"),
          nqp::list("utf8-c8","utf-8-c8"),
          nqp::list("utf16","utf-16"),
          nqp::list("utf32","utf-32"),
          nqp::list("windows-1252")
        );
        my int $i = -1;
        my int $elems = nqp::elems($encodings);
        while nqp::islt_i(($i = nqp::add_i($i,1)),$elems) {
            my $names := nqp::atpos($encodings,$i);
            my $builtin := nqp::create(Encoding::Builtin).SET-SELF(
              nqp::shift($names),nqp::clone($names));
            nqp::bindkey($lookup,$builtin.name,$builtin);
            while nqp::elems($names) {
                nqp::bindkey($lookup,nqp::shift($names),$builtin);
            }
        }
    }

    method register(Encoding $enc --> Nil) {
        $lock.protect: {
            nqp::stmts(
              nqp::if(
                nqp::existskey($lookup,(my str $key = $enc.name.fc)),
                X::Encoding::AlreadyRegistered.new(name => $enc.name).throw,
                nqp::bindkey($lookup,$key,$enc)
              ),
              (my $names :=
                nqp::getattr($enc.alternative-names,List,'$!reified')),
              (my int $elems = nqp::elems($names)),
              (my int $i = -1),
              nqp::while(
                nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                nqp::if(
                  nqp::existskey($lookup,($key = nqp::atpos($names,$i).fc)),
                  X::Encoding::AlreadyRegistered.new(
                    name => nqp::atpos($names,$i)).throw,
                  nqp::bindkey($lookup,$key,$enc)
                )
              )
            )
        }
    }

    method find(Str() $name) {
        $lock.protect: {
            nqp::ifnull(
              nqp::atkey($lookup,$name.fc),
              X::Encoding::Unknown.new(:$name).throw
            )
        }
    }
}

#line 1 SETTING::src/core/Str.pm
my class Range  { ... }
my class Match  { ... }
my class X::Cannot::Capture      { ... }
my class X::Str::InvalidCharName { ... }
my class X::Str::Numeric  { ... }
my class X::Str::Match::x { ... }
my class X::Str::Subst::Adverb { ... }
my class X::Str::Trans::IllegalKey { ... }
my class X::Str::Trans::InvalidArg { ... }
my class X::Numeric::Confused { ... }
my class X::Syntax::Number::RadixOutOfRange { ... }

my constant $?TABSTOP = 8;

my class Str does Stringy { # declared in BOOTSTRAP
    # class Str is Cool
    #     has str $!value is box_target;

    my $empty := nqp::list;   # for nqp::splice

    multi method WHY('Life, the Universe and Everything': --> 42) { }

    multi method WHICH(Str:D:) {
        nqp::box_s(
          nqp::concat(
            nqp::if(
              nqp::eqaddr(self.WHAT,Str),
              'Str|',
              nqp::concat(nqp::unbox_s(self.^name), '|')
            ),
            $!value
          ),
          ObjAt
        )
    }
    submethod BUILD(Str() :$value = '' --> Nil) {
        nqp::bindattr_s(self, Str, '$!value', nqp::unbox_s($value))
    }

    multi method Bool(Str:D:) {
        nqp::p6bool(nqp::chars($!value));
    }
    method Capture() { die X::Cannot::Capture.new: :what(self) }

    multi method Str(Str:D:)     { self }
    multi method Stringy(Str:D:) { self }
    multi method DUMP(Str:D:) { self.perl }

    method Int(Str:D:) {
        nqp::if(
          nqp::isge_i(
            nqp::findnotcclass(
              nqp::const::CCLASS_NUMERIC,$!value,0,nqp::chars($!value)),
            nqp::chars($!value)
          )

            # Compare Str.chars == Str.codes to filter out any combining characters
            && nqp::iseq_i(
                nqp::chars($!value),
                nqp::codes($!value)
            )





          ,
          nqp::atpos(nqp::radix_I(10,$!value,0,0,Int),0),  # all numeric chars
          nqp::if(
            nqp::istype((my $numeric := self.Numeric),Failure),
            $numeric,
            $numeric.Int
          )
        )
    }
    method Num(Str:D:) {
        nqp::if(
            nqp::istype((my $numeric := self.Numeric),Failure),
            $numeric,
            $numeric.Num || nqp::if(
                # handle sign of zero. While self.Numeric will give correctly
                # signed zero for nums in strings, it won't for other types,
                # and since this method is `Num` we want to return proper zero.
                # Find first non-whitespace char and check whether it is one
                # of the minuses.
                nqp::chars(self)
                && (
                    nqp::iseq_i(
                        (my $ch := nqp::ord(
                            nqp::substr(
                                self,
                                nqp::findnotcclass(
                                    nqp::const::CCLASS_WHITESPACE, self, 0,
                                    nqp::sub_i(nqp::chars(self), 1)
                                ),
                                1,
                            )
                        )),
                        45, # '-' minus
                    ) || nqp::iseq_i($ch, 8722) # '' minus
                ),
                -0e0,
                 0e0
            )
        )
    }

    multi method ACCEPTS(Str:D: Str:D \other) {
        nqp::p6bool(nqp::iseq_s(nqp::unbox_s(other),$!value));
    }
    multi method ACCEPTS(Str:D: Any:D \other) {
        nqp::p6bool(nqp::iseq_s(nqp::unbox_s(other.Str),$!value));
    }

    method chomp(Str:D:) {
        nqp::if(
          (nqp::isge_i((my int $chars = nqp::sub_i(nqp::chars($!value),1)),0)
            && nqp::iscclass(nqp::const::CCLASS_NEWLINE,$!value,$chars)),
          nqp::p6box_s(nqp::substr($!value,0,$chars)),
          self
        )
    }

    multi method chop(Str:D:) {
        nqp::if(
          nqp::isgt_i(nqp::chars($!value),0),
          nqp::p6box_s(
            nqp::substr($!value,0,nqp::sub_i(nqp::chars($!value),1))),
          ''
        )
    }
    multi method chop(Str:D: Int() $chopping) {
        my Int $chars = nqp::chars($!value) - $chopping;
        $chars > 0 ?? nqp::p6box_s(nqp::substr($!value,0,$chars)) !! '';
    }

    # TODO Use coercer in 1 candidate when RT131014
    proto method starts-with(|) {*}
    multi method starts-with(Str:D: Cool:D $needle) {self.starts-with: $needle.Str}
    multi method starts-with(Str:D: Str:D $needle) {
        nqp::p6bool(nqp::eqat(self, $needle, 0))
    }

    # TODO Use coercer in 1 candidate when RT131014
    proto method ends-with(|) {*}
    multi method ends-with(Str:D: Cool:D $suffix) {self.ends-with: $suffix.Str}
    multi method ends-with(Str:D: Str:D $suffix) {
        nqp::p6bool(nqp::eqat(
          $!value,
          nqp::getattr($suffix,Str,'$!value'),
          nqp::chars($!value) - nqp::chars(nqp::getattr($suffix,Str,'$!value'))
        ))
    }

    # TODO Use coercer in 1 candidate when RT131014
    proto method substr-eq(|) {*}
    multi method substr-eq(Str:D: Cool:D $needle) {self.substr-eq: $needle.Str}
    multi method substr-eq(Str:D: Str:D $needle) {
        nqp::p6bool(nqp::eqat($!value,nqp::getattr($needle,Str,'$!value'),0))
    }
    multi method substr-eq(Str:D: Cool:D $needle, Int:D $pos) {self.substr-eq: $needle.Str, $pos.Int}
    multi method substr-eq(Str:D: Str:D $needle, Int:D $pos) {
        nqp::p6bool(
          nqp::if(
            (nqp::isge_i($pos,0) && nqp::islt_i($pos,nqp::chars($!value))),
            nqp::eqat($!value,nqp::getattr($needle,Str,'$!value'),$pos)
          )
        )
    }

    # TODO Use coercer in 1 candidate when RT131014
    proto method contains(|) {*}
    multi method contains(Str:D: Cool:D $needle) {self.contains: $needle.Str}
    multi method contains(Str:D: Str:D $needle) {
        nqp::p6bool(nqp::isne_i(
          nqp::index($!value,nqp::getattr($needle,Str,'$!value'),0),-1
        ))
    }
    multi method contains(Str:D: Cool:D $needle, Int(Cool:D) $pos) {self.contains: $needle.Str, $pos}
    multi method contains(Str:D: Str:D $needle, Int:D $pos) {
        nqp::p6bool(
          nqp::if(
            (nqp::isge_i($pos,0) && nqp::islt_i($pos,nqp::chars($!value))),
            nqp::isne_i(
              nqp::index($!value,nqp::getattr($needle,Str,'$!value'),$pos),-1)
          )
        )
    }

    # TODO Use coercer in 1 candidate when RT131014
    proto method indices(|) {*}
    multi method indices(Str:D: Cool:D $needle, *%pars) {self.indices: $needle.Str, |%pars}
    multi method indices(Str:D: Str:D $needle, :$overlap) {
        nqp::stmts(
          (my $need    := nqp::getattr($needle,Str,'$!value')),
          (my int $add  = nqp::if($overlap,1,nqp::chars($need) || 1)),
          (my $indices := nqp::create(IterationBuffer)),
          (my int $pos),
          (my int $i),
          nqp::while(
            nqp::isge_i(($i = nqp::index($!value,$need,$pos)),0),
            nqp::stmts(
              nqp::push($indices,nqp::p6box_i($i)),
              ($pos = nqp::add_i($i,$add))
            )
          ),
          nqp::p6bindattrinvres(nqp::create(List),List,'$!reified',$indices)
        )
    }
    multi method indices(Str:D: Cool:D $needle, Cool:D $start, *%pars) {self.indices: $needle.Str, $start.Int, |%pars}
    multi method indices(Str:D: Str:D $needle, Int:D $start, :$overlap) {
        nqp::stmts(
          (my int $pos = $start),
          nqp::if(
            nqp::isgt_i($pos,nqp::chars($!value)),
            nqp::create(List),   # position after string, always empty List
            nqp::stmts(
              (my $need   := nqp::getattr($needle,Str,'$!value')),
              (my int $add = nqp::if($overlap,1,nqp::chars($need) || 1)),
              (my $indices := nqp::create(IterationBuffer)),
              (my int $i),
              nqp::while(
                nqp::isge_i(($i = nqp::index($!value,$need,$pos)),0),
                nqp::stmts(
                  nqp::push($indices,nqp::p6box_i($i)),
                  ($pos = nqp::add_i($i,$add))
                )
              ),
              nqp::p6bindattrinvres(nqp::create(List),List,'$!reified',$indices)
            )
          )
        )
    }

    # TODO Use coercer in 1 candidate when RT131014
    proto method index(|) {*}
    multi method index(Str:D: Cool:D $needle) {self.index: $needle.Str}
    multi method index(Str:D: Str:D $needle) {
        nqp::if(
          nqp::islt_i((my int $i =
            nqp::index($!value,nqp::getattr($needle,Str,'$!value'))),
            0
          ),
          Nil,
          nqp::p6box_i($i)
        )
    }
    multi method index(Str:D: Cool:D $needle, Cool:D $pos) {self.index: $needle.Str, $pos.Int}
    multi method index(Str:D: Str:D $needle, Int:D $pos) {
        nqp::if(
          nqp::isbig_I(nqp::decont($pos)),
          Failure.new(X::OutOfRange.new(
            :what("Position in index"),
            :got($pos),
            :range("0..{self.chars}")
          )),
          nqp::if(
            nqp::islt_i($pos,0),
            Failure.new(X::OutOfRange.new(
              :what("Position in index"),
              :got($pos),
              :range("0..{self.chars}")
            )),
            nqp::if(
              nqp::islt_i((my int $i = nqp::index(
                $!value,nqp::getattr($needle,Str,'$!value'),$pos
              )),0),
              Nil,
              nqp::p6box_i($i)
            )
          )
        )
    }

    # TODO Use coercer in 1 candidate when RT131014
    proto method rindex(|) {*}
    multi method rindex(Str:D: Cool:D $needle) {self.rindex: $needle.Str}
    multi method rindex(Str:D: Str:D $needle) {
        nqp::if(
          nqp::islt_i((my int $i =
            nqp::rindex($!value,nqp::getattr($needle,Str,'$!value'))),
            0
          ),
          Nil,
          nqp::p6box_i($i)
        )
    }
    multi method rindex(Str:D: Cool:D $needle, Cool:D $pos) {self.rindex: $needle.Str, $pos.Int}
    multi method rindex(Str:D: Str:D $needle, Int:D $pos) {
        nqp::if(
          nqp::isbig_I(nqp::decont($pos)),
          Failure.new(X::OutOfRange.new(
            :what("Position in rindex"),
            :got($pos),
            :range("0..{self.chars}")
          )),
          nqp::if(
            nqp::islt_i($pos,0),
            Failure.new(X::OutOfRange.new(
              :what("Position in rindex"),
              :got($pos),
              :range("0..{self.chars}")
            )),
            nqp::if(
              nqp::islt_i((my int $i = nqp::rindex(
                $!value,nqp::getattr($needle,Str,'$!value'),$pos
              )),0),
              Nil,
              nqp::p6box_i($i)
            )
          )
        )
    }

    method pred(Str:D:) {
        (my int $chars = Rakudo::Internals.POSSIBLE-MAGIC-CHARS(self))
          ?? Rakudo::Internals.PRED(self,$chars - 1)
          !! self
    }

    method succ(Str:D:) {
        (my int $chars = Rakudo::Internals.POSSIBLE-MAGIC-CHARS(self))
          ?? Rakudo::Internals.SUCC(self,$chars - 1)
          !! self
    }

    multi method Numeric(Str:D:) {
        # Handle special empty string
        self.trim eq ""
          ?? 0
          !! val(self, :val-or-fail)
    }

    multi method gist(Str:D:) { self }
    multi method perl(Str:D:) {
        '"' ~ Rakudo::Internals.PERLIFY-STR(self) ~ '"'
    }

    proto method comb(|) { * }
    multi method comb(Str:D:) {
        Seq.new(class :: does Iterator {
            has str $!str;
            has int $!chars;
            has int $!pos;
            method !SET-SELF(\string) {
                nqp::stmts(
                  ($!str   = nqp::unbox_s(string)),
                  ($!chars = nqp::chars($!str)),
                  ($!pos = -1),
                  self
                )
            }
            method new(\string) {
                nqp::if(
                  string,
                  nqp::create(self)!SET-SELF(string),
                  Rakudo::Iterator.Empty
                )
            }
            method pull-one() {
                nqp::if(
                  nqp::islt_i(($!pos = nqp::add_i($!pos,1)),$!chars),
                  nqp::p6box_s(nqp::substr($!str,$!pos,1)),
                  IterationEnd
                )
            }
            method count-only() { nqp::p6box_i($!chars) }
            method bool-only(--> True) { }
        }.new(self));
    }
    multi method comb(Str:D: Int:D $size is copy, $limit = *) {
        my int $inf = nqp::istype($limit,Whatever) || $limit == Inf;
        return self.comb if $size <= 1 && $inf;
        $size = 1 if $size < 1;

        Seq.new(class :: does Iterator {
            has str $!str;
            has int $!chars;
            has int $!size;
            has int $!pos;
            has int $!max;
            has int $!todo;
            method !SET-SELF(\string,\size,\limit,\inf) {
                nqp::stmts(
                  ($!str   = nqp::unbox_s(string)),
                  ($!chars = nqp::chars($!str)),
                  ($!size  = 1 max size),
                  ($!pos   = -size),
                  ($!max   = 1 + floor( ( $!chars - 1 ) / $!size )),
                  ($!todo  = (inf ?? $!max !! (0 max limit)) + 1),
                  self
                )
            }
            method new(\string,\size,\limit,\inf) {
                nqp::if(
                  string,
                  nqp::create(self)!SET-SELF(string,size,limit,inf),
                  Rakudo::Iterator.Empty
                )
            }
            method pull-one() {
                ($!todo = $!todo - 1) && ($!pos = $!pos + $!size) < $!chars
                  ?? nqp::p6box_s(nqp::substr($!str, $!pos, $!size))
                  !! IterationEnd
            }
            method push-all($target --> IterationEnd) {
                my int $todo  = $!todo;
                my int $pos   = $!pos;
                my int $size  = $!size;
                my int $chars = $!chars;
                $target.push(nqp::p6box_s(nqp::substr($!str, $pos, $size)))
                  while ($todo = $todo - 1 ) && ($pos = $pos + $size) < $chars;
                $!pos = $!chars;
            }
            method count-only() { $!max }
            method bool-only(--> True) { }
        }.new(self,$size,$limit,$inf))
    }
    multi method comb(Str:D: Str $pat) {
        return self.comb(1) unless $pat;
        Seq.new(class :: does Iterator {
            has str $!str;
            has str $!pat;
            has int $!pos;
            method !SET-SELF(\string, \pat) {
                $!str = nqp::unbox_s(string);
                $!pat = nqp::unbox_s(pat);
                self
            }
            method new(\string, \pat) { nqp::create(self)!SET-SELF(string,pat) }
            method pull-one() {
                my int $found = nqp::index($!str, $!pat, $!pos);
                if $found < 0 {
                    IterationEnd
                }
                else {
                    $!pos = $found + 1;
                    nqp::p6box_s($!pat)
                }
            }
        }.new(self, $pat));
    }
    multi method comb(Str:D: Str $pat, $limit) {
        return self.comb($pat)
          if nqp::istype($limit,Whatever) || $limit == Inf;
        return self.comb(1, $limit) unless $pat;

        Seq.new(class :: does Iterator {
            has str $!str;
            has str $!pat;
            has int $!pos;
            has int $!todo;
            method !SET-SELF(\string, \pat, \limit) {
                $!str  = nqp::unbox_s(string);
                $!pat  = nqp::unbox_s(pat);
                $!todo = nqp::unbox_i(limit.Int);
                self
            }
            method new(\string, \pat, \limit) {
                nqp::create(self)!SET-SELF(string, pat, limit)
            }
            method pull-one() {
                my int $found = nqp::index($!str, $!pat, $!pos);
                if $found < 0 || $!todo == 0 {
                    IterationEnd
                }
                else {
                    $!pos  = $found + 1;
                    $!todo = $!todo - 1;
                    nqp::p6box_s($!pat)
                }
            }
        }.new(self, $pat, $limit));
    }
    multi method comb(Str:D: Regex:D $pattern, :$match) {
        nqp::if(
          $match,
          self.match($pattern, :g),
          self.match($pattern, :g, :as(Str))
        )
    }
    multi method comb(Str:D: Regex:D $pattern, $limit, :$match) {
        nqp::if(
          nqp::istype($limit,Whatever) || $limit == Inf,
          self.comb($pattern, :$match),
          nqp::if(
            $match,
            self.match($pattern, :x(1..$limit)),
            self.match($pattern, :x(1..$limit), :as(Str))
          )
        )
    }

    # cache cursor initialization lookup
    my $cursor-init := Match.^lookup("!cursor_init");

    my \CURSOR-GLOBAL     := Match.^lookup("CURSOR_MORE"   );  # :g
    my \CURSOR-OVERLAP    := Match.^lookup("CURSOR_OVERLAP");  # :ov
    my \CURSOR-EXHAUSTIVE := Match.^lookup("CURSOR_NEXT"   );  # :ex

    my \POST-MATCH  := Match.^lookup("MATCH" );  # Match object
    my \POST-STR    := Match.^lookup("STR"   );  # Str object

    # iterate with post-processing
    class POST-ITERATOR does Iterator {
        has Mu $!cursor; # cannot put these 3 lines in role
        has Mu $!move;
        has Mu $!post;
        method !SET-SELF(\cursor,\move,\post) {
            $!cursor := cursor;
            $!move   := move;
            $!post   := post;
            self
        }
        method new(\c,\t,\p) { nqp::create(self)!SET-SELF(c,t,p) }
        method pull-one() is raw {
            nqp::if(
              nqp::isge_i(nqp::getattr_i($!cursor,Match,'$!pos'),0),
              nqp::stmts(
                (my $pulled := $!cursor),
                ($!cursor := $!move($!cursor)),
                $!post($pulled)
              ),
              IterationEnd
            )
        }
        method skip-one() is raw {
            nqp::if(
              nqp::isge_i(nqp::getattr_i($!cursor,Match,'$!pos'),0),
              ($!cursor := $!move($!cursor)),
            )
        }
        method push-all($target --> IterationEnd) {
            nqp::while(
              nqp::isge_i(nqp::getattr_i($!cursor,Match,'$!pos'),0),
              nqp::stmts(
                $target.push($!post($!cursor)),
                ($!cursor := $!move($!cursor))
              )
            )
        }
    }

    # iterate returning Matches
    class CURSOR-ITERATOR does Iterator {
        has Mu $!cursor;
        has Mu $!move;
        method !SET-SELF(\cursor,\move) {
            $!cursor := cursor;
            $!move   := move;
            self
        }
        method new(\c,\t) { nqp::create(self)!SET-SELF(c,t) }
        method pull-one() is raw {
            nqp::if(
              nqp::isge_i(nqp::getattr_i($!cursor,Match,'$!pos'),0),
              nqp::stmts(
                (my $pulled := $!cursor),
                ($!cursor := $!move($!cursor)),
                $pulled
              ),
              IterationEnd
            )
        }
        method skip-one() is raw {
            nqp::if(
              nqp::isge_i(nqp::getattr_i($!cursor,Match,'$!pos'),0),
              ($!cursor := $!move($!cursor)),
            )
        }
        method push-all($target --> IterationEnd) {
            nqp::while(
              nqp::isge_i(nqp::getattr_i($!cursor,Match,'$!pos'),0),
              nqp::stmts(
                $target.push($!cursor),
                ($!cursor := $!move($!cursor))
              )
            )
        }
    }

    # Look for short/long named parameter and remove it from the hash
    sub fetch-short-long(\opts, str $short, str $long, \store --> Nil) {
        nqp::if(
          nqp::existskey(opts,$short),
          nqp::stmts(
            (store = nqp::atkey(opts,$short)),
            nqp::deletekey(opts,$short)
          ),
          nqp::if(
            nqp::existskey(opts,$long),
            nqp::stmts(
              (store = nqp::atkey(opts,$long)),
              nqp::deletekey(opts,$long)
            )
          )
        )
    }

    # Look for named parameters, do not remove from hash
    sub fetch-all-of(\opts, @names, \store --> Nil) {
        nqp::stmts(
          (my int $elems = @names.elems),   # reifies
          (my $list := nqp::getattr(@names,List,'$!reified')),
          (my int $i = -1),
          nqp::while(
            nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
            nqp::if(
              nqp::existskey(opts,nqp::unbox_s(nqp::atpos($list,$i))),
              (store = nqp::atkey(opts,nqp::unbox_s(nqp::atpos($list,$i)))),
            )
          )
        )
    }

    sub die-before-first($got) {
        die "Attempt to retrieve before :1st match -- :nth({
            $got // $got.^name
        })"
    }

    # All of these !match methods take a nqp::getlexcaller value for the $/
    # to be set as the first parameter.  The second parameter is usually
    # the Match object to be used (or something from which a Match can
    # be made).

    # Generic fallback for matching with a pattern
    method !match-pattern(\slash, $pattern, str $name, $value, \opts) {
        nqp::stmts(
          (my $opts := nqp::getattr(opts,Map,'$!storage')),
          nqp::bindkey($opts,$name,$value),
          fetch-short-long($opts, "p", "pos", my $p),
          fetch-short-long($opts, "c", "continue", my $c),
          nqp::unless(nqp::defined($c), $c = 0),
          nqp::if(
            nqp::elems($opts),
            nqp::if(
              nqp::defined($p),
              self!match-cursor(slash,
                $pattern($cursor-init(Match,self,:$p)), '', 0, $opts),
              self!match-cursor(slash,
                $pattern($cursor-init(Match,self,:$c)), '', 0, $opts)
            ),
            nqp::if(
              nqp::defined($p),
              self!match-one(slash,
                $pattern($cursor-init(Match,self,:$p))),
              self!match-one(slash,
                $pattern($cursor-init(Match,self,:$c)))
            )
          )
        )
    }

    # Generic fallback for matching with a cursor.  This is typically
    # called if more than one named parameter was specified.  Arguments
    # 3/4 are the initial named parameter matched: instead of flattening
    # the named parameter into another slurpy hash, we pass the name and
    # the value as extra parameters, and add it back in the hash with
    # named parameters.
    method !match-cursor(\slash, \cursor, str $name, $value, \opts) {
        nqp::stmts(
          (my $opts := nqp::getattr(opts,Map,'$!storage')),
          nqp::if(
            nqp::chars($name),
            nqp::bindkey($opts,$name,$value)
          ),
          fetch-short-long($opts, "ex", "exhaustive", my $ex),
          fetch-short-long($opts, "ov", "overlap",    my $ov),
          (my \move := nqp::if($ex, CURSOR-EXHAUSTIVE,
            nqp::if($ov, CURSOR-OVERLAP, CURSOR-GLOBAL))),

          fetch-short-long($opts, "as", "as", my $as),
          (my \post := nqp::if(nqp::istype($as,Str), POST-STR, POST-MATCH)),

          fetch-short-long($opts, "g", "global", my $g),
          nqp::if(
            nqp::elems($opts),
            nqp::stmts(
              fetch-short-long($opts, "x", "x", my $x),
              fetch-all-of($opts, <st nd rd th nth>, my $nth),
              nqp::if(
                nqp::defined($nth),
                nqp::if(
                  nqp::defined($x),                             # :nth && :x
                  self!match-x(slash,
                    self!match-nth(slash, cursor,
                      move, post, $nth, nqp::hash).iterator, $x),
                  self!match-nth(slash, cursor,
                    move, post, $nth, nqp::hash)  # nth
                ),
                nqp::if(
                  nqp::defined($x),
                  self!match-x(slash,                           # :x
                    POST-ITERATOR.new(cursor, move, post), $x),
                  nqp::if(                                      # only :ex|ov|g
                    $ex || $ov || $g,
                    self!match-list(slash, cursor, move, post),
                    self!match-one(slash, cursor)
                  )
                )
              )
            ),
            nqp::if(                                            # only :ex|ov|g
              $ex || $ov || $g,
              self!match-list(slash, cursor, move, post),
              self!match-one(slash, cursor)
            )
          )
        )
    }

    # Match object at given position
    method !match-one(\slash, \cursor) {
        nqp::decont(slash = nqp::if(
          nqp::isge_i(nqp::getattr_i(cursor,Match,'$!pos'),0),
          cursor.MATCH,
          Nil
        ))
    }

    # Some object at given position
    method !match-as-one(\slash, \cursor, \as) {
        nqp::decont(slash = nqp::if(
          nqp::isge_i(nqp::getattr_i(cursor,Match,'$!pos'),0),
          nqp::if(nqp::istype(as,Str), POST-STR, POST-MATCH)(cursor),
          Nil
        ))
    }

    # Create list from the appropriate Sequence given the move
    method !match-list(\slash, \cursor, \move, \post) {
        nqp::decont(slash = nqp::if(
          nqp::isge_i(nqp::getattr_i(cursor,Match,'$!pos'),0),
          Seq.new(POST-ITERATOR.new(cursor, move, post)).list,
          List.new,
        ))
    }

    # Handle matching of the nth match specification.
    method !match-nth(\slash, \cursor, \move, \post, $nth, %opts) {
        nqp::if(
          nqp::elems(nqp::getattr(%opts,Map,'$!storage')),
          self!match-cursor(slash, cursor, 'nth', $nth, %opts),
          nqp::if(
            nqp::defined($nth),
            nqp::if(
              nqp::istype($nth,Whatever),
              self!match-last(slash, cursor, move),
              nqp::if(
                nqp::istype($nth,Numeric),
                nqp::if(
                  $nth == Inf,
                  self!match-last(slash, cursor, move),
                  nqp::if(
                    $nth < 1,
                    die-before-first($nth),
                    self!match-nth-int(slash, cursor, move, post, $nth.Int)
                  )
                ),
                nqp::if(
                  nqp::istype($nth,WhateverCode),
                  nqp::if(
                    nqp::iseq_i((my int $tail = abs($nth(-1))),1),
                    self!match-last(slash, cursor, move),
                    self!match-nth-tail(slash, cursor, move, $tail)
                  ),
                  nqp::if(
                    nqp::istype($nth,Callable),
                    self!match-nth-int(slash,
                      cursor, move, post, $nth()),
                    self!match-nth-iterator(slash,
                      POST-ITERATOR.new(cursor, move, post),
                      $nth.iterator)
                  )
                )
              )
            ),
            self!match-one(slash, cursor)
          )
        )
    }

    # Give back the nth match found
    method !match-nth-int(\slash, \cursor, \move, \post, int $nth) {
        nqp::decont(slash = nqp::if(
          nqp::isge_i(nqp::getattr_i(cursor,Match,'$!pos'),0),
          nqp::if(
            nqp::eqaddr(
              (my $pulled := POST-ITERATOR.new(cursor, move, post)
                .skip-at-least-pull-one(nqp::sub_i($nth,1))),
              IterationEnd
            ),
            Nil,              # not enough matches
            $pulled           # found it!
          ),
          Nil                 # no matches whatsoever
        ))
    }

    # Give back the N-tail match found
    method !match-nth-tail(\slash, \cursor, \move, int $tail) {
        nqp::decont(slash = nqp::if(
          nqp::eqaddr((my $pulled :=
            Rakudo::Iterator.LastNValues(
              CURSOR-ITERATOR.new(cursor, move),
              $tail, 'match', 1).pull-one),
            IterationEnd
          ),
          Nil,
          $pulled.MATCH
        ))
    }

    # Give last value of given iterator, or Nil if none
    method !match-last(\slash, \cursor, \move) {
        nqp::decont(slash = nqp::if(
          nqp::eqaddr((my $pulled :=
            Rakudo::Iterator.LastValue(
              CURSOR-ITERATOR.new(cursor, move),
              'match')),
            IterationEnd
          ),
          Nil,
          $pulled.MATCH
        ))
    }

    # These !match methods take an iterator instead of a cursor.
    # Give list with matches found given a range with :nth
    method !match-nth-range(\slash, \iterator, $min, $max) {
        nqp::decont(slash = nqp::stmts(
          (my int $skip = $min),
          nqp::if(
            nqp::islt_i($skip,1),
            die-before-first($min),
            nqp::stmts(
              nqp::while(
                nqp::isgt_i($skip,1) && iterator.skip-one,
                ($skip = nqp::sub_i($skip,1))
              ),
              nqp::if(
                nqp::iseq_i($skip,1),
                nqp::if(                       # did not exhaust while skipping
                  $max == Inf,                 # * is Inf in N..*
                  nqp::stmts(                  # open ended
                    (my $matches := nqp::create(IterationBuffer)),
                    nqp::until(
                      nqp::eqaddr(
                        (my $pulled := iterator.pull-one),
                        IterationEnd
                      ),
                      nqp::push($matches,$pulled)
                    ),
                    nqp::p6bindattrinvres(
                      nqp::create(List),List,'$!reified',$matches)
                  ),
                  nqp::stmts(                  # upto the max index
                    (my int $todo = $max - $min + 1),
                    ($matches :=
                      nqp::setelems(nqp::create(IterationBuffer),$todo)),
                    (my int $i = -1),
                    nqp::until(
                      nqp::iseq_i(($i = nqp::add_i($i,1)),$todo)
                        || nqp::eqaddr(
                             ($pulled := iterator.pull-one),IterationEnd),
                      nqp::bindpos($matches,$i,$pulled)
                    ),
                    nqp::if(
                      nqp::iseq_i($i,$todo),
                      nqp::p6bindattrinvres(  # found all values
                        nqp::create(List),List,'$!reified',$matches),
                      Empty                   # no match, since not all values
                    )
                  )
                ),
                Empty                         # exhausted while skipping
              )
            )
          )
        ))
    }

    # Give list with matches found given an iterator with :nth
    method !match-nth-iterator(\slash, \source, \indexes) {
        nqp::decont(slash = nqp::stmts(
          Seq.new(Rakudo::Iterator.MonotonicIndexes(
            source, indexes, 1,
            -> $got,$next {
              nqp::if(
                $next == 1,
                die-before-first($got),
                (die "Attempt to fetch match #$got after #{$next - 1}")
              )
            }
          )).list
        ))
    }

    # Give list with matches found given an iterator with :x
    method !match-x(\slash, \iterator, $x) {
        nqp::if(
          nqp::istype($x,Whatever),
          Seq.new(iterator).list,
          nqp::if(
            nqp::istype($x,Numeric),
            nqp::if(
              $x == Inf,
              Seq.new(iterator).list,
              nqp::if(
                nqp::istype($x,Int),
                self!match-x-range(slash, iterator, $x, $x),
                nqp::stmts(
                  (my int $xint = $x.Int),
                  self!match-x-range(slash, iterator, $xint, $xint)
                )
              )
            ),
            nqp::if(
              nqp::istype($x,Range),
              self!match-x-range(slash, iterator, $x.min, $x.max),
              nqp::stmts(
                (slash = Nil),
                Failure.new(X::Str::Match::x.new(:got($x)))
              )
            )
          )
        )
    }

    # Give list with matches found given a range with :x
    method !match-x-range(\slash, \iterator, $min, $max) {
        nqp::decont(slash = nqp::stmts(
          (my int $todo = nqp::if($max == Inf, 0x7fffffff, $max)),
          (my $matches := nqp::create(IterationBuffer)),
          nqp::until(
            nqp::islt_i(($todo = nqp::sub_i($todo,1)), 0) ||
              nqp::eqaddr((my $pulled := iterator.pull-one),IterationEnd),
            nqp::push($matches,$pulled)
          ),
          nqp::if(
            nqp::elems($matches) >= $min,
            nqp::p6bindattrinvres(
              nqp::create(List),List,'$!reified',$matches),
            Empty
          )
        ))
    }

    proto method match(|) { $/ := nqp::getlexcaller('$/'); {*} }
    multi method match(Cool:D $pattern, |c) {
        $/ := nqp::getlexcaller('$/');
        self.match(/ "$pattern": /,|c)
    }

    # All of these .match candidates take a single required named parameter
    # so that handling specification of a single named parameter can be much
    # quicker.  Unfortunately, we cannot cheaply do MMD on an empty slurpy
    # hash, which would make things much more simple.
    multi method match(Regex:D $pattern, :continue(:$c)!, *%_) {
        nqp::if(
          nqp::elems(nqp::getattr(%_,Map,'$!storage')),
          self!match-pattern(nqp::getlexcaller('$/'), $pattern, 'c', $c, %_),
          self!match-one(nqp::getlexcaller('$/'),
            $pattern($cursor-init(Match,self,:$c)))
        )
    }
    multi method match(Regex:D $pattern, :pos(:$p)!, *%_) {
        nqp::if(
          nqp::elems(nqp::getattr(%_,Map,'$!storage')),
          self!match-pattern(nqp::getlexcaller('$/'), $pattern, 'p', $p, %_),
          nqp::if(
            nqp::defined($p),
            self!match-one(nqp::getlexcaller('$/'),
              $pattern($cursor-init(Match,self,:$p))),
            self!match-one(nqp::getlexcaller('$/'),
              $pattern($cursor-init(Match,self,:0c)))
          )
        )
    }
    multi method match(Regex:D $pattern, :global(:$g)!, *%_) {
        nqp::if(
          nqp::elems(nqp::getattr(%_,Map,'$!storage')),
          self!match-cursor(nqp::getlexcaller('$/'),
            $pattern($cursor-init(Match,self,:0c)), 'g', $g, %_),
          nqp::if(
            $g,
            self!match-list(nqp::getlexcaller('$/'),
              $pattern($cursor-init(Match,self,:0c)),
              CURSOR-GLOBAL, POST-MATCH),
            self!match-one(nqp::getlexcaller('$/'),
              $pattern($cursor-init(Match,self,:0c)))
          )
        )
    }
    multi method match(Regex:D $pattern, :overlap(:$ov)!, *%_) {
        nqp::if(
          nqp::elems(nqp::getattr(%_,Map,'$!storage')),
          self!match-cursor(nqp::getlexcaller('$/'),
            $pattern($cursor-init(Match,self,:0c)), 'ov', $ov, %_),
          nqp::if(
            $ov,
            self!match-list(nqp::getlexcaller('$/'),
              $pattern($cursor-init(Match,self,:0c)),
              CURSOR-OVERLAP, POST-MATCH),
            self!match-one(nqp::getlexcaller('$/'),
              $pattern($cursor-init(Match,self,:0c)))
          )
        )
    }
    multi method match(Regex:D $pattern, :exhaustive(:$ex)!, *%_) {
        nqp::if(
          nqp::elems(nqp::getattr(%_,Map,'$!storage')),
          self!match-cursor(nqp::getlexcaller('$/'),
            $pattern($cursor-init(Match,self,:0c)), 'ex', $ex, %_),
          nqp::if(
            $ex,
            self!match-list(nqp::getlexcaller('$/'),
              $pattern($cursor-init(Match,self,:0c)),
              CURSOR-EXHAUSTIVE, POST-MATCH),
            self!match-one(nqp::getlexcaller('$/'),
              $pattern($cursor-init(Match,self,:0c)))
          )
        )
    }
    multi method match(Regex:D $pattern, :$x!, *%_) {
        nqp::if(
          nqp::elems(nqp::getattr(%_,Map,'$!storage')),
          self!match-cursor(nqp::getlexcaller('$/'),
            $pattern($cursor-init(Match,self,:0c)), 'x', $x, %_),
          nqp::if(
            nqp::defined($x),
            self!match-x(nqp::getlexcaller('$/'),
              POST-ITERATOR.new($pattern($cursor-init(Match,self,:0c)),
                CURSOR-GLOBAL, POST-MATCH
              ), $x),
            self!match-one(nqp::getlexcaller('$/'),
              $pattern($cursor-init(Match,self,:0c)), $x)
          )
        )
    }
    multi method match(Regex:D $pattern, :$st!, *%_) {
        self!match-nth(nqp::getlexcaller('$/'),
          $pattern($cursor-init(Match,self,:0c)),
          CURSOR-GLOBAL, POST-MATCH, $st, %_)
    }
    multi method match(Regex:D $pattern, :$nd!, *%_) {
        self!match-nth(nqp::getlexcaller('$/'),
          $pattern($cursor-init(Match,self,:0c)),
          CURSOR-GLOBAL, POST-MATCH, $nd, %_)
    }
    multi method match(Regex:D $pattern, :$rd!, *%_) {
        self!match-nth(nqp::getlexcaller('$/'),
          $pattern($cursor-init(Match,self,:0c)),
          CURSOR-GLOBAL, POST-MATCH, $rd, %_)
    }
    multi method match(Regex:D $pattern, :$th!, *%_) {
        self!match-nth(nqp::getlexcaller('$/'),
          $pattern($cursor-init(Match,self,:0c)),
          CURSOR-GLOBAL, POST-MATCH, $th, %_)
    }
    multi method match(Regex:D $pattern, :$nth!, *%_) {
        self!match-nth(nqp::getlexcaller('$/'),
          $pattern($cursor-init(Match,self,:0c)),
          CURSOR-GLOBAL, POST-MATCH, $nth, %_)
    }
    multi method match(Regex:D $pattern, :$as!, *%_) {
        nqp::if(
          nqp::elems(nqp::getattr(%_,Map,'$!storage')),
          self!match-cursor(nqp::getlexcaller('$/'),
            $pattern($cursor-init(Match,self,:0c)), 'as', $as, %_),
          self!match-as-one(nqp::getlexcaller('$/'),
            $pattern($cursor-init(Match,self,:0c)), $as)
        )
    }
    multi method match(Regex:D $pattern, *%_) {
        nqp::if(
          nqp::elems(nqp::getattr(%_,Map,'$!storage')),
          self!match-cursor(nqp::getlexcaller('$/'),
            $pattern($cursor-init(Match,self,:0c)), '', 0, %_),
          self!match-one(nqp::getlexcaller('$/'),
            $pattern($cursor-init(Match,self,:0c)))
        )
    }

    proto method subst-mutate(|) {
        $/ := nqp::getlexcaller('$/');
        {*}
    }
    multi method subst-mutate(
      Str:D $self is rw: Any:D $matcher, $replacement,
      :ii(:$samecase), :ss(:$samespace), :mm(:$samemark), *%options
    ) {
        my $global = %options<g> || %options<global>;
        my $caller_dollar_slash := nqp::getlexcaller('$/');
        my $SET_DOLLAR_SLASH     = nqp::istype($matcher, Regex);
        my $word_by_word = so $samespace || %options<s> || %options<sigspace>;

        $caller_dollar_slash = $/ if $SET_DOLLAR_SLASH;
        my @matches = %options
          ?? self.match($matcher, |%options)
          !! self.match($matcher);  # 30% faster

        if nqp::istype(@matches[0], Failure) {
            @matches[0];
        }
        elsif !@matches || (@matches == 1 && !@matches[0]) {
            Nil;
        }
        else {
            $self = $self!APPLY-MATCHES(
              @matches,
              $replacement,
              $caller_dollar_slash,
              $SET_DOLLAR_SLASH,
              $word_by_word,
              $samespace,
              $samecase,
              $samemark,
            );
            nqp::if(
              $global || %options<x>,
              nqp::p6bindattrinvres(
                nqp::create(List),
                List,
                '$!reified',
                nqp::getattr(@matches,List,'$!reified')
              ),
              @matches[0]
            )
        }
    }

    proto method subst(|) {
        $/ := nqp::getlexcaller('$/');
        {*}
    }
    multi method subst(Str:D: Str:D $original, Str:D $final, *%options) {
        nqp::if(
          (my $opts := nqp::getattr(%options,Map,'$!storage'))
            && nqp::isgt_i(nqp::elems($opts),1),
            self!SUBST(nqp::getlexcaller('$/'),$original,$final,|%options),
          nqp::if(
            nqp::elems($opts),
            nqp::if(                                      # one named
              nqp::atkey($opts,'g') || nqp::atkey($opts,'global'),
              Rakudo::Internals.TRANSPOSE(self, $original, $final),
              nqp::if(                                    # no trueish g/global
                nqp::existskey($opts,'g') || nqp::existskey($opts,'global'),
                Rakudo::Internals.TRANSPOSE-ONE(self, $original, $final),
                self!SUBST(nqp::getlexcaller('$/'),$original,$final,|%options)
              )
            ),
            Rakudo::Internals.TRANSPOSE-ONE(self, $original, $final) # no nameds
          )
        )
    }
    multi method subst(Str:D: $matcher, $replacement, *%options) {
        self!SUBST(nqp::getlexcaller('$/'), $matcher, $replacement, |%options)
    }
    method !SUBST(Str:D: \caller_dollar_slash, $matcher, $replacement,
      :global(:$g), :ii(:$samecase), :ss(:$samespace), :mm(:$samemark),
      *%options
    ) {
        X::Str::Subst::Adverb.new(:name($_), :got(%options{$_})).throw
          if %options{$_} for <ov ex>;

        my $SET_DOLLAR_SLASH = nqp::istype($matcher, Regex);
        my $word_by_word = so $samespace || %options<s> || %options<sigspace>;

        # nothing to do
        caller_dollar_slash = $/ if $SET_DOLLAR_SLASH;
        my @matches = %options
          ?? self.match($matcher, :$g, |%options)
          !! self.match($matcher, :$g);  # 30% faster

        nqp::istype(@matches[0], Failure)
            ?? @matches[0]
            !! !@matches || (@matches == 1 && !@matches[0])
                  ?? self
                  !! self!APPLY-MATCHES(
                       @matches,
                       $replacement,
                       caller_dollar_slash,
                       $SET_DOLLAR_SLASH,
                       $word_by_word,
                       $samespace,
                       $samecase,
                       $samemark,
                     );
    }

    method !APPLY-MATCHES(\matches,$replacement,\cds,\SDS,\word_by_word,\space,\case,\mark) {
        my \callable       := nqp::istype($replacement,Callable);

        my int $prev;
        my str $str    = nqp::unbox_s(self);
        my Mu $result := nqp::list_s();
        cds = $/ if SDS;

        # need to do something special
        if SDS || space || case || mark || callable {
            my \noargs        := callable ?? $replacement.count == 0 !! False;
            my \fancy         := space || case || mark || word_by_word;
            my \case-and-mark := case && mark;

            for flat matches -> $m {
                cds = $m if SDS;
                nqp::push_s(
                  $result,nqp::substr($str,$prev,nqp::unbox_i($m.from) - $prev)
                );

                if fancy {
                    my $mstr := $m.Str;
                    my $it := ~(callable
                      ?? (noargs ?? $replacement() !! $replacement($m))
                      !! $replacement
                    );
                    if word_by_word {  # all spacers delegated to word-by-word
                        my &filter :=
                        case-and-mark
                        ?? -> $w,$p { $w.samemark($p).samecase($p) }
                        !! case
                            ?? -> $w,$p { $w.samecase($p) }
                            !! -> $w,$p { $w.samemark($p) }
                        nqp::push_s($result,nqp::unbox_s(
                          $it.word-by-word($mstr,&filter,:samespace(?space))
                        ) );
                    }
                    elsif case-and-mark {
                        nqp::push_s($result,nqp::unbox_s(
                          $it.samecase($mstr).samemark($mstr)
                        ) );
                    }
                    elsif case {
                        nqp::push_s($result,nqp::unbox_s($it.samecase(~$m)));
                    }
                    else { # mark
                        nqp::push_s($result,nqp::unbox_s($it.samemark(~$m)));
                    }
                }
                else {
                    nqp::push_s($result,nqp::unbox_s( ~(callable
                      ?? (noargs ?? $replacement() !! $replacement($m))
                      !! $replacement
                    ) ) );
                }
                $prev = nqp::unbox_i($m.to);
            }
            nqp::push_s($result,nqp::substr($str,$prev));
            nqp::p6box_s(nqp::join('',$result));
        }

        # simple string replacement
        else {
            for flat matches -> $m {
                nqp::push_s(
                  $result,nqp::substr($str,$prev,nqp::unbox_i($m.from) - $prev)
                );
                $prev = nqp::unbox_i($m.to);
            }
            nqp::push_s($result,nqp::substr($str,$prev));
            nqp::p6box_s(nqp::join(nqp::unbox_s(~$replacement),$result));
        }
    }


    method ords(Str:D:) { self.NFC.list }

























    proto method lines(|) { * }
    multi method lines(Str:D: :$count!) {
        # we should probably deprecate this feature
        $count ?? self.lines.elems !! self.lines;
    }
    multi method lines(Str:D: $limit) {
        nqp::istype($limit,Whatever) || $limit == Inf
          ?? self.lines
          !! self.lines.head($limit)
    }
    multi method lines(Str:D:) {
        Seq.new(class :: does Iterator {
            has str $!str;
            has int $!chars;
            has int $!pos;
            method !SET-SELF(\string) {
                $!str   = nqp::unbox_s(string);
                $!chars = nqp::chars($!str);
                $!pos   = 0;
                self
            }
            method new(\string) { nqp::create(self)!SET-SELF(string) }
            method pull-one() {
                my int $left;
                return IterationEnd if ($left = $!chars - $!pos) <= 0;

                my int $nextpos = nqp::findcclass(
                  nqp::const::CCLASS_NEWLINE, $!str, $!pos, $left);
                my str $found = nqp::substr($!str, $!pos, $nextpos - $!pos);
                $!pos = $nextpos + 1;
                $found;
            }
            method push-all($target --> IterationEnd) {
                my int $left;
                my int $nextpos;

                while ($left = $!chars - $!pos) > 0 {
                    $nextpos = nqp::findcclass(
                      nqp::const::CCLASS_NEWLINE, $!str, $!pos, $left);

                    $target.push(nqp::substr($!str, $!pos, $nextpos - $!pos));
                    $!pos = $nextpos + 1;
                }
            }
        }.new(self));
    }

    method !ensure-split-sanity(\v,\k,\kv,\p) {
        # cannot combine these
        my int $any = ?v + ?k + ?kv + ?p;
        X::Adverb.new(
          what   => 'split',
          source => 'Str',
          nogo   => (:v(v),:k(k),:kv(kv),:p(p)).grep(*.value).map(*.key),
        ).throw if nqp::isgt_i($any,1);
        $any
    }

    method !ensure-limit-sanity(\limit --> Nil) {
        X::TypeCheck.new(
          operation => 'split ($limit argument)',
          expected  => 'any Real type (non-NaN) or Whatever',
          got       => limit.perl,
        ).throw if limit === NaN;

        limit = Inf if nqp::istype(limit,Whatever);
    }

    method parse-base(Str:D: Int:D $radix) {
        fail X::Syntax::Number::RadixOutOfRange.new(:$radix)
            unless 2 <= $radix <= 36; # (0..9,"a".."z").elems == 36

        # do not modify $!value directly as that affects other same strings
        my ($value, $sign, $sign-offset) = $!value, 1, 0;
        given $value.substr(0,1) {
            when '-'|'' { $sign = -1; $sign-offset = 1 }
            when '+'     {             $sign-offset = 1 }
        }

        if $value.contains('.') { # fractional
            my ($whole, $fract) = $value.split: '.', 2;
            my $w-parsed := nqp::radix_I($radix, $whole, $sign-offset, 0, Int);
            my $f-parsed := nqp::radix_I($radix, $fract, 0,            0, Int);

            # Whole part did not parse in its entirety
            fail X::Str::Numeric.new(
                :source($value),
                :pos($w-parsed[2] max $sign-offset),
                :reason("malformed base-$radix number"),
            ) unless $w-parsed[2] == nqp::chars($whole)
                or nqp::chars($whole) == $sign-offset; # or have no whole part

            # Fractional part did not parse in its entirety
            fail X::Str::Numeric.new(
                :source($value),
                :pos(
                      ($w-parsed[2] max $sign-offset)
                    + 1 # decimal dot
                    + ($f-parsed[2] max 0)
                ),
                :reason("malformed base-$radix number"),
            ) unless $f-parsed[2] == nqp::chars($fract);

            $sign * ($w-parsed[0] + $f-parsed[0]/$f-parsed[1]);
        }
        else { # Int
            my $parsed := nqp::radix_I($radix, $value, $sign-offset, 0, Int);

            # Did not parse the number in its entirety
            fail X::Str::Numeric.new(
                :source($value),
                :pos($parsed[2] max $sign-offset),
                :reason("malformed base-$radix number"),
            ) unless $parsed[2] == nqp::chars($value);

            $sign * $parsed[0];
        }
    }

    method parse-names(Str:D:) {
        my     \names := nqp::split(',', self);
        my int $elems  = nqp::elems(names);
        my int $i      = -1;
        my str $res    = '';
        nqp::while(
            nqp::islt_i( ($i = nqp::add_i($i,1)), $elems ),
            ($res = nqp::concat($res,
                nqp::unless(
                    nqp::getstrfromname(nqp::atpos(names, $i).trim),
                    X::Str::InvalidCharName.new(
                        :name(nqp::atpos(names, $i).trim)
                    ).fail
            ))),
        );
        $res
    }

    multi method split(Str:D: Regex:D $pat, $limit is copy = Inf;;
      :$v is copy, :$k, :$kv, :$p, :$skip-empty) {

        my int $any = self!ensure-split-sanity($v,$k,$kv,$p);

        self!ensure-limit-sanity($limit);
        return Seq.new(Rakudo::Iterator.Empty) if $limit <= 0;

        my \matches = $limit == Inf
          ?? self.match($pat, :g)
          !! self.match($pat, :x(1..$limit-1));

        my str $str   = nqp::unbox_s(self);
        my int $elems = +matches;  # make sure all reified
        return Seq.new(Rakudo::Iterator.OneValue(self)) unless $elems;

        my $matches  := nqp::getattr(matches,List,'$!reified');
        my $result   := nqp::create(IterationBuffer);
        my int $i = -1;
        my int $pos;
        my int $found;

        if $any || $skip-empty {
            my int $notskip = !$skip-empty;
            my int $next;
            while nqp::islt_i(++$i,$elems) {
                my $match := nqp::decont(nqp::atpos($matches,$i));
                $found  = nqp::getattr_i($match,Match,'$!from');
                $next   = $match.to;
                if $notskip {
                    nqp::push($result,
                      nqp::substr($str,$pos,nqp::sub_i($found,$pos)));
                }
                elsif nqp::sub_i($found,$pos) -> $chars {
                    nqp::push($result,
                      nqp::substr($str,$pos,$chars));
                }
                nqp::if(
                  $any,
                  nqp::if(
                    $v,
                    nqp::push($result,$match),                  # v
                    nqp::if(
                      $k,
                      nqp::push($result,0),                     # k
                      nqp::if(
                        $kv,
                        nqp::stmts(
                          nqp::push($result,0),                 # kv
                          nqp::push($result,$match)             # kv
                        ),
                        nqp::push($result, Pair.new(0,$match))  # $p
                      )
                    )
                  )
                );
                $pos = $next;
            }
            nqp::push($result,nqp::substr($str,$pos))
              if $notskip || nqp::islt_i($pos,nqp::chars($str));
        }
        else {
            my $match;
            nqp::setelems($result,$elems + 1);
            while nqp::islt_i(++$i,$elems) {
                $match := nqp::decont(nqp::atpos($matches,$i));
                $found  = nqp::getattr_i($match,Match,'$!from');
                nqp::bindpos($result,$i,
                  nqp::substr($str,$pos,nqp::sub_i($found,$pos)));
                $pos = $match.to;
            }
            nqp::bindpos($result,$i,nqp::substr($str,$pos));
        }

        Seq.new(Rakudo::Iterator.ReifiedList($result))
    }

    multi method split(Str:D: Str(Cool) $match;;
      :$v is copy, :$k, :$kv, :$p, :$skip-empty) {
        my int $any = self!ensure-split-sanity($v,$k,$kv,$p);

        # nothing to work with
        my str $needle = nqp::unbox_s($match);
        my int $chars  = nqp::chars($needle);
        return Seq.new($chars && !$skip-empty
          ?? Rakudo::Iterator.OneValue(self)
          !! Rakudo::Iterator.Empty
        ) unless self.chars;

        # split really, really fast in NQP, also supports ""
        my $matches := nqp::split($needle,nqp::unbox_s(self));

        # interleave the necessary strings if needed
        if $chars {
            if $any {
                my $match-list :=
                     $v  ?? nqp::list($needle)
                  !! $k  ?? nqp::list(0)
                  !! $kv ?? nqp::list(0,$needle)
                  !!        nqp::list(Pair.new(0,$needle)); # $p

                if $match-list {
                    my int $i = nqp::elems($matches);
                    if $skip-empty {
                        nqp::splice($matches,$match-list,$i,

                          nqp::not_i(nqp::isne_i(
                            nqp::chars(nqp::atpos($matches,$i)),0)))
                              while $i = nqp::sub_i($i,1);
                        nqp::splice($matches,$empty,0,1)
                          unless nqp::chars(nqp::atpos($matches,0));
                    }
                    else {
                        nqp::splice($matches,$match-list,$i,0)
                          while $i = nqp::sub_i($i,1);
                    }
                }
            }
            elsif $skip-empty {
                my int $i = nqp::elems($matches);
                my $match-list := nqp::list;
                while nqp::isge_i($i = nqp::sub_i($i,1),0) {
                  nqp::splice($matches,$match-list,$i,1)
                    if nqp::iseq_i(nqp::chars(nqp::atpos($matches,$i)),0);
                }
            }
        }

        # single chars need empty before/after, unless inhibited
        elsif !$skip-empty {
            nqp::unshift($matches,"");
            nqp::push($matches,"");
        }

        Seq.new(Rakudo::Iterator.ReifiedList($matches))
    }

    multi method split(Str:D: Str(Cool) $match, $limit is copy = Inf;;
      :$v is copy, :$k, :$kv, :$p, :$skip-empty) {
        my int $any = self!ensure-split-sanity($v,$k,$kv,$p);

        self!ensure-limit-sanity($limit);
        return Seq.new(Rakudo::Iterator.Empty) if $limit <= 0;

        # nothing to work with
        my int $chars = $match.chars;
        if !self.chars {
            return $chars ?? self.list !! ();
        }

        # nothing to do
        elsif $limit == 1 {
            return self.list;
        }

        # want them all
        elsif $limit == Inf {
            return self.split($match,:$v,:$k,:$kv,:$p,:$skip-empty);
        }

        # we have something to split on
        elsif $chars {

            # let the multi-needle handler handle all nameds
            return self.split(($match,),$limit,:$v,:$k,:$kv,:$p,:$skip-empty)
              if $any || $skip-empty;

            # make the sequence
            Seq.new(class :: does Iterator {
                has str $!string;
                has str $!chars;
                has str $!match;
                has int $!match-chars;
                has int $!todo;
                has int $!pos;
                method !SET-SELF(\string, \match, \todo) {
                    $!string      = nqp::unbox_s(string);
                    $!chars       = nqp::chars($!string);
                    $!match       = nqp::unbox_s(match);
                    $!match-chars = nqp::chars($!match);
                    $!todo        = todo - 1;
                    self
                }
                method new(\string,\match,\todo) {
                    nqp::create(self)!SET-SELF(string,match,todo)
                }
                method !last-part() is raw {
                    my str $string = nqp::substr($!string,$!pos);
                    $!pos  = $!chars + 1;
                    $!todo = 0;
                    nqp::p6box_s($string)
                }
                method !next-part(int $found) is raw {
                    my str $string =
                      nqp::substr($!string,$!pos, $found - $!pos);
                    $!pos = $found + $!match-chars;
                    nqp::p6box_s($string);
                }
                method pull-one() is raw {
                    if $!todo {
                        $!todo = $!todo - 1;
                        my int $found = nqp::index($!string,$!match,$!pos);
                        nqp::islt_i($found,0)
                          ?? nqp::isle_i($!pos,$!chars)
                            ?? self!last-part
                            !! IterationEnd
                          !! self!next-part($found);
                    }
                    else {
                        nqp::isle_i($!pos,$!chars)
                          ?? self!last-part
                          !! IterationEnd
                    }
                }
                method push-all($target --> IterationEnd) {
                    while $!todo {
                        $!todo = $!todo - 1;
                        my int $found = nqp::index($!string,$!match,$!pos);
                        nqp::islt_i($found,0)
                          ?? ($!todo = 0)
                          !! $target.push(self!next-part($found));
                    }
                    $target.push(self!last-part) if nqp::isle_i($!pos,$!chars);
                }
                method sink-all(--> IterationEnd) { }
            }.new(self,$match,$limit));
        }

        # just separate chars
        else {
            Seq.new(class :: does Iterator {
                has str $!string;
                has int $!todo;
                has int $!chars;
                has int $!pos;
                has int $!first;
                has int $!last;
                method !SET-SELF(\string, \todo, \skip-empty) {
                    $!string = nqp::unbox_s(string);
                    $!chars  = nqp::chars($!string);
                    $!todo   = todo;
                    $!first  = !skip-empty;

                    if $!todo > $!chars + 2 {  # will return all chars
                        $!todo = $!chars + 1;
                        $!last = !skip-empty;
                    }
                    else {
                        $!todo = $!todo - 1;
                        $!last = !skip-empty && ($!todo == $!chars + 1);
                    }
                    self
                }
                method new(\string,\todo,\skip-empty) {
                    nqp::create(self)!SET-SELF(string,todo,skip-empty)
                }
                method pull-one() is raw {
                    if $!first {             # do empty string first
                        $!first = 0;
                        $!todo  = $!todo - 1;
                        ""
                    }
                    elsif $!todo {           # next char
                        $!todo = $!todo - 1;
                        nqp::p6box_s(nqp::substr($!string,$!pos++,1))
                    }
                    elsif $!last {           # do final empty string
                        $!last = 0;
                        ""
                    }
                    elsif nqp::islt_i($!pos,$!chars) {  # do rest of string
                        my str $rest = nqp::substr($!string,$!pos);
                        $!pos = $!chars;
                        nqp::p6box_s($rest)
                    }
                    else {
                        IterationEnd
                    }
                }
                method push-all($target --> IterationEnd) {
                    $target.push("") if $!first;
                    $!todo = $!todo - 1;
                    while $!todo {
                        $target.push(
                          nqp::p6box_s(nqp::substr($!string,$!pos++,1)));
                        $!todo = $!todo - 1;
                    }
                    $target.push( nqp::p6box_s(nqp::substr($!string,$!pos)))
                      if nqp::islt_i($!pos,$!chars);
                    $target.push("") if $!last;
                }
                method count-only() { nqp::p6box_i($!todo + $!first + $!last) }
                method bool-only() { nqp::p6bool($!todo + $!first + $!last) }
                method sink-all(--> IterationEnd) { }
            }.new(self,$limit,$skip-empty));
        }
    }

    multi method split(Str:D: @needles, $parts is copy = Inf;;
       :$v is copy, :$k, :$kv, :$p, :$skip-empty) {
        my int $any = self!ensure-split-sanity($v,$k,$kv,$p);

        # must all be Cool, otherwise we'll just use a regex
        return self.split(rx/ @needles /,:$v,:$k,:$kv,:$p,:$skip-empty) # / hl
          unless Rakudo::Internals.ALL_TYPE(@needles,Cool);

        self!ensure-limit-sanity($parts);
        return Seq.new(Rakudo::Iterator.Empty) if $parts <= 0;

        my int $limit = $parts.Int
          unless nqp::istype($parts,Whatever) || $parts == Inf;

        my str $str       = nqp::unbox_s(self);
        my $positions    := nqp::list;
        my $needles      := nqp::list_s;
        my $needle-chars := nqp::list_i;
        my $needles-seen := nqp::hash;
        my int $tried;
        my int $fired;

        # search using all needles
        for @needles.kv -> int $index, $needle {
            my str $need  = nqp::unbox_s($needle.DEFINITE ?? $needle.Str !! "");
            my int $chars = nqp::chars($need);
            nqp::push_s($needles,$need);
            nqp::push_i($needle-chars,$chars);

            # search for this needle if there is one, and not done before
            nqp::if(
              nqp::isgt_i($chars,0)
                && nqp::not_i(nqp::existskey($needles-seen,$need)),
              nqp::stmts(
                nqp::bindkey($needles-seen,$need,1),
                (my int $pos),
                (my int $i),
                (my int $seen = nqp::elems($positions)),
                nqp::if(
                  nqp::isgt_i($limit,0),  # 0 = no limit
                  nqp::stmts(
                    (my int $todo = $limit),
                    nqp::while(
                      nqp::isge_i(($todo = nqp::sub_i($todo,1)),0)
                        && nqp::isge_i($i = nqp::index($str,$need,$pos),0),
                      nqp::stmts(
                        nqp::push($positions,nqp::list_i($i,$index)),
                        ($pos = nqp::add_i($i,1)),
                      )
                    )
                  ),
                  nqp::while(
                    nqp::isge_i($i = nqp::index($str,$need,$pos),0),
                    nqp::stmts(
                      nqp::push($positions,nqp::list_i($i,$index)),
                      ($pos = nqp::add_i($i,1))
                    )
                  )
                ),
                ($tried = nqp::add_i($tried,1)),
                ($fired =
                  nqp::add_i($fired,nqp::isge_i(nqp::elems($positions),$seen)))
              )
            )
        }

        # no needle tried, assume we want chars
        return self.split("",$limit) if nqp::not_i($tried);

        # sort by position if more than one needle fired
        $positions := nqp::getattr(
          Rakudo::Sorting.MERGESORT-REIFIED-LIST-WITH(
            nqp::p6bindattrinvres(
              nqp::create(List),List,'$!reified',$positions
            ),
            -> \a, \b {
                nqp::cmp_i(
                  nqp::atpos_i(a,0),
                  nqp::atpos_i(b,0)
                ) || nqp::cmp_i(
                  nqp::atpos_i($needle-chars,nqp::atpos_i(b,1)),
                  nqp::atpos_i($needle-chars,nqp::atpos_i(a,1))
                )
            }
          ),
          List,
          '$!reified'
        ) if nqp::isgt_i($fired,1);

        # remove elements we don't want
        if nqp::isgt_i($limit,0) {
            nqp::stmts(
              (my int $limited = 1),   # split one less than entries returned
              (my int $elems = nqp::elems($positions)),
              (my int $pos),
              (my int $i = -1),
              nqp::while(
                nqp::islt_i(($i = nqp::add_i($i,1)),$elems)
                  && nqp::islt_i($limited,$limit),
                nqp::if(
                  nqp::isge_i(   # not hidden by other needle
                    nqp::atpos_i(nqp::atpos($positions,$i),0),
                    $pos
                  ),
                  nqp::stmts(
                    ($limited = nqp::add_i($limited,1)),
                    ($pos = nqp::add_i(
                      nqp::atpos_i(nqp::atpos($positions,$i),0),
                      nqp::atpos_i($needle-chars,
                        nqp::atpos_i(nqp::atpos($positions,$i),1))
                    ))
                  )
                )
              ),
              nqp::if(
                nqp::islt_i($i,$elems),
                nqp::splice($positions,$empty,
                  $i,nqp::sub_i(nqp::elems($positions),$i))
              )
            )
        }

        # create the final result
        my int $skip = ?$skip-empty;
        my int $pos = 0;
        my $result := nqp::create(IterationBuffer);
        if $any {
            nqp::stmts(
              (my int $i = -1),
              (my int $elems = nqp::elems($positions)),
              nqp::while(
                nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                nqp::if(
                  nqp::isge_i( # not hidden by other needle
                    (my int $from = nqp::atpos_i(
                      (my $pair := nqp::atpos($positions,$i)),0)
                    ),
                    $pos
                  ),
                  nqp::stmts(
                    (my int $needle-index = nqp::atpos_i($pair,1)),
                    nqp::unless(
                      $skip && nqp::iseq_i($from,$pos),
                      nqp::push($result,
                        nqp::substr($str,$pos,nqp::sub_i($from,$pos)))
                    ),
                    nqp::if($k || $kv,
                      nqp::push($result,nqp::clone($needle-index))
                    ),
                    nqp::if($v || $kv,
                      nqp::push($result,nqp::atpos_s($needles,$needle-index))
                    ),
                    nqp::if($p,
                      nqp::push($result,Pair.new(
                        $needle-index,nqp::atpos_s($needles,$needle-index)))
                    ),
                    ($pos = nqp::add_i(
                      $from,
                      nqp::atpos_i($needle-chars,$needle-index)
                    ))
                  )
                )
              )
            )
        }
        else {
            nqp::stmts(
              (my int $i = -1),
              (my int $elems = nqp::elems($positions)),
              nqp::while(
                nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                nqp::if(
                  nqp::isge_i( # not hidden by other needle
                    (my int $from = nqp::atpos_i(
                      (my $pair := nqp::atpos($positions,$i)),0)
                    ),
                    $pos
                  ),
                  nqp::stmts(
                    nqp::unless(
                      $skip && nqp::iseq_i($from,$pos),
                      nqp::push($result,
                        nqp::substr($str,$pos,nqp::sub_i($from,$pos))),
                    ),
                    ($pos = nqp::add_i($from,
                      nqp::atpos_i($needle-chars,nqp::atpos_i($pair,1))
                    ))
                  )
                )
              )
            )
        }
        nqp::push($result,nqp::substr($str,$pos))
          unless $skip && nqp::iseq_i($pos,nqp::chars($str));

        Seq.new(Rakudo::Iterator.ReifiedList($result))
    }

    # Note that in these same* methods, as used by s/LHS/RHS/, the
    # pattern is actually the original string matched by LHS, while the
    # invocant "original" is really the replacement RHS part.  Confusing...
    method samecase(Str:D: Str:D $pattern) {
        nqp::if(
          nqp::chars(nqp::unbox_s($pattern)),        # something to work with
          nqp::stmts(
            (my $result := nqp::list_s),
            (my $cases  := nqp::getattr($pattern,Str,'$!value')),
            (my int $base-chars  = nqp::chars($!value)),
            (my int $cases-chars = nqp::if(
              nqp::isgt_i(nqp::chars($cases),$base-chars),
              $base-chars,
              nqp::chars($cases)
            )),
            (my int $i = 0),
            (my int $j = 0),
            (my int $prev-case = nqp::if(            # set up initial case
              nqp::iscclass(nqp::const::CCLASS_LOWERCASE,$cases,0),
              -1,
              nqp::iscclass(nqp::const::CCLASS_UPPERCASE,$cases,0)
            )),

            nqp::while(                              # other chars in pattern
              nqp::islt_i(($i = nqp::add_i($i,1)),$cases-chars),
              nqp::stmts(
                (my int $case = nqp::if(             # -1 =lc, 1 = uc, 0 = else
                  nqp::iscclass(nqp::const::CCLASS_LOWERCASE,$cases,$i),
                  -1,
                  nqp::iscclass(nqp::const::CCLASS_UPPERCASE,$cases,$i)
                )),
                nqp::if(
                  nqp::isne_i($case,$prev-case),
                  nqp::stmts(                        # seen a change
                    nqp::push_s($result,nqp::if(
                      nqp::iseq_i($prev-case,-1),    # coming from lc
                      nqp::lc(nqp::substr($!value,$j,nqp::sub_i($i,$j))),
                      nqp::if(
                        nqp::iseq_i($prev-case,1),   # coming from uc
                        nqp::uc(nqp::substr($!value,$j,nqp::sub_i($i,$j))),
                        nqp::substr($!value,$j,nqp::sub_i($i,$j))
                      )
                    )),
                    ($prev-case = $case),
                    ($j         = $i)
                  )
                )
              )
            ),

            nqp::if(                                 # something left
              nqp::islt_i($j,$base-chars),
              nqp::push_s($result,nqp::if(
                nqp::iseq_i($prev-case,-1),          # must become lc
                nqp::lc(nqp::substr($!value,$j,nqp::sub_i($base-chars,$j))),
                nqp::if(
                  nqp::iseq_i($prev-case,1),         # must become uc
                  nqp::uc(nqp::substr($!value,$j,nqp::sub_i($base-chars,$j))),
                  nqp::substr($!value,$j,nqp::sub_i($base-chars,$j))
                )
              ))
            ),

            nqp::join("",$result)                    # wrap it up
          ),

          self                                       # nothing to be done
        )
    }


    method samemark(Str:D: Str:D $pattern) {
        nqp::if(
          nqp::chars(nqp::unbox_s($pattern)),        # something to work with
          nqp::stmts(
            (my $base   := nqp::split("",$!value)),
            (my $marks  := nqp::split("",nqp::unbox_s($pattern))),
            (my int $base-elems  = nqp::elems($base)),
            (my int $marks-elems = nqp::elems($marks) min $base-elems),
            (my $result := nqp::setelems(nqp::list_s,$base-elems)),

            (my int $i = -1),
            nqp::while(                               # for all marks
              nqp::islt_i(($i = nqp::add_i($i,1)),$marks-elems),
              nqp::bindpos_s($result,$i,              # store the result of:
                nqp::stmts(
                  (my $marks-nfd := nqp::strtocodes(  # char + accents of mark
                    nqp::atpos($marks,$i),
                    nqp::const::NORMALIZE_NFD,
                    nqp::create(NFD)
                  )),
                  nqp::shift_i($marks-nfd),           # lose the char
                  (my $marks-base := nqp::strtocodes( # char + accents of base
                    nqp::atpos($base,$i),
                    nqp::const::NORMALIZE_NFD,
                    nqp::create(NFD)
                  )),
                  nqp::strfromcodes(                  # join base+rest of marks
                    nqp::splice(
                      $marks-base,
                      $marks-nfd,
                      1,
                      nqp::sub_i(nqp::elems($marks-base),1)
                    )
                  )
                )
              )
            ),

            ($i = nqp::sub_i($i,1)),
            nqp::while(                               # remaining base chars
              nqp::islt_i(($i = nqp::add_i($i,1)),$base-elems),
              nqp::bindpos_s($result,$i,              # store the result of:
                nqp::stmts(
                  ($marks-base := nqp::strtocodes(    # char+all accents of base
                    nqp::atpos($base,$i),
                    nqp::const::NORMALIZE_NFD,
                    nqp::create(NFD)
                  )),
                  nqp::strfromcodes(                  # join base+rest of marks
                    nqp::splice(
                      $marks-base,
                      $marks-nfd, # NOTE: state of last iteration previous loop
                      1,
                      nqp::sub_i(nqp::elems($marks-base),1)
                    )
                  )
                )
              )
            ),

            nqp::join("",$result)                     # wrap it up
          ),

          self                                        # nothing to be done
        )
    }





    method samespace(Str:D: Str:D $pattern) { self.word-by-word($pattern, :samespace) }

    method word-by-word(Str:D: Str:D $pattern, &filter?, Bool :$samespace) {
        my str $str = nqp::unbox_s(self);
        my str $pat = nqp::unbox_s($pattern);
        my Mu $ret := nqp::list_s;

        my int $chars = nqp::chars($str);
        my int $pos = 0;
        my int $nextpos;
        my int $patchars = nqp::chars($pat);
        my int $patpos = 0;
        my int $patnextpos;
        my int $left;
        my $patword;

        # Still something to look for?
        while ($left = $chars - $pos) > 0 {

            $nextpos = nqp::findcclass(
              nqp::const::CCLASS_WHITESPACE, $str, $pos, $left);

            $patnextpos = nqp::findcclass(nqp::const::CCLASS_WHITESPACE, $pat, $patpos, $patchars - $patpos);

            if &filter {
                # We latch on last pattern word if pattern runs out of words first.
                $patword := nqp::p6box_s(nqp::substr($pat, $patpos, $patnextpos - $patpos)) if $patpos < $patchars;
                nqp::push_s($ret, nqp::unbox_s(filter(nqp::substr($str, $pos, $nextpos - $pos), $patword)));
            }
            else {
                nqp::push_s($ret, nqp::substr($str, $pos, $nextpos - $pos));
            }

            # Did we have the last word?
            last if $nextpos >= $chars;

            $pos = nqp::findnotcclass( nqp::const::CCLASS_WHITESPACE,
              $str, $nextpos, $chars - $nextpos);
            if $patnextpos >= $patchars {  # No more pat space, just copy original space.
                nqp::push_s($ret,
                  nqp::substr($str, $nextpos, $pos - $nextpos));
                $patpos = $patnextpos;
            }
            else {  # Traverse pat space, use if wanted
                $patpos = nqp::findnotcclass( nqp::const::CCLASS_WHITESPACE,
                  $pat, $patnextpos, $patchars - $patnextpos);

                if $samespace {  # Carry over pattern space?
                    nqp::push_s($ret,
                      nqp::substr($pat, $patnextpos, $patpos - $patnextpos));
                }
                else {   # Nope, just use original space.
                    nqp::push_s($ret,
                      nqp::substr($str, $nextpos, $pos - $nextpos));
                }
            }
        }

        nqp::join("",$ret)
    }

    method trim-leading(Str:D:) {
        my str $str = nqp::unbox_s(self);
        my int $pos = nqp::findnotcclass(
                          nqp::const::CCLASS_WHITESPACE,
                          $str, 0, nqp::chars($str));
        $pos ?? nqp::p6box_s(nqp::substr($str, $pos)) !! self;
    }

    method trim-trailing(Str:D:) {
        my str $str = nqp::unbox_s(self);
        my int $pos = nqp::chars($str) - 1;
        $pos = $pos - 1
            while nqp::isge_i($pos, 0)
               && nqp::iscclass(nqp::const::CCLASS_WHITESPACE, $str, $pos);
        nqp::islt_i($pos, 0) ?? '' !! nqp::p6box_s(nqp::substr($str, 0, $pos + 1));
    }

    method trim(Str:D:) {
        my str $str  = nqp::unbox_s(self);
        my int $pos  = nqp::chars($str) - 1;
        my int $left = nqp::findnotcclass(
                           nqp::const::CCLASS_WHITESPACE, $str, 0, $pos + 1);
        $pos = $pos - 1
            while nqp::isge_i($pos, $left)
               && nqp::iscclass(nqp::const::CCLASS_WHITESPACE, $str, $pos);
        nqp::islt_i($pos, $left) ?? '' !! nqp::p6box_s(nqp::substr($str, $left, $pos + 1 - $left));
    }

    proto method words(|) { * }
    multi method words(Str:D: :$autoderef!) { # in Actions.postprocess_words
        my @list := self.words.List;
        return @list == 1 ?? @list[0] !! @list;
    }
    multi method words(Str:D: $limit) {
        nqp::istype($limit,Whatever) || $limit == Inf
          ?? self.words
          !! self.words.head($limit)
    }
    multi method words(Str:D:) {
        Seq.new(class :: does Iterator {
            has str $!str;
            has int $!chars;
            has int $!pos;

            method !SET-SELF(\string) {
                $!str   = nqp::unbox_s(string);
                $!chars = nqp::chars($!str);
                $!pos   = nqp::findnotcclass(
                  nqp::const::CCLASS_WHITESPACE, $!str, 0, $!chars);
                self
            }
            method new(\string) { nqp::create(self)!SET-SELF(string) }
            method pull-one() {
                my int $left;
                my int $nextpos;

                if ($left = $!chars - $!pos) > 0 {
                    $nextpos = nqp::findcclass(
                      nqp::const::CCLASS_WHITESPACE, $!str, $!pos, $left);

                    my str $found =
                      nqp::substr($!str, $!pos, $nextpos - $!pos);
                    $!pos = nqp::findnotcclass( nqp::const::CCLASS_WHITESPACE,
                      $!str, $nextpos, $!chars - $nextpos);

                    return nqp::p6box_s($found);
                }
                IterationEnd
            }
            method push-all($target --> IterationEnd) {
                my int $left;
                my int $nextpos;

                while ($left = $!chars - $!pos) > 0 {
                    $nextpos = nqp::findcclass(
                      nqp::const::CCLASS_WHITESPACE, $!str, $!pos, $left);

                    $target.push(nqp::p6box_s(
                      nqp::substr($!str, $!pos, $nextpos - $!pos)
                    ));
                    $!pos = nqp::findnotcclass( nqp::const::CCLASS_WHITESPACE,
                      $!str, $nextpos, $!chars - $nextpos);
                }
            }
        }.new(self));
    }

    proto method encode(|) {*}
    multi method encode(Str:D $encoding = 'utf8', :$replacement, Bool() :$translate-nl = False) {
        Encoding::Registry.find($encoding)
            .encoder(:$replacement, :$translate-nl)
            .encode-chars(self)
    }


    method NFC() {
        nqp::strtocodes(nqp::unbox_s(self), nqp::const::NORMALIZE_NFC, nqp::create(NFC))
    }
    method NFD() {
        nqp::strtocodes(nqp::unbox_s(self), nqp::const::NORMALIZE_NFD, nqp::create(NFD))
    }
    method NFKC() {
        nqp::strtocodes(nqp::unbox_s(self), nqp::const::NORMALIZE_NFKC, nqp::create(NFKC))
    }
    method NFKD() {
        nqp::strtocodes(nqp::unbox_s(self), nqp::const::NORMALIZE_NFKD, nqp::create(NFKD))
    }








    method wordcase(Str:D: :&filter = &tclc, Mu :$where = True) {
        self.subst(:g, / [<:L> \w* ] +% <['\-]> /, -> $m {  # ' highlighting
            my Str $s = $m.Str;
            $s ~~ $where ?? filter($s) !! $s;
        });
    }

    proto method trans(|) { $/ := nqp::getlexcaller('$/'); {*} }
    multi method trans(Str:D: Pair:D \what, *%n) {
        my $from = what.key;
        my $to   = what.value;
        $/ := nqp::getlexcaller('$/');

        return self.trans((what,), |%n)
          if !nqp::istype($from,Str)   # from not a string
          || !$from.defined            # or a type object
          || !nqp::istype($to,Str)     # or to not a string
          || !$to.defined              # or a type object
          || %n;                       # or any named params passed

        # from 1 char
        return Rakudo::Internals.TRANSPOSE(self, $from, substr($to,0,1))
          if $from.chars == 1;

        my str $sfrom  = Rakudo::Internals.EXPAND-LITERAL-RANGE($from,0);
        my str $str    = nqp::unbox_s(self);
        my str $chars  = nqp::chars($str);
        my Mu $result := nqp::list_s();
        my str $check;
        my int $i = -1;

        # something to convert to
        if $to.chars -> $tochars {
            nqp::setelems($result,$chars);

            # all convert to one char
            if $tochars == 1 {
                my str $sto = nqp::unbox_s($to);

                while nqp::islt_i(++$i,$chars) {
                    $check = nqp::substr($str,$i,1);
                    nqp::bindpos_s(
                      $result, $i, nqp::iseq_i(nqp::index($sfrom,$check),-1)
                        ?? $check
                        !! $sto
                    );
                }
            }

            # multiple chars to convert to
            else {
                my str $sto = Rakudo::Internals.EXPAND-LITERAL-RANGE($to,0);
                my int $sfl = nqp::chars($sfrom);
                my int $found;

                # repeat until mapping complete
                $sto = $sto ~ $sto while nqp::islt_i(nqp::chars($sto),$sfl);

                while nqp::islt_i(++$i,$chars) {
                    $check = nqp::substr($str,$i,1);
                    $found = nqp::index($sfrom,$check);
                    nqp::bindpos_s($result, $i, nqp::iseq_i($found,-1)
                      ?? $check
                      !! nqp::substr($sto,$found,1)
                    );
                }
            }
        }

        # just remove
        else {
            while nqp::islt_i(++$i,$chars) {
                $check = nqp::substr($str,$i,1);
                nqp::push_s($result, $check)
                  if nqp::iseq_i(nqp::index($sfrom,$check),-1);
            }
        }

        nqp::p6box_s(nqp::join('',$result));
    }

    my class LSM {
        has str $!source;
        has     $!substitutions;
        has int $!squash;
        has int $!complement;
        has str $!prev_result;

        has int $!index;
        has int $!next_match;
        has int $!substitution_length;

        has $!first_substitution; # need this one for :c with arrays
        has $!next_substitution;
        has $!match_obj;
        has $!last_match_obj;

        has str $!unsubstituted_text;
        has str $!substituted_text;

        method !SET-SELF(\source,\substitutions,\squash,\complement) {
            $!source         = nqp::unbox_s(source);
            $!substitutions := nqp::getattr(substitutions,List,'$!reified');
            $!squash         = ?squash;
            $!complement     = ?complement;
            $!prev_result    = '';
            self
        }
        method new(\source,\substitutions,\squash,\complement) {
            nqp::create(self)!SET-SELF(source,substitutions,squash,complement)
        }

        method !compare_substitution(
          $substitution, int $pos, int $length --> Nil
        ) {
            if nqp::isgt_i($!next_match,$pos)
              || nqp::iseq_i($!next_match,$pos)
                   && nqp::islt_i($!substitution_length,$length) {

                $!next_match          = $pos;
                $!substitution_length = $length;
                $!next_substitution   = $substitution;
                $!match_obj           = $!last_match_obj;
            }
        }

        method !increment_index($s --> Nil) {
            $/ := nqp::getlexcaller('$/');
            if nqp::istype($s,Regex) {
                $!index = $!next_match + (
                    substr($!source,$!index) ~~ $s ?? $/.chars !! 0
                );
                $!last_match_obj = $/;
            }
            else {
                $!index = $!next_match
                  + nqp::chars(nqp::istype($s,Str) ?? $s !! $s.Str);
            }
        }

        # note: changes outer $/
        method get_next_substitution_result {
            my $value = $!complement
              ?? $!first_substitution.value
              !! $!next_substitution.value;

            my $outer_slash := nqp::getlexcaller('$/');
            $/ := nqp::getlexcaller('$/');
            $outer_slash = $!match_obj;

            my str $result = nqp::istype($value,Callable)
              ?? $value().Str
              !! nqp::istype($value,Str)
                ?? $value
                !! $value.Str;
            my str $orig_result = $result;

            $result = ''
              if $!squash
              && nqp::chars($!prev_result)
              && nqp::iseq_s($!prev_result,$result)
              && nqp::iseq_s($!unsubstituted_text,'');

            $!prev_result = $orig_result;
            $result
        }

        method next_substitution() {
            $/ := nqp::getlexcaller('$/');
            $!next_match = nqp::chars($!source);
            $!first_substitution = nqp::atpos($!substitutions,0)
              unless nqp::defined($!first_substitution);

            # triage substitutions left to do
            my $todo := nqp::list;
            my $iter := nqp::iterator($!substitutions);
            while $iter {
                my $this := nqp::shift($iter);
                my $key  := $this.key;
                if nqp::istype($key,Regex) {
                    if $!source.match($key, :continue($!index)) -> \m {
                        $!last_match_obj = $/;
                        self!compare_substitution($this, m.from, m.to - m.from);
                        nqp::push($todo,$this);
                    }
                }
                elsif nqp::istype($key,Cool) {
                    my str $skey = nqp::istype($key,Str) ?? $key !! $key.Str;
                    my int $pos  = nqp::index($!source,$skey,$!index);
                    if nqp::isge_i($pos,0) {
                        self!compare_substitution($this,$pos,nqp::chars($skey));
                        nqp::push($todo,$this);
                    }
                }
                else {
                    X::Str::Trans::IllegalKey.new(key => $this).throw;
                }
            }
            $!substitutions := $todo;

            $!unsubstituted_text =
              nqp::substr($!source,$!index,$!next_match - $!index);
            if $!next_substitution.defined {
                if $!complement {
                    my $oldidx = $!index;
                    if nqp::chars($!unsubstituted_text) -> \todo {
                        my $result = self.get_next_substitution_result;
                        self!increment_index($!next_substitution.key);
                        $!substituted_text = nqp::substr(
                          $!source,
                          $oldidx + todo,
                          $!index - $oldidx - todo,
                        );
                        $!unsubstituted_text = $!squash
                          ?? $result
                          !! $result x todo;
                    }
                    else {
                        return if $!next_match == nqp::chars($!source);
                        my $result = self.get_next_substitution_result;
                        self!increment_index($!next_substitution.key);
                        $!substituted_text = '';
                        $!unsubstituted_text =
                          nqp::substr($!source,$oldidx,$!index - $oldidx);
                    }
                }
                else {
                    return if $!next_match == nqp::chars($!source);
                    $!substituted_text = self.get_next_substitution_result;
                    self!increment_index($!next_substitution.key);
                }
            }

            nqp::islt_i($!next_match,nqp::chars($!source))
              && nqp::elems($!substitutions)
        }

        method result() {
            $/ := nqp::getlexcaller('$/');
            my Mu $result := nqp::list_s;

            while self.next_substitution {
                nqp::push_s($result,$!unsubstituted_text);
                nqp::push_s($result,$!substituted_text);
            }
            nqp::push_s($result,$!unsubstituted_text);
            nqp::p6box_s(nqp::join('', $result))
        }
    }
    multi method trans(Str:D:
      *@changes, :c(:$complement), :s(:$squash), :d(:$delete)) {

        # nothing to do
        return self unless self.chars;

        $/ := nqp::getlexcaller('$/');

        my sub myflat(*@s) {
            @s.map: { nqp::istype($_, Iterable) ?? .list.Slip !! $_ }
        }
        my sub expand($s) {
            nqp::istype($s,Iterable) || nqp::istype($s,Positional)
              ?? (my @ = myflat($s.list).Slip)
              !! Rakudo::Internals.EXPAND-LITERAL-RANGE($s,1)
        }

        my int $just-strings = !$complement && !$squash;
        my int $just-chars   = $just-strings;
        my $needles := nqp::list;
        my $pins    := nqp::list;

        my $substitutions := nqp::list;
        for @changes -> $p {
            X::Str::Trans::InvalidArg.new(got => $p).throw
              unless nqp::istype($p,Pair);

            my $key   := $p.key;
            my $value := $p.value;
            if nqp::istype($key,Regex) {
                $just-strings = 0;
                nqp::push($substitutions,$p);
            }
            elsif nqp::istype($value,Callable) {
                $just-strings = 0;
                nqp::push($substitutions,Pair.new($_,$value)) for expand $key;
            }
            else {
                my $from := nqp::getattr(expand($key),  List,'$!reified');
                my $to   := nqp::getattr(expand($value),List,'$!reified');
                my $from-elems = nqp::elems($from);
                my $to-elems   = nqp::elems($to);
                my $padding = $delete
                  ?? ''
                  !! $to-elems
                    ?? nqp::atpos($to,$to-elems - 1)
                    !! '';

                my int $i = -1;
                while nqp::islt_i($i = $i + 1,$from-elems) {
                    my $key   := nqp::atpos($from,$i);
                    my $value := nqp::islt_i($i,$to-elems)
                      ?? nqp::atpos($to,$i)
                      !! $padding;
                    nqp::push($substitutions,Pair.new($key,$value));
                    if $just-strings {
                        if nqp::istype($key,Str) && nqp::istype($value,Str) {
                            $key := nqp::unbox_s($key);
                            $just-chars = 0 if nqp::isgt_i(nqp::chars($key),1);
                            nqp::push($needles,$key);
                            nqp::push($pins,nqp::unbox_s($value));
                        }
                        else {
                            $just-strings = 0;
                        }
                    }
                }
            }
        }

        # can do special cases for just strings
        if $just-strings {

            # only need to go through string once
            if $just-chars {
                my $lookup   := nqp::hash;
                my int $elems = nqp::elems($needles);
                my int $i     = -1;
                nqp::bindkey($lookup,
                  nqp::atpos($needles,$i),nqp::atpos($pins,$i))
                  while nqp::islt_i($i = $i + 1,$elems);

                my $result := nqp::split("",nqp::unbox_s(self));
                $i = -1;
                $elems = nqp::elems($result);
                nqp::bindpos($result,$i,
                  nqp::atkey($lookup,nqp::atpos($result,$i)))
                    if nqp::existskey($lookup,nqp::atpos($result,$i))
                  while nqp::islt_i($i = $i + 1,$elems);
                nqp::join("",$result)
            }

            # use multi-needle split with in-place mapping
            else {
                nqp::stmts(
                  (my $iterator := self.split($needles,:k).iterator),
                  (my $strings := nqp::list_s($iterator.pull-one)),
                  nqp::until(
                    nqp::eqaddr((my $i := $iterator.pull-one),IterationEnd),
                    nqp::stmts(
                      nqp::push_s($strings,nqp::atpos($pins,$i)),
                      nqp::push_s($strings,$iterator.pull-one)
                    )
                  ),
                  nqp::join("",$strings)
                )
            }
        }

        # alas, need to use more complex route
        else {
            LSM.new(self,$substitutions,$squash,$complement).result;
        }
    }
    proto method indent($) {*}
    # Zero indent does nothing
    multi method indent(Int() $steps where { $_ == 0 }) {
        self;
    }

    # Positive indent does indent
    multi method indent(Int() $steps where { $_ > 0 }) {
    # We want to keep trailing \n so we have to .comb explicitly instead of .lines
        self.comb(/:r ^^ \N* \n?/).map({
            given $_.Str {
                when /^ \n? $ / {
                    $_;
                }
                # Use the existing space character if they're all the same
                # (but tabs are done slightly differently)
                when /^(\t+) ([ \S .* | $ ])/ {
                    $0 ~ "\t" x ($steps div $?TABSTOP) ~
                         ' '  x ($steps mod $?TABSTOP) ~ $1
                }
                when /^(\h) $0* [ \S | $ ]/ {
                    $0 x $steps ~ $_
                }

                # Otherwise we just insert spaces after the existing leading space
                default {
                    $_ ~~ /^(\h*) (.*)$/;
                    $0 ~ (' ' x $steps) ~ $1
                }
            }
        }).join;
    }

    # Negative indent (de-indent)
    multi method indent(Int() $steps where { $_ < 0 }) {
        de-indent(self, $steps);
    }

    # Whatever indent (de-indent)
    multi method indent(Whatever $steps) {
        de-indent(self, $steps);
    }

    sub de-indent($obj, $steps) {
        # Loop through all lines to get as much info out of them as possible
        my @lines = $obj.comb(/:r ^^ \N* \n?/).map({
            # Split the line into indent and content
            my ($indent, $rest) = @($_ ~~ /^(\h*) (.*)$/);

            # Split the indent into characters and annotate them
            # with their visual size
            my $indent-size = 0;
            my @indent-chars = $indent.comb.map(-> $char {
                my $width = $char eq "\t"
                    ?? $?TABSTOP - ($indent-size mod $?TABSTOP)
                    !! 1;
                $indent-size += $width;
                $char => $width;
            }).eager;

            { :$indent-size, :@indent-chars, :rest(~$rest) };
        });

        # Figure out the amount * should de-indent by, we also use this for warnings
        my $common-prefix = min @lines.grep({ .<indent-size> ||  .<rest> ~~ /\S/}).map({ $_<indent-size> });
        return $obj if $common-prefix === Inf;

        # Set the actual de-indent amount here
        my Int $de-indent = nqp::istype($steps,Whatever)
          ?? $common-prefix
          !! -$steps;

        warn "Asked to remove $de-indent spaces, but the shortest indent is $common-prefix spaces"
            if $de-indent > $common-prefix;

        # Work forwards from the left end of the indent whitespace, removing
        # array elements up to # (or over, in the case of tab-explosion)
        # the specified de-indent amount.
        @lines.map(-> $l {
            my $pos = 0;
            while $l<indent-chars> and $pos < $de-indent {
                if $l<indent-chars>.shift.key eq "\t" {
                    $pos -= $pos % $?TABSTOP;
                    $pos += $?TABSTOP;
                } else {
                    $pos++
                }
            }
            if $l<indent-chars> and $pos % $?TABSTOP {
                my $check = $?TABSTOP - $pos % $?TABSTOP;
                $check = $l<indent-chars>[lazy 0..^$check].first(*.key eq "\t",:k);
                with $check {
                    $l<indent-chars>.shift for 0..$check;
                    $pos -= $pos % $?TABSTOP;
                    $pos += $?TABSTOP;
                }
            }
            $l<indent-chars>.key.join ~ ' ' x ($pos - $de-indent) ~ $l<rest>;
        }).join;
    }

    proto method codes(|) { * }
    multi method codes(Str:D: --> Int:D) {

        nqp::codes(self)




    }
    multi method codes(Str:U: --> Int:D) {
        self.Str;  # generate undefined warning
        0
    }

    proto method chars(|) { * }
    multi method chars(Str:D: --> Int:D) {
        nqp::p6box_i(nqp::chars($!value))
    }
    multi method chars(Str:U: --> Int:D) {
        self.Str;  # generate undefined warning
        0
    }

    proto method uc(|) { * }
    multi method uc(Str:D:) {
        nqp::p6box_s(nqp::uc($!value));
    }
    multi method uc(Str:U:) {
        self.Str;
    }

    proto method lc(|) { * }
    multi method lc(Str:D:) {
        nqp::p6box_s(nqp::lc($!value));
    }
    multi method lc(Str:U:) {
        self.Str;
    }

    proto method tc(|) { * }
    multi method tc(Str:D:) {
        nqp::p6box_s(nqp::tc(nqp::substr($!value,0,1)) ~ nqp::substr($!value,1));
    }
    multi method tc(Str:U:) {
        self.Str
    }

    proto method fc(|) { * }
    multi method fc(Str:D:) {
        nqp::p6box_s(nqp::fc($!value));
    }
    multi method fc(Str:U:) {
        self.Str;
    }

    proto method tclc(|) { * }
    multi method tclc(Str:D:) {
        nqp::p6box_s(nqp::tclc($!value))
    }
    multi method tclc(Str:U:) {
        self.Str
    }

    proto method flip(|) { * }
    multi method flip(Str:D:) {
        nqp::p6box_s(nqp::flip($!value))
    }
    multi method flip(Str:U:) {
        self.Str
    }

    proto method ord(|) { * }
    multi method ord(Str:D: --> Int:D) {
        nqp::chars($!value)
          ?? nqp::p6box_i(nqp::ord($!value))
          !! Nil;
    }
    multi method ord(Str:U: --> Nil) { }
}


multi sub prefix:<~>(Str:D \a)         { a.Str }
multi sub prefix:<~>(str   $a --> str) { $a    }

multi sub infix:<~>(Str:D \a, Str:D \b --> Str:D) {
    nqp::p6box_s(nqp::concat(nqp::unbox_s(a), nqp::unbox_s(b)))
}
multi sub infix:<~>(str $a, str $b --> str) { nqp::concat($a, $b) }
multi sub infix:<~>(Any:D \a, Str:D \b) {
    nqp::p6box_s(nqp::concat(nqp::unbox_s(a.Stringy), nqp::unbox_s(b)))
}
multi sub infix:<~>(Str:D \a, Any:D \b) {
    nqp::p6box_s(nqp::concat(nqp::unbox_s(a), nqp::unbox_s(b.Stringy)))
}
multi sub infix:<~>(*@args) { @args.join }

multi sub infix:<x>(Str:D $s, Int:D $repetition --> Str:D) {
    nqp::if(nqp::islt_i($repetition, 0),
        '',
        nqp::p6box_s(nqp::x(nqp::unbox_s($s), nqp::unbox_i($repetition))))
}
multi sub infix:<x>(str $s, int $repetition --> str) {
    nqp::if(nqp::islt_i($repetition, 0), '', nqp::x($s, $repetition))
}

multi sub infix:<cmp>(Str:D \a, Str:D \b --> Order:D) {
    ORDER(nqp::cmp_s(nqp::unbox_s(a), nqp::unbox_s(b)))
}
multi sub infix:<cmp>(str $a, str $b --> Order:D) {
    ORDER(nqp::cmp_s($a, $b))
}

multi sub infix:<===>(Str:D \a, Str:D \b --> Bool:D) {
    nqp::p6bool(
      nqp::eqaddr(a.WHAT,b.WHAT)
      && nqp::iseq_s(nqp::unbox_s(a), nqp::unbox_s(b))
    )
}
multi sub infix:<===>(str $a, str $b --> Bool:D) {
    nqp::p6bool(nqp::iseq_s($a, $b))
}

multi sub infix:<leg>(Str:D \a, Str:D \b --> Order:D) {
    ORDER(nqp::cmp_s(nqp::unbox_s(a), nqp::unbox_s(b)))
}
multi sub infix:<leg>(str $a, str $b --> Order:D) {
    ORDER(nqp::cmp_s($a, $b))
}

multi sub infix:<eq>(Str:D \a, Str:D \b --> Bool:D) {
    nqp::p6bool(nqp::iseq_s(nqp::unbox_s(a), nqp::unbox_s(b)))
}
multi sub infix:<eq>(str $a, str $b --> Bool:D) {
    nqp::p6bool(nqp::iseq_s($a, $b))
}

multi sub infix:<ne>(Str:D \a, Str:D \b --> Bool:D) {
    nqp::p6bool(nqp::isne_s(nqp::unbox_s(a), nqp::unbox_s(b)))
}
multi sub infix:<ne>(str $a, str $b --> Bool:D) {
    nqp::p6bool(nqp::isne_s($a, $b))
}

multi sub infix:<lt>(Str:D \a, Str:D \b --> Bool:D) {
    nqp::p6bool(nqp::islt_s(nqp::unbox_s(a), nqp::unbox_s(b)))
}
multi sub infix:<lt>(str $a, str $b --> Bool:D) {
    nqp::p6bool(nqp::islt_s($a, $b))
}

multi sub infix:<le>(Str:D \a, Str:D \b --> Bool:D) {
    nqp::p6bool(nqp::isle_s(nqp::unbox_s(a), nqp::unbox_s(b)))
}
multi sub infix:<le>(str $a, str $b --> Bool:D) {
    nqp::p6bool(nqp::isle_s($a, $b))
}

multi sub infix:<gt>(Str:D \a, Str:D \b --> Bool:D) {
    nqp::p6bool(nqp::isgt_s(nqp::unbox_s(a), nqp::unbox_s(b)))
}
multi sub infix:<gt>(str $a, str $b --> Bool:D) {
    nqp::p6bool(nqp::isgt_s($a, $b))
}

multi sub infix:<ge>(Str:D \a, Str:D \b --> Bool:D) {
    nqp::p6bool(nqp::isge_s(nqp::unbox_s(a), nqp::unbox_s(b)))
}
multi sub infix:<le>(str $a, str $b --> Bool:D) {
    nqp::p6bool(nqp::isle_s($a, $b))
}

multi sub infix:<~|>(Str:D \a, Str:D \b --> Str:D) {
    nqp::p6box_s(nqp::bitor_s(nqp::unbox_s(a), nqp::unbox_s(b)))
}
multi sub infix:<~|>(str $a, str $b --> str) { nqp::bitor_s($a, $b) }

multi sub infix:<~&>(Str:D \a, Str:D \b --> Str:D) {
    nqp::p6box_s(nqp::bitand_s(nqp::unbox_s(a), nqp::unbox_s(b)))
}
multi sub infix:<~&>(str $a, str $b --> str) { nqp::bitand_s($a, $b) }

multi sub infix:<~^>(Str:D \a, Str:D \b --> Str:D) {
    nqp::p6box_s(nqp::bitxor_s(nqp::unbox_s(a), nqp::unbox_s(b)))
}
multi sub infix:<~^>(str $a, str $b --> str) { nqp::bitxor_s($a, $b) }

multi sub prefix:<~^>(Str \a) {
    Failure.new("prefix:<~^> NYI")   # XXX
}

# XXX: String-wise shifts NYI
multi sub infix:~>(Str:D \a, Int:D \b --> Str:D) {
    X::NYI.new(feature => "infix:~>").throw;
}
multi sub infix:~>(str $a, int $b) {
    X::NYI.new(feature => "infix:~>").throw;
}
multi sub infix:~<(Str:D \a, Int:D \b --> Str:D) {
    X::NYI.new(feature => "infix:~<").throw;
}
multi sub infix:~<(str $a, int $b) {
    X::NYI.new(feature => "infix:~<").throw;
}

multi sub ords(Str $s) {
    $s.ords
}

sub trim         (Cool:D $s --> Str:D) { $s.trim }
sub trim-leading (Cool:D $s --> Str:D) { $s.trim-leading }
sub trim-trailing(Cool:D $s --> Str:D) { $s.trim-trailing }

# the opposite of Real.base, used for :16($hex_str)
proto sub UNBASE (|) { * }
multi sub UNBASE(Int:D $base, Any:D $num) {
    X::Numeric::Confused.new(:$num, :$base).throw;
}
multi sub UNBASE(Int:D $base, Str:D $str) {
    my Str $ch = substr($str, 0, 1);
    if $ch eq '0' {
        $ch = substr($str, 1, 1);
        if    $base <= 11 && $ch eq any(<x d o b>)
           or $base <= 24 && $ch eq any <o x>
           or $base <= 33 && $ch eq 'x' {
            $str.Numeric;
        } else {
            ":{$base}<$str>".Numeric;
        }
    } elsif $ch eq ':' && substr($str, 1, 1) ~~ ('1'..'9') {
        $str.Numeric;
    } else {
        ":{$base}<$str>".Numeric;
    }
}

# for :16[1, 2, 3]
sub UNBASE_BRACKET($base, @a) {
    my $v = 0;
    my $denom = 1;
    my Bool $seen-dot = False;
    for @a {
        if $seen-dot {
            die "Only one decimal dot allowed" if $_ eq '.';
            $denom *= $base;
            $v += $_ / $denom
        }
        elsif $_ eq '.' {
            $seen-dot = True;
        }
        else {
            $v = $v * $base + $_;
        }
    }
    $v;
}
proto sub infix:<unicmp>(|) is pure { * }
proto sub infix:<coll>(|) { * }

multi sub infix:<unicmp>(Str:D \a, Str:D \b --> Order:D) {
    ORDER(
        nqp::unicmp_s(
            nqp::unbox_s(a), nqp::unbox_s(b), 85,0,0))
}
multi sub infix:<unicmp>(Pair:D \a, Pair:D \b) {
    (a.key unicmp b.key) || (a.value unicmp b.value)
}
multi sub infix:<coll>(Str:D \a, Str:D \b --> Order:D) {
    ORDER(
        nqp::unicmp_s(
            nqp::unbox_s(a), nqp::unbox_s(b), $*COLLATION.collation-level,0,0))
}
multi sub infix:<coll>(Cool:D \a, Cool:D \b --> Order:D) {
    ORDER(
        nqp::unicmp_s(
            nqp::unbox_s(a.Str), nqp::unbox_s(b.Str), $*COLLATION.collation-level,0,0))
}
multi sub infix:<coll>(Pair:D \a, Pair:D \b) {
    (a.key coll b.key) || (a.value coll b.value)
}






sub chrs(*@c --> Str:D) {
    fail X::Cannot::Lazy.new(action => 'chrs') if @c.is-lazy;
    my $list     := nqp::getattr(@c,List,'$!reified');
    my int $i     = -1;
    my int $elems = nqp::elems($list);
    my $result   := nqp::list_s;
    nqp::setelems($result,$elems);

    my $value;
    nqp::istype(($value := nqp::atpos($list,$i)),Int)
      ?? nqp::bindpos_s($result,$i,nqp::chr($value))
      !! nqp::istype($value, Str)
          ?? (nqp::istype(($value := +$value), Failure)
              ?? return $value
              !! nqp::bindpos_s($result,$i,nqp::chr($value)))
          !! fail X::TypeCheck.new(
                operation => "converting element #$i to .chr",
                got       => $value,
                expected  => Int)
      while nqp::islt_i(++$i,$elems);

    nqp::join("",$result)
}

proto sub parse-base(|) { * }
multi sub parse-base(Str:D $str, Int:D $radix) { $str.parse-base($radix) }

sub parse-names(Str:D $str) { $str.parse-names }

proto sub substr(|) { * }
multi sub substr(Str:D \what, Int:D \start) {
    my str $str  = nqp::unbox_s(what);
    my int $max  = nqp::chars($str);
    my int $from = nqp::unbox_i(start);

    Rakudo::Internals.SUBSTR-START-OOR($from,$max).fail
      if nqp::islt_i($from,0) || nqp::isgt_i($from,$max);

    nqp::p6box_s(nqp::substr($str,$from));
}
multi sub substr(Str:D \what, Callable:D \start) {
    my str $str  = nqp::unbox_s(what);
    my int $max  = nqp::chars($str);
    my int $from = nqp::unbox_i((start)(nqp::p6box_i($max)));

    Rakudo::Internals.SUBSTR-START-OOR($from,$max).fail
      if nqp::islt_i($from,0) || nqp::isgt_i($from,$max);

    nqp::p6box_s(nqp::substr($str,$from));
}
multi sub substr(Str:D \what, Int:D \start, Int:D \want) {
    my str $str   = nqp::unbox_s(what);
    my int $max   = nqp::chars($str);
    my int $from  = nqp::unbox_i(start);

    Rakudo::Internals.SUBSTR-START-OOR($from,$max).fail
     if nqp::islt_i($from,0) || nqp::isgt_i($from,$max);

    my int $chars = nqp::unbox_i(want);
    Rakudo::Internals.SUBSTR-CHARS-OOR($chars).fail
      if nqp::islt_i($chars,0);

    nqp::p6box_s(nqp::substr($str,$from,$chars));
}
multi sub substr(Str() $what, \start, $want?) {

    # should really be int, but \ then doesn't work for rw access
    my $r := Rakudo::Internals.SUBSTR-SANITY($what, start, $want, my Int $from, my Int $chars);
    nqp::istype($r,Failure)
      ?? $r
      !! nqp::p6box_s(nqp::substr(
           nqp::unbox_s($what),nqp::unbox_i($from),nqp::unbox_i($chars)
         ))
}

sub substr-rw(\what, \start, $want?) is rw {
    my $Str := nqp::istype(what,Str) ?? what !! what.Str;

    # should really be int, but \ then doesn't work for rw access
    my $r := Rakudo::Internals.SUBSTR-SANITY($Str, start, $want, my Int $from, my Int $chars);
    nqp::istype($r,Failure)
      ?? $r
      !! Proxy.new(
           FETCH => sub ($) {
               nqp::p6box_s(nqp::substr(
                 nqp::unbox_s($Str), nqp::unbox_i($from), nqp::unbox_i($chars)
               ));
           },
           STORE => sub ($, Str() $new) {
               my $str = nqp::unbox_s($Str);
               what = nqp::p6box_s(
                 nqp::concat(
                   nqp::substr($str,0,nqp::unbox_i($from)),
                   nqp::concat(
                     nqp::unbox_s($new),
                     nqp::substr($str,nqp::unbox_i($from + $chars))
                   )
                 )
               );
           },
         )
}

multi sub infix:<eqv>(Str:D \a, Str:D \b) {
    nqp::p6bool(
      nqp::unless(
        nqp::eqaddr(nqp::decont(a),nqp::decont(b)),
        nqp::eqaddr(a.WHAT,b.WHAT) && nqp::iseq_s(a,b)
      )
    )
}

proto sub samemark(|) {*}
multi sub samemark($s, $pat) { $s.samemark($pat) }

#line 1 SETTING::src/core/Capture.pm
my class Capture { # declared in BOOTSTRAP
    # class Capture is Any
    #     has @!list;   # positional parameters
    #     has %!hash;   # named parameters

    method from-args(|c) { c }

    submethod BUILD(:@list, :%hash --> Nil) {
        @list.elems; # force reification of all
        nqp::bindattr(self, Capture, '@!list',
            nqp::getattr(nqp::decont(@list.list), List, '$!reified')
        );
        nqp::bindattr(self,Capture,'%!hash',
          nqp::getattr(nqp::decont(%hash),Map,'$!storage'))
            if nqp::attrinited(nqp::decont(%hash),Map,'$!storage')
    }

    multi method WHICH (Capture:D:) {
        my $WHICH = nqp::istype(self.WHAT,Capture) ?? 'Capture' !! self.^name;
        if !nqp::isnull(@!list) && @!list {
            $WHICH ~= '|';
            for nqp::hllize(@!list) -> \elem {
                $WHICH ~= ( '(' ~ elem.VAR.WHICH ~ ')' )
            }
        }
        if !nqp::isnull(%!hash) && %!hash {
            $WHICH ~= '|';
            $WHICH ~= ( $_ ~ '(' ~ nqp::atkey(%!hash, nqp::unbox_s($_)).WHICH ~ ')' )
              for nqp::hllize(%!hash).keys.sort;
        }
        $WHICH;
    }

    multi method AT-KEY(Capture:D: Str:D \key) is raw {
        nqp::ifnull(nqp::atkey(%!hash,nqp::unbox_s(key)), Nil)
    }
    multi method AT-KEY(Capture:D: \key) is raw {
        nqp::ifnull(nqp::atkey(%!hash,nqp::unbox_s(key.Str)), Nil)
    }

    multi method AT-POS(Capture:D: int \pos) is raw {
        nqp::islt_i(pos,0)
          ?? Failure.new(X::OutOfRange.new(
               :what($*INDEX // 'Index'),:got(pos),:range<0..^Inf>))
          !! nqp::ifnull(nqp::atpos(@!list,pos),Nil)
    }
    multi method AT-POS(Capture:D: Int:D \pos) is raw {
        my int $pos = nqp::unbox_i(pos);
        nqp::islt_i($pos,0)
          ?? Failure.new(X::OutOfRange.new(
               :what($*INDEX // 'Index'),:got(pos),:range<0..^Inf>))
          !! nqp::ifnull(nqp::atpos(@!list,$pos),Nil)
    }

    method hash(Capture:D:) {
        nqp::if(
          (nqp::defined(%!hash) && nqp::elems(%!hash)),
          nqp::p6bindattrinvres(nqp::create(Map),Map,'$!storage',%!hash),
          nqp::create(Map)
        )
    }

    multi method EXISTS-KEY(Capture:D: Str:D \key ) {
        nqp::p6bool(nqp::existskey(%!hash, nqp::unbox_s(key)));
    }
    multi method EXISTS-KEY(Capture:D: \key ) {
        nqp::p6bool(nqp::existskey(%!hash, nqp::unbox_s(key.Str)));
    }

    method list(Capture:D:) {
        nqp::if(
          (nqp::defined(@!list) && nqp::elems(@!list)),
          nqp::p6bindattrinvres(nqp::create(List),List,'$!reified',@!list),
          nqp::create(List)
        )
    }

    method elems(Capture:D:) {
        nqp::isnull(@!list) ?? 0 !! nqp::p6box_i(nqp::elems(@!list))
    }

    multi method Str(Capture:D:) {
        my Mu $str := nqp::list_s();
        if @!list {
            my Mu $iter := nqp::iterator(@!list);
            nqp::push_s($str, nqp::unbox_s(nqp::shift($iter).Str)) while $iter;
        }
        if %!hash {
            my Mu $iter := nqp::iterator(%!hash);
            while $iter {
                my $kv := nqp::shift($iter);
                nqp::push_s($str, nqp::unbox_s((nqp::p6box_s(nqp::iterkey_s($kv)) => nqp::iterval($kv).Str).Str));
            }
        }
        nqp::p6box_s(nqp::join(' ', $str))
    }
    multi method gist(Capture:D:) { self.Capture::perl }
    multi method perl(Capture:D:) {
        my %hash := self.Capture::hash;
        if self.^name eq 'Capture' {
            "\\({
                join ', ',
                    ((nqp::atpos(@!list, $_).perl for ^nqp::elems(@!list)) if @!list),
                    %hash.sort.map( *.perl )
            })";
        } else {
            self.^name
              ~ '.new('
              ~ ( 'list => (' ~ (nqp::atpos(@!list, $_).perl for ^nqp::elems(@!list)).join(', ') ~ ',)' if @!list)
              ~ (', ' if +@!list and +%hash)
              ~ ( 'hash => {' ~ %hash.sort.map( *.perl ).join(', ') ~ '}' if +%hash)
              ~ ')';
        }
    }
    multi method Bool(Capture:D:) {
        nqp::p6bool(
          nqp::elems(@!list) || nqp::elems(%!hash)
        )
    }

    method Capture(Capture:D:) {
        self
    }

    multi method Numeric(Capture:D:) {
        self.Capture::elems
    }

    method FLATTENABLE_LIST() { @!list ?? @!list !! nqp::list() }
    method FLATTENABLE_HASH() { %!hash ?? %!hash !! nqp::hash() }

    multi method keys(Capture:D:) {
        (self.Capture::list.keys, self.Capture::hash.keys).flat;
    }
    multi method kv(Capture:D:) {
        (self.Capture::list.kv, self.Capture::hash.kv).flat;
    }
    multi method values(Capture:D:) {
        (self.Capture::list.values, self.Capture::hash.values).flat;
    }
    multi method pairs(Capture:D:) {
        (self.Capture::list.pairs, self.Capture::hash.pairs).flat;
    }
    multi method antipairs(Capture:D:) {
        (self.Capture::list.antipairs, self.Capture::hash.antipairs).flat;
    }
}

multi sub infix:<eqv>(Capture:D \a, Capture:D \b) {
    nqp::p6bool(
      nqp::eqaddr(a,b)
        || (nqp::eqaddr(a.WHAT,b.WHAT)
             && a.Capture::list eqv b.Capture::list && a.Capture::hash eqv b.Capture::hash)
    )
}

#line 1 SETTING::src/core/IterationBuffer.pm
# IterationBuffer is used when the list/iteration implementation needs a
# lightweight way to store/transmit values. Replaces the use of nqp::list in
# the list guts, which is an impediment to introspectability and also to
# allowing the implementation of custom iterators (though in reality most
# folks won't implement Iterator directly, but instead use gather/take or lazy
# loops). It doesn't make Scalar containers, and only supports mutation
# through implementing push and BIND-POS, and access by implementing AT-POS.
# Hot-paths are free to use the nqp:: op set directly on this, and do things
# outside the scope of the method API it exposes. This type is engineered for
# performance over friendliness, and should not be encountered in normal use
# of Perl 6. Do NOT add any checks and validation to methods in here. They
# need to remain trivially inlineable for performance reasons.
my class IterationBuffer {
    method clear(IterationBuffer:D: --> Nil) {
        nqp::setelems(self, 0)
    }

    multi method elems(IterationBuffer:D:) {
        nqp::elems(self)
    }

    multi method push(IterationBuffer:D: Mu \value) {
        nqp::push(self, value)
    }

    multi method AT-POS(IterationBuffer:D: int $pos) is raw {
        nqp::atpos(self, $pos)
    }
    multi method AT-POS(IterationBuffer:D: Int $pos) is raw {
        nqp::atpos(self, $pos)
    }

    proto method BIND-POS(|) { * }
    multi method BIND-POS(IterationBuffer:D: int $pos, Mu \value) {
        nqp::bindpos(self, $pos, value)
    }
    multi method BIND-POS(IterationBuffer:D: Int $pos, Mu \value) {
        nqp::bindpos(self, $pos, value)
    }

    # For core debugging purposes only: basically warp the IterationBuffer
    # into a full-fledged List and .perl that.  We don't care that it will
    # not round-trip.
    multi method perl(IterationBuffer:D:) {
        nqp::p6bindattrinvres(nqp::create(List),List,'$!reified',self).perl
    }
}

#line 1 SETTING::src/core/Sequence.pm
# A Sequence represents anything that can lazily produce a sequence of values.
# There are various concrete implementations of Sequence, the most common
# being Seq, which represents a sequentially produced sequence.
#
# Sequences are born in a state where iterating them will consume the values.
# However, calling .cache will return a List that will lazily reify to the
# values in the Sequence. The List is memoized, so that subsequent calls to
# .cache will always return the same List (safe as List is immutable). More
# than one call to .iterator throws an exception (and calling .cache calls the
# .iterator method the first time also). The memoization can be avoided by
# asking very specifically for the Seq to be coerced to a List (using .List
# or .list), a Slip (.Slip) or an Array (.Array).
#
# The actual memoization functionality is factored out into a role,
# PositionalBindFailover, which is used by the binder to identify types that,
# on failure to bind to an @-sigilled thing, can have .cache called on them
# and get memoization semantics. This decouples this functionality from the
# Sequence role, so other user-defined types can get access to this
# functionality.

my role PositionalBindFailover {
    has $!list;

    method cache() {
        $!list.DEFINITE
            ?? $!list
            !! ($!list := List.from-iterator(self.iterator))
    }
    multi method list(::?CLASS:D:) {
        List.from-iterator(self.iterator)
    }

    method iterator() { ... }
}
nqp::p6configposbindfailover(Positional, PositionalBindFailover); # Binder
Routine.'!configure_positional_bind_failover'(Positional, PositionalBindFailover); # Multi-dispatch

my role Sequence does PositionalBindFailover {
    multi method Array(::?CLASS:D:) { Array.from-iterator(self.iterator) }
    multi method List(::?CLASS:D:)  { List.from-iterator(self.iterator) }
    multi method Slip(::?CLASS:D:)  { Slip.from-iterator(self.iterator) }

    multi method Str(::?CLASS:D:) {
        self.cache.Str
    }

    multi method Stringy(::?CLASS:D:) {
        self.cache.Stringy
    }

    multi method AT-POS(::?CLASS:D: Int $idx) is raw {
        self.cache.AT-POS($idx)
    }

    multi method AT-POS(::?CLASS:D: int $idx) is raw {
        self.cache.AT-POS($idx)
    }

    multi method EXISTS-POS(::?CLASS:D: Int $idx) {
        self.cache.EXISTS-POS($idx)
    }

    multi method EXISTS-POS(::?CLASS:D: int $idx) {
        self.cache.EXISTS-POS($idx)
    }

    multi method eager(::?CLASS:D:) { List.from-iterator(self.iterator).eager }

    method fmt(|c) {
        self.cache.fmt(|c)
    }

    multi method gist(::?CLASS:D:) {
        self.cache.gist
    }
}
#line 1 SETTING::src/core/Seq.pm
my class X::Seq::Consumed { ... }
my class X::Seq::NotIndexable { ... }
my class Seq is Cool does Iterable does Sequence {
    # The underlying iterator that iterating this sequence will work its
    # way through. Can only be obtained once.
    has Iterator $!iter;

    # The only valid way to create a Seq directly is by giving it the
    # iterator it will consume and maybe memoize.
    method new(Iterator:D $iter) {
        nqp::p6bindattrinvres(nqp::create(self),Seq,'$!iter',nqp::decont($iter))
    }

    method new-consumed() {
        self.bless;
    }

    method iterator(Seq:D:) {
        nqp::if(
          (my \iter = $!iter).DEFINITE,
          nqp::stmts(
            ($!iter := Iterator),
            iter
          ),
          nqp::if(
            $!list.DEFINITE,
            $!list.iterator,
            X::Seq::Consumed.new.throw
          )
        )
    }

    multi method is-lazy(Seq:D:) {
        nqp::if(
          $!iter.DEFINITE,
          $!iter.is-lazy,
          nqp::if(
            $!list.DEFINITE,
            $!list.is-lazy,
            X::Seq::Consumed.new.throw
          )
        )
    }

    multi method Seq(Seq:D:)   { self }

    method Capture() {
        self.List.Capture
    }

    method elems() {
        nqp::if(
          self.is-lazy,
          Failure.new(X::Cannot::Lazy.new(action => '.elems')),
          nqp::if(
            ($!iter.DEFINITE && nqp::can($!iter,'count-only')),
            $!iter.count-only,
            self.cache.elems
          )
        )
    }

    method Numeric() {
        nqp::if(
          ($!iter.DEFINITE && nqp::can($!iter,'count-only')),
          $!iter.count-only,
          self.cache.Numeric
        )
    }

    method Int() {
        nqp::if(
          ($!iter.DEFINITE && nqp::can($!iter,'count-only')),
          $!iter.count-only,
          self.cache.Int
        )
    }

    method Bool(Seq:D:) {
        nqp::if(
          $!iter.DEFINITE,
          nqp::if(
            nqp::can($!iter,'bool-only'),
            $!iter.bool-only,
            nqp::if(
              nqp::can($!iter,'count-only'),
              ?$!iter.count-only,
              self.cache.Bool
            )
          ),
          self.cache.Bool
        )
    }

    multi method perl(Seq:D \SELF:) {
        # If we don't have an iterator, someone grabbed it already;
        # Check for cached $!list; if that's missing too, we're consumed
        my $perl;
        if not $!iter.DEFINITE and not $!list.DEFINITE {
            # cannot call .cache on a Seq that's already been iterated,
            # so we need to produce a string that, when EVAL'd, reproduces
            # an already iterated Seq.
            # compare RT #127492
            $perl = self.^name ~ '.new-consumed()';
        }
        else { $perl = self.cache.perl ~ '.Seq' }
        nqp::iscont(SELF) ?? '$(' ~ $perl ~ ')' !! $perl
    }

    method join(Seq:D: $separator = '' --> Str:D) {
        nqp::if(
          (my $iterator := self.iterator).is-lazy,
          '...',
          nqp::stmts(
            (my $strings  := nqp::list_s),
            nqp::until(
              nqp::eqaddr((my $pulled := $iterator.pull-one),IterationEnd),
              nqp::push_s($strings,nqp::unbox_s(
                nqp::if(
                  nqp::isconcrete($pulled) && nqp::istype($pulled,Str),
                  $pulled,
                  nqp::if(
                    nqp::can($pulled,'Str'),
                    $pulled.Str,
                    nqp::box_s($pulled,Str)
                  )
                )
              ))
            ),
            nqp::box_s(nqp::join(nqp::unbox_s($separator.Str),$strings),Str)
          )
        )
    }

    method sink(--> Nil) {
        nqp::if(
          $!iter.DEFINITE,
          nqp::stmts(
            $!iter.sink-all,
            ($!iter := Iterator)
          ),
          nqp::if(
            $!list.DEFINITE,
            $!list.sink
          )
        )
    }

    proto method from-loop(|) { * }
    multi method from-loop(&body) {
        Seq.new(Rakudo::Iterator.Loop(&body))
    }
    multi method from-loop(&body, &cond, :$repeat!) {
        Seq.new($repeat
          ?? Rakudo::Iterator.RepeatLoop(&body, &cond)
          !! Rakudo::Iterator.WhileLoop(&body, &cond)
        )
    }
    multi method from-loop(&body, &cond) {
        Seq.new(Rakudo::Iterator.WhileLoop(&body, &cond))
    }
    multi method from-loop(&body, &cond, &afterwards) {
        Seq.new(Rakudo::Iterator.CStyleLoop(&body, &cond, &afterwards))
    }

    multi method skip()         { nqp::stmts( $!iter.skip-one, self) }
    multi method skip(Int() $n) { nqp::stmts( $!iter.skip-at-least($n), self) }
}

sub GATHER(&block) {
    Seq.new(class :: does SlippyIterator {
        has &!resumption;
        has $!push-target;
        has int $!wanted;

        my constant PROMPT = nqp::create(Mu);

        method new(&block) {
            my \iter = nqp::create(self);
            my int $wanted;
            my $taken;
            my $taker := {
                nqp::stmts(
                  ($taken := nqp::getpayload(nqp::exception())),
                  nqp::if(
                    nqp::istype($taken, Slip),
                    nqp::stmts(
                      iter!start-slip-wanted($taken),
                      ($wanted = nqp::getattr_i(iter, self, '$!wanted'))
                    ),
                    nqp::stmts(  # doesn't sink
                      nqp::getattr(iter, self, '$!push-target').push($taken),
                      ($wanted = nqp::bindattr_i(iter,self,'$!wanted',
                        nqp::sub_i(nqp::getattr_i(iter,self,'$!wanted'),1)))
                    )
                  ),
                  nqp::if(
                    nqp::iseq_i($wanted,0),
                    nqp::continuationcontrol(0, PROMPT, -> Mu \c {
                        nqp::bindattr(iter, self, '&!resumption', c);
                    })
                  ),
                  nqp::resume(nqp::exception())
                )
            }
            nqp::bindattr(iter, self, '&!resumption', {
                nqp::stmts(  # doesn't sink
                  nqp::handle(&block(), 'TAKE', $taker()),
                  nqp::continuationcontrol(0, PROMPT, -> | {
                      nqp::bindattr(iter, self, '&!resumption', Callable)
                  })
                )
            });
            iter
        }

        method pull-one() is raw {
            nqp::if(
              $!slipping && nqp::not_i(
                nqp::eqaddr((my \result = self.slip-one),IterationEnd)
              ),
              result,
              nqp::stmts(
                nqp::unless(
                  $!push-target.DEFINITE,
                  ($!push-target := nqp::create(IterationBuffer))
                ),
                ($!wanted = 1),
                nqp::continuationreset(PROMPT, &!resumption),
                nqp::if(
                  &!resumption.DEFINITE,
                  nqp::shift($!push-target),
                  IterationEnd
                )
              )
            )
        }

        method push-exactly($target, int $n) {
            nqp::if(
              nqp::isgt_i($n,0),
              nqp::stmts(
                ($!wanted = $n),
                ($!push-target := $target),
                nqp::if(
                  $!slipping && nqp::not_i(
                    nqp::eqaddr(self!slip-wanted,IterationEnd)
                  ),
                  nqp::stmts(
                    ($!push-target := nqp::null),
                    $n
                  ),
                  nqp::stmts(
                    nqp::continuationreset(PROMPT, &!resumption),
                    ($!push-target := nqp::null),
                    nqp::if(
                      &!resumption.DEFINITE,
                      ($n - $!wanted),
                      IterationEnd
                    )
                  )
                )
              )
            )
        }

        method !start-slip-wanted(\slip --> Nil) {
            my $value := self.start-slip(slip);
            nqp::unless(
              nqp::eqaddr($value,IterationEnd),
              nqp::stmts(  # doesn't sink
                $!push-target.push($value),
                (my int $i = 0),
                (my int $n = $!wanted),
                nqp::while(  # doesn't sink
                  nqp::islt_i($i = nqp::add_i($i,1),$n),
                  nqp::if(
                    nqp::eqaddr(($value := self.slip-one),IterationEnd),
                    last
                  ),
                  $!push-target.push($value)
                ),
                ($!wanted = $!wanted - $i)
              )
            )
        }

        method !slip-wanted() {
            my int $i = -1;
            my int $n = $!wanted;
            my $value;
            nqp::while(
              nqp::islt_i($i = nqp::add_i($i,1),$n),
              nqp::stmts(  # doesn't sink
                nqp::if(
                  nqp::eqaddr(($value := self.slip-one),IterationEnd),
                  last
                ),
                $!push-target.push($value)
              )
            );
            $!wanted = nqp::sub_i($!wanted,$i);
            nqp::if(
              nqp::eqaddr($value,IterationEnd),
              IterationEnd,
              $n
            )
        }
    }.new(&block))
}

multi sub infix:<eqv>(Seq:D \a, Seq:D \b) {
    nqp::p6bool(
      nqp::unless(
        nqp::eqaddr(a,b),
        nqp::if(
          nqp::eqaddr(a.WHAT,b.WHAT),
          nqp::if(
            nqp::iseq_i(
              (my \ia := a.iterator).is-lazy,
              (my \ib := b.iterator).is-lazy
            ),
            nqp::if(
              ia.is-lazy,
              die(X::Cannot::Lazy.new: :action<eqv>),
              nqp::stmts(
                nqp::until(
                  nqp::stmts(
                    (my \pa := ia.pull-one),
                    (my \pb := ib.pull-one),
                    nqp::eqaddr(pa,IterationEnd)
                      || nqp::eqaddr(pb,IterationEnd)
                      || nqp::not_i(pa eqv pb)
                  ),
                  nqp::null
                ),
                nqp::eqaddr(pa,pb)  # exhausted if both IterationEnd
              )
            )
          )
        )
      )
    )
}

#line 1 SETTING::src/core/Rakudo/Internals/HyperWorkBatch.pm
# A batch of work sent to a worker in a hyper or race operation. It is an
# Iterable, and iterates to the items in the batch. This is so that it can be
# easily processed in terms of (non-hyper) Iterable implementations.
my class Rakudo::Internals::HyperWorkBatch does Iterable {
    # The items in the batch.
    has IterationBuffer $.items;

    # Sequence number of the batch, starting from zero.
    has int $.sequence-number;

    # Is this the first batch that was produced at the last fork point or the last batch that the
    # fork point will produce?
    has Bool $.first;
    has Bool $.last;

    # Iterator for a HyperWorkBatch;
    my class HyperWorkBatchIterator does Iterator {
        has $!items;
        has int $!i;
        has int $!n;

        submethod BUILD(:$items --> Nil) {
            $!items := nqp::decont($items);
            $!i = -1;
            $!n = nqp::elems($!items);
        }

        method pull-one() {
            ++$!i < $!n
                ?? nqp::atpos($!items, $!i)
                !! IterationEnd
        }
    }

    method iterator(--> Iterator) {
        HyperWorkBatchIterator.new(:$!items)
    }

    method replace-with(IterationBuffer $ib --> Nil) {
        $!items := $ib;
    }
}

#line 1 SETTING::src/core/Rakudo/Internals/HyperWorkStage.pm
# Work stages are individual steps in a hyper/race pipeline. They are chained
# in a linked list by the source attribute. Roles for different kinds of stages
# follow.
my role Rakudo::Internals::HyperWorkStage {
    has Rakudo::Internals::HyperWorkStage $.source;
}

# A HyperBatcher stage produces batches of work to do. It will typically be
# created with an Iterable of some kind, and divide up the work into batches
# of the appropriate size. Such a stage always lives at the start of a piece
# of parallel processing pipeline.
my role Rakudo::Internals::HyperBatcher does Rakudo::Internals::HyperWorkStage {
    has $!sequence = -1;

    method next-sequence-number() {
        ++$!sequence
    }

    method produce-batch(int $batch-size --> Rakudo::Internals::HyperWorkBatch) { ... }
}

# A HyperProcessor performs some operation in a work batch, updating it to
# reflect the results of the operation.
my role Rakudo::Internals::HyperProcessor does Rakudo::Internals::HyperWorkStage {
    method process-batch(Rakudo::Internals::HyperWorkBatch $batch --> Nil) { ... }
}

# A HyperRebatcher is given batches, and may produce zero or more batches as a
# result. The produced batches will be passed on to the next pipeline stages.
# This is intended only for steps that need to look across multiple batches,
# but that work in a "streaming" way rather than being a full bottleneck in
# the pipeline. A HyperRebatcher should produce one output batch for each
# input batch it gets (though may produce no batches on one call, and two on
# the next, for example).
my role Rakudo::Internals::HyperRebatcher does Rakudo::Internals::HyperWorkStage {
    method rebatch(Rakudo::Internals::HyperWorkBatch $batch --> List) { ... }
}

# Comes at the end of a pipeline, or a stage in a multi-stage pipeline (that
# is, one with a step in it where all results are needed). The batch-used
# method should be called whenever a batch passed to consume-batch has been
# used. This allows for backpressure control: a sequential iterator at the
# end of a parallel pipeline can choose to call batch-used only at the point
# when the downstream iterator has actually eaten all the values in a batch.
my role Rakudo::Internals::HyperJoiner does Rakudo::Internals::HyperWorkStage {
    has $!batch-used-channel;
    method consume-batch(Rakudo::Internals::HyperWorkBatch $batch --> Nil) { ... }
    method consume-error(Exception \e) { ... }
    method batch-used(--> Nil) {
        $!batch-used-channel.send(True);
    }
    method SET-BATCH-USED-CHANNEL($!batch-used-channel) {}
}

#line 1 SETTING::src/core/Rakudo/Internals/HyperPipeline.pm
# Takes a linked list of pipeline stages and assembles them into a pipeline.
# Given a pipeline must end with a HyperJoiner, it expects to be passed
# something of this type.
my class Rakudo::Internals::HyperPipeline {
    method start(Rakudo::Internals::HyperJoiner $stage, HyperConfiguration $config) {
        # Create channel that the last non-join operation in the pipeline will
        # put its results into, and start a worker to handle the channel.
        my $cur-dest-channel = Channel.new;
        self!join-worker($stage, $cur-dest-channel);

        # Create a channel that will signal we're ready for more batches,
        # and set join stage to send on it when batch-used is called.
        my $ready-channel = Channel.new;
        $stage.SET-BATCH-USED-CHANNEL($ready-channel);

        # Go through the rest of the stages.
        my $cur-stage = $stage.source;
        my @processors;
        while $cur-stage {
            my $next-stage = $cur-stage.source;
            given $cur-stage {
                when Rakudo::Internals::HyperProcessor {
                    # Unshift them so a sequence will be in application order.
                    unshift @processors, $_;
                }
                when Rakudo::Internals::HyperBatcher {
                    if $next-stage {
                        die "A HyperBatcher may only be at the pipeline start";
                    }
                    $cur-dest-channel = self!maybe-processor-workers:
                        [@processors], $cur-dest-channel, $config.degree;
                    @processors = ();
                    self!batch-worker($cur-stage, $cur-dest-channel, $ready-channel,
                        $config.batch);
                }
                default {
                    die "Unrecognized hyper pipeline stage " ~ .^name();
                }
            }
            $cur-stage = $next-stage;
        }

        # Set off $degree batches.
        $ready-channel.send(True) for ^$config.degree;
    }

    method !batch-worker(Rakudo::Internals::HyperBatcher $stage, Channel $dest-channel,
                         Channel $ready-channel, int $size) {
        start {
            loop {
                $*AWAITER.await($ready-channel);
                my $batch := $stage.produce-batch($size);
                $dest-channel.send($batch);
                last if $batch.last;
                CATCH {
                    default {
                        $dest-channel.fail($_);
                    }
                }
            }
        }
    }

    method !maybe-processor-workers(@processors, Channel $dest-channel, Int $degree) {
        return $dest-channel unless @processors;
        my $source-channel := Channel.new;
        for ^$degree {
            start {
                loop {
                    my $batch := $*AWAITER.await($source-channel);
                    for @processors {
                        .process-batch($batch);
                    }
                    $dest-channel.send($batch);
                }
                CATCH {
                    when X::Channel::ReceiveOnClosed {
                        $dest-channel.close;
                    }
                    default {
                        $dest-channel.fail($_);
                    }
                }
            }
        }
        return $source-channel;
    }

    method !join-worker(Rakudo::Internals::HyperJoiner $stage, Channel $source) {
        start {
            loop {
                $stage.consume-batch($*AWAITER.await($source));
            }
            CATCH {
                when X::Channel::ReceiveOnClosed {
                    # We got everything; quietly exit the start block.
                }
                default {
                    $stage.consume-error($_);
                    CATCH {
                        default {
                            # Error handling code blew up; let the scheduler's
                            # error handler do it, which will typically bring
                            # the program down. Should never get here unless
                            # we've some bug in a joiner implementation.
                            $*SCHEDULER.handle_uncaught($_);
                        }
                    }
                }
            }
        }
    }
}

#line 1 SETTING::src/core/Rakudo/Internals/HyperIteratorBatcher.pm
# Batches values sourced from an iterator, producing a work batch from them.
my role Rakudo::Internals::HyperIteratorBatcher does Rakudo::Internals::HyperBatcher {
    my constant NO_LOOKAHEAD = Mu.CREATE;
    has Iterator $!iterator;
    has $!lookahead;
   
    submethod BUILD(Iterator :$iterator!) {
        $!iterator := $iterator;
        $!lookahead := NO_LOOKAHEAD;
    }
    
    method produce-batch(int $batch-size --> Rakudo::Internals::HyperWorkBatch) {
        my IterationBuffer $items .= new;
        my Bool $first;
        my Bool $last;
        if $!lookahead =:= NO_LOOKAHEAD {
            $first = True;
            if $!iterator.push-exactly($items, $batch-size) =:= IterationEnd {
                $last = True;
            }
            else {
                $!lookahead := $!iterator.pull-one;
                $last = True if $!lookahead =:= IterationEnd;
            }
        }
        else {
            $first = False;
            $items.push($!lookahead);
            if $!iterator.push-exactly($items, $batch-size - 1) =:= IterationEnd {
                $last = True;
            }
            else {
                $!lookahead := $!iterator.pull-one;
                $last = True if $!lookahead =:= IterationEnd;
            }
        }
        my $sequence-number = self.next-sequence-number();
        return Rakudo::Internals::HyperWorkBatch.new(:$sequence-number, :$items, :$first, :$last);
    }
}

#line 1 SETTING::src/core/Rakudo/Internals/HyperToIterator.pm
my class Backtrace { ... }
my role X::HyperRace::Died {
    has $.start-backtrace;
    multi method gist(::?CLASS:D:) {
        "A worker in a parallel iteration (hyper or race) initiated here:\n" ~
            ((try $!start-backtrace ~ "\n") // '<unknown location>') ~
            "Died at:\n" ~
            callsame().indent(4)
    }
}

my class Rakudo::Internals::HyperToIterator does Rakudo::Internals::HyperJoiner does Iterator {
    has Channel $.batches .= new;

    has int $!last-target = -1;
    has int $!next-to-send = 0;
    has @!held-back;
    method consume-batch(Rakudo::Internals::HyperWorkBatch $batch --> Nil) {
        if $batch.last {
            $!last-target = $batch.sequence-number;
        }
        self!handle-batch($batch);
        if $!last-target >= 0 && $!next-to-send > $!last-target {
            $!batches.close;
        }
    }
    method !handle-batch($batch) {
        my int $seq = $batch.sequence-number;
        if $seq == $!next-to-send {
            $!batches.send($batch);
            ++$!next-to-send;
            if @!held-back {
                @!held-back.=sort(*.sequence-number);
                while @!held-back && @!held-back[0].sequence-number == $!next-to-send {
                    $!batches.send(@!held-back.shift);
                    ++$!next-to-send;
                }
            }
        }
        else {
            @!held-back.push($batch);
        }
    }

    method consume-error(Exception $e --> Nil) {
        $!batches.fail($e);
    }

    my constant EMPTY_BUFFER = IterationBuffer.CREATE;
    has IterationBuffer $!current-items = EMPTY_BUFFER;
    method pull-one() {
        until nqp::elems(nqp::decont($!current-items)) { # Handles empty batches
            my $batch = $!batches.receive;
            self.batch-used();
            $!current-items = $batch.items;
            CATCH {
                when X::Channel::ReceiveOnClosed {
                    return IterationEnd;
                }
                default {
                    unless nqp::istype($_, X::HyperRace::Died) {
                        ($_ but X::HyperRace::Died(Backtrace.new(5))).rethrow
                    }
                }
            }
        }
        nqp::shift(nqp::decont($!current-items))
    }
}

#line 1 SETTING::src/core/Rakudo/Internals/RaceToIterator.pm
my class Rakudo::Internals::RaceToIterator does Rakudo::Internals::HyperJoiner does Iterator {
    has Channel $.batches .= new;

    has int $!last-target = -1;
    has int $!batches-seen = 0;
    method consume-batch(Rakudo::Internals::HyperWorkBatch $batch --> Nil) {
        $!batches.send($batch);
        ++$!batches-seen;
        if $batch.last {
            $!last-target = $batch.sequence-number;
        }
        if $!last-target >= 0 && $!batches-seen == $!last-target + 1 {
            $!batches.close;
        }
    }

    method consume-error(Exception $e --> Nil) {
        $!batches.fail($e);
    }

    my constant EMPTY_BUFFER = IterationBuffer.CREATE;
    has IterationBuffer $!current-items = EMPTY_BUFFER;
    method pull-one() {
        until nqp::elems(nqp::decont($!current-items)) { # Handles empty batches
            my $batch = $!batches.receive;
            self.batch-used();
            $!current-items = $batch.items;
            CATCH {
                when X::Channel::ReceiveOnClosed {
                    return IterationEnd;
                }
                default {
                    unless nqp::istype($_, X::HyperRace::Died) {
                        ($_ but X::HyperRace::Died(Backtrace.new(5))).rethrow
                    }
                }
            }
        }
        nqp::shift(nqp::decont($!current-items))
    }
}

#line 1 SETTING::src/core/Rakudo/Internals/HyperRaceSharedImpl.pm
# Implementations shared between HyperSeq and RaceSeq.
class Rakudo::Internals::HyperRaceSharedImpl {
    my class GrepSM does Rakudo::Internals::HyperProcessor {
        has $!matcher;

        submethod TWEAK(:$!matcher) {}

        method process-batch(Rakudo::Internals::HyperWorkBatch $batch) {
            my $result := IterationBuffer.new;
            my $items := $batch.items;
            my int $n = $items.elems;
            loop (my int $i = 0; $i < $n; ++$i) {
                my \item := nqp::atpos($items, $i);
                $result.push(item) if $!matcher.ACCEPTS(item);
            }
            $batch.replace-with($result);
        }
    }
    multi method grep(\hyper, $source, \matcher, %options) {
        if %options || nqp::istype(matcher, Code) && matcher.count > 1 {
            # Fall back to sequential grep for cases we can't yet handle
            self.rehyper(hyper, hyper.Any::grep(matcher, |%options))
        }
        else {
            hyper.bless:
                configuration => hyper.configuration,
                work-stage-head => GrepSM.new(:$source, :matcher(matcher))
        }
    }

    my class GrepCode does Rakudo::Internals::HyperProcessor {
        has &!matcher;

        submethod TWEAK(:&!matcher) {}

        method process-batch(Rakudo::Internals::HyperWorkBatch $batch) {
            my $result := IterationBuffer.new;
            my $items := $batch.items;
            my int $n = $items.elems;
            my &matcher = &!matcher.clone;
            loop (my int $i = 0; $i < $n; ++$i) {
                my \item := nqp::atpos($items, $i);
                $result.push(item) if matcher(item);
            }
            $batch.replace-with($result);
        }
    }
    multi method grep(\hyper, $source, &matcher, %options) {
        X::NYI.new(feature => 'Phasers in hyper/race').throw
          if nqp::istype(&matcher,Block) && &matcher.has-phasers;

        if %options || &matcher.count > 1 {
            # Fall back to sequential grep for cases we can't yet handle
            self.rehyper(hyper, hyper.Any::grep(&matcher, |%options))
        }
        else {
            hyper.bless:
                configuration => hyper.configuration,
                work-stage-head => GrepCode.new(:$source, :&matcher)
        }
    }

    my class Map does Rakudo::Internals::HyperProcessor {
        has &!mapper;

        submethod TWEAK(:&!mapper) {}

        method process-batch(Rakudo::Internals::HyperWorkBatch $batch) {
            my $result := IterationBuffer.new;
            my $items := $batch.items;
            my int $n = $items.elems;
            my &mapper := &!mapper.clone;
            loop (my int $i = 0; $i < $n; ++$i) {
                my \mapped = mapper(nqp::atpos($items, $i));
                nqp::istype(mapped, Slip) && !nqp::iscont(mapped)
                    ?? mapped.iterator.push-all($result)
                    !! $result.push(mapped)
            }
            $batch.replace-with($result);
        }
    }
    multi method map(\hyper, $source, &mapper, %options) {
        X::NYI.new(feature => 'Phasers in hyper/race').throw
          if nqp::istype(&mapper,Block) && &mapper.has-phasers;

        if %options || &mapper.count > 1 {
            # Fall back to sequential map for cases we can't yet handle
            self.rehyper(hyper, hyper.Any::map(&mapper, |%options))
        }
        else {
            hyper.bless:
                configuration => hyper.configuration,
                work-stage-head => Map.new(:$source, :&mapper)
        }
    }

    my class Sink does Rakudo::Internals::HyperJoiner {
        has Promise $.complete .= new;

        has int $!last-target = -1;
        has int $!batches-seen = 0;
        method consume-batch(Rakudo::Internals::HyperWorkBatch $batch --> Nil) {
            ++$!batches-seen;
            self.batch-used();
            if $batch.last {
                $!last-target = $batch.sequence-number;
            }
            if $!last-target >= 0 && $!batches-seen == $!last-target + 1 {
                $!complete.keep(True);
            }
        }

        method consume-error(Exception $e --> Nil) {
            $!complete.break($e);
        }
    }
    method sink(\hyper, $source --> Nil) {
        if hyper.DEFINITE {
            my $sink = Sink.new(:$source);
            Rakudo::Internals::HyperPipeline.start($sink, hyper.configuration);
            $*AWAITER.await($sink.complete);
            CATCH {
                unless nqp::istype($_, X::HyperRace::Died) {
                    ($_ but X::HyperRace::Died(Backtrace.new(5))).rethrow
                }
            }
        }
    }

    proto method rehyper($, $) {*}
    multi method rehyper(HyperSeq \hyper, \seq) {
        my \conf = hyper.configuration;
        seq.hyper(:degree(conf.degree), :batch(conf.batch))
    }
    multi method rehyper(RaceSeq \hyper, \seq) {
        my \conf = hyper.configuration;
        seq.race(:degree(conf.degree), :batch(conf.batch))
    }
}

#line 1 SETTING::src/core/HyperSeq.pm
# A HyperSeq performs batches of work in parallel, but retains order of output
# values relative to input values.
my class HyperSeq does Iterable does Sequence {
    has HyperConfiguration $.configuration;
    has Rakudo::Internals::HyperWorkStage $!work-stage-head;

    submethod BUILD(:$!configuration!, :$!work-stage-head!) {}

    method iterator(HyperSeq:D: --> Iterator) {
        my $joiner := Rakudo::Internals::HyperToIterator.new:
            source => $!work-stage-head;
        Rakudo::Internals::HyperPipeline.start($joiner, $!configuration);
        $joiner
    }

    method grep(HyperSeq:D: $matcher, *%options) {
        Rakudo::Internals::HyperRaceSharedImpl.grep:
            self, $!work-stage-head, $matcher, %options
    }

    method map(HyperSeq:D: $matcher, *%options) {
        Rakudo::Internals::HyperRaceSharedImpl.map:
            self, $!work-stage-head, $matcher, %options
    }

    method hyper(HyperSeq:D:) { self }

    method is-lazy() { False }

    method race(HyperSeq:D:) {
        RaceSeq.new(:$!configuration, :$!work-stage-head)
    }

    multi method serial(HyperSeq:D:) { self.Seq }

    method sink(--> Nil) {
        Rakudo::Internals::HyperRaceSharedImpl.sink(self, $!work-stage-head)
    }
}

#line 1 SETTING::src/core/RaceSeq.pm
# A RaceSeq performs batches of work in parallel, and will deliver the results
# in the order they are produced (so potentially disordering them relative to
# the input).
my class RaceSeq does Iterable does Sequence {
    has HyperConfiguration $.configuration;
    has Rakudo::Internals::HyperWorkStage $!work-stage-head;

    submethod BUILD(:$!configuration!, :$!work-stage-head!) {}

    method iterator(RaceSeq:D: --> Iterator) {
        my $joiner := Rakudo::Internals::RaceToIterator.new:
            source => $!work-stage-head;
        Rakudo::Internals::HyperPipeline.start($joiner, $!configuration);
        $joiner
    }

    method grep(RaceSeq:D: $matcher, *%options) {
        Rakudo::Internals::HyperRaceSharedImpl.grep:
            self, $!work-stage-head, $matcher, %options
    }

    method hyper(RaceSeq:D:) {
        HyperSeq.new(:$!configuration, :$!work-stage-head)
    }

    method is-lazy() { False }

    method map(RaceSeq:D: $matcher, *%options) {
        Rakudo::Internals::HyperRaceSharedImpl.map:
            self, $!work-stage-head, $matcher, %options
    }

    method race(RaceSeq:D:) { self }

    multi method serial(RaceSeq:D:) { self.Seq }

    method sink(--> Nil) {
        Rakudo::Internals::HyperRaceSharedImpl.sink(self, $!work-stage-head)
    }
}

#line 1 SETTING::src/core/Nil.pm
class X::Assignment::RO { ... }

my class Nil is Cool { # declared in BOOTSTRAP
    method new(*@ --> Nil)    { }
    multi method gist(Nil:)   { 'Nil' }
    method Numeric() { warn "Use of {self.gist} in numeric context"; 0 }
    method Str() { warn "Use of {self.gist} in string context"; '' }
    method sink(--> Nil) { }     # required by RESTRICTED setting

    method AT-POS(| --> Nil) { }
    method AT-KEY(| --> Nil) { }
#    method ACCEPTS(*@ --> Nil) { }  # XXX spec says Nil, but makes spectest hang

    method BIND-POS(|)   { die "Attempted to BIND-POS to {self.gist}." }
    method BIND-KEY(|)   { Failure.new(X::Bind.new(target => self.gist)) }
    method ASSIGN-POS(|) { die "Attempted to ASSIGN-POS to {self.gist}." }
    method ASSIGN-KEY(|) { die "Attempted to ASSIGN-KEY to {self.gist}." }
    method STORE(|)      { X::Assignment::RO.new(:value<Nil>).throw }
    method push(|)    is nodal { die "Attempted to push to {self.gist}." }
    method append(|)  is nodal { die "Attempted to append to {self.gist}." }
    method unshift(|) is nodal { die "Attempted to unshift to {self.gist}." }
    method prepend(|) is nodal { die "Attempted to prepend to {self.gist}." }
    method FALLBACK(| --> Nil) { }

    # These suggest using Nil.new if they fall through, which is LTA
    method ords() { self.Str.ords }
    method chrs() { self.Int.chrs }

    method chop()  { self.Str.chop }
    method chomp() { self.Str.chomp }

    method iterator() { self.list.iterator }

    # QuantHash coercions
    method Set()     { Set.new(Nil)     }
    method SetHash() { SetHash.new(Nil) }
    method Bag()     { Bag.new(Nil)     }
    method BagHash() { BagHash.new(Nil) }
    method Mix()     { Mix.new(Nil)     }
    method MixHash() { MixHash.new(Nil) }
}

#line 1 SETTING::src/core/Range.pm
my class X::Immutable { ... }
my class X::Range::InvalidArg { ... }

my class Range is Cool does Iterable does Positional {
    has $.min;
    has $.max;
    has int $!excludes-min;
    has int $!excludes-max;
    has int $!infinite;
    has int $!is-int;

    method !SET-SELF( $!min, $!max, \excludes-min, \excludes-max, \infinite) {
        $!excludes-min = excludes-min // 0;
        $!excludes-max = excludes-max // 0;
        $!infinite = infinite;
        $!is-int   = nqp::istype($!min,Int) && nqp::istype($!max,Int);
        self
    }
    multi method is-lazy(Range:D:) { self.infinite }

    # The order of "method new" declarations matters here, to ensure
    # appropriate candidate tiebreaking when mixed type arguments
    # are present (e.g., Range,Whatever or Real,Range).
    proto method new(|) {*}
    multi method new(Range $min, \max, :$excludes-min, :$excludes-max) {
        X::Range::InvalidArg.new(:got($min)).throw;
    }
    multi method new(\min, Range $max, :$excludes-min, :$excludes-max) {
        X::Range::InvalidArg.new(:got($max)).throw;
    }
    multi method new(Seq \min, \max, :$excludes-min, :$excludes-max) {
        X::Range::InvalidArg.new(:got(Seq)).throw;
    }
    multi method new(\min , Seq \max, :$excludes-min, :$excludes-max) {
        X::Range::InvalidArg.new(:got(Seq)).throw;
    }
    multi method new(Complex \min, \max, :$excludes-min, :$excludes-max) {
        X::Range::InvalidArg.new(:got(min)).throw;
    }
    multi method new(\min , Complex \max, :$excludes-min, :$excludes-max) {
        X::Range::InvalidArg.new(:got(max)).throw;
    }
    multi method new(Whatever \min,Whatever \max,:$excludes-min,:$excludes-max){
        nqp::create(self)!SET-SELF(-Inf,Inf,$excludes-min,$excludes-max,1);
    }
    multi method new(Whatever \min, \max, :$excludes-min, :$excludes-max) {
        nqp::create(self)!SET-SELF(-Inf,max,$excludes-min,$excludes-max,1);
    }
    multi method new(\min, Whatever \max, :$excludes-min, :$excludes-max) {
        nqp::create(self)!SET-SELF(min,Inf,$excludes-min,$excludes-max,1);
    }
    multi method new(Real \min, Real() $max, :$excludes-min, :$excludes-max) {
        nqp::create(self)!SET-SELF(
          min,$max,$excludes-min,$excludes-max,$max == Inf || min == -Inf);
    }
    multi method new(List:D \min, \max, :$excludes-min, :$excludes-max) {
        nqp::create(self)!SET-SELF(
          +min,
          nqp::istype(max,List) || nqp::istype(max,Match) ?? +max !! max,
          $excludes-min, $excludes-max, 0);
    }
    multi method new(Match:D \min, \max, :$excludes-min, :$excludes-max) {
        nqp::create(self)!SET-SELF(
          +min,
          nqp::istype(max,List) || nqp::istype(max,Match) ?? +max !! max,
          $excludes-min, $excludes-max, 0);
    }
    multi method new(\min, \max, :$excludes-min, :$excludes-max!) {
        nqp::create(self)!SET-SELF(min, max,$excludes-min,$excludes-max,0);
    }
    multi method new(\min, \max, :$excludes-min!, :$excludes-max) {
        nqp::create(self)!SET-SELF(min,max,$excludes-min,$excludes-max,0);
    }
    multi method new(\min, \max) { nqp::create(self)!SET-SELF(min,max,0,0,0) }

    method excludes-min() { nqp::p6bool($!excludes-min) }
    method excludes-max() { nqp::p6bool($!excludes-max) }
    method infinite()     { nqp::p6bool($!infinite)     }
    method is-int()       { nqp::p6bool($!is-int)       }

    multi method WHICH (Range:D:) {
        (nqp::istype(self.WHAT,Range) ?? 'Range|' !! (self.^name ~ '|'))
          ~ $!min
          ~ ("^" if $!excludes-min)
          ~ '..'
          ~ ("^" if $!excludes-max)
          ~ $!max;
    }
    multi method EXISTS-POS(Range:D: int \pos) {
        0 <= pos < self.elems;
    }

    multi method EXISTS-POS(Range:D: Int \pos) {
        0 <= pos < self.elems;
    }

    method elems {
        $!is-int
          ?? 0 max $!max - $!excludes-max - $!min - $!excludes-min + 1
          !! $!infinite
            ?? Failure.new(X::Cannot::Lazy.new(:action<.elems>))
            !! nextsame
    }

    method iterator() {
        # can use native ints
        if $!is-int
          && !nqp::isbig_I(nqp::decont($!min))
          && !nqp::isbig_I(nqp::decont($!max)) {
            Rakudo::Iterator.IntRange(
              $!min + $!excludes-min, $!max - $!excludes-max)
        }

        # doesn't make much sense, but there you go
        elsif $!min === -Inf {
            class :: does Iterator {
                method new()      { nqp::create(self) }
                method pull-one() { -Inf }
                method is-lazy()  { True  }
            }.new
        }

        # Also something quick and easy for 1..* style things
        elsif nqp::istype($!min, Numeric) && $!max === Inf {
            class :: does Iterator {
                has $!i;

                method !SET-SELF(\i)  { $!i = i - 1; self }
                method new(\i)    { nqp::create(self)!SET-SELF(i) }
                method pull-one() { ++$!i }
                method is-lazy()  { True  }
            }.new($!min + $!excludes-min)
        }

        # if we have (simple) char range
        elsif nqp::istype($!min,Str) {
            $!min after $!max
              ?? ().iterator
              !! $!min.chars == 1 && nqp::istype($!max,Str) && $!max.chars == 1
                ?? class :: does Iterator {
                       has int $!i;
                       has int $!n;

                       method !SET-SELF(\from,\end,\excludes-min,\excludes-max) {
                           $!i = nqp::ord(nqp::unbox_s(from))
                               - (excludes-min ?? 0 !! 1);
                           $!n = nqp::ord(nqp::unbox_s(end))
                               - (excludes-max ?? 1 !! 0);
                           self
                       }
                       method new(\from,\end,\excludes-min,\excludes-max) {
                           nqp::create(self)!SET-SELF(
                              from,end,excludes-min,excludes-max)
                       }
                       method pull-one() {
                           ( $!i = $!i + 1 ) <= $!n
                             ?? nqp::chr($!i)
                             !! IterationEnd
                       }
                       method push-all($target --> IterationEnd) {
                           my int $i = $!i;
                           my int $n = $!n;
                           $target.push(nqp::chr($i)) while ($i = $i + 1) <= $n;
                           $!i = $i;
                       }
                       method count-only() { nqp::p6box_i($!n - $!i) }
                       method bool-only() { nqp::p6bool(nqp::isgt_i($!n,$!i)) }
                       method sink-all(--> IterationEnd) { $!i = $!n }
                   }.new($!min, $!max, $!excludes-min, $!excludes-max)
                !! SEQUENCE(
                       ($!excludes-min ?? $!min.succ !! $!min),
                       $!max, :exclude_end($!excludes-max)
                   ).iterator
        }

        # General case according to spec
        else {
            class :: does Iterator {
                has $!i;
                has $!e;
                has int $!exclude;

                method !SET-SELF(\i,\exclude,\e) {
                    $!i       = i;
                    $!exclude = exclude.Int;
                    $!e       = e;
                    self
                }
                method new(\i,\exclude,\e) {
                    nqp::create(self)!SET-SELF(i,exclude,e)
                }

                method pull-one() {
                    if $!exclude ?? $!i before $!e !! not $!i after $!e {
                        my Mu $i = $!i;
                        $!i = $i.succ;
                        $i
                    }
                    else {
                        IterationEnd
                    }
                }
                method push-all($target --> IterationEnd) {
                    my Mu $i = $!i;
                    my Mu $e = $!e;
                    if $!exclude {
                        while $i before $e {
                            $target.push(nqp::clone($i));
                            $i = $i.succ;
                        }
                    }
                    else {
                        while not $i after $e {
                            $target.push(nqp::clone($i));
                            $i = $i.succ;
                        }
                    }
                    $!i = $e.succ;
                }
                method sink-all(--> IterationEnd) { $!i = $!e.succ }
            }.new($!excludes-min ?? $!min.succ !! $!min,$!excludes-max,$!max)
        }
    }
    multi method list(Range:D:) { List.from-iterator(self.iterator) }
    method flat(Range:D:) { Seq.new(self.iterator) }

    method !reverse-iterator() {
        # can use native ints
        if $!is-int
          && !nqp::isbig_I(nqp::decont($!min))
          && !nqp::isbig_I(nqp::decont($!max)) {
            class :: does Iterator {
                has int $!i;
                has int $!n;

                method !SET-SELF(\i,\n) { $!i = i + 1; $!n = n; self }
                method new(\i,\n)   { nqp::create(self)!SET-SELF(i,n) }

                method pull-one() {
                    ( $!i = $!i - 1 ) >= $!n ?? $!i !! IterationEnd
                }
                method push-all($target --> IterationEnd) {
                    my int $i = $!i;
                    my int $n = $!n;
                    $target.push(nqp::p6box_i($i)) while ($i = $i - 1) >= $n;
                    $!i = $i;
                }
                method count-only() { nqp::p6box_i($!i - $!n) }
                method bool-only() { nqp::p6bool(nqp::isgt_i($!i,$!n)) }
                method sink-all(--> IterationEnd)   { $!i = $!n }
            }.new($!max - $!excludes-max, $!min + $!excludes-min)
        }

        # doesn't make much sense, but there you go
        elsif $!max === -Inf {
            class :: does Iterator {
                method new()      { nqp::create(self) }
                method pull-one(--> Inf) { }
                method is-lazy(--> True) { }
            }.new
        }

        # Also something quick and easy for -Inf..42 style things
        elsif nqp::istype($!min, Numeric) && $!min === -Inf {
            class :: does Iterator {
                has $!i;

                method !SET-SELF(\i)  { $!i = i; self }
                method new(\i)    { nqp::create(self)!SET-SELF(i) }
                method pull-one() { $!i-- }
                method is-lazy()  { True  }
            }.new($!max - $!excludes-max)
        }

        # if we have (simple) char range
        elsif nqp::istype($!min,Str) {
            my $max = $!excludes-max ?? $!max.pred !! $!max;
            $max before $!min
              ?? ().iterator
              !! $max.chars == 1 && nqp::istype($!min,Str) && $!min.chars == 1
                ?? class :: does Iterator {
                       has int $!i;
                       has int $!n;

                       method !SET-SELF(\from,\end) {
                           $!i = nqp::ord(nqp::unbox_s(from)) + 1;
                           $!n = nqp::ord(nqp::unbox_s(end));
                           self
                       }
                       method new(\from,\end) {
                           nqp::create(self)!SET-SELF(from,end)
                       }
                       method pull-one() {
                           ( $!i = $!i - 1 ) >= $!n
                             ?? nqp::chr($!i)
                             !! IterationEnd
                       }
                       method push-all($target --> IterationEnd) {
                           my int $i = $!i;
                           my int $n = $!n;
                           $target.push(nqp::chr($i)) while ($i = $i - 1) >= $n;
                           $!i = $i;
                       }
                       method count-only() { nqp::p6box_i($!i - $!n) }
                       method bool-only() { nqp::p6bool(nqp::isgt_i($!i,$!n)) }
                       method sink-all(--> IterationEnd) { $!i = $!n }
                   }.new($max, $!excludes-min ?? $!min.succ !! $!min)
                !! SEQUENCE($max,$!min,:exclude_end($!excludes-min)).iterator
        }

        # General case according to spec
        else {
            class :: does Iterator {
                has $!i;
                has $!e;
                has int $!exclude;

                method !SET-SELF(\i,\exclude,\e) {
                    $!i       = i;
                    $!exclude = exclude.Int;
                    $!e       = e;
                    self
                }
                method new(\i,\exclude,\e) {
                    nqp::create(self)!SET-SELF(i,exclude,e)
                }

                method pull-one() {
                    if $!exclude ?? $!i after $!e !! not $!i before $!e {
                        my Mu $i = $!i;
                        $!i = $i.pred;
                        $i
                    }
                    else {
                        IterationEnd
                    }
                }
                method push-all($target --> IterationEnd) {
                    my Mu $i = $!i;
                    my Mu $e = $!e;
                    if $!exclude {
                        while $i after $e {
                            $target.push(nqp::clone($i));
                            $i = $i.pred;
                        }
                    }
                    else {
                        while not $i before $e {
                            $target.push(nqp::clone($i));
                            $i = $i.pred;
                        }
                    }
                }
                method sink-all(--> IterationEnd) { $!i = $!e }
            }.new($!excludes-max ?? $!max.pred !! $!max,$!excludes-min,$!min)
        }
    }
    method reverse(Range:D:) { Seq.new(self!reverse-iterator) }
    method first (|c) {
        if c<end> {
            my \res := self.reverse.first(|c, :!end);
            if c<k> and nqp::istype(res, Numeric) {
                self.elems - res - 1
            }
            elsif c<p> and nqp::istype(res, Pair) {
                Pair.new(self.elems - res.key - 1, res.value)
            }
            else {
                res
            }
        }
        else { nextsame };
    }

    method bounds() { (nqp::decont($!min), nqp::decont($!max)) }
    proto method int-bounds(|) { * }
    multi method int-bounds($from is rw, $to is rw) {
        nqp::if(
          $!is-int,
          nqp::stmts(
            ($from = $!min + $!excludes-min),
            ($to   = $!max - $!excludes-max)
          ),
          nqp::if(
            nqp::istype($!min,Real)
              && $!min.floor == $!min
              && nqp::istype($!max,Real)
              && nqp::istype($!min.Int, Int)  # exclude NaN and Infs, who will fail() here
              && nqp::istype($!max.Int, Int),
            nqp::stmts(
              ($from = $!min.floor + $!excludes-min),
              ($to   = $!max.floor - ($!excludes-max && $!max.Int == $!max))
            ),
            (die "Cannot determine integer bounds")
          )
        )
    }
    multi method int-bounds() {
        $!is-int
          ?? ($!min + $!excludes-min, $!max - $!excludes-max)
          !! nqp::istype($!min,Real) && $!min.floor == $!min && nqp::istype($!max,Real)
                && nqp::istype($!min.Int, Int) # exclude NaN and Infs, who will fail() here
                && nqp::istype($!max.Int, Int)
            ?? ($!min.floor + $!excludes-min, $!max.floor - ($!excludes-max && $!max.Int == $!max))
            !! Failure.new("Cannot determine integer bounds")
    }

    method fmt(|c) {
        self.list.fmt(|c)
    }

    multi method Str(Range:D:) {
        $!min === -Inf && $!max === Inf
          ?? "*{'^' if $!excludes-min}..{'^' if $!excludes-max}*"
          !! $!min === -Inf
            ?? "*{'^' if $!excludes-min}..{'^' if $!excludes-max}$!max"
            !! $!max === Inf
              ?? "{$!min}{'^' if $!excludes-min}..{'^' if $!excludes-max}*"
              !! self.list.Str
    }

    multi method ACCEPTS(Range:D: Mu \topic) {
        (topic cmp $!min) > -(!$!excludes-min)
          and (topic cmp $!max) < +(!$!excludes-max)
    }
    multi method ACCEPTS(Range:D: Cool:D \got) {
        $!is-int && nqp::istype(got,Int)
          ?? got >= $!min + $!excludes-min && got <= $!max - $!excludes-max
          !! ($!excludes-min ?? got after $!min !! not got before $!min)
               && ($!excludes-max ?? got before $!max !! not got after $!max)
    }
    multi method ACCEPTS(Range:D: Complex:D \got) {
        nqp::istype(($_ := got.Real), Failure) ?? False !! nextwith $_
    }
    multi method ACCEPTS(Range:D: Range \topic) {
        nqp::istype($!min, Numeric)
            ?? # RHS is a numeric range, use numeric comparators
                try {
                    (topic.min > $!min
                     || topic.min == $!min
                        && !(!topic.excludes-min && $!excludes-min))
                    &&
                    (topic.max < $!max
                     || topic.max == $!max
                        && !(!topic.excludes-max && $!excludes-max))
                } // False # don't explode on failures to coerce to numerics
            !! # RHS is a stringy range, use stringy comparators
                (topic.min gt $!min
                 || topic.min eq $!min
                    && !(!topic.excludes-min && $!excludes-min))
                &&
                (topic.max lt $!max
                 || topic.max eq $!max
                    && !(!topic.excludes-max && $!excludes-max))
    }

    multi method AT-POS(Range:D: int \pos) {
        $!is-int
            ?? self.EXISTS-POS(pos)
                ?? $!min + $!excludes-min + pos
                !! pos < 0
                    ?? Failure.new(X::OutOfRange.new(
                        :what($*INDEX // 'Index'), :got(pos), :range<0..^Inf>
                    )) !! Nil
            !! self.list.AT-POS(pos);
    }
    multi method AT-POS(Range:D: Int:D \pos) {
        $!is-int
            ?? self.EXISTS-POS(pos)
                ?? $!min + $!excludes-min + pos
                !! pos < 0
                    ?? Failure.new(X::OutOfRange.new(
                        :what($*INDEX // 'Index'), :got(pos), :range<0..^Inf>
                    )) !! Nil
            !! self.list.AT-POS(nqp::unbox_i(pos));
    }

    multi method perl(Range:D:) {
        $!is-int && $!min == 0 && !$!excludes-min && $!excludes-max
            ?? "^$!max"
            !! "{$!min.perl}{'^' if $!excludes-min}..{'^' if $!excludes-max}$!max.perl()"
    }

    proto method roll(|) { * }
    multi method roll(Range:D: Whatever) {
        if self.elems -> $elems {
            $!is-int
              ?? Seq.new(class :: does Iterator {
                    has int $!min;
                    has Int $!elems;
                    method !SET-SELF(\min,\elems) {
                        $!min    = min;
                        $!elems := nqp::decont(elems);
                        self
                    }
                    method new(\b,\e) { nqp::create(self)!SET-SELF(b,e) }
                    method pull-one() { $!min + nqp::rand_I($!elems, Int) }
                    method is-lazy(--> True) { }
                }.new($!min + $!excludes-min, $elems))
              !! self.list.roll(*)
        }
        else {
            Nil xx *
        }
    }
    multi method roll(Range:D:) {
        if $!is-int {
            my $elems = $!max - $!excludes-max - $!min - $!excludes-min + 1;
            $elems > 0
              ?? $!min + $!excludes-min + nqp::rand_I(nqp::decont($elems),Int)
              !! Nil
        }
        else {
            self.list.roll
        }
    }
    multi method roll(Int(Cool) $todo) {
        if self.elems -> $elems {
            $!is-int
              ?? Seq.new(class :: does Iterator {
                    has int $!min;
                    has Int $!elems;
                    has int $!todo;
                    method !SET-SELF(\min,\elems,\todo) {
                        $!min    = min;
                        $!elems := nqp::decont(elems);
                        $!todo   = todo;
                        self
                    }
                    method new(\m,\e,\t) { nqp::create(self)!SET-SELF(m,e,t) }
                    method pull-one() {
                        $!todo--
                          ?? $!min + nqp::rand_I($!elems, Int)
                          !! IterationEnd
                    }
                    method push-all($target --> IterationEnd) {
                        $target.push($!min + nqp::rand_I($!elems, Int))
                          while $!todo--;
                    }
                }.new($!min + $!excludes-min,$elems,0 max $todo))
              !! self.list.roll($todo)
        }
        else {
            Nil xx $todo
        }
    }

    proto method pick(|)        { * }
    multi method pick()          { self.roll };
    multi method pick(Whatever)  { self.list.pick(*) };
    multi method pick(Int(Cool) $todo) {
        if self.elems -> $elems {
            $!is-int && $elems > 3 * $todo # heuristic for sparse lookup
              ?? Seq.new(class :: does Iterator {
                    has int $!min;
                    has Int $!elems;
                    has int $!todo;
                    has $!seen;
                    method !SET-SELF(\min,\elems,\todo) {
                        $!min    = min;
                        $!elems := nqp::decont(elems);
                        $!todo   = todo;
                        $!seen  := nqp::hash();
                        self
                    }
                    method new(\m,\e,\t) { nqp::create(self)!SET-SELF(m,e,t) }
                    method pull-one() {
                        my Int $value;
                        my str $key;
                        if $!todo {
                            repeat {
                                $value = $!min + nqp::rand_I($!elems, Int);
                                $key   = nqp::tostr_I(nqp::decont($value));
                            } while nqp::existskey($!seen,$key);
                            $!todo = $!todo - 1;
                            nqp::bindkey($!seen,$key,1);
                            $value
                        }
                        else {
                            IterationEnd
                        }
                    }
                    method push-all($target --> IterationEnd) {
                        my str $key;
                        while $!todo {
                            my Int $value = $!min + nqp::rand_I($!elems, Int);
                            $key   = nqp::tostr_I(nqp::decont($value));
                            unless nqp::existskey($!seen,$key) {
                                $target.push($value);
                                $!todo = $!todo - 1;
                                nqp::bindkey($!seen,$key,1);
                            }
                        }
                    }
                }.new($!min + $!excludes-min,$elems,0 max $todo))
              !! self.list.pick($todo)
        }
        else {
            Nil xx $todo
        }
    }

    method Capture(Range:D:) {
        \( :$!min, :$!max,
           excludes-min => self.excludes-min,
           excludes-max => self.excludes-max,
           infinite     => self.infinite,
           is-int       => self.is-int)
    }

    multi method Numeric(Range:D:) {
        $!is-int
          ?? self.elems
          !! nqp::istype($!min,Numeric) && nqp::istype($!max,Numeric)
            ?? do {
                my $diff  = 0 max $!max - $!min - $!excludes-min;
                my $floor = $diff.floor;
                $floor + 1 - ($floor == $diff ?? $!excludes-max !! 0)
            }
            !! self.flat.elems
    }

    method clone-with-op(&op, $value) {
        my $min    = $!min [&op] $value;
        my $max    = $!max [&op] $value;
        my $is-int = nqp::istype($min,Int) && nqp::istype($max,Int);
        my $clone := self.clone( :$min, :$max );
        nqp::bindattr_i($clone, $clone.WHAT, '$!is-int', $is-int);
        $clone;
    }

    method push(|) is nodal {
        X::Immutable.new(:typename<Range>,:method<push>).throw
    }
    method append(|) is nodal {
        X::Immutable.new(:typename<Range>,:method<append>).throw
    }
    method unshift(|) is nodal {
        X::Immutable.new(:typename<Range>,:method<unshift>).throw
    }
    method prepend(|) is nodal {
        X::Immutable.new(:typename<Range>,:method<prepend>).throw
    }
    method shift(|) is nodal {
        X::Immutable.new(:typename<Range>,:method<shift>).throw
    }
    method pop(|) is nodal {
        X::Immutable.new(:typename<Range>, :method<pop>).throw
    }

    method sum() is nodal {
        my ($start,$stop) = self.int-bounds || nextsame;
        my $elems = 0 max $stop - $start + 1;
        ($start + $stop) * $elems div 2;
    }

    method rand() {
        fail "Can only get a random value on Real values, did you mean .pick?"
          unless nqp::istype($!min,Real) && nqp::istype($!max,Real);
        fail "Can only get a random value from numeric values"
          if $!min === NaN || $!max === NaN;
        fail "Can not get a random value from an infinite range"
          if $!min === -Inf || $!max === Inf;

        my $range = $!max - $!min;
        fail "Can only get a random value if the range is positive"
          unless $range > 0;


        my $value = 0;
        if $!excludes-min || $!excludes-max {
            if $!excludes-min {
                if $!excludes-max {
                    $value = $range.rand
                        while $value+$!min == $!min || $value+$!min == $!max;
                }
                else {
                    $value = $range.rand while $value+$!min == $!min;
                }
            }
            else {  # $!excludes-max
                repeat {
                    $value = $range.rand
                } while $value+$!min == $!max;
            }
        }
        else {
            $value = $range.rand
        }
        $value + $!min;
    }

    method in-range($got, $what?) {
        self.ACCEPTS($got)
          || X::OutOfRange.new(:what($what // 'Value'),:got($got.perl),:range(self)).throw
    }

    multi method minmax(Range:D:) {
        $!is-int
          ?? self.int-bounds
          !! $!excludes-min || $!excludes-max
            ?? Failure.new("Cannot return minmax on Range with excluded ends")
            !! ($!min,$!max)
    }
}

sub infix:<..>($min, $max) is pure {
    Range.new($min, $max)
}
sub infix:<^..>($min, $max) is pure {
    Range.new($min, $max, :excludes-min)
}
sub infix:<..^>($min, $max) is pure {
    Range.new($min, $max, :excludes-max)
}
sub infix:<^..^>($min, $max) is pure {
    Range.new($min, $max, :excludes-min, :excludes-max)
}
sub prefix:<^>($max) is pure {
    Range.new(0, $max.Numeric, :excludes-max)
}

multi sub infix:<eqv>(Range:D \a, Range:D \b) {
    nqp::p6bool(
      nqp::eqaddr(a,b)
        || (nqp::eqaddr(a.WHAT,b.WHAT)
             && a.min eqv b.min
             && a.max eqv b.max
             && nqp::iseq_i(
               nqp::getattr_i(nqp::decont(a),Range,'$!excludes-min'),
               nqp::getattr_i(nqp::decont(b),Range,'$!excludes-min')
             )
             && nqp::iseq_i(
               nqp::getattr_i(nqp::decont(a),Range,'$!excludes-max'),
               nqp::getattr_i(nqp::decont(b),Range,'$!excludes-max')
             ))
    )
}

multi sub infix:<+>(Range:D \a, Real:D \b) { a.clone-with-op(&[+], b) }
multi sub infix:<+>(Real:D \a, Range:D \b) { b.clone-with-op(&[+], a) }
multi sub infix:<->(Range:D \a, Real:D \b) { a.clone-with-op(&[-], b) }
multi sub infix:<*>(Range:D \a, Real:D \b) { a.clone-with-op(&[*], b) }
multi sub infix:<*>(Real:D \a, Range:D \b) { b.clone-with-op(&[*], a) }
multi sub infix:</>(Range:D \a, Real:D \b) { a.clone-with-op(&[/], b) }

multi sub infix:<cmp>(Range:D \a, Range:D \b --> Order:D) {
    a.min cmp b.min || a.excludes-min cmp b.excludes-min || a.max cmp b.max || b.excludes-max cmp a.excludes-max
}
multi sub infix:<cmp>(Num(Real) \a, Range:D \b --> Order:D) { (a..a) cmp b }
multi sub infix:<cmp>(Range:D \a, Num(Real) \b --> Order:D) { a cmp (b..b) }

multi sub infix:<cmp>(Positional \a, Range:D \b --> Order:D) { a cmp b.list }
multi sub infix:<cmp>(Range:D \a, Positional \b --> Order:D) { a.list cmp b }

#line 1 SETTING::src/core/List.pm
# A List is a (potentially infinite) immutable list. The immutability is not
# deep; a List may contain Scalar containers that can be assigned to. However,
# it is not possible to shift/unshift/push/pop/splice/bind. A List is also
# Positional, and so may be indexed.
my class List does Iterable does Positional { # declared in BOOTSTRAP
    # class List is Cool
    #   The reified elements in the list so far (that is, those that we already
    #   have produced the values for).
    #   has $!reified;
    #
    #   Object that reifies the rest of the list. We don't just inline it into
    #   the List class itself, because a STORE on Array can clear things and
    #   upset an ongoing iteration. (An easy way to create such a case is to
    #   assign an array with lazy parts into itself.)
    #   has $!todo;

    # The object that goes into $!todo.
    class Reifier {
        # Our copy of the reified elements in the list so far.
        has $!reified;

        # The current iterator, if any, that we're working our way through in
        # order to lazily reify values. Must be depleted before $!future is
        # considered.
        has Iterator $!current-iter;

        # The (possibly lazy) values we've not yet incorporated into the list. The
        # only thing we can't simply copy from $!future into $!reified is a Slip
        # (and so the only reason to have a $!future is that there is at least one
        # Slip).
        has $!future;

        # The reification target (what .reify-* will .push to). Exists so we can
        # share the reification code between List/Array. List just uses its own
        # $!reified buffer; the Array one shoves stuff into Scalar containers
        # first.
        has $!reification-target;

        method reify-at-least(int $elems) {
            nqp::stmts(
              nqp::if(
                ($!current-iter.DEFINITE
                  && nqp::eqaddr(
                       $!current-iter.push-at-least(
                         $!reification-target,
                         nqp::sub_i($elems,nqp::elems($!reified))
                       ),
                       IterationEnd
                     )),
                $!current-iter := Iterator
              ),

              # there is a future
              nqp::if(
                $!future.DEFINITE,

                # still need and can get something from the future
                nqp::stmts(
                  nqp::while(
                    (nqp::islt_i(nqp::elems($!reified),$elems)
                      && nqp::elems($!future)),
                    nqp::if(
                      (nqp::istype((my $current := nqp::shift($!future)),Slip)
                        && nqp::isconcrete($current)),
                      nqp::stmts(
                        (my $iter := $current.iterator),
                        nqp::unless(
                          nqp::eqaddr(
                            $iter.push-at-least(
                              $!reification-target,
                              nqp::sub_i($elems,nqp::elems($!reified))
                            ),
                            IterationEnd
                          ),
                          # The iterator produced enough values to fill the need,
                          # but did not reach its end. We save it for next time.
                          # We know we'll exit the loop, since the < $elems check
                          # must be False (unless the iterator broke contract).
                          ($!current-iter := $iter)
                        )
                      ),
                      $!reification-target.push($current)
                    )
                  ),

                  # that was the future
                  nqp::unless(
                    nqp::elems($!future),
                    ($!future := Mu)
                  )
                )
              ),

              nqp::elems($!reified)
            )
        }

        method reify-until-lazy() {
            nqp::stmts(
              nqp::if(
                ($!current-iter.DEFINITE
                  && nqp::eqaddr(
                       $!current-iter.push-until-lazy($!reification-target),
                       IterationEnd
                     )
                ),
                $!current-iter := Iterator
              ),

              nqp::if(
                ($!future.DEFINITE && nqp::not_i($!current-iter.DEFINITE)),
                nqp::stmts(
                  nqp::while(
                    nqp::elems($!future),
                    nqp::if(
                      (nqp::istype((my $current := nqp::shift($!future)),Slip)
                        && nqp::isconcrete($current)),
                      nqp::unless(
                        nqp::eqaddr(
                          (my $iter := $current.iterator).push-until-lazy(
                            $!reification-target),
                          IterationEnd
                        ),
                        nqp::stmts(
                          ($!current-iter := $iter),
                          last
                        )
                      ),
                      $!reification-target.push($current)
                    )
                  ),
                  nqp::unless(
                    nqp::elems($!future),
                    $!future := Mu
                  )
                )
              ),
              nqp::elems($!reified)
            )
        }

        method reify-all() {
            nqp::stmts(
              nqp::if(
                $!current-iter.DEFINITE,
                nqp::stmts(
                  $!current-iter.push-all($!reification-target),
                  $!current-iter := Iterator
                )
              ),
              nqp::if(
                $!future.DEFINITE,
                nqp::stmts(
                  nqp::while(
                    nqp::elems($!future),
                    nqp::if(
                      (nqp::istype((my $current := nqp::shift($!future)),Slip)
                        && nqp::isconcrete($current)),
                      $current.iterator.push-all($!reification-target),
                      $!reification-target.push($current)
                    )
                  ),
                  ($!future := Mu)
                )
              ),
              nqp::elems($!reified)
            )
        }

        method fully-reified() {
            !($!current-iter.DEFINITE || $!future.DEFINITE)
        }

        method is-lazy() {
            nqp::if(
              $!current-iter.DEFINITE,
              $!current-iter.is-lazy
            )
        }
    }

    method from-iterator(List:U: Iterator $iter) {
        nqp::stmts(
          (my \buffer := nqp::create(IterationBuffer)),
          nqp::bindattr(
            (my \result := nqp::create(self)),List,'$!reified',buffer),
          nqp::bindattr(
            (my \todo := nqp::create(Reifier)),Reifier,'$!reified',buffer),
          nqp::bindattr(todo,Reifier,'$!current-iter',$iter),
          # since Array has its own from-iterator, we don't need to
          # call reification-target, because it is the same as buffer
          nqp::bindattr(todo,Reifier,'$!reification-target',buffer),
          nqp::p6bindattrinvres(result,List,'$!todo',todo)
        )
    }

    method from-slurpy(|) {
        my \result      := nqp::create(self);
        my Mu \vm-tuple := nqp::captureposarg(nqp::usecapture,1);

        nqp::if(
          nqp::isgt_i(nqp::elems(vm-tuple),0),
          nqp::stmts(
            nqp::bindattr(result,List,'$!reified',
              my \buffer := nqp::create(IterationBuffer)),
            nqp::bindattr(result,List,'$!todo',
              my \todo   := nqp::create(List::Reifier)),
            nqp::bindattr(todo,List::Reifier,'$!reified',
              buffer),
            nqp::bindattr(todo,List::Reifier,'$!reification-target',
              result.reification-target),
            nqp::bindattr(todo,List::Reifier,'$!future',vm-tuple)
          )
        );

        result
    }

    method from-slurpy-onearg(|) {
        my Mu \vm-tuple := nqp::captureposarg(nqp::usecapture, 1);
        my $result;
        my $buffer;
        my $todo;
        my $consider;

        nqp::if(
          nqp::isgt_i(nqp::elems(vm-tuple),1),
          nqp::stmts(  # handle as slurpy
            nqp::bindattr(($result := nqp::create(self)),List,'$!reified',
              $buffer := nqp::create(IterationBuffer)),
            nqp::bindattr($result,List,'$!todo',
              $todo   := nqp::create(List::Reifier)),
            nqp::bindattr($todo,List::Reifier,'$!reified',
              $buffer),
            nqp::bindattr($todo,List::Reifier,'$!reification-target',
              $result.reification-target),
            nqp::bindattr($todo,List::Reifier,'$!future',vm-tuple),
            $result
          ),
          nqp::if(
            nqp::iseq_i(nqp::elems(vm-tuple),1),
            nqp::if(  # single arg semantics active
              nqp::istype(($consider := nqp::atpos(vm-tuple,0)),Seq),
              nqp::if(  # a single Seq
                nqp::istype(self,Array),
                $consider.cache,
                $consider
              ),
              nqp::stmts( # something else
                nqp::bindattr(($result := nqp::create(self)),List,'$!reified',
                  $buffer := nqp::create(IterationBuffer)),
                nqp::bindattr($result,List,'$!todo',
                  $todo   := nqp::create(List::Reifier)),
                nqp::bindattr($todo,List::Reifier,'$!reified',
                  $buffer),
                nqp::bindattr($todo,List::Reifier,'$!reification-target',
                  $result.reification-target),
                nqp::if(
                  nqp::iscont($consider)
                    || nqp::not_i(nqp::istype($consider,Iterable))
                    || nqp::not_i(nqp::p6definite($consider)),
                  nqp::bindattr($todo,List::Reifier,'$!future',
                    vm-tuple),
                  nqp::bindattr($todo,List::Reifier,'$!future',
                    nqp::list($consider.list.Slip))
                ),
                $result
              )
            ),
            nqp::create(self)  # no args, so just a bare object
          )
        )
    }

    method from-slurpy-flat(|) {

        nqp::if(
          (my int $elems = nqp::elems(
            (my Mu $vm-tuple := nqp::captureposarg(nqp::usecapture,1))
          )),
          nqp::stmts(
            (my $future := nqp::setelems(nqp::create(IterationBuffer),$elems)),
            (my int $i   = -1),
            (my int $b   = 0),
            nqp::while(
              nqp::islt_i($i = nqp::add_i($i,1),$elems),
              nqp::if(
                nqp::iscont(my $consider := nqp::atpos($vm-tuple,$i)),
                nqp::bindpos($future,$i,$consider),
                nqp::if(
                  (nqp::istype($consider,Iterable) && $consider.DEFINITE),
                  nqp::if(
                    nqp::istype($consider,PositionalBindFailover),
                    nqp::bindpos($future,$i,$consider.cache.flat.Slip),
                    nqp::bindpos($future,$i,$consider.flat.Slip)
                  ),
                  nqp::stmts(
                    nqp::bindpos($future,$i,$consider),
                    ($b = nqp::add_i($b,1))
                  )
                )
              )
            ),
            nqp::if(
              nqp::iseq_i($b,$elems),

              # we already reified everything
              nqp::p6bindattrinvres(nqp::create(self),List,'$!reified',$future),

              # need full fledged List with a $todo
              nqp::stmts(
                (my $result :=
                  nqp::p6bindattrinvres(nqp::create(self),List,'$!reified',
                    (my $buffer := nqp::create(IterationBuffer))
                  )
                ),
                (my $todo := nqp::create(List::Reifier)),
                nqp::bindattr($todo,List::Reifier,'$!reified',
                  $buffer
                ),
                nqp::bindattr($todo,List::Reifier,'$!reification-target',
                  $result.reification-target
                ),
                nqp::bindattr($todo,List::Reifier,'$!future',
                  $future
                ),
                $todo.reify-until-lazy,
                nqp::unless(
                  $todo.fully-reified,
                  nqp::bindattr($result,List,'$!todo', $todo),
                ),
                $result
              )
            )
          ),

          # no args, an empty list suffices
          nqp::create(self)
        )
    }

    method new(**@things) {
        my \list = nqp::create(self);
        my \iterbuffer = nqp::create(IterationBuffer);
        nqp::bindattr(list, List, '$!reified', iterbuffer);

        my int $elems = +@things;  # reify
        my int $i     = -1;
        my $reified  := nqp::getattr(@things,List,'$!reified');

        nqp::while(  # doesn't sink
          nqp::islt_i($i = nqp::add_i($i,1),$elems),
          nqp::bindpos(iterbuffer,$i,(nqp::atpos($reified,$i)))
        );
        list
    }

    multi method Bool(List:D:) {
        nqp::p6bool(
          nqp::unless(
            ($!reified.DEFINITE && nqp::elems($!reified)),
            ($!todo.DEFINITE && $!todo.reify-at-least(1))
          )
        )
    }
    multi method Int(List:D:)     { self.elems }
    multi method end(List:D:)     { self.elems - 1 }
    multi method Numeric(List:D:) { self.elems }
    multi method Str(List:D:)     { self.join(' ') }

    # Pretend we're a Match assuming we're a list of Matches
    method to()      { self.elems ?? self[self.end].to !! Nil }
    method from()    { self.elems ?? self[0].from !! Nil }

    method sum() is nodal {
        nqp::if(
          self.is-lazy,
          Failure.new(X::Cannot::Lazy.new(:action('.sum'))),
          nqp::if(
            $!reified.DEFINITE && (my int $elems = self.elems),      # reifies
            nqp::stmts(
              (my $list := $!reified),
              (my $sum = nqp::ifnull(nqp::atpos($list,0),0)),
              (my int $i),
              nqp::while(
                nqp::islt_i($i = nqp::add_i($i,1),$elems),
                ($sum = $sum + nqp::ifnull(nqp::atpos($list,$i),0))
              ),
              $sum
            ),
            0
          )
        )
    }

    proto method fmt(|) { * }
    multi method fmt() {
        nqp::if(
          (my int $elems = self.elems),             # reifies
          nqp::stmts(
            (my $list    := $!reified),
            (my $strings := nqp::setelems(nqp::list_s,$elems)),
            (my int $i = -1),
            nqp::while(
              nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
              nqp::bindpos_s($strings,$i,nqp::atpos($list,$i).Str)
            ),
            nqp::p6box_s(nqp::join(' ',$strings))
          ),
          ''
        )
    }
    multi method fmt(Str(Cool) $format) {
        nqp::if(
          nqp::iseq_s($format,'%s'),
          self.fmt,
          self.fmt($format,' ')
        )
    }
    multi method fmt(Str(Cool) $format, $separator) {
        nqp::if(
          nqp::iseq_s($format,'%s') && nqp::iseq_s($separator,' '),
          self.fmt,
          nqp::if(
            (my int $elems = self.elems),             # reifies
            nqp::stmts(
              (my $list    := $!reified),
              (my $strings := nqp::setelems(nqp::list_s,$elems)),
              (my int $i = -1),
              nqp::if(
                nqp::iseq_i(                          # only one % in format?
                  nqp::elems(nqp::split('%',$format)),
                  2
                ) && nqp::iseq_i(                     # only one %s in format
                       nqp::elems(my $parts := nqp::split('%s',$format)),
                       2
                     ),
                nqp::while(                           # only a single %s
                  nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                  nqp::bindpos_s($strings,$i,
                    nqp::join(nqp::atpos($list,$i).Str,$parts)
                  )
                ),
                nqp::while(                           # something else
                  nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                  nqp::bindpos_s($strings,$i,
                    nqp::atpos($list,$i).fmt($format)
                  )
                )
              ),
              nqp::p6box_s(nqp::join($separator,$strings))
            ),
            ''
          )
        )
    }

    multi method elems(List:D:) is nodal {
        nqp::if(
          $!todo.DEFINITE,
          nqp::stmts(
            $!todo.reify-until-lazy,
            nqp::if(
              $!todo.fully-reified,
              nqp::stmts(
                ($!todo := nqp::null),
                nqp::elems($!reified)
              ),
              Failure.new(X::Cannot::Lazy.new(:action('.elems')))
            )
          ),
          nqp::if(
            $!reified.DEFINITE,
            nqp::elems($!reified),
            0
          )
        )
    }

    multi method AT-POS(List:D: Int:D $pos) is raw {
        nqp::if(
          nqp::islt_i($pos,0),
          Failure.new(X::OutOfRange.new(
            :what($*INDEX // 'Index'), :got($pos), :range<0..^Inf>)),
          nqp::if(
            $!reified.DEFINITE,
            nqp::ifnull(
              nqp::atpos($!reified,$pos),
              nqp::if(
                ($!todo.DEFINITE && $!todo.reify-at-least(nqp::add_i($pos,1))),
                nqp::ifnull(nqp::atpos($!reified,$pos),Nil),
                Nil
              )
            ),
            Nil
          )
        )
    }

    multi method AT-POS(List:D: int $pos) is raw {
        nqp::if(
          nqp::islt_i($pos,0),
          Failure.new(X::OutOfRange.new(
            :what($*INDEX // 'Index'), :got($pos), :range<0..^Inf>)),
          nqp::if(
            $!reified.DEFINITE,
            nqp::if(
              nqp::islt_i($pos,nqp::elems($!reified)),
              nqp::atpos($!reified,$pos),
              nqp::if(
                ($!todo.DEFINITE && $!todo.reify-at-least(nqp::add_i($pos,1))),
                nqp::ifnull(nqp::atpos($!reified,$pos),Nil),
                Nil
              )
            ),
            Nil
          )
        )
    }

    method BIND-POS(List:D: Int:D \pos, \what) is raw {
        nqp::iscont(self.AT-POS(pos))
          ?? nqp::bindpos($!reified,nqp::unbox_i(pos),what)
          !! X::Bind.new.throw
    }

    multi method EXISTS-POS(List:D: int $pos) {
        nqp::p6bool(
          nqp::if(
            nqp::isge_i($pos,0),
            nqp::if(
              $!reified.DEFINITE && nqp::islt_i($pos,nqp::elems($!reified)),
              nqp::existspos($!reified,$pos),
              nqp::if(
                $!todo.DEFINITE,
                nqp::stmts(
                  $!todo.reify-at-least(nqp::add_i($pos,1)),
                  nqp::existspos($!reified,$pos)
                )
              )
            )
          )
        )
    }
    multi method EXISTS-POS(List:D: Int:D $pos) {
        nqp::p6bool(
          nqp::if(
            nqp::isge_i($pos,0),
            nqp::if(
              $!reified.DEFINITE && nqp::islt_i($pos,nqp::elems($!reified)),
              nqp::existspos($!reified,$pos),
              nqp::if(
                $!todo.DEFINITE,
                nqp::stmts(
                  $!todo.reify-at-least(nqp::add_i($pos,1)),
                  nqp::existspos($!reified,$pos)
                )
              )
            )
          )
        )
    }

    method reification-target(List:D:) {
        nqp::ifnull(
          $!reified,
          $!reified := nqp::create(IterationBuffer)
        )
    }

    method iterator(List:D:) {

        # something to iterate over in the future
        nqp::if(
          $!todo.DEFINITE,
            class :: does Iterator {
                has int $!i;
                has $!list;
                has $!reified;
                has $!todo;

                method !SET-SELF(\list) {
                    $!i        = -1;
                    $!list    := list;
                    $!reified := nqp::getattr(list,List,'$!reified').DEFINITE
                      # we already have a place to put values in
                      ?? nqp::getattr(list,List,'$!reified')
                      # create a place here and there to put values in
                      !! nqp::bindattr(list,List,'$!reified',
                           nqp::create(IterationBuffer));
                    $!todo := nqp::getattr(list, List, '$!todo');
                    self
                }
                method new(\list) { nqp::create(self)!SET-SELF(list) }

                method pull-one() is raw {
                    nqp::ifnull(
                      nqp::atpos($!reified,$!i = nqp::add_i($!i,1)),
                      $!todo.DEFINITE
                        ?? nqp::islt_i($!i,$!todo.reify-at-least(nqp::add_i($!i,1)))
                          ?? nqp::atpos($!reified,$!i)
                          !! self!done
                        !! IterationEnd
                    )
                }
                method !done() is raw {
                    $!todo := nqp::bindattr($!list,List,'$!todo',nqp::null);
                    IterationEnd
                }

                method push-until-lazy($target) {
                    if $!todo.DEFINITE {
                        my int $elems = $!todo.reify-until-lazy;
                        nqp::while(  # doesn't sink
                          nqp::islt_i($!i = nqp::add_i($!i,1),$elems),
                          $target.push(nqp::atpos($!reified,$!i))
                        );
                        nqp::if(
                          $!todo.fully-reified,
                          self!done,
                          nqp::stmts(
                            ($!i = $elems - 1),
                            Mu
                          )
                        )
                    }
                    else {
                        my int $elems = nqp::elems($!reified);
                        nqp::while(  # doesn't sink
                          nqp::islt_i($!i = nqp::add_i($!i,1),$elems),
                          $target.push(nqp::atpos($!reified,$!i))
                        );
                        IterationEnd
                    }
                }

                method is-lazy() { $!todo.DEFINITE && $!todo.is-lazy }
            }.new(self),

          # everything we need is already there
          nqp::if(
            $!reified.DEFINITE,
            Rakudo::Iterator.ReifiedList(self),
            Rakudo::Iterator.Empty
          )
        )
    }

    multi method ACCEPTS(List:D: $topic) {
        CATCH { default { return False } } # .elems on lazies throws
        return True if nqp::eqaddr(self, nqp::decont($topic));

        unless nqp::istype($topic, Iterable) {
            return self unless self.elems;
            return self if nqp::istype(self[0], Match);
            return False;
        }
        my $sseq = self;
        my $tseq = $topic;

        sub tailmatch($s,$t) {
            my int $spos = $s;
            my int $tpos = $t;
            while $spos < $sseq {
                # if the next element is Whatever
                if nqp::istype($sseq[$spos], HyperWhatever) {
                    # skip over all of the Whatevers
                    $spos = $spos + 1
                        while $spos <= $sseq && nqp::istype($sseq[$spos], HyperWhatever);
                    # if nothing left, we're done
                    return True if $spos == $sseq;
                    # find a target matching our new target
                    while $tpos < $tseq {
                        my $result = tailmatch($spos,$tpos);
                        return True if $result;
                        $tpos = $tpos + 1
                    }
                    # return false if we ran out
                    return False;
                }
                elsif $tpos == $tseq or not $sseq[$spos].ACCEPTS($tseq[$tpos] ) {
                    return False;
                }
                # skip matching elements
                $spos = $spos + 1;
                $tpos = $tpos + 1;
            }
            # If nothing left to match, we're successful.
            $tpos >= $tseq;
        }

        tailmatch(0,0);
    }

    multi method list(List:D:) { self }

    method sink(--> Nil) { }

    multi method values(List:D:) {
        Seq.new(self.iterator)
    }
    multi method keys(List:D:) {
        Seq.new(nqp::if(
          self.is-lazy,
          nqp::stmts(
            (my int $i = -1),
            Rakudo::Iterator.Callable( { $i = nqp::add_i($i,1) }, True )
          ),
          Rakudo::Iterator.IntRange(0, self.elems - 1)
        ))
    }
    multi method kv(List:D:) {
        Seq.new(Rakudo::Iterator.KeyValue(self.iterator))
    }
    multi method pairs(List:D:) {
        Seq.new(Rakudo::Iterator.Pair(self.iterator))
    }
    multi method antipairs(List:D:) {
        Seq.new(Rakudo::Iterator.AntiPair(self.iterator))
    }
    multi method invert(List:D:) {
        Seq.new(Rakudo::Iterator.Invert(self.iterator))
    }

    # Store in List targets containers with in the list. This handles list
    # assignments, like ($a, $b) = foo().
    proto method STORE(|) { * }
    multi method STORE(List:D: Iterable:D \iterable) {
        # First pass -- scan lhs containers and pick out scalar versus list
        # assignment. This also reifies the RHS values we need, and deconts
        # them. The decont is needed so that we can do ($a, $b) = ($b, $a).
        my \cv = nqp::list();
        my \lhs-iter = self.iterator;
        my \rhs-iter = iterable.iterator;
        my int $rhs-done;
        my Mu $v;
        my Mu $c;
        my Mu $sub-iter;
        my Mu $sc;

        nqp::until(
          nqp::eqaddr(($c := lhs-iter.pull-one),IterationEnd),
          nqp::if(          # Container: scalar assignment
            nqp::iscont($c),
            nqp::stmts(
              nqp::push(cv,$c),
              nqp::if(
                ($rhs-done || ($rhs-done =
                  nqp::eqaddr(($v := rhs-iter.pull-one),IterationEnd))),
                nqp::push(cv,Nil),
                nqp::push(cv,nqp::decont($v)),
              )
            ),
            nqp::if(        # Whatever: skip assigning value
              nqp::istype($c,Whatever),
              nqp::if(
                (nqp::not_i($rhs-done)
                  && nqp::eqaddr(rhs-iter.pull-one,IterationEnd)),
                ($rhs-done = 1)
              ),
              nqp::if(      # List splice into current lhs
                (nqp::istype($c,List) && nqp::not_i(nqp::istype($c,Array))),
                nqp::stmts(
                  ($sub-iter := $c.iterator),
                  nqp::until(
                    nqp::eqaddr(($sc := $sub-iter.pull-one),IterationEnd),
                    nqp::stmts(
                      nqp::push(cv,$sc);
                      nqp::if(
                        ($rhs-done = nqp::eqaddr(
                          ($v := rhs-iter.pull-one),IterationEnd
                        )),
                        nqp::push(cv,Nil),
                        nqp::push(cv,nqp::decont($v))
                      )
                    )
                  )
                ),
                nqp::stmts( # Non-container: store entire remaining rhs
                  nqp::push(cv,$c),
                  nqp::push(cv,List.from-iterator(rhs-iter)),
                  ($rhs-done = 1)
                )
              )
            )
          )
        );

        # Second pass, perform the assignments.
        nqp::shift(cv) = nqp::shift(cv) while nqp::elems(cv);

        self
    }
    multi method STORE(List:D: Mu \item) {
        self.STORE((item,));
    }

    multi method gist(List:D:) {
        self.gistseen('List', {
            '(' ~ self.map( -> $elem {
                given ++$ {
                    when 101 { '...' }
                    when 102 { last }
                    default  { $elem.gist }
                }
            }).join(' ') ~ ')'
        })
    }

    multi method perl(List:D \SELF:) {
        SELF.perlseen('List', {
            '$' x nqp::iscont(SELF) ~ '('
            ~ (self.elems == 1 ?? self[0].perl ~ ',' !! self.map({.perl}).join(', '))
            ~ ' ' x nqp::istrue(self.not && nqp::iscont(SELF)) # add space to avoid `$()`
            ~ ')'
        })
    }

    multi method List(List:D:) { self }

    multi method Slip(List:D:) {
        nqp::if(
          $!todo.DEFINITE,
          # We're not fully reified, and so have internal mutability still.
          # The safe thing to do is to take an iterator of ourself and build
          # the Slip out of that.
          Slip.from-iterator(self.iterator),
          # We're fully reified - and so immutable inside and out! Just make
          # a Slip that shares our reified buffer.
          nqp::p6bindattrinvres(nqp::create(Slip),List,'$!reified',$!reified)
        )
    }

    multi method Array(List:D:) {
        # We need to populate the Array slots with Scalar containers
        nqp::if(
          $!todo.DEFINITE,
          Array.from-iterator(self.iterator),
          nqp::if(
            $!reified.DEFINITE,
            nqp::stmts(
              (my int $elems = nqp::elems($!reified)),
              (my $array := nqp::setelems(nqp::create(IterationBuffer),$elems)),
              (my int $i = -1),
              nqp::while(
                nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                nqp::bindpos($array, $i,
                  nqp::assign(
                    nqp::p6scalarfromdesc(nqp::null),
                    nqp::atpos($!reified,$i)
                  )
                )
              ),
              nqp::p6bindattrinvres(nqp::create(Array),List,'$!reified',$array)
            ),
            nqp::create(Array)
          )
        )
    }

    method eager {
        nqp::stmts(
          nqp::if(
            $!todo.DEFINITE,
            nqp::stmts(
              $!todo.reify-all,
              ($!todo := nqp::null)
            )
          ),
          self
        )
    }

    method Capture() {
        fail X::Cannot::Lazy.new(:action('create a Capture from'))
            if self.is-lazy;

        # we have something to work with
        if $!reified.DEFINITE && nqp::elems($!reified) -> int $elems {
            my $capture := nqp::create(Capture);
            my $list := nqp::create(IterationBuffer);
            my $hash := nqp::hash;
            my int $i = -1;
            my $v;
            nqp::istype(($v := nqp::atpos($!reified, $i)),Pair)
              ?? nqp::bindkey($hash, $v.key.Str, $v.value)
              !! nqp::push($list,$v)
              while nqp::islt_i($i = nqp::add_i($i,1),$elems);
            nqp::bindattr($capture,Capture,'@!list',$list) if nqp::elems($list);
            nqp::bindattr($capture,Capture,'%!hash',$hash) if nqp::elems($hash);
            $capture
        }

        # nothing to work with
        else {
            nqp::create(Capture)
        }
    }
    method FLATTENABLE_LIST() {
        nqp::if(
          $!todo.DEFINITE,
          nqp::stmts(
            $!todo.reify-all,
            $!reified
          ),
          nqp::if(
            $!reified.DEFINITE,
            $!reified,
            nqp::bindattr(self,List,'$!reified',nqp::create(IterationBuffer))
          )
        )
    }
    method FLATTENABLE_HASH() { nqp::hash() }

    multi method Supply(List:D:) { Supply.from-list(self) }

    method CALL-ME(List:U: |c) {
        self.new(|c);
    }

    multi method is-lazy(List:D:) {
        nqp::if(
          $!todo.DEFINITE,
          nqp::stmts(
            $!todo.reify-until-lazy,
            nqp::if(
              $!todo.fully-reified,
              nqp::p6bool($!todo := nqp::null),
              True
            )
          )
        )
    }

    proto method pick(|) is nodal { * }
    multi method pick(List:D:) {
        self.is-lazy
         ?? Failure.new(X::Cannot::Lazy.new(:action('.pick from')))
         !! (my Int $elems = self.elems)
           ?? nqp::atpos($!reified, $elems.rand.floor)
           !! Nil
    }
    multi method pick(List:D: Callable:D $calculate) {
        self.is-lazy
         ?? Failure.new(X::Cannot::Lazy.new(:action('.pick from')))
         !! self.pick( $calculate(self.elems) )
    }
    multi method pick(List:D: $number is copy) {
        fail X::Cannot::Lazy.new(:action('.pick from')) if self.is-lazy;
        my Int $elems = self.elems;
        return () unless $elems;

        $number = nqp::istype($number,Whatever) || $number == Inf
          ?? $elems
          !! $number.UInt min $elems;
        Seq.new(class :: does Iterator {
            has $!list;
            has Int $!elems;
            has int $!number;

            method !SET-SELF(\list,$!elems,\number) {
                $!list  := nqp::clone(nqp::getattr(list,List,'$!reified'));
                $!number = number + 1;
                self
            }
            method new(\list,\elems,\number) {
                nqp::create(self)!SET-SELF(list,elems,number)
            }
            method pull-one() {
                if ($!number = nqp::sub_i($!number,1)) {
                    my int $i;
                    my \tmp = nqp::atpos($!list,$i = $!elems.rand.floor);
                    nqp::bindpos($!list,$i,
                      nqp::atpos($!list,nqp::unbox_i(--$!elems))
                    );
                    tmp
                }
                else {
                    IterationEnd
                }
            }
            method push-all($target --> IterationEnd) {
                my int $i;
                nqp::while(
                  ($!number = nqp::sub_i($!number,1)),
                  nqp::stmts(  # doesn't sink
                    ($target.push(nqp::atpos($!list,$i = $!elems.rand.floor))),
                    (nqp::bindpos($!list,$i,
                      nqp::atpos($!list,nqp::unbox_i(--$!elems))))
                  )
                )
            }
        }.new(self,$elems,$number))
    }

    proto method roll(|) is nodal { * }
    multi method roll() {
        self.is-lazy
          ?? Failure.new(X::Cannot::Lazy.new(:action('.roll from')))
          !! (my Int $elems = self.elems)
            ?? nqp::atpos($!reified, $elems.rand.floor)
            !! Nil
    }
    multi method roll(Whatever) {
        nqp::if(
          self.is-lazy,
          X::Cannot::Lazy.new(:action('.roll from')).throw,
          Seq.new(nqp::if(
            (my $elems := self.elems),
            Rakudo::Iterator.Callable( {
                nqp::atpos($!reified, $elems.rand.floor)
            }, True ),
            Rakudo::Iterator.Empty
          ))
        )
    }
    multi method roll(\number) {
        number == Inf
          ?? self.roll(*)
          !! self.is-lazy
            ?? X::Cannot::Lazy.new(:action('.roll from')).throw
            !! self.elems   # this allocates/reifies
              ?? Seq.new(class :: does Iterator {
                     has $!list;
                     has Int $!elems;
                     has int $!todo;
                     method !SET-SELF(\list,\todo) {
                         $!list := nqp::getattr(list,List,'$!reified');
                         $!elems = nqp::elems($!list);
                         $!todo  = todo;
                         self
                     }
                     method new(\list,\todo) {
                         nqp::create(self)!SET-SELF(list,todo)
                     }
                     method pull-one() is raw {
                         if $!todo {
                             $!todo = $!todo - 1;
                             nqp::atpos($!list,$!elems.rand.floor)
                         }
                         else {
                             IterationEnd
                         }
                     }
                 }.new(self,number.Int))
              !! Seq.new(Rakudo::Iterator.Empty)
    }

    method reverse() is nodal {
        nqp::if(
          self.is-lazy,    # reifies
          Failure.new(X::Cannot::Lazy.new(:action<reverse>)),
          Seq.new(nqp::if(
            $!reified,
            Rakudo::Iterator.ReifiedListReverse($!reified),
            Rakudo::Iterator.Empty
          ))
        )
    }

    method rotate(Int(Cool) $rotate = 1) is nodal {
        nqp::if(
          self.is-lazy,    # reifies
          Failure.new(X::Cannot::Lazy.new(:action<rotate>)),
          nqp::if(
            $!reified,
            Rakudo::Internals.RotateListToList(
              self, $rotate,
              nqp::p6bindattrinvres(nqp::create(self),List,'$!reified',
                nqp::setelems(
                  nqp::create(IterationBuffer),nqp::elems($!reified)
                )
              )
            ),
            nqp::create(self)
          )
        )
    }

    proto method combinations(|) is nodal {*}
    multi method combinations() {
        nqp::stmts(
          (my int $elems = self.elems),           # reifies
          (my int $i = -1),
          Seq.new(
            Rakudo::Iterator.SequentialIterators(
              Rakudo::Iterator.Callable( {
                  nqp::if(
                    nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                    Rakudo::Iterator.ListIndexes( # basically .combinations($i)
                      self,
                      Rakudo::Iterator.Combinations($elems, $i, 1)
                    ),
                    nqp::if(
                      nqp::iseq_i($i,$elems),
                      Rakudo::Iterator.OneValue(  # last one is self
                        nqp::p6bindattrinvres(    # but must be a (new) List
                          nqp::create(List),      # so transplant innards
                          List,
                          '$!reified',
                          nqp::getattr(self,List,'$!reified')
                        )
                      ),
                      IterationEnd
                    )
                  )
              } )
            )
          )
        )
    }

    multi method combinations(Int() $of) {
        Seq.new(
          Rakudo::Iterator.ListIndexes(
            self, Rakudo::Iterator.Combinations( self.elems, $of, 1)
          )
        )
    }
    multi method combinations(Range:D $ofrange) {
        nqp::stmts(
          (my int $elems = self.elems),      # reifies
          $ofrange.int-bounds(my int $i, my int $to),
          ($i = nqp::if(nqp::islt_i($i,0),-1,nqp::sub_i($i,1))),
          nqp::if(nqp::isgt_i($to,$elems),($to = $elems)),
          Seq.new(
            Rakudo::Iterator.SequentialIterators(
              Rakudo::Iterator.Callable( {
                  nqp::if(
                    nqp::isle_i(($i = nqp::add_i($i,1)),$to),
                    Rakudo::Iterator.ListIndexes( # basically .combinations($i)
                      self,
                      Rakudo::Iterator.Combinations($elems, $i, 1)
                    ),
                    IterationEnd
                  )
              } )
            )
          )
        )
    }

    proto method permutations(|) is nodal {*}
    multi method permutations() {
        Seq.new(
          Rakudo::Iterator.ListIndexes(
            self, Rakudo::Iterator.Permutations( self.elems, 1)
          )
        )
    }

    method join(List:D: Str(Cool) $separator = '') is nodal {
        nqp::stmts(
          nqp::if(
            $!todo.DEFINITE,
            nqp::stmts(                          # need to reify first
              $!todo.reify-until-lazy,
              nqp::if(
                $!todo.fully-reified,
                ($!todo := nqp::null),           # all reified
                (my int $infinite = 1)           # still stuff left to do
              )
            )
          ),
          nqp::if(
            $!reified.DEFINITE
              && (my int $elems = nqp::elems($!reified)),
            nqp::stmts(                          # something to join
              (my $strings := nqp::list_s),
              (my int $i = -1),
              nqp::while(
                nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                nqp::stmts(                      # something left to check
                  (my $tmp := nqp::ifnull(
                    nqp::atpos($!reified,$i),
                    nqp::if(
                      nqp::isconcrete(my $default),
                      $default,                  # seen before
                      ($default := nqp::if(      # first time we see null
                        nqp::can(self,'default'),
                        self.default.Str,
                        ''
                      ))
                    )
                  )),
                  nqp::if(
                    nqp::isconcrete($tmp),
                    nqp::if(                     # not a type object
                      nqp::istype($tmp,Junction),
                      (return self!junctionize(  # follow Junction path
                        $separator, $strings, $i, $elems, $tmp
                      )),
                      nqp::push_s(               # no special action needed
                        $strings,
                        nqp::if(
                          nqp::istype($tmp,Str),
                          $tmp,
                          nqp::if(
                            nqp::can($tmp,'Str'),
                            $tmp.Str,
                            nqp::box_s($tmp,Str)
                          )
                        )
                      )
                    ),
                    nqp::push_s($strings,$tmp.Str)   # type object
                  )
                )
              ),
              nqp::if($infinite,nqp::push_s($strings,'...')),
              nqp::p6box_s(nqp::join($separator,$strings))  # done
            ),
            nqp::if($infinite,'...','')          # nothing to join
          )
        )
    }

    # When we find a Junction in the list, start handling the rest
    # of the list as junctions, and stringify the parts between Junctions
    # normally, for performance.
    method !junctionize(\sep, Mu \strings, \i, \elems, Mu \initial) {
        nqp::stmts(
          nqp::if(
            nqp::elems(strings),
            nqp::stmts(                          # some strings on left
              (my $junction := infix:<~>(
                nqp::concat(nqp::join(sep,strings),sep),
                initial
              )),
              nqp::setelems(strings,0)
            ),
            ($junction := initial)               # just start with this one
          ),
          nqp::while(
            nqp::islt_i((i = nqp::add_i(i,1)),elems),
            nqp::stmts(                          # something left in list
              (my $tmp := nqp::ifnull(
                nqp::atpos($!reified,i),
                nqp::if(
                  nqp::isconcrete(my $default),
                  $default,                      # seen before
                  ($default := nqp::if(          # first time we have a null
                    nqp::can(self,'default'),
                    self.default.Str,
                    ''
                  ))
                )
              )),
              nqp::if(
                nqp::isconcrete($tmp),
                nqp::if(                         # not a type object
                  nqp::istype($tmp,Junction),
                  nqp::stmts(                    # found another Junction
                    nqp::if(
                      nqp::elems(strings),
                      nqp::stmts(                # process string on left
                        ($junction := infix:<~>(
                          $junction,
                          nqp::concat(sep,nqp::join(sep,strings))
                        )),
                        nqp::setelems(strings,0)
                      )
                    ),
                    ($junction := infix:<~>($junction, $tmp))
                  ),
                  nqp::push_s(strings,nqp::if(   # not a Junction
                    nqp::istype($tmp,Str),
                    $tmp,
                    nqp::if(
                      nqp::can($tmp,'Str'),
                      $tmp.Str,
                      nqp::box_s($tmp,Str)
                    )
                  ))
                ),
                nqp::push_s(strings,$tmp.Str)    # type object
              )
            )
          ),
          nqp::if(
            nqp::elems(strings),
            infix:<~>(                           # need to concat right
              $junction,
              nqp::concat(sep,nqp::join(sep,strings))
            ),
            $junction                            # nothing left to concat
          )
        )
    }

    # https://en.wikipedia.org/wiki/Merge_sort#Bottom-up_implementation
    multi method sort(List:D:) {
        nqp::stmts(
          nqp::if(
            $!todo.DEFINITE,
            nqp::stmts(
              $!todo.reify-until-lazy,
              nqp::if(
                $!todo.fully-reified,
                ($!todo := nqp::null),
                X::Cannot::Lazy.new(:action('.sort')).throw
              )
            )
          ),
          Seq.new(
            nqp::if(
              $!reified.DEFINITE,
              Rakudo::Iterator.ReifiedList(
                Rakudo::Sorting.MERGESORT-REIFIED-LIST(
                  nqp::p6bindattrinvres(
                    nqp::create(List),List,'$!reified',
                    nqp::clone(nqp::getattr(self,List,'$!reified'))
                  )
                )
              ),
              Rakudo::Iterator.Empty
            )
          )
        )
    }
    multi method sort(List:D: &by) {
        nqp::stmts(
          nqp::if(
            $!todo.DEFINITE,
            nqp::stmts(
              $!todo.reify-until-lazy,
              nqp::if(
                $!todo.fully-reified,
                ($!todo := nqp::null),
                X::Cannot::Lazy.new(:action('.sort')).throw
              )
            )
          ),
          Seq.new(
            nqp::if(
              $!reified.DEFINITE,
              Rakudo::Iterator.ReifiedList(
                nqp::if(
                  nqp::eqaddr(&by,&infix:<cmp>),
                  Rakudo::Sorting.MERGESORT-REIFIED-LIST(
                    nqp::p6bindattrinvres(nqp::create(List),List,'$!reified',
                      nqp::clone(nqp::getattr(self,List,'$!reified')))
                  ),
                  nqp::if(
                    &by.count < 2,
                    Rakudo::Sorting.MERGESORT-REIFIED-LIST-AS(
                      nqp::p6bindattrinvres(nqp::create(List),List,'$!reified',
                        nqp::getattr(self,List,'$!reified')),
                      &by
                    ),
                    Rakudo::Sorting.MERGESORT-REIFIED-LIST-WITH(
                      nqp::p6bindattrinvres(nqp::create(List),List,'$!reified',
                        nqp::clone(nqp::getattr(self,List,'$!reified'))),
                      &by
                    )
                  )
                )
              ),
              Rakudo::Iterator.Empty
            )
          )
        )
    }
    multi method tail(List:D:) is raw {
        nqp::if(
          $!todo.DEFINITE,
          self.Any::tail,
          nqp::if(
            $!reified.DEFINITE && nqp::elems($!reified),
            nqp::atpos($!reified,nqp::sub_i(nqp::elems($!reified),1)),
            Nil
          )
        )
    }
    multi method tail(List:D: $n) {
        nqp::if(
          $!todo.DEFINITE,
          self.Any::tail($n),
          Seq.new(
            nqp::if(
              $!reified.DEFINITE && nqp::elems($!reified),
              nqp::stmts(
                (my $iterator := Rakudo::Iterator.ReifiedList(self)),
                nqp::if(
                  nqp::istype($n,Callable)
                    && nqp::isgt_i((my $skip := -($n(0).Int)),0),
                  $iterator.skip-at-least($skip),
                  nqp::unless(
                    nqp::istype($n,Whatever) || $n == Inf,
                    $iterator.skip-at-least(nqp::elems($!reified) - $n)
                  )
                ),
                $iterator
              ),
              Rakudo::Iterator.Empty
            )
          )
        )
    }

    method push(|) is nodal {
        X::Immutable.new(:typename<List>,:method<push>).throw
    }
    method append(|) is nodal {
        X::Immutable.new(:typename<List>,:method<append>).throw
    }
    method unshift(|) is nodal {
        X::Immutable.new(:typename<List>,:method<unshift>).throw
    }
    method prepend(|) is nodal {
        X::Immutable.new(:typename<List>,:method<prepend>).throw
    }
    method shift(|) is nodal {
        X::Immutable.new(:typename<List>,:method<shift>).throw
    }
    method pop(|) is nodal {
        X::Immutable.new(:typename<List>, :method<pop>).throw
    }
}

# The , operator produces a List.
proto sub infix:<,>(|) is pure {*}
multi sub infix:<,>() { nqp::create(List) }
multi sub infix:<,>(|) {

    # look for a Slip in the parameters
    my \in := nqp::p6argvmarray();
    my int $i     = -1;
    my int $elems = nqp::elems(in);
    nqp::while(
      (nqp::islt_i(($i = nqp::add_i($i,1)),$elems)
        && nqp::not_i(nqp::istype(nqp::atpos(in,$i),Slip))),
      nqp::null
    );

    nqp::if(
      nqp::iseq_i($i,$elems),  # no Slip seen, so just alias input params
      nqp::p6bindattrinvres(nqp::create(List),List,'$!reified',in),
      nqp::stmts(  # Slip seen, first copy non-slippy things
        ($elems = $i),
        ($i     = -1),
        (my $reified := nqp::setelems(nqp::create(IterationBuffer),$elems)),
        nqp::while(
          nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
          nqp::bindpos($reified,$i,nqp::shift(in))
        ),
        # now set up the List with a future
        (my $list :=
          nqp::p6bindattrinvres(nqp::create(List),List,'$!reified',$reified)),
        nqp::bindattr($list,List,'$!todo',
          my $todo:= nqp::create(List::Reifier)),
        nqp::bindattr($todo,List::Reifier,'$!reified',$reified),
        nqp::bindattr($todo,List::Reifier,'$!future',in),
        nqp::bindattr($todo,List::Reifier,'$!reification-target',$reified),
        $list
      )
    )
}

sub combinations(Int() $n, Int() $k) {
    Seq.new(Rakudo::Iterator.Combinations($n,$k,0))
}

sub permutations(Int() $n) {
    Seq.new(Rakudo::Iterator.Permutations($n,0))
}

sub list(+l) { l }

# Use **@list and then .flat it, otherwise we'll end up remembering all the
# things we flatten, which would be different semantics to .flat which gives
# back a Seq. We also add an Iterable candidate, to preserve .is-lazy
# of an Iterable whenever we can.
proto flat(|) {*}
multi flat(**@list is raw) { @list.flat }
multi flat(Iterable \a)    {     a.flat }

sub cache(+@l) { @l }

proto sub infix:<xx>(|) { * }
multi sub infix:<xx>() { Failure.new("No zero-arg meaning for infix:<xx>") }
multi sub infix:<xx>(Mu \x) { x }
multi sub infix:<xx>(&x, Num() $n) {
    infix:<xx>(&x, $n == Inf ?? Whatever !! $n.Int);
}
multi sub infix:<xx>(&x, Whatever) {
    Seq.new(Rakudo::Iterator.Callable-xx-Whatever(&x))
}
multi sub infix:<xx>(&x, Int $n) {
    my int $todo = $n + 1;
    my Mu $pulled;
    my Mu $list := nqp::create(IterationBuffer);
    nqp::while(
      nqp::isgt_i($todo = nqp::sub_i($todo,1),0),
      nqp::if(
        nqp::istype(($pulled := &x.()),Slip),
        (nqp::push($list,$_) for $pulled),
        nqp::if(
          nqp::istype($pulled,Seq),
          nqp::push($list,$pulled.cache),
          nqp::push($list,nqp::decont($pulled))
        )
      )
    );
    Seq.new(Rakudo::Iterator.ReifiedList($list))
}
multi sub infix:<xx>(Mu \x, Num() $n) {
    Seq.new(nqp::if(
      $n == Inf,
      Rakudo::Iterator.UnendingValue(x),
      Rakudo::Iterator.OneValueTimes(x,$n.Int)
    ))
}
multi sub infix:<xx>(Mu \x, Whatever) {
    Seq.new(Rakudo::Iterator.UnendingValue(x))
}
multi sub infix:<xx>(Mu \x, Int:D $n) is pure {
    Seq.new(Rakudo::Iterator.OneValueTimes(x,$n))
}

proto sub reverse(|)   { * }
multi sub reverse(@a)  { @a.reverse }
multi sub reverse(+@a) { @a.reverse }

sub rotate(@a, Int $n = 1)  { @a.rotate($n) }

sub prefix:<|>(\x) { x.Slip }

multi sub infix:<cmp>(@a, @b) {
    (@a Zcmp @b).first(&prefix:<?>) || @a <=> @b
}

proto sub infix:<X>(|) is pure {*}
multi sub infix:<X>(+lol, :&with!) {
    Seq.new(Rakudo::Iterator.CrossIterablesOp(lol,&with))
}
multi sub infix:<X>(+lol) {
    Seq.new(Rakudo::Iterator.CrossIterablesOp(lol,&infix:<,>))
}
my constant &cross := &infix:<X>;

proto sub infix:<Z>(|) is pure {*}
multi sub infix:<Z>(+lol, :&with!) {
    Seq.new(Rakudo::Iterator.ZipIterablesOp(lol,&with))
}
multi sub infix:<Z>(+lol) {
    Seq.new(Rakudo::Iterator.ZipIterables(lol))
}
my constant &zip := &infix:<Z>;

sub roundrobin(+lol) {
    Seq.new(Rakudo::Iterator.RoundrobinIterables(lol))
}

#line 1 SETTING::src/core/array_slice.pm
# all sub postcircumfix [] candidates here please

# Generates list of positions to index into the array at. Takes all those
# before something lazy is encountered and eagerly reifies them. If there
# are any lazy things in the slice, then we lazily consider those, but will
# truncate at the first one that is out of range. The optional
# :$eagerize will be called if Whatever/WhateverCode is encountered or if
# clipping of lazy indices is enacted.  It should return the number of
# elements of the array if called with Whatever, or do something EXISTS-POSish
# if called with an Int.  Before it does so, it may cause the calling code
# to switch to a memoized version of an iterator by modifying variables in
# the caller's scope.
proto sub POSITIONS(|) { * }
multi sub POSITIONS(
  \SELF,
  \pos,
  Callable :$eagerize = -> $idx {
      nqp::if(
        nqp::istype($idx,Whatever),
        nqp::if(nqp::isconcrete(SELF),SELF.elems,0),
        SELF.EXISTS-POS($idx)
      )
  }
) {
    my class IndicesReificationTarget {
        has $!target;
        has $!star;

        method new(\target, \star) {
            my \rt = nqp::create(self);
            nqp::bindattr(rt, self, '$!target', target);
            nqp::bindattr(rt, self, '$!star', star);
            rt
        }

        method push(Mu \value) {
            nqp::if(
              nqp::istype(value,Callable),
              nqp::stmts(
                nqp::if(
                  nqp::istype($!star,Callable),
                  nqp::bindattr(self,IndicesReificationTarget,'$!star',$!star(*))
                ),
                # just using value(...) causes stage optimize to die
                (my &whatever := value),
                nqp::if(
                  &whatever.count == Inf,
                  nqp::push($!target, whatever(+$!star)),
                  nqp::push($!target, whatever(|(+$!star xx &whatever.count)))
                )
              ),
              nqp::push($!target,value)
            )
        }
    }

    # we can optimize `42..*` Ranges; as long as they're from core, unmodified
    my \pos-iter = nqp::eqaddr(pos.WHAT,Range)
        && nqp::eqaddr(pos.max,Inf)
        && nqp::isfalse(SELF.is-lazy)
          ?? Range.new(pos.min, SELF.elems-1,
              :excludes-min(pos.excludes-min),
              :excludes-max(pos.excludes-max)
          ).iterator
          !! pos.iterator;

    my \pos-list = nqp::create(List);
    my \eager-indices = nqp::create(IterationBuffer);
    my \target = IndicesReificationTarget.new(eager-indices, $eagerize);
    nqp::bindattr(pos-list, List, '$!reified', eager-indices);
    unless pos-iter.push-until-lazy(target) =:= IterationEnd {
        # There are lazy positions to care about too. We truncate at the first
        # one that fails to exists.
        my \rest-seq = Seq.new(pos-iter).flatmap: -> Int() $i {
            nqp::unless(
              $eagerize($i),
              last,
              $i
            )
        };
        my \todo := nqp::create(List::Reifier);
        nqp::bindattr(todo, List::Reifier, '$!reified', eager-indices);
        nqp::bindattr(todo, List::Reifier, '$!current-iter', rest-seq.iterator);
        nqp::bindattr(todo, List::Reifier, '$!reification-target', eager-indices);
        nqp::bindattr(pos-list, List, '$!todo', todo);
    }
    pos-list
}

proto sub postcircumfix:<[ ]>(|) is nodal { * }

multi sub postcircumfix:<[ ]>( \SELF, Any:U $type, |c ) is raw {
    die "Unable to call postcircumfix {try SELF.VAR.name}[ $type.gist() ] with a type object\n"
      ~ "Indexing requires a defined object";
}

# @a[int 1]
multi sub postcircumfix:<[ ]>( \SELF, int $pos ) is raw {
    SELF.AT-POS($pos);
}
multi sub postcircumfix:<[ ]>( \SELF, int $pos, Mu \assignee ) is raw {
    SELF.ASSIGN-POS($pos, assignee);
}
multi sub postcircumfix:<[ ]>(\SELF, int $pos, Mu :$BIND! is raw) is raw {
    SELF.BIND-POS($pos, $BIND);
}
multi sub postcircumfix:<[ ]>( \SELF, int $pos, :$delete!, *%other ) is raw {
    $delete && nqp::not_i(nqp::elems(nqp::getattr(%other,Map,'$!storage')))
      ?? SELF.DELETE-POS($pos)
      !! SLICE_ONE_LIST( SELF, $pos, 'delete', $delete, %other );
}
multi sub postcircumfix:<[ ]>( \SELF, int $pos, :$exists!, *%other ) is raw {
    $exists && nqp::not_i(nqp::elems(nqp::getattr(%other,Map,'$!storage')))
      ?? SELF.EXISTS-POS($pos)
      !! SLICE_ONE_LIST( SELF, $pos, 'exists', $exists, %other );
}
multi sub postcircumfix:<[ ]>( \SELF, int $pos, :$kv!, *%other ) is raw {
    $kv && nqp::not_i(nqp::elems(nqp::getattr(%other,Map,'$!storage')))
      ?? (SELF.EXISTS-POS($pos) ?? ($pos, SELF.AT-POS($pos)) !! ())
      !! SLICE_ONE_LIST( SELF, $pos, 'kv', $kv, %other );
}
multi sub postcircumfix:<[ ]>( \SELF, int $pos, :$p!, *%other ) is raw {
    $p && nqp::not_i(nqp::elems(nqp::getattr(%other,Map,'$!storage')))
      ?? (SELF.EXISTS-POS($pos) ?? Pair.new($pos,SELF.AT-POS($pos)) !! ())
      !! SLICE_ONE_LIST( SELF, $pos, 'p', $p, %other );
}
multi sub postcircumfix:<[ ]>( \SELF, int $pos, :$k!, *%other ) is raw {
    $k && nqp::not_i(nqp::elems(nqp::getattr(%other,Map,'$!storage')))
      ?? (SELF.EXISTS-POS($pos) ?? $pos !! ())
      !! SLICE_ONE_LIST( SELF, $pos, 'k', $k, %other );
}
multi sub postcircumfix:<[ ]>( \SELF, int $pos, :$v!, *%other ) is raw {
    $v && nqp::not_i(nqp::elems(nqp::getattr(%other,Map,'$!storage')))
      ?? (SELF.EXISTS-POS($pos) ?? nqp::decont(SELF.AT-POS($pos)) !! ())
      !! SLICE_ONE_LIST( SELF, $pos, 'v', $v, %other );
}

# @a[Int 1]
multi sub postcircumfix:<[ ]>( \SELF, Int:D $pos ) is raw {
    SELF.AT-POS($pos);
}
multi sub postcircumfix:<[ ]>( \SELF, Int:D $pos, Mu \assignee ) is raw {
    SELF.ASSIGN-POS($pos, assignee);
}
multi sub postcircumfix:<[ ]>(\SELF, Int:D $pos, Mu :$BIND! is raw) is raw {
    SELF.BIND-POS($pos, $BIND);
}
multi sub postcircumfix:<[ ]>( \SELF, Int:D $pos, :$delete!, *%other ) is raw {
    $delete && nqp::not_i(nqp::elems(nqp::getattr(%other,Map,'$!storage')))
      ?? SELF.DELETE-POS($pos)
      !! SLICE_ONE_LIST( SELF, $pos, 'delete', $delete, %other );
}
multi sub postcircumfix:<[ ]>( \SELF, Int:D $pos, :$exists!, *%other ) is raw {
    $exists && nqp::not_i(nqp::elems(nqp::getattr(%other,Map,'$!storage')))
      ?? SELF.EXISTS-POS($pos)
      !! SLICE_ONE_LIST( SELF, $pos, 'exists', $exists, %other );
}
multi sub postcircumfix:<[ ]>( \SELF, Int:D $pos, :$kv!, *%other ) is raw {
    $kv && nqp::not_i(nqp::elems(nqp::getattr(%other,Map,'$!storage')))
      ?? (SELF.EXISTS-POS($pos) ?? ($pos, SELF.AT-POS($pos)) !! ())
      !! SLICE_ONE_LIST( SELF, $pos, 'kv', $kv, %other );
}
multi sub postcircumfix:<[ ]>( \SELF, Int:D $pos, :$p!, *%other ) is raw {
    $p && nqp::not_i(nqp::elems(nqp::getattr(%other,Map,'$!storage')))
      ?? (SELF.EXISTS-POS($pos) ?? Pair.new($pos,SELF.AT-POS($pos)) !! ())
      !! SLICE_ONE_LIST( SELF, $pos, 'p', $p, %other );
}
multi sub postcircumfix:<[ ]>( \SELF, Int:D $pos, :$k!, *%other ) is raw {
    $k && nqp::not_i(nqp::elems(nqp::getattr(%other,Map,'$!storage')))
      ?? (SELF.EXISTS-POS($pos) ?? $pos !! ())
      !! SLICE_ONE_LIST( SELF, $pos, 'k', $k, %other );
}
multi sub postcircumfix:<[ ]>( \SELF, Int:D $pos, :$v!, *%other ) is raw {
    $v && nqp::not_i(nqp::elems(nqp::getattr(%other,Map,'$!storage')))
      ?? (SELF.EXISTS-POS($pos) ?? nqp::decont(SELF.AT-POS($pos)) !! ())
      !! SLICE_ONE_LIST( SELF, $pos, 'v', $v, %other );
}

# @a[$x]
multi sub postcircumfix:<[ ]>( \SELF, Any:D \pos ) is raw {
    SELF.AT-POS(pos.Int);
}
multi sub postcircumfix:<[ ]>( \SELF, Any:D \pos, Mu \assignee ) is raw {
    SELF.ASSIGN-POS(pos.Int, assignee);
}
multi sub postcircumfix:<[ ]>(\SELF, Any:D \pos, Mu :$BIND! is raw) is raw {
    SELF.BIND-POS(pos.Int, $BIND);
}
multi sub postcircumfix:<[ ]>( \SELF, Any:D \pos, :$delete!, *%other ) is raw {
    $delete && nqp::not_i(nqp::elems(nqp::getattr(%other,Map,'$!storage')))
      ?? SELF.DELETE-POS(pos.Int)
      !! SLICE_ONE_LIST( SELF, pos.Int, 'delete', $delete, %other );
}
multi sub postcircumfix:<[ ]>( \SELF, Any:D \pos, :$exists!, *%other ) is raw {
    $exists && nqp::not_i(nqp::elems(nqp::getattr(%other,Map,'$!storage')))
      ?? SELF.EXISTS-POS(pos.Int)
      !! SLICE_ONE_LIST( SELF, pos.Int, 'exists', $exists, %other );
}
multi sub postcircumfix:<[ ]>( \SELF, Any:D \pos, :$kv!, *%other ) is raw {
    $kv && nqp::not_i(nqp::elems(nqp::getattr(%other,Map,'$!storage')))
      ?? (SELF.EXISTS-POS(pos.Int) ?? (pos, SELF.AT-POS(pos.Int)) !! ())
      !! SLICE_ONE_LIST( SELF, pos.Int, 'kv', $kv, %other );
}
multi sub postcircumfix:<[ ]>( \SELF, Any:D \pos, :$p!, *%other ) is raw {
    $p && nqp::not_i(nqp::elems(nqp::getattr(%other,Map,'$!storage')))
      ?? (SELF.EXISTS-POS(pos.Int) ?? Pair.new(pos, SELF.AT-POS(pos.Int)) !! ())
      !! SLICE_ONE_LIST( SELF, pos.Int, 'p', $p, %other );
}
multi sub postcircumfix:<[ ]>( \SELF, Any:D \pos, :$k!, *%other ) is raw {
    $k && nqp::not_i(nqp::elems(nqp::getattr(%other,Map,'$!storage')))
      ?? (SELF.EXISTS-POS(pos.Int) ?? pos !! ())
      !! SLICE_ONE_LIST( SELF, pos.Int, 'k', $k, %other );
}
multi sub postcircumfix:<[ ]>( \SELF, Any:D \pos, :$v!, *%other ) is raw {
    $v && nqp::not_i(nqp::elems(nqp::getattr(%other,Map,'$!storage')))
      ?? (SELF.EXISTS-POS(pos.Int) ?? nqp::decont(SELF.AT-POS(pos.Int)) !! ())
      !! SLICE_ONE_LIST( SELF, pos.Int, 'v', $v, %other );
}

# @a[@i]
multi sub postcircumfix:<[ ]>( \SELF, Iterable:D \pos ) is raw {
    nqp::iscont(pos)
      ?? SELF.AT-POS(pos.Int)
      !! POSITIONS(SELF, pos).map({ SELF[$_] }).eager.list;
}
multi sub postcircumfix:<[ ]>(\SELF, Iterable:D \pos, Mu \val ) is raw {
    # MMD is not behaving itself so we do this by hand.
    if nqp::iscont(pos) {
        return SELF[pos.Int] = val;
    }

    # Prep an iterator that will assign Nils past end of rval
    my \rvlist :=
        do if  nqp::iscont(val)
            or not nqp::istype(val, Iterator)
               and not nqp::istype(val, Iterable) {
            (nqp::decont(val),).Slip
        }
        elsif nqp::istype(val, Iterator) {
            Slip.from-loop({ nqp::decont(val.pull-one) })
        }
        elsif nqp::istype(val, Iterable) {
            val.map({ nqp::decont($_) }).Slip
        }, (Nil xx Inf).Slip;

    if nqp::istype(SELF, Positional) {
        # For Positionals, preserve established/expected evaluation order.
        my $list   := List.new;
        my $target := nqp::getattr($list,List,'$!reified');

        # We try to reify indices eagerly first, in case doing so
        # manipulates SELF.  If pos is lazy or contains Whatevers/closures,
        # the SELF may start to reify as well.
        my \indices := POSITIONS(SELF, pos);
        indices.iterator.sink-all;

        # Extract the values/containers which will be assigned to, in case
        # reifying the rhs does crazy things like splicing SELF.
        my int $p = -1;
        nqp::bindpos($target,++$p,SELF[$_]) for indices;

        rvlist.EXISTS-POS($p);
        my \rviter := rvlist.iterator;
        $p = -1;
        my $elems = nqp::elems($target);
        nqp::atpos($target,$p) = rviter.pull-one
          while nqp::islt_i(++$p,$elems);
        $list
    }
    else { # The assumption for now is this must be Iterable
        # Lazy list assignment.  This is somewhat experimental and
        # semantics may change.
        my $target := SELF.iterator;
        my sub eagerize ($idx) {
            once $target := $target.cache.iterator;
            $idx ~~ Whatever ?? $target.elems !! $target.EXISTS-POS($idx);
        }
        my @poslist := POSITIONS(SELF, pos, :eagerize(&eagerize)).eager;
        my %keep;
        # TODO: we could also use a quanthash and count occurences of an
        # index to let things go to GC sooner.
        %keep{@poslist} = ();
        my $max = -1;
        my \rviter := rvlist.iterator;
        @poslist.map: -> $p {
            my $lv;
            for $max ^.. $p -> $i {
                $max = $i;
                my $lv := $target.pull-one;
                %keep{$i} := $lv
                  if %keep{$i}:exists and !($lv =:= IterationEnd);
            }
            $lv := %keep{$p};
            $lv = rviter.pull-one;
        };
    }
}
multi sub postcircumfix:<[ ]>(\SELF, Iterable:D \pos, :$BIND!) is raw {
    X::Bind::Slice.new(type => SELF.WHAT).throw;
}
multi sub postcircumfix:<[ ]>(\SELF, Iterable:D \pos,:$delete!,*%other) is raw {
    nqp::iscont(pos)
        ?? SLICE_ONE_LIST( SELF, pos.Int, 'delete', $delete, %other )
        !! SLICE_MORE_LIST(SELF,POSITIONS(SELF,pos),'delete',$delete,%other)
}
multi sub postcircumfix:<[ ]>(\SELF, Iterable:D \pos,:$exists!,*%other) is raw {
    nqp::iscont(pos)
        ?? SLICE_ONE_LIST( SELF, pos.Int, 'exists', $exists, %other )
        !! SLICE_MORE_LIST(SELF,POSITIONS(SELF,pos),'exists',$exists,%other)
}
multi sub postcircumfix:<[ ]>(\SELF, Iterable:D \pos, :$kv!, *%other) is raw {
    nqp::iscont(pos)
        ?? SLICE_ONE_LIST( SELF, pos.Int, 'kv', $kv, %other )
        !! SLICE_MORE_LIST(SELF,POSITIONS(SELF,pos),'kv',$kv,%other)
}
multi sub postcircumfix:<[ ]>(\SELF, Iterable:D \pos, :$p!, *%other) is raw {
    nqp::iscont(pos)
        ?? SLICE_ONE_LIST( SELF, pos.Int, 'p', $p, %other )
        !! SLICE_MORE_LIST(SELF,POSITIONS(SELF,pos),'p',$p,%other)
}
multi sub postcircumfix:<[ ]>(\SELF, Iterable:D \pos, :$k!, *%other) is raw {
    nqp::iscont(pos)
        ?? SLICE_ONE_LIST( SELF, pos.Int, 'k', $k, %other )
        !! SLICE_MORE_LIST(SELF,POSITIONS(SELF,pos),'k',$k,%other)
}
multi sub postcircumfix:<[ ]>(\SELF, Iterable:D \pos, :$v!, *%other) is raw {
    nqp::iscont(pos)
        ?? SLICE_ONE_LIST( SELF, pos.Int, 'v', $v, %other )
        !! SLICE_MORE_LIST(SELF,POSITIONS(SELF,pos),'v',$v,%other)
}

# @a[->{}]
multi sub postcircumfix:<[ ]>(\SELF, Callable:D $block ) is raw {
    nqp::stmts(
      (my $*INDEX = 'Effective index'),
      SELF[$block.pos(SELF)]
    )
}
multi sub postcircumfix:<[ ]>(\SELF, Callable:D $block, Mu \assignee ) is raw {
    nqp::stmts(
      (my $*INDEX = 'Effective index'),
      SELF[$block.pos(SELF)] = assignee
    )
}
multi sub postcircumfix:<[ ]>(\SELF, Callable:D $block, :$BIND!) is raw {
    X::Bind::Slice.new(type => SELF.WHAT).throw;
}
multi sub postcircumfix:<[ ]>(\SELF,Callable:D $block,:$delete!,*%other) is raw {
    nqp::stmts(
      (my $*INDEX = 'Effective index'),
      nqp::if(
        nqp::istype((my $pos := $block.pos(SELF)),Int),
        SLICE_ONE_LIST(  SELF,  $pos, 'delete', $delete, %other ),
        SLICE_MORE_LIST( SELF, @$pos, 'delete', $delete, %other )
      )
    )
}
multi sub postcircumfix:<[ ]>(\SELF,Callable:D $block,:$exists!,*%other) is raw {
    nqp::stmts(
      (my $*INDEX = 'Effective index'),
      nqp::if(
        nqp::istype((my $pos := $block.pos(SELF)),Int),
        SLICE_ONE_LIST(  SELF,  $pos, 'exists', $exists, %other ),
        SLICE_MORE_LIST( SELF, @$pos, 'exists', $exists, %other )
      )
    )
}
multi sub postcircumfix:<[ ]>(\SELF,Callable:D $block,:$kv!,*%other) is raw {
    nqp::stmts(
      (my $*INDEX = 'Effective index'),
      nqp::if(
        nqp::istype((my $pos := $block.pos(SELF)),Int),
        SLICE_ONE_LIST(  SELF,  $pos, 'kv', $kv, %other ),
        SLICE_MORE_LIST( SELF, @$pos, 'kv', $kv, %other )
      )
    )
}
multi sub postcircumfix:<[ ]>(\SELF,Callable:D $block,:$p!,*%other) is raw {
    nqp::stmts(
      (my $*INDEX = 'Effective index'),
      nqp::if(
        nqp::istype((my $pos := $block.pos(SELF)),Int),
        SLICE_ONE_LIST(  SELF,  $pos, 'p', $p, %other ),
        SLICE_MORE_LIST( SELF, @$pos, 'p', $p, %other )
      )
    )
}
multi sub postcircumfix:<[ ]>(\SELF,Callable:D $block,:$k!,*%other) is raw {
    nqp::stmts(
      (my $*INDEX = 'Effective index'),
      nqp::if(
        nqp::istype((my $pos := $block.pos(SELF)),Int),
        SLICE_ONE_LIST(  SELF,  $pos, 'k', $k, %other ),
        SLICE_MORE_LIST( SELF, @$pos, 'k', $k, %other )
      )
    )
}
multi sub postcircumfix:<[ ]>(\SELF,Callable:D $block,:$v!,*%other) is raw {
    nqp::stmts(
      (my $*INDEX = 'Effective index'),
      nqp::if(
        nqp::istype((my $pos := $block.pos(SELF)),Int),
        SLICE_ONE_LIST(  SELF,  $pos, 'v', $v, %other ),
        SLICE_MORE_LIST( SELF, @$pos, 'v', $v, %other )
      )
    )
}

# @a[*]
multi sub postcircumfix:<[ ]>( \SELF, Whatever:D ) is raw {
    SELF[^SELF.elems];
}
multi sub postcircumfix:<[ ]>( \SELF, Whatever:D, Mu \assignee ) is raw {
    SELF[^SELF.elems] = assignee;
}
multi sub postcircumfix:<[ ]>(\SELF, Whatever:D, :$BIND!) is raw {
    X::Bind::Slice.new(type => SELF.WHAT).throw;
}
multi sub postcircumfix:<[ ]>(\SELF, Whatever:D, :$delete!, *%other) is raw {
    SLICE_MORE_LIST( SELF, ^SELF.elems, 'delete', $delete, %other );
}
multi sub postcircumfix:<[ ]>(\SELF, Whatever:D, :$exists!, *%other) is raw {
    SLICE_MORE_LIST( SELF, ^SELF.elems, 'exists', $exists, %other );
}
multi sub postcircumfix:<[ ]>(\SELF, Whatever:D, :$kv!, *%other) is raw {
    SLICE_MORE_LIST( SELF, ^SELF.elems, 'kv', $kv, %other );
}
multi sub postcircumfix:<[ ]>(\SELF, Whatever:D, :$p!, *%other) is raw {
    SLICE_MORE_LIST( SELF, ^SELF.elems, 'p', $p, %other );
}
multi sub postcircumfix:<[ ]>(\SELF, Whatever:D, :$k!, *%other) is raw {
    SLICE_MORE_LIST( SELF, ^SELF.elems, 'k', $k, %other );
}
multi sub postcircumfix:<[ ]>(\SELF, Whatever:D, :$v!, *%other) is raw {
    nqp::elems(nqp::getattr(%other,Map,'$!storage'))
      ?? SLICE_MORE_LIST( SELF, ^SELF.elems, 'v', $v, %other )
      !! SELF[^SELF.elems];
}

# @a[**]
multi sub postcircumfix:<[ ]>(\SELF, HyperWhatever:D $, *%adv) is raw {
    X::NYI.new(feature => 'HyperWhatever in array index').throw;
}
multi sub postcircumfix:<[ ]>(\SELF, HyperWhatever:D $, Mu \assignee) is raw {
    X::NYI.new(feature => 'HyperWhatever in array index').throw;
}

# @a[]
multi sub postcircumfix:<[ ]>(\SELF, :$BIND!) is raw {
    X::Bind::ZenSlice.new(type => SELF.WHAT).throw;
}
multi sub postcircumfix:<[ ]>(\SELF, :$delete!, *%other) is raw {
    SLICE_MORE_LIST( SELF, ^SELF.elems, 'delete', $delete, %other );
}
multi sub postcircumfix:<[ ]>(\SELF, :$exists!, *%other) is raw {
    SLICE_MORE_LIST( SELF, ^SELF.elems, 'exists', $exists, %other );
}
multi sub postcircumfix:<[ ]>(\SELF, :$kv!, *%other) is raw {
    SLICE_MORE_LIST( SELF, ^SELF.elems, 'kv', $kv, %other );
}
multi sub postcircumfix:<[ ]>(\SELF, :$p!, *%other) is raw {
    SLICE_MORE_LIST( SELF, ^SELF.elems, 'p', $p, %other );
}
multi sub postcircumfix:<[ ]>(\SELF, :$k!, *%other) is raw {
    SLICE_MORE_LIST( SELF, ^SELF.elems, 'k', $k, %other );
}
multi sub postcircumfix:<[ ]>(\SELF, :$v!, *%other) is raw {
    nqp::elems(nqp::getattr(%other,Map,'$!storage'))
      ?? SLICE_MORE_LIST( SELF, ^SELF.elems, 'v', $v, %other )
      !! SELF[^SELF.elems];
}
multi sub postcircumfix:<[ ]>(\SELF, *%other) is raw {
    SELF.ZEN-POS(|%other);
}

#line 1 SETTING::src/core/multidim_slice.pm
# all sub postcircumfix [;] candidates here please
proto sub postcircumfix:<[; ]>(|) is nodal { * }

sub MD-ARRAY-SLICE-ONE-POSITION(\SELF, \indices, \idx, int $dim, \target) is raw {
    my int $next-dim = $dim + 1;
    if $next-dim < indices.elems {
        if nqp::istype(idx, Iterable) && !nqp::iscont(idx) {
            for idx {
                MD-ARRAY-SLICE-ONE-POSITION(SELF, indices, $_, $dim, target)
            }
        }
        elsif nqp::istype(idx, Int) {
            MD-ARRAY-SLICE-ONE-POSITION(SELF.AT-POS(idx), indices, indices.AT-POS($next-dim), $next-dim, target)
        }
        elsif nqp::istype(idx, Whatever) {
            for ^SELF.elems {
                MD-ARRAY-SLICE-ONE-POSITION(SELF.AT-POS($_), indices, indices.AT-POS($next-dim), $next-dim, target)
            }
        }
        elsif nqp::istype(idx, Callable) {
            MD-ARRAY-SLICE-ONE-POSITION(SELF, indices, idx.(|(SELF.elems xx (idx.count == Inf ?? 1 !! idx.count))), $dim, target);
        }
        else  {
            MD-ARRAY-SLICE-ONE-POSITION(SELF.AT-POS(idx.Int), indices, indices.AT-POS($next-dim), $next-dim, target)
        }
    }
    else {
        if nqp::istype(idx, Iterable) && !nqp::iscont(idx) {
            for idx {
                MD-ARRAY-SLICE-ONE-POSITION(SELF, indices, $_, $dim, target)
            }
        }
        elsif nqp::istype(idx, Int) {
            nqp::push(target, SELF.AT-POS(idx))
        }
        elsif nqp::istype(idx, Whatever) {
            for ^SELF.elems {
                nqp::push(target, SELF.AT-POS($_))
            }
        }
        elsif nqp::istype(idx, Callable) {
            nqp::push(target, SELF.AT-POS(idx.(|(SELF.elems xx (idx.count == Inf ?? 1 !! idx.count)))))
        }
        else {
            nqp::push(target, SELF.AT-POS(idx.Int))
        }
    }
}
sub MD-ARRAY-SLICE(\SELF, @indices) is raw {
    my \target = IterationBuffer.new;
    MD-ARRAY-SLICE-ONE-POSITION(SELF, @indices, @indices.AT-POS(0), 0, target);
    nqp::p6bindattrinvres(nqp::create(List), List, '$!reified', target)
}

multi sub postcircumfix:<[; ]>(\SELF, @indices) is raw {
    nqp::stmts(
      (my $indices := nqp::getattr(@indices,List,'$!reified')),
      (my int $elems = nqp::elems($indices)),
      (my int $i = -1),
      nqp::while(
        nqp::islt_i(($i = nqp::add_i($i,1)),$elems)
          && nqp::istype(nqp::atpos($indices,$i),Int),
        nqp::null
      ),
      nqp::if(
        nqp::islt_i($i,$elems),
        MD-ARRAY-SLICE(SELF,@indices),
        nqp::if(
          nqp::iseq_i($elems,2),
          SELF.AT-POS(
            nqp::atpos($indices,0),
            nqp::atpos($indices,1)
          ),
          nqp::if(
            nqp::iseq_i($elems,3),
            SELF.AT-POS(
              nqp::atpos($indices,0),
              nqp::atpos($indices,1),
              nqp::atpos($indices,2)
            ),
            SELF.AT-POS(|@indices)
          )
        )
      )
    )
}

multi sub postcircumfix:<[; ]>(\SELF, @indices, Mu \assignee) is raw {
    nqp::stmts(
      (my int $elems = @indices.elems),   # reifies
      (my $indices := nqp::getattr(@indices,List,'$!reified')),
      (my int $i = -1),
      nqp::while(
        nqp::islt_i(($i = nqp::add_i($i,1)),$elems)
          && nqp::istype(nqp::atpos($indices,$i),Int),
        nqp::null
      ),
      nqp::if(
        nqp::islt_i($i,$elems),
        (MD-ARRAY-SLICE(SELF,@indices) = assignee),
        nqp::if(
          nqp::iseq_i($elems,2),
          SELF.ASSIGN-POS(
            nqp::atpos($indices,0),
            nqp::atpos($indices,1),
            assignee
          ),
          nqp::if(
            nqp::iseq_i($elems,3),
            SELF.ASSIGN-POS(
              nqp::atpos($indices,0),
              nqp::atpos($indices,1),
              nqp::atpos($indices,2),
              assignee
            ),
            SELF.ASSIGN-POS(|@indices,assignee)
          )
        )
      )
    )
}

multi sub postcircumfix:<[; ]>(\SELF, @indices, :$BIND!) is raw {
    nqp::stmts(
      (my int $elems = @indices.elems),   # reifies
      (my $indices := nqp::getattr(@indices,List,'$!reified')),
      (my int $i = -1),
      nqp::while(
        nqp::islt_i(($i = nqp::add_i($i,1)),$elems)
          && nqp::istype(nqp::atpos($indices,$i),Int),
        nqp::null
      ),
      nqp::if(
        nqp::islt_i($i,$elems),
        X::Bind::Slice.new(type => SELF.WHAT).throw,
        nqp::if(
          nqp::iseq_i($elems,2),
          SELF.BIND-POS(
            nqp::atpos($indices,0),
            nqp::atpos($indices,1),
            $BIND
          ),
          nqp::if(
            nqp::iseq_i($elems,3),
            SELF.BIND-POS(
              nqp::atpos($indices,0),
              nqp::atpos($indices,1),
              nqp::atpos($indices,2),
              $BIND
            ),
            SELF.BIND-POS(|@indices, $BIND)
          )
        )
      )
    )
}

multi sub postcircumfix:<[; ]>(\SELF, @indices, :$delete!) is raw {
    nqp::if(
      $delete,
      nqp::stmts(
        (my int $elems = @indices.elems),   # reifies
        (my $indices := nqp::getattr(@indices,List,'$!reified')),
        (my int $i = -1),
        nqp::while(
          nqp::islt_i(($i = nqp::add_i($i,1)),$elems)
            && nqp::istype(nqp::atpos($indices,$i),Int),
          nqp::null
        ),
        nqp::if(
          nqp::islt_i($i,$elems),
          Failure.new(X::NYI.new(
            feature => ':delete on multi-dimensional slices')),
          nqp::if(
            nqp::iseq_i($elems,2),
            SELF.DELETE-POS(
              nqp::atpos($indices,0),
              nqp::atpos($indices,1)
            ),
            nqp::if(
              nqp::iseq_i($elems,3),
              SELF.DELETE-POS(
                nqp::atpos($indices,0),
                nqp::atpos($indices,1),
                nqp::atpos($indices,2)
              ),
              SELF.DELETE-POS(|@indices)
            )
          )
        )
      ),
      postcircumfix:<[; ]>(SELF, @indices)
    )
}

multi sub postcircumfix:<[; ]>(\SELF, @indices, :$exists!) is raw {
    nqp::if(
      $exists,
      nqp::stmts(
        (my int $elems = @indices.elems),   # reifies
        (my $indices := nqp::getattr(@indices,List,'$!reified')),
        (my int $i = -1),
        nqp::while(
          nqp::islt_i(($i = nqp::add_i($i,1)),$elems)
            && nqp::istype(nqp::atpos($indices,$i),Int),
          nqp::null
        ),
        nqp::if(
          nqp::islt_i($i,$elems),
          Failure.new(X::NYI.new(
            feature => ':exists on multi-dimensional slices')),
          nqp::if(
            nqp::iseq_i($elems,2),
            SELF.EXISTS-POS(
              nqp::atpos($indices,0),
              nqp::atpos($indices,1)
            ),
            nqp::if(
              nqp::iseq_i($elems,3),
              SELF.EXISTS-POS(
                nqp::atpos($indices,0),
                nqp::atpos($indices,1),
                nqp::atpos($indices,2)
              ),
              SELF.EXISTS-POS(|@indices)
            )
          )
        )
      ),
      postcircumfix:<[; ]>(SELF, @indices)
    )
}

multi sub postcircumfix:<[; ]>(\SELF, @indices, :$kv!) is raw {
    nqp::if(
      $kv,
      nqp::stmts(
        (my int $elems = @indices.elems),   # reifies
        (my $indices := nqp::getattr(@indices,List,'$!reified')),
        (my int $i = -1),
        nqp::while(
          nqp::islt_i(($i = nqp::add_i($i,1)),$elems)
            && nqp::istype(nqp::atpos($indices,$i),Int),
          nqp::null
        ),
        nqp::if(
          nqp::islt_i($i,$elems),
          Failure.new(X::NYI.new(
            feature => ':kv on multi-dimensional slices')),
          nqp::if(
            nqp::iseq_i($elems,2),
            nqp::if(
              SELF.EXISTS-POS(
                nqp::atpos($indices,0),
                nqp::atpos($indices,1)
              ),
              (@indices, SELF.AT-POS(
                nqp::atpos($indices,0),
                nqp::atpos($indices,1)
              )),
              ()
            ),
            nqp::if(
              nqp::iseq_i($elems,3),
              nqp::if(
                SELF.EXISTS-POS(
                  nqp::atpos($indices,0),
                  nqp::atpos($indices,1),
                  nqp::atpos($indices,2)
                ),
                (@indices, SELF.AT-POS(
                  nqp::atpos($indices,0),
                  nqp::atpos($indices,1),
                  nqp::atpos($indices,2)
                )),
                ()
              ),
              nqp::if(
                SELF.EXISTS-POS(|@indices),
                (@indices, SELF.AT-POS(|@indices)),
                ()
              )
            )
          )
        )
      ),
      postcircumfix:<[; ]>(SELF, @indices)
    )
}

multi sub postcircumfix:<[; ]>(\SELF, @indices, :$p!) is raw {
    nqp::if(
      $p,
      nqp::stmts(
        (my int $elems = @indices.elems),   # reifies
        (my $indices := nqp::getattr(@indices,List,'$!reified')),
        (my int $i = -1),
        nqp::while(
          nqp::islt_i(($i = nqp::add_i($i,1)),$elems)
            && nqp::istype(nqp::atpos($indices,$i),Int),
          nqp::null
        ),
        nqp::if(
          nqp::islt_i($i,$elems),
          Failure.new(X::NYI.new(
            feature => ':p on multi-dimensional slices')),
          nqp::if(
            nqp::iseq_i($elems,2),
            nqp::if(
              SELF.EXISTS-POS(
                nqp::atpos($indices,0),
                nqp::atpos($indices,1)
              ),
              Pair.new(@indices, SELF.AT-POS(
                nqp::atpos($indices,0),
                nqp::atpos($indices,1)
              )),
              ()
            ),
            nqp::if(
              nqp::iseq_i($elems,3),
              nqp::if(
                SELF.EXISTS-POS(
                  nqp::atpos($indices,0),
                  nqp::atpos($indices,1),
                  nqp::atpos($indices,2)
                ),
                Pair.new(@indices, SELF.AT-POS(
                  nqp::atpos($indices,0),
                  nqp::atpos($indices,1),
                  nqp::atpos($indices,2)
                )),
                ()
              ),
              nqp::if(
                SELF.EXISTS-POS(|@indices),
                Pair.new(@indices, SELF.AT-POS(|@indices)),
                ()
              )
            )
          )
        )
      ),
      postcircumfix:<[; ]>(SELF, @indices)
    )
}

multi sub postcircumfix:<[; ]>(\SELF, @indices, :$k!) is raw {
    nqp::if(
      $k,
      nqp::stmts(
        (my int $elems = @indices.elems),   # reifies
        (my $indices := nqp::getattr(@indices,List,'$!reified')),
        (my int $i = -1),
        nqp::while(
          nqp::islt_i(($i = nqp::add_i($i,1)),$elems)
            && nqp::istype(nqp::atpos($indices,$i),Int),
          nqp::null
        ),
        nqp::if(
          nqp::islt_i($i,$elems),
          Failure.new(X::NYI.new(
            feature => ':k on multi-dimensional slices')),
          nqp::if(
            nqp::iseq_i($elems,2),
            nqp::if(
              SELF.EXISTS-POS(
                nqp::atpos($indices,0),
                nqp::atpos($indices,1)
              ),
              @indices,
              ()
            ),
            nqp::if(
              nqp::iseq_i($elems,3),
              nqp::if(
                SELF.EXISTS-POS(
                  nqp::atpos($indices,0),
                  nqp::atpos($indices,1),
                  nqp::atpos($indices,2)
                ),
                @indices,
                ()
              ),
              nqp::if(
                SELF.EXISTS-POS(|@indices),
                @indices,
                ()
              )
            )
          )
        )
      ),
      postcircumfix:<[; ]>(SELF, @indices)
    )
}

multi sub postcircumfix:<[; ]>(\SELF, @indices, :$v!) is raw {
    nqp::if(
      $v,
      nqp::stmts(
        (my int $elems = @indices.elems),   # reifies
        (my $indices := nqp::getattr(@indices,List,'$!reified')),
        (my int $i = -1),
        nqp::while(
          nqp::islt_i(($i = nqp::add_i($i,1)),$elems)
            && nqp::istype(nqp::atpos($indices,$i),Int),
          nqp::null
        ),
        nqp::if(
          nqp::islt_i($i,$elems),
          Failure.new(X::NYI.new(
            feature => ':v on multi-dimensional slices')),
          nqp::if(
            nqp::iseq_i($elems,2),
            nqp::if(
              SELF.EXISTS-POS(
                nqp::atpos($indices,0),
                nqp::atpos($indices,1)
              ),
              nqp::decont(SELF.AT-POS(
                nqp::atpos($indices,0),
                nqp::atpos($indices,1)
              )),
              ()
            ),
            nqp::if(
              nqp::iseq_i($elems,3),
              nqp::if(
                SELF.EXISTS-POS(
                  nqp::atpos($indices,0),
                  nqp::atpos($indices,1),
                  nqp::atpos($indices,2)
                ),
                nqp::decont(SELF.AT-POS(
                  nqp::atpos($indices,0),
                  nqp::atpos($indices,1),
                  nqp::atpos($indices,2)
                )),
                ()
              ),
              nqp::if(
                SELF.EXISTS-POS(|@indices),
                nqp::decont(SELF.AT-POS(|@indices)),
                ()
              )
            )
          )
        )
      ),
      postcircumfix:<[; ]>(SELF, @indices)
    )
}

#line 1 SETTING::src/core/Slip.pm
# A Slip is a kind of List that is immediately incorporated into an iteration
# or another List. Other than that, it's a totally normal List.
my class Slip { # is List
    multi method Slip(Slip:D:) { self }
    method defined ()          { self.so }
    method CALL-ME (+args)     { args.Slip }
    multi method perl(Slip:D:) {
        nqp::if(
          nqp::eqaddr(self,Empty),
          'Empty',
          nqp::stmts(
            (my str $guts = callsame),
            nqp::if(
              nqp::eqat($guts,'$',0), # we're itemized
              nqp::concat('$(slip',nqp::concat(nqp::substr($guts,1),')')),
              nqp::concat('slip',$guts)
            )
          )
        )
    }
    multi method List(Slip:D:) {
        nqp::stmts(
          (my $list := nqp::create(List)),
          nqp::if(
            nqp::getattr(self,List,'$!todo').DEFINITE,
            nqp::bindattr($list,List,'$!todo',
              nqp::getattr(self,List,'$!todo'))
          ),
          nqp::if(
            nqp::getattr(self,List,'$!reified').DEFINITE,
            nqp::bindattr($list,List,'$!reified',
              nqp::getattr(self,List,'$!reified'))
          ),
          $list
        )
    }
}

# The slip(...) function creates a Slip.
proto slip(|)     { * }
multi slip()      { Empty }
multi slip(@args) { @args.Slip }
multi slip(+args) { args.Slip }

#line 1 SETTING::src/core/Array.pm
# for our tantrums
my class X::TypeCheck { ... };
my class X::TypeCheck::Splice { ... }
my class X::Subscript::Negative { ... };
my class X::NotEnoughDimensions { ... };
my class X::Assignment::ArrayShapeMismatch { ... };

# stub what we need now
my class array is repr('VMArray') { ... };

# An Array is a List that ensures every item added to it is in a Scalar
# container. It also supports push, pop, shift, unshift, splice, BIND-POS,
# and so forth.
my class Array { # declared in BOOTSTRAP
    # class Array is List
    #     has Mu $!descriptor;

    my class ArrayReificationTarget {
        has $!target;
        has $!descriptor;

        method new(\target, Mu \descriptor) {
            nqp::stmts(
              nqp::bindattr((my \rt = nqp::create(self)),
                self,'$!target',target),
              nqp::p6bindattrinvres(rt,
                self,'$!descriptor',descriptor)
            )
        }

        method push(Mu \value) {
            nqp::push($!target,
                nqp::assign(nqp::p6scalarfromdesc($!descriptor), value));
        }
    }

    my class ListReificationTarget {
        has $!target;

        method new(\target) {
            nqp::p6bindattrinvres(nqp::create(self), self, '$!target', target);
        }

        method push(Mu \value) {
            nqp::push($!target,
                nqp::decont(value));
        }
    }

    multi method clone(Array:D:) { [self] }

    method iterator(Array:D:) {

        # something to iterate over in the future
        if nqp::getattr(self,List,'$!todo').DEFINITE {
            class :: does Iterator {
                has int $!i;
                has $!array;
                has $!reified;
                has $!todo;
                has $!descriptor;

                method !SET-SELF(\array) {
                    $!i           = -1;
                    $!array      := array;
                    $!reified    :=
                      nqp::ifnull(
                        nqp::getattr( array,List,'$!reified'),
                        nqp::bindattr(array,List,'$!reified',
                          nqp::create(IterationBuffer))
                      );
                    $!todo       := nqp::getattr(array,List, '$!todo');
                    $!descriptor := nqp::getattr(array,Array,'$!descriptor');
                    self
                }
                method new(\array) { nqp::create(self)!SET-SELF(array) }

                method pull-one() is raw {
                    nqp::ifnull(
                      nqp::atpos($!reified,$!i = nqp::add_i($!i,1)),
                      nqp::islt_i($!i,nqp::elems($!reified))
                        ?? self!found-hole
                        !! $!todo.DEFINITE
                          ?? nqp::islt_i($!i,$!todo.reify-at-least(nqp::add_i($!i,1)))
                            ?? nqp::atpos($!reified,$!i) # cannot be nqp::null
                            !! self!done
                          !! IterationEnd
                    )
                }
                method !found-hole() {
                   nqp::p6bindattrinvres(
                     (my \v := nqp::p6scalarfromdesc($!descriptor)),
                     Scalar,
                     '$!whence',
                     -> { nqp::bindpos($!reified,$!i,v) }
                   )
                }
                method !done() is raw {
                    $!todo := nqp::bindattr($!array,List,'$!todo',Mu);
                    IterationEnd
                }

                method push-until-lazy($target) {
                    if $!todo.DEFINITE {
                        my int $elems = $!todo.reify-until-lazy;
                        nqp::while(   # doesn't sink
                          nqp::islt_i($!i = nqp::add_i($!i,1),$elems),
                          $target.push(nqp::atpos($!reified,$!i))
                        );
                        nqp::if(
                          $!todo.fully-reified,
                          self!done,
                          nqp::stmts(
                            ($!i = nqp::sub_i($elems,1)),
                            Mu
                          )
                        )
                    }
                    else {
                        my int $elems = nqp::elems($!reified);
                        nqp::while(   # doesn't sink
                          nqp::islt_i($!i = nqp::add_i($!i,1),$elems),
                          $target.push(
                            nqp::ifnull(
                              nqp::atpos($!reified,$!i),
                              nqp::p6bindattrinvres(
                                (my \v := nqp::p6scalarfromdesc($!descriptor)),
                                Scalar,
                                '$!whence',
                                -> { nqp::bindpos($!reified,$!i,v) }
                              )
                            )
                          )
                        );
                        IterationEnd
                    }
                }

                method is-lazy() { $!todo.DEFINITE && $!todo.is-lazy }
            }.new(self)
        }

        # everything we need is already there
        elsif nqp::getattr(self,List,'$!reified').DEFINITE {
            Rakudo::Iterator.ReifiedArray(
              self,
              nqp::getattr(self,Array,'$!descriptor')
            )
        }

        # nothing now or in the future to iterate over
        else {
            Rakudo::Iterator.Empty
        }
    }
    method from-iterator(Array:U: Iterator $iter) {
        nqp::if(
          nqp::eqaddr(
            $iter.push-until-lazy(
              my \target := ArrayReificationTarget.new(
                (my \buffer := nqp::create(IterationBuffer)),
                nqp::null
              )
            ),
            IterationEnd
          ),
          nqp::p6bindattrinvres(nqp::create(self),List,'$!reified',buffer),
          nqp::stmts(
            nqp::bindattr((my \result := nqp::create(self)),
              List,'$!reified',buffer),
            nqp::bindattr((my \todo := nqp::create(List::Reifier)),
              List::Reifier,'$!current-iter',$iter),
            nqp::bindattr(todo,
              List::Reifier,'$!reified',buffer),
            nqp::bindattr(todo,
              List::Reifier,'$!reification-target',target),
            nqp::p6bindattrinvres(result,List,'$!todo',todo)
          )
        )
    }

    proto method new(|) { * }
    multi method new(:$shape!) {
        nqp::if(
          nqp::defined($shape),
          set-shape(self,$shape),
          nqp::if(
            Metamodel::EnumHOW.ACCEPTS($shape.HOW),
            set-shape(self,$shape.^elems),
            nqp::create(self)
          )
        )
    }
    multi method new() {
        nqp::create(self)
    }
    multi method new(\values, :$shape!) {
        nqp::if(
          nqp::defined($shape),
          set-shape(self,$shape),
          nqp::if(
            Metamodel::EnumHOW.ACCEPTS($shape.HOW),
            set-shape(self,$shape.^elems),
            nqp::create(self)
          )
        ).STORE(values)
    }
    multi method new(\values) {
        nqp::create(self).STORE(values)
    }
    multi method new(**@values is raw, :$shape!) {
        nqp::if(
          nqp::defined($shape),
          set-shape(self,$shape),
          nqp::if(
            Metamodel::EnumHOW.ACCEPTS($shape.HOW),
            set-shape(self,$shape.^elems),
            nqp::create(self)
          )
        ).STORE(@values)
    }
    multi method new(**@values is raw) {
        nqp::create(self).STORE(@values)
    }

    proto method STORE(|) { * }
    multi method STORE(Array:D: Iterable:D \iterable) {
        nqp::iscont(iterable)
            ?? self!STORE-ONE(iterable)
            !! self!STORE-ITERABLE(iterable)
    }
    multi method STORE(Array:D: Mu \item) {
        self!STORE-ONE(item)
    }
    method !STORE-ITERABLE(\iterable) {
        my \new-storage = nqp::create(IterationBuffer);
        my \iter = iterable.iterator;
        my \target = ArrayReificationTarget.new(new-storage,
            nqp::decont($!descriptor));
        if iter.push-until-lazy(target) =:= IterationEnd {
            nqp::bindattr(self, List, '$!todo', Mu);
        }
        else {
            my \new-todo = nqp::create(List::Reifier);
            nqp::bindattr(new-todo, List::Reifier, '$!reified', new-storage);
            nqp::bindattr(new-todo, List::Reifier, '$!current-iter', iter);
            nqp::bindattr(new-todo, List::Reifier, '$!reification-target', target);
            nqp::bindattr(self, List, '$!todo', new-todo);
        }
        nqp::bindattr(self, List, '$!reified', new-storage);
        self
    }
    method !STORE-ONE(Mu \item) {
        my \new-storage = nqp::create(IterationBuffer);
        nqp::push(new-storage,
            nqp::assign(nqp::p6scalarfromdesc($!descriptor), item));
        nqp::bindattr(self, List, '$!reified', new-storage);
        nqp::bindattr(self, List, '$!todo', Mu);
        self
    }

    method reification-target() {
        ArrayReificationTarget.new(
            nqp::getattr(self, List, '$!reified'),
            nqp::decont($!descriptor))
    }

    multi method Slip(Array:D:) {

       # A Slip-With-Default is a special kind of Slip that also has a
       # descriptor to be able to generate containers for null elements that
       # have type and default information.
        my class Slip-With-Descriptor is Slip {
            has $!descriptor;

            method iterator() {
                Rakudo::Iterator.ReifiedArray(self,$!descriptor)
            }
            multi method AT-POS(Int:D $pos) {
                nqp::ifnull(
                  nqp::atpos(nqp::getattr(self,List,'$!reified'),$pos),
                  nqp::p6bindattrinvres(
                    (my $scalar := nqp::p6scalarfromdesc($!descriptor)),
                    Scalar,
                    '$!whence',
                    -> { nqp::bindpos(
                           nqp::getattr(self,List,'$!reified'),$pos,$scalar) }
                  )
                )
            }
            method default() { $!descriptor.default }
        }
        BEGIN Slip-With-Descriptor.^set_name("Slip");

        nqp::if(
          nqp::getattr(self,List,'$!todo').DEFINITE,
          # We're not fully reified, and so have internal mutability still.
          # The safe thing to do is to take an iterator of ourself and build
          # the Slip out of that.
          Slip.from-iterator(self.iterator),
          # We're fully reified.  Make a Slip that shares our reified buffer
          # but that will fill in default values for nulls.
          nqp::if(
            nqp::getattr(self,List,'$!reified').DEFINITE,
            nqp::p6bindattrinvres(
              nqp::p6bindattrinvres(
                nqp::create(Slip-With-Descriptor),
                Slip-With-Descriptor,
                '$!descriptor',
                $!descriptor
              ),
              List,
              '$!reified',
              nqp::getattr(self,List,'$!reified')
            ),
            nqp::create(Slip)
          )
        )
    }

    method FLATTENABLE_LIST() {
        nqp::if(
          nqp::getattr(self,List,'$!todo').DEFINITE,
          nqp::stmts(
            nqp::getattr(self,List,'$!todo').reify-all,
            nqp::getattr(self,List,'$!reified')
          ),
          nqp::if(
            (my $reified := nqp::getattr(self,List,'$!reified')).DEFINITE,
            nqp::stmts(
              nqp::if(
                (my int $elems = nqp::elems($reified)),
                nqp::stmts(
                  (my int $i = -1),
                  nqp::while(
                    nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                    nqp::if(
                      nqp::isnull(nqp::atpos($reified,$i)),
                      nqp::bindpos(
                        $reified,
                        $i,
                        nqp::p6scalarfromdesc($!descriptor)
                      )
                    )
                  )
                )
              ),
              nqp::getattr(self,List,'$!reified')
            ),
            nqp::bindattr(self,List,'$!reified',nqp::create(IterationBuffer))
          )
        )
    }

    multi method flat(Array:U:) { self }
    multi method flat(Array:D:) { Seq.new(self.iterator) }

    multi method List(Array:D: :$view) {
        nqp::if(
          self.is-lazy,                           # can't make a List
          X::Cannot::Lazy.new(:action<List>).throw,

          nqp::if(                                # all reified
            (my $reified := nqp::getattr(self,List,'$!reified')).DEFINITE,
            nqp::if(
              $view,                              # assume no change in array
              nqp::p6bindattrinvres(
                nqp::create(List),List,'$!reified',$reified),
              nqp::stmts(                         # make cow copy
                (my int $elems = nqp::elems($reified)),
                (my $cow := nqp::setelems(nqp::create(IterationBuffer),$elems)),
                (my int $i = -1),
                nqp::while(
                  nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                  nqp::bindpos($cow,$i,nqp::ifnull(nqp::decont(nqp::atpos($reified,$i)),Nil)),
                ),
                nqp::p6bindattrinvres(nqp::create(List),List,'$!reified',$cow)
              )
            ),
            nqp::create(List)                     # was empty, is empty
          )
        )
    }

    method shape() { (*,) }

    multi method AT-POS(Array:D: int $pos) is raw {
        nqp::if(
          nqp::islt_i($pos,0),
          Failure.new(X::OutOfRange.new(
            :what($*INDEX // 'Index'),:got($pos),:range<0..^Inf>)),
          nqp::if(
            (my $reified := nqp::getattr(self,List,'$!reified')).DEFINITE,
            nqp::ifnull(
              nqp::atpos($reified,$pos),           # found it!
              nqp::if(
                nqp::islt_i(
                  $pos,nqp::elems(nqp::getattr(self,List,'$!reified'))),
                self!AT-POS-CONTAINER($pos),       # it's a hole
                nqp::if(                           # too far out, try reifying
                  (my $todo := nqp::getattr(self,List,'$!todo')).DEFINITE,
                  nqp::stmts(
                    $todo.reify-at-least(nqp::add_i($pos,1)),
                    nqp::ifnull(
                      nqp::atpos($reified,$pos),   # reified ok
                      self!AT-POS-CONTAINER($pos)  # reifier didn't reach
                    )
                  ),
                  self!AT-POS-CONTAINER($pos)      # create an outlander
                )
              )
            ),
            # no reified, implies no todo
            nqp::stmts(                            # create reified
              nqp::bindattr(self,List,'$!reified',nqp::create(IterationBuffer)),
              self!AT-POS-CONTAINER($pos)          # create an outlander
            )
          )
        )
    }
    # because this is a very hot path, we copied the code from the int candidate
    multi method AT-POS(Array:D: Int:D $pos) is raw {
        nqp::if(
          nqp::islt_i($pos,0),
          Failure.new(X::OutOfRange.new(
            :what($*INDEX // 'Index'),:got($pos),:range<0..^Inf>)),
          nqp::if(
            (my $reified := nqp::getattr(self,List,'$!reified')).DEFINITE,
            nqp::ifnull(
              nqp::atpos($reified,$pos),           # found it!
              nqp::if(
                nqp::islt_i(
                  $pos,nqp::elems(nqp::getattr(self,List,'$!reified'))),
                self!AT-POS-CONTAINER($pos),       # it's a hole
                nqp::if(                           # too far out, try reifying
                  (my $todo := nqp::getattr(self,List,'$!todo')).DEFINITE,
                  nqp::stmts(
                    $todo.reify-at-least(nqp::add_i($pos,1)),
                    nqp::ifnull(
                      nqp::atpos($reified,$pos),   # reified ok
                      self!AT-POS-CONTAINER($pos)  # reifier didn't reach
                    )
                  ),
                  self!AT-POS-CONTAINER($pos)      # create an outlander
                )
              )
            ),
            # no reified, implies no todo
            nqp::stmts(                            # create reified
              nqp::bindattr(self,List,'$!reified',nqp::create(IterationBuffer)),
              self!AT-POS-CONTAINER($pos)          # create an outlander
            )
          )
        )
    }
    method !AT-POS-CONTAINER(int $pos) is raw {
        nqp::p6bindattrinvres(
          (my $scalar := nqp::p6scalarfromdesc($!descriptor)),
          Scalar,
          '$!whence',
          -> { nqp::bindpos(nqp::getattr(self,List,'$!reified'),$pos,$scalar) }
        )
    }

    multi method ASSIGN-POS(Array:D: int $pos, Mu \assignee) {
        nqp::if(
          nqp::islt_i($pos,0),
          Failure.new(X::OutOfRange.new(
            :what($*INDEX // 'Index'),:got($pos),:range<0..^Inf>)),
          nqp::if(
            (my $reified := nqp::getattr(self,List,'$!reified')).DEFINITE,
            nqp::if(
              nqp::existspos($reified,$pos),
              (nqp::atpos($reified,$pos) = assignee),         # found it!
              nqp::if(
                nqp::islt_i($pos,nqp::elems($reified)),       # it's a hole
                (nqp::bindpos($reified,$pos,
                  nqp::p6scalarfromdesc($!descriptor)) = assignee),
                nqp::if(
                  (my $todo := nqp::getattr(self,List,'$!todo')).DEFINITE,
                  nqp::stmts(                                 # can reify
                    $todo.reify-at-least(nqp::add_i($pos,1)),
                    nqp::if(
                      nqp::existspos($reified,$pos),
                      (nqp::atpos($reified,$pos) = assignee), # reified
                      (nqp::bindpos($reified,$pos,            # outlander
                        nqp::p6scalarfromdesc($!descriptor)) = assignee),
                    )
                  ),
                  (nqp::bindpos($reified,$pos,                # outlander
                    nqp::p6scalarfromdesc($!descriptor)) = assignee)
                )
              )
            ),
            nqp::stmts(                                       # new outlander
              nqp::bindattr(self,List,'$!reified',nqp::create(IterationBuffer)),
              (nqp::bindpos(nqp::getattr(self,List,'$!reified'),$pos,
                nqp::p6scalarfromdesc($!descriptor)) = assignee)
            )
          )
        )
    }
    # because this is a very hot path, we copied the code from the int candidate
    multi method ASSIGN-POS(Array:D: Int:D $pos, Mu \assignee) {
        nqp::if(
          nqp::islt_i($pos,0),
          Failure.new(X::OutOfRange.new(
            :what($*INDEX // 'Index'),:got($pos),:range<0..^Inf>)),
          nqp::if(
            (my $reified := nqp::getattr(self,List,'$!reified')).DEFINITE,
            nqp::if(
              nqp::existspos($reified,$pos),
              (nqp::atpos($reified,$pos) = assignee),         # found it!
              nqp::if(
                nqp::islt_i($pos,nqp::elems($reified)),       # it's a hole
                (nqp::bindpos($reified,$pos,
                  nqp::p6scalarfromdesc($!descriptor)) = assignee),
                nqp::if(
                  (my $todo := nqp::getattr(self,List,'$!todo')).DEFINITE,
                  nqp::stmts(                                 # can reify
                    $todo.reify-at-least(nqp::add_i($pos,1)),
                    nqp::if(
                      nqp::existspos($reified,$pos),
                      (nqp::atpos($reified,$pos) = assignee), # reified
                      (nqp::bindpos($reified,$pos,            # outlander
                        nqp::p6scalarfromdesc($!descriptor)) = assignee),
                    )
                  ),
                  (nqp::bindpos($reified,$pos,                # outlander
                    nqp::p6scalarfromdesc($!descriptor)) = assignee)
                )
              )
            ),
            nqp::stmts(                                       # new outlander
              nqp::bindattr(self,List,'$!reified',nqp::create(IterationBuffer)),
              (nqp::bindpos(nqp::getattr(self,List,'$!reified'),$pos,
                nqp::p6scalarfromdesc($!descriptor)) = assignee)
            )
          )
        )
    }

    multi method BIND-POS(Array:D: int $pos, Mu \bindval) is raw {
        nqp::if(
          nqp::islt_i($pos,0),
          Failure.new(X::OutOfRange.new(
            :what($*INDEX // 'Index'),:got($pos),:range<0..^Inf>)),
          nqp::stmts(
            nqp::if(
              nqp::getattr(self,List,'$!reified').DEFINITE,
              nqp::if(
                (nqp::isge_i(
                  $pos,nqp::elems(nqp::getattr(self,List,'$!reified')))
                    && nqp::getattr(self,List,'$!todo').DEFINITE),
                nqp::getattr(self,List,'$!todo').reify-at-least(
                  nqp::add_i($pos,1)),
              ),
              nqp::bindattr(self,List,'$!reified',nqp::create(IterationBuffer))
            ),
            nqp::bindpos(nqp::getattr(self,List,'$!reified'),$pos,bindval)
          )
        )
    }
    # because this is a very hot path, we copied the code from the int candidate
    multi method BIND-POS(Array:D: Int:D $pos, Mu \bindval) is raw {
        nqp::if(
          nqp::islt_i($pos,0),
          Failure.new(X::OutOfRange.new(
            :what($*INDEX // 'Index'),:got($pos),:range<0..^Inf>)),
          nqp::stmts(
            nqp::if(
              nqp::getattr(self,List,'$!reified').DEFINITE,
              nqp::if(
                (nqp::isge_i(
                  $pos,nqp::elems(nqp::getattr(self,List,'$!reified')))
                    && nqp::getattr(self,List,'$!todo').DEFINITE),
                nqp::getattr(self,List,'$!todo').reify-at-least(
                  nqp::add_i($pos,1)),
              ),
              nqp::bindattr(self,List,'$!reified',nqp::create(IterationBuffer))
            ),
            nqp::bindpos(nqp::getattr(self,List,'$!reified'),$pos,bindval)
          )
        )
    }

    multi method DELETE-POS(Array:D: int $pos) is raw {
        nqp::if(
          nqp::islt_i($pos,0),
          Failure.new(X::OutOfRange.new(
            :what($*INDEX // 'Index'),:got($pos),:range<0..^Inf>)),
          nqp::if(
            (my $reified := nqp::getattr(self,List,'$!reified')).DEFINITE,
            nqp::stmts(
              nqp::if(
                (my $todo := nqp::getattr(self,List,'$!todo')).DEFINITE,
                $todo.reify-at-least(nqp::add_i($pos,1)),
              ),
              nqp::if(
                nqp::isle_i(                               # something to delete
                  $pos,my int $end = nqp::sub_i(nqp::elems($reified),1)),
                nqp::stmts(
                  (my $value := nqp::ifnull(               # save the value
                    nqp::atpos($reified,$pos),
                    self.default
                  )),
                  nqp::bindpos($reified,$pos,nqp::null),   # remove this one
                  nqp::if(
                    nqp::iseq_i($pos,$end) && nqp::not_i(nqp::defined($todo)),
                    nqp::stmts(                            # shorten from end
                      (my int $i = $pos),
                      nqp::while(
                        (nqp::isge_i(($i = nqp::sub_i($i,1)),0)
                          && nqp::not_i(nqp::existspos($reified,$i))),
                        nqp::null
                      ),
                      nqp::setelems($reified,nqp::add_i($i,1))
                    ),
                  ),
                  $value                                   # value, if any
                ),
                self.default                               # outlander
              ),
            ),
            self.default                                 # no elements
          )
        )
    }
    multi method DELETE-POS(Array:D: Int:D $pos) is raw {
        self.DELETE-POS(nqp::unbox_i($pos))
    }

    # MUST have a separate Slip variant to have it slip
    multi method push(Array:D: Slip \value) {
        self.is-lazy
          ?? X::Cannot::Lazy.new(action => 'push to').throw
          !! self!append-list(value)
    }
    multi method push(Array:D: \value) {
        nqp::if(
          self.is-lazy,
          X::Cannot::Lazy.new(action => 'push to').throw,
          nqp::stmts(
            nqp::push(
              nqp::if(
                nqp::getattr(self,List,'$!reified').DEFINITE,
                nqp::getattr(self,List,'$!reified'),
                nqp::bindattr(self,List,'$!reified',
                  nqp::create(IterationBuffer))
              ),
              nqp::assign(nqp::p6scalarfromdesc($!descriptor),value)
            ),
            self
          )
        )
    }
    multi method push(Array:D: **@values is raw) {
        self.is-lazy
          ?? X::Cannot::Lazy.new(action => 'push to').throw
          !! self!append-list(@values)
    }

    multi method append(Array:D: \value) {
        nqp::if(
          self.is-lazy,
          X::Cannot::Lazy.new(action => 'append to').throw,
          nqp::if(
            (nqp::iscont(value) || nqp::not_i(nqp::istype(value, Iterable))),
            nqp::stmts(
              nqp::push(
                nqp::if(
                  nqp::getattr(self,List,'$!reified').DEFINITE,
                  nqp::getattr(self,List,'$!reified'),
                  nqp::bindattr(self,List,'$!reified',
                    nqp::create(IterationBuffer))
                ),
                nqp::assign(nqp::p6scalarfromdesc($!descriptor),value)
              ),
              self
            ),
            self!append-list(value.list)
          )
        )
    }
    multi method append(Array:D: **@values is raw) {
        self.is-lazy
          ?? X::Cannot::Lazy.new(action => 'append to').throw
          !! self!append-list(@values)
    }
    method !append-list(@values) {
        nqp::if(
          nqp::eqaddr(
            @values.iterator.push-until-lazy(
              ArrayReificationTarget.new(
                nqp::if(
                  nqp::getattr(self,List,'$!reified').DEFINITE,
                  nqp::getattr(self,List,'$!reified'),
                  nqp::bindattr(self,List,'$!reified',
                    nqp::create(IterationBuffer))
                ),
                nqp::decont($!descriptor)
              )
            ),
            IterationEnd
          ),
          self,
          X::Cannot::Lazy.new(:action<push>,:what(self.^name)).throw
        )
    }

    multi method unshift(Array:D: Slip \value) {
        self!prepend-list(value)
    }
    multi method unshift(Array:D: \value) {
        nqp::stmts(
          nqp::unshift(
            nqp::if(
              nqp::getattr(self,List,'$!reified').DEFINITE,
              nqp::getattr(self,List,'$!reified'),
              nqp::bindattr(self,List,'$!reified',
                nqp::create(IterationBuffer))
            ),
            nqp::assign(nqp::p6scalarfromdesc($!descriptor),value)
          ),
          self
        )
    }
    multi method unshift(Array:D: **@values is raw) {
        self!prepend-list(@values)
    }
    multi method prepend(Array:D: \value) {
        nqp::if(
          (nqp::iscont(value) || nqp::not_i(nqp::istype(value, Iterable))),
          nqp::stmts(
            nqp::unshift(
              nqp::if(
                nqp::getattr(self,List,'$!reified').DEFINITE,
                nqp::getattr(self,List,'$!reified'),
                nqp::bindattr(self,List,'$!reified',
                  nqp::create(IterationBuffer))
              ),
              nqp::assign(nqp::p6scalarfromdesc($!descriptor),value)
            ),
            self
          ),
          self!prepend-list(value.list)
        )
    }
    multi method prepend(Array:D: **@values is raw) {
        self!prepend-list(@values)
    }
    method !prepend-list(@values) {
        nqp::stmts(
          nqp::if(
            nqp::getattr(self,List,'$!reified').DEFINITE,
            nqp::splice(nqp::getattr(self,List,'$!reified'), # prepend existing
              nqp::stmts(
                @values.iterator.push-all(
                  ArrayReificationTarget.new(
                    (my $containers := nqp::create(IterationBuffer)),
                    nqp::decont($!descriptor)
                  )
                ),
                $containers
              ),
              0,
              0
            ),
            @values.iterator.push-all(        # no list yet, make this it
              ArrayReificationTarget.new(
                nqp::bindattr(self,List,'$!reified',
                  nqp::create(IterationBuffer)),
                nqp::decont($!descriptor)
              )
            )
          ),
          self
        )
    }

    method pop(Array:D:) is raw is nodal {
        nqp::if(
          self.is-lazy,
          Failure.new(X::Cannot::Lazy.new(action => 'pop from')),
          nqp::if(
            (nqp::getattr(self,List,'$!reified').DEFINITE
              && nqp::elems(nqp::getattr(self,List,'$!reified'))),
            nqp::pop(nqp::getattr(self,List,'$!reified')),
            Failure.new(X::Cannot::Empty.new(:action<pop>,:what(self.^name)))
          )
        )
    }

    method shift(Array:D:) is raw is nodal {
        nqp::if(
          nqp::getattr(self,List,'$!reified').DEFINITE
            && nqp::elems(nqp::getattr(self,List,'$!reified')),
          nqp::ifnull(  # handle holes
            nqp::shift(nqp::getattr(self,List,'$!reified')),
            Nil
          ),
          nqp::if(
            (nqp::getattr(self,List,'$!todo').DEFINITE
              && nqp::getattr(self,List,'$!todo').reify-at-least(1)),
            nqp::shift(nqp::getattr(self,List,'$!reified')),
            Failure.new(X::Cannot::Empty.new(:action<shift>,:what(self.^name)))
          )
        )
    }

    my $empty := nqp::create(IterationBuffer); # splicing in without values
    #------ splice() candidates
    multi method splice(Array:D \SELF:) {
        nqp::if(
          nqp::getattr(SELF,List,'$!reified').DEFINITE,
          nqp::stmts(
            (my $result := nqp::create(SELF)),
            nqp::bindattr($result,Array,'$!descriptor',$!descriptor),
            nqp::stmts(       # transplant the internals
              nqp::bindattr($result,List,'$!reified',
                nqp::getattr(SELF,List,'$!reified')),
              nqp::if(
                nqp::getattr(SELF,List,'$!todo').DEFINITE,
                nqp::bindattr($result,List,'$!todo',
                  nqp::getattr(SELF,List,'$!todo')),
              )
            ),
            (SELF = nqp::create(SELF)),  # XXX this preserves $!descriptor ??
            $result
          ),
          nqp::p6bindattrinvres(   # nothing to return, so create new one
            nqp::create(SELF),Array,'$!descriptor',$!descriptor)
        )
    }

    #------ splice(offset) candidates
    multi method splice(Array:D: Whatever $) {
        nqp::p6bindattrinvres(     # nothing to return, so create new one
          nqp::create(self),Array,'$!descriptor',$!descriptor)
    }
    multi method splice(Array:D: Callable:D $offset) {
        self.splice($offset(self.elems))
    }
    multi method splice(Array:D: Int:D $offset) {
        nqp::if(
          $offset,
          nqp::if(
            nqp::islt_i(nqp::unbox_i($offset),0),
            self!splice-offset-fail($offset),
            nqp::if(
              (my $todo := nqp::getattr(self,List,'$!todo')).DEFINITE,
              nqp::if(
                nqp::isge_i(
                  $todo.reify-at-least($offset),nqp::unbox_i($offset)),
                self!splice-offset(nqp::unbox_i($offset)),
                self!splice-offset-fail($offset)
              ),
              nqp::if(
                (nqp::getattr(self,List,'$!reified').DEFINITE
                  && nqp::isge_i(
                    nqp::elems(nqp::getattr(self,List,'$!reified')),
                    nqp::unbox_i($offset))),
                self!splice-offset(nqp::unbox_i($offset)),
                self!splice-offset-fail($offset)
              )
            )
          ),
          self.splice       # offset 0, take the quick route out
        )
    }
    method !splice-offset(int $offset) {
        nqp::stmts(
          (my int $elems = nqp::elems(nqp::getattr(self,List,'$!reified'))),
          (my int $size  = nqp::sub_i($elems,$offset)),
          nqp::bindattr((my $result:= nqp::create(self)),List,'$!reified',
            (my $buffer := nqp::setelems(nqp::create(IterationBuffer),$size))),
          nqp::bindattr($result,Array,'$!descriptor',$!descriptor),
          (my int $i = nqp::sub_i($offset,1)),
          nqp::while(
            nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
            nqp::bindpos($buffer,nqp::sub_i($i,$offset),
              nqp::atpos(nqp::getattr(self,List,'$!reified'),$i))
          ),
          nqp::splice(
            nqp::getattr(self,List,'$!reified'),$empty,$offset,$size),
          $result
        )
    }
    method !splice-offset-fail($got) {
        X::OutOfRange.new(
          :what('Offset argument to splice'), :$got, :range("0..{self.elems}")
        ).throw
    }

    #------ splice(offset,size) candidates
    multi method splice(Array:D: Whatever $, Whatever $) {
        nqp::p6bindattrinvres(     # nothing to return, so create new one
          nqp::create(self),Array,'$!descriptor',$!descriptor)
    }
    multi method splice(Array:D: Whatever $, Int:D $size) {
        self.splice(self.elems,$size)
    }
    multi method splice(Array:D: Whatever $, Callable:D $size) {
        my int $elems = self.elems;
        self.splice($elems,$size(nqp::sub_i($elems,$elems)));
    }
    multi method splice(Array:D: Callable:D $offset, Callable:D $size) {
        nqp::stmts(
          (my int $elems = self.elems),
          (my int $from  = $offset($elems)),
          self.splice($from,$size(nqp::sub_i($elems,$from)))
        )
    }
    multi method splice(Array:D: Callable:D $offset, Whatever $) {
        self.splice($offset(self.elems))
    }
    multi method splice(Array:D: Callable:D $offset, Int:D $size) {
        self.splice($offset(self.elems),$size)
    }
    multi method splice(Array:D: Int:D $offset, Whatever $) {
        self.splice($offset)
    }
    multi method splice(Array:D: Int:D $offset, Callable:D $size) {
        self.splice($offset,$size(self.elems - $offset))
    }
    multi method splice(Array:D: Int:D $offset, Int:D $size) {
        nqp::if(
          nqp::islt_i(nqp::unbox_i($offset),0),
          self!splice-offset-fail($offset),
          nqp::if(
            nqp::islt_i(nqp::unbox_i($size),0),
            self!splice-size-fail($size,$offset),
            nqp::if(
              (my $todo := nqp::getattr(self,List,'$!todo')).DEFINITE,
              nqp::if(
                nqp::isge_i(
                  $todo.reify-at-least(
                    nqp::add_i(nqp::unbox_i($offset),nqp::unbox_i($size))
                  ),nqp::unbox_i($offset)),
                self!splice-offset-size(
                  nqp::unbox_i($offset),nqp::unbox_i($size)),
                self!splice-size-fail($size,$offset)
              ),
              nqp::if(
                nqp::getattr(self,List,'$!reified').DEFINITE,
                nqp::if(
                  nqp::isge_i(
                    nqp::elems(nqp::getattr(self,List,'$!reified')),
                    nqp::unbox_i($offset)),
                  self!splice-offset-size(
                    nqp::unbox_i($offset),nqp::unbox_i($size)),
                  self!splice-size-fail($size,$offset)
                ),
                nqp::if(
                  nqp::iseq_i(nqp::unbox_i($offset),0),
                  nqp::p6bindattrinvres(     # nothing to return, create new
                    nqp::create(self),Array,'$!descriptor',$!descriptor),
                  self!splice-offset-fail($offset)
                )
              )
            )
          )
        )
    }
    method !splice-offset-size(int $offset,int $size) {
        nqp::stmts(
          (my $result := self!splice-save($offset,$size,my int $removed)),
          nqp::splice(
            nqp::getattr(self,List,'$!reified'),$empty,$offset,$removed),
          $result
        )
    }
    method !splice-save(int $offset,int $size, \removed) {
        nqp::stmts(
          (removed = nqp::if(
            nqp::isgt_i(
              nqp::add_i($offset,$size),
              nqp::elems(nqp::getattr(self,List,'$!reified'))
            ),
            nqp::sub_i(nqp::elems(nqp::getattr(self,List,'$!reified')),$offset),
            $size
          )),
          nqp::if(
            removed,
            nqp::stmts(
              nqp::bindattr((my $saved:= nqp::create(self)),List,'$!reified',
                (my $buffer :=
                  nqp::setelems(nqp::create(IterationBuffer),removed))),
              nqp::bindattr($saved,Array,'$!descriptor',$!descriptor),
              (my int $i = -1),
              nqp::while(
                nqp::islt_i(($i = nqp::add_i($i,1)),removed),
                nqp::bindpos($buffer,$i,nqp::atpos(
                  nqp::getattr(self,List,'$!reified'),nqp::add_i($offset,$i)))
              ),
              $saved
            ),
            nqp::p6bindattrinvres(     # effective size = 0, create new one
              nqp::create(self),Array,'$!descriptor',$!descriptor)
          )
        )
    }
    method !splice-size-fail($got,$offset) {
        nqp::if(
          $offset > self.elems,
          self!splice-offset-fail($offset),
          X::OutOfRange.new(
            :what('Size argument to splice'),
            :$got,
            :range("0..^{self.elems - $offset}")
          ).throw
        )
    }
    #------ splice(offset,size,array) candidates

    # we have these 9 multies to avoid infiniloop when incorrect types are
    # given to $offset/$size. Other attempts to resolve this showed 30%+
    # performance decreases
    multi method splice(Array:D: Whatever   $offset, Whatever   $size, **@new) { self.splice($offset, $size, @new) }
    multi method splice(Array:D: Whatever   $offset, Callable:D $size, **@new) { self.splice($offset, $size, @new) }
    multi method splice(Array:D: Whatever   $offset, Int:D      $size, **@new) { self.splice($offset, $size, @new) }
    multi method splice(Array:D: Callable:D $offset, Whatever   $size, **@new) { self.splice($offset, $size, @new) }
    multi method splice(Array:D: Callable:D $offset, Callable:D $size, **@new) { self.splice($offset, $size, @new) }
    multi method splice(Array:D: Callable:D $offset, Int:D      $size, **@new) { self.splice($offset, $size, @new) }
    multi method splice(Array:D: Int:D      $offset, Whatever   $size, **@new) { self.splice($offset, $size, @new) }
    multi method splice(Array:D: Int:D      $offset, Callable:D $size, **@new) { self.splice($offset, $size, @new) }
    multi method splice(Array:D: Int:D      $offset, Int:D      $size, **@new) { self.splice($offset, $size, @new) }

    multi method splice(Array:D: Whatever $, Whatever $, @new) {
        self.splice(self.elems,0,@new)
    }
    multi method splice(Array:D: Whatever $, Int:D $size, @new) {
        self.splice(self.elems,$size,@new)
    }
    multi method splice(Array:D: Whatever $, Callable:D $size, @new) {
        my int $elems = self.elems;
        self.splice($elems,$size(nqp::sub_i($elems,$elems)),@new);
    }
    multi method splice(Array:D: Callable:D $offset, Callable:D $size, @new) {
        nqp::stmts(
          (my int $elems = self.elems),
          (my int $from  = $offset($elems)),
          self.splice($from,$size(nqp::sub_i($elems,$from)),@new)
        )
    }
    multi method splice(Array:D: Callable:D $offset, Whatever $, @new) {
        nqp::stmts(
          (my int $elems = self.elems),
          (my int $from  = $offset($elems)),
          self.splice($from,nqp::sub_i($elems,$from),@new)
        )
    }
    multi method splice(Array:D: Callable:D $offset, Int:D $size, @new) {
        self.splice($offset(self.elems),$size,@new)
    }
    multi method splice(Array:D: Int:D $offset, Whatever $, @new) {
        self.splice($offset,self.elems - $offset,@new)
    }
    multi method splice(Array:D: Int:D $offset, Callable:D $size, @new) {
        self.splice($offset,$size(self.elems - $offset),@new)
    }
    multi method splice(Array:D: Int:D $offset, Int:D $size, @new) {
        nqp::if(
          nqp::islt_i(nqp::unbox_i($offset),0),
          self!splice-offset-fail($offset),
          nqp::if(
            nqp::islt_i(nqp::unbox_i($size),0),
            self!splice-size-fail($size,$offset),
            nqp::if(
              (my $todo := nqp::getattr(self,List,'$!todo')).DEFINITE,
              nqp::if(
                nqp::isge_i(
                  $todo.reify-at-least(
                    nqp::add_i(nqp::unbox_i($offset),nqp::unbox_i($size))
                  ),nqp::unbox_i($offset)),
                self!splice-offset-size-new(
                  nqp::unbox_i($offset),nqp::unbox_i($size),@new),
                self!splice-size-fail($size,$offset)
              ),
              nqp::if(
                nqp::isge_i(
                  nqp::elems(nqp::if(
                    nqp::getattr(self,List,'$!reified').DEFINITE,
                    nqp::getattr(self,List,'$!reified'),
                    nqp::bindattr(self,List,'$!reified',
                      nqp::create(IterationBuffer))
                  )),
                  nqp::unbox_i($offset),
                ),
                self!splice-offset-size-new(
                  nqp::unbox_i($offset),nqp::unbox_i($size),@new),
                self!splice-offset-fail($offset)
              )
            )
          )
        )
    }
    method !splice-offset-size-new(int $offset,int $size,@new) {
        nqp::if(
          nqp::eqaddr(@new.iterator.push-until-lazy(
            (my $new := IterationBuffer.new)),IterationEnd),
          nqp::if(      # reified all values to splice in
            (nqp::isnull($!descriptor) || nqp::eqaddr(self.of,Mu)),
            nqp::stmts( # no typecheck needed
              (my $result := self!splice-save($offset,$size,my int $removed)),
              nqp::splice(
                nqp::getattr(self,List,'$!reified'),$new,$offset,$removed),
              $result
            ),
            nqp::stmts( # typecheck the values first
              (my $expected := self.of),
              (my int $elems = nqp::elems($new)),
              (my int $i = -1),
              nqp::while(
                (nqp::islt_i(($i = nqp::add_i($i,1)),$elems)
                  && nqp::istype(nqp::atpos($new,$i),$expected)),
                nqp::null
              ),
              nqp::if(
                nqp::islt_i($i,$elems),   # exited loop because of wrong type
                X::TypeCheck::Splice.new(
                  :action<splice>,
                  :got(nqp::atpos($new,$i).WHAT),
                  :$expected
                ).throw,
                nqp::stmts(
                  ($result := self!splice-save($offset,$size,$removed)),
                  nqp::splice(
                    nqp::getattr(self,List,'$!reified'),$new,$offset,$removed),
                  $result
                )
              )
            )
          ),
          X::Cannot::Lazy.new(:action('splice in')).throw
        )
    }

    multi method tail(Array:D: $n) {
        nqp::if(
          nqp::getattr(self,List,'$!todo').DEFINITE,
          self.Any::tail($n),
          Seq.new(
            nqp::if(
              (my $reified := nqp::getattr(self,List,'$!reified')).DEFINITE
                && nqp::elems($reified),
              nqp::stmts(
                (my $iterator := Rakudo::Iterator.ReifiedArray(
                  self,
                  nqp::getattr(self,Array,'$!descriptor')
                )),
                nqp::if(
                  nqp::istype($n,Callable)
                    && nqp::isgt_i((my $skip := -($n(0).Int)),0),
                  $iterator.skip-at-least($skip),
                  nqp::unless(
                    nqp::istype($n,Whatever) || $n == Inf,
                    $iterator.skip-at-least(nqp::elems($reified) - $n)
                  )
                ),
                $iterator
              ),
              Rakudo::Iterator.Empty
            )
          )
        )
    }

    # introspection
    method name() {
        nqp::isnull($!descriptor) ?? Nil !! $!descriptor.name
    }
    method of() {
        nqp::isnull($!descriptor) ?? Mu !! $!descriptor.of
    }
    method default() {
        nqp::isnull($!descriptor) ?? Any !! $!descriptor.default
    }
    method dynamic() {
        nqp::isnull($!descriptor) ?? False !! so $!descriptor.dynamic
    }
    multi method perl(Array:D \SELF:) {
        SELF.perlseen('Array', {
             '$' x nqp::iscont(SELF)  # self is always deconted
             ~ '['
             ~ self.map({nqp::decont($_).perl}).join(', ')
             ~ ',' x (self.elems == 1 && nqp::istype(self.AT-POS(0),Iterable))
             ~ ']'
        })
    }
    multi method gist(Array:D:) {
        self.gistseen('Array', { '[' ~ self.map({.gist}).join(' ') ~ ']' } )
    }
    multi method WHICH(Array:D:) { self.Mu::WHICH }

#=============== class Array is closed in src/core/TypedArray.pm ===============

#line 1 SETTING::src/core/ShapedArray.pm
# this is actually part of the Array class

    my role ShapedArray does Rakudo::Internals::ShapedArrayCommon {
        has $.shape;

        # Handle dimensions > 3 or more indices than dimensions.
        # If dimensions <= 3, then custom AT-POS should have caught
        # correct number of indices already.
        multi method AT-POS(::?CLASS:D: **@indices) is raw {
            nqp::stmts(
              (my $reified := nqp::getattr(self,List,'$!reified')),
              nqp::if(
                nqp::islt_i(
                  @indices.elems,                    # reifies
                  (my int $numdims = nqp::numdimensions($reified))
                ),
                X::NYI.new(
                  feature => "Partially dimensioned views of shaped arrays").throw,
                nqp::stmts(
                  (my $indices := nqp::getattr(@indices,List,'$!reified')),
                  (my $idxs := nqp::list_i),
                  nqp::while(                        # native index list
                    nqp::isge_i(($numdims = nqp::sub_i($numdims,1)),0),
                    nqp::push_i($idxs,nqp::shift($indices))
                  ),
                  (my $element := nqp::ifnull(
                    nqp::atposnd($reified,$idxs),    # found it
                    nqp::p6bindattrinvres(           # create container
                      (my $scalar := nqp::p6scalarfromdesc(
                        nqp::getattr(self,Array,'$!descriptor'))),
                      Scalar,
                      '$!whence',
                      -> { nqp::bindposnd($reified,$idxs,$scalar) }
                    )
                  )),
                  nqp::if(
                    nqp::elems($indices),
                    $element.AT-POS(|@indices),      # index further
                    $element                         # we're done!
                  )
                )
              )
            )
        }

        multi method ASSIGN-POS(::?CLASS:D: **@indices) {
            nqp::stmts(
              (my $value   := @indices.pop),         # reifies
              (my $indices := nqp::getattr(@indices,List,'$!reified')),
              (my $reified := nqp::getattr(self,List,'$!reified')),
              nqp::if(
                nqp::isge_i(
                  (my int $numind  = nqp::elems($indices)),
                  (my int $numdims = nqp::numdimensions($reified))
                ),
                nqp::stmts(                          # more than enough indices
                  (my $idxs := nqp::list_i),
                  nqp::while(                        # native index list
                    nqp::isge_i(($numdims = nqp::sub_i($numdims,1)),0),
                    nqp::push_i($idxs,nqp::shift($indices))
                  ),
                  (my $element := nqp::ifnull(
                    nqp::atposnd($reified,$idxs),    # found it!
                    nqp::bindposnd($reified,$idxs,   # create new scalar
                      nqp::p6scalarfromdesc(
                        nqp::getattr(self,Array,'$!descriptor')))
                  )),
                  nqp::if(
                    nqp::elems($indices),
                    $element.AT-POS(|@indices),      # go deeper
                    $element                         # this is it
                  ) = $value                         # and assign
                ),
                X::NotEnoughDimensions.new(          # too few indices
                  operation         => 'assign to',
                  got-dimensions    => $numind,
                  needed-dimensions => $numdims
                ).throw
              )
            )
        }

        multi method EXISTS-POS(::?CLASS:D: **@indices) {
            nqp::p6bool(
              nqp::stmts(
                (my int $numind = @indices.elems),     # reifies
                (my $indices := nqp::getattr(@indices,List,'$!reified')),
                (my $reified := nqp::getattr(self,List,'$!reified')),
                (my $dims    := nqp::dimensions($reified)),
                (my int $i = -1),
                nqp::if(
                  nqp::isge_i(
                    $numind,
                    (my int $numdims = nqp::numdimensions($reified)),
                  ),
                  nqp::stmts(                          # same or more indices
                    (my $idxs := nqp::list_i),
                    nqp::while(
                      nqp::islt_i(                     # still indices left
                        ($i = nqp::add_i($i,1)),
                        $numind)
                        && nqp::islt_i(                # within range?
                             (my $idx = nqp::shift($indices)),
                             nqp::atpos_i($dims,$i)),
                      nqp::push_i($idxs,$idx)
                    ),
                    nqp::if(
                      nqp::iseq_i($i,$numind)
                        && nqp::not_i(
                             nqp::isnull(nqp::atposnd($reified,$idxs))),
                      nqp::unless(                     # base pos exists
                        nqp::not_i(nqp::elems($indices)),
                        nqp::atposnd($reified,$idxs).EXISTS-POS(|@indices)
                      )
                    )
                  ),
                  nqp::stmts(                          # fewer inds than dims
                    nqp::while(
                      nqp::islt_i(($i = nqp::add_i($i,1)),$numind)
                        && nqp::islt_i(
                             nqp::atpos($indices,$i),
                             nqp::atpos_i($dims,$i)),
                      nqp::null
                    ),
                    nqp::iseq_i($i,$numind)            # all clear or oor
                  )
                )
              )
            )
        }

        proto method DELETE-POS(|) {*}
        multi method DELETE-POS(::?CLASS:U: |c) {
            self.Any::DELETE-POS(|c)
        }
        multi method DELETE-POS(::?CLASS:D:) is raw {
            die "Must specify at least one index with DELETE-POS"
        }

        multi method DELETE-POS(::?CLASS:D: **@indices) {
            nqp::stmts(
              (my int $numind = @indices.elems),     # reifies
              (my $indices := nqp::getattr(@indices,List,'$!reified')),
              (my $reified := nqp::getattr(self,List,'$!reified')),
              (my int $i = -1),
              nqp::if(
                nqp::isge_i(
                  $numind,
                  (my int $numdims = nqp::numdimensions($reified)),
                ),
                nqp::stmts(                          # same or more indices
                  (my $idxs := nqp::list_i),
                  nqp::while(
                    nqp::islt_i(                     # still indices left
                      ($i = nqp::add_i($i,1)),$numind),
                    nqp::push_i($idxs,nqp::shift($indices)),
                  ),
                  nqp::if(
                    nqp::isnull(my $value := nqp::atposnd($reified,$idxs)),
                    Nil,                             # nothing here
                    nqp::if(
                      nqp::elems($indices),
                      $value.DELETE-POS(|@indices),  # delete at deeper level
                      nqp::stmts(                    # found it, nullify here
                        nqp::bindposnd($reified,$idxs,nqp::null),
                        $value
                      )
                    )
                  )
                ),
                X::NotEnoughDimensions.new(          # fewer inds than dims
                  operation         => 'delete from',
                  got-dimensions    => $numind,
                  needed-dimensions => $numdims
                ).throw
              )
            )
        }

        proto method BIND-POS(|) is raw {*}
        multi method BIND-POS(::?CLASS:U: |c) is raw {
            self.Any::BIND-POS(|c)
        }
        multi method BIND-POS(::?CLASS:D:) {
            die "Must specify at least one index and a value with BIND-POS"
        }
        multi method BIND-POS(::?CLASS:D: $) {
            die "Must specify at least one index and a value with BIND-POS"
        }

        multi method BIND-POS(::?CLASS:D: **@indices) is raw {
            nqp::stmts(
              (my $value   := nqp::decont(@indices.pop)), # reifies
              (my $indices := nqp::getattr(@indices,List,'$!reified')),
              (my $reified := nqp::getattr(self,List,'$!reified')),
              (my int $i = -1),
              nqp::if(
                nqp::isge_i(
                  (my int $numind  = nqp::elems($indices)),
                  (my int $numdims = nqp::numdimensions($reified)),
                ),
                nqp::stmts(                               # same or more indices
                  (my $idxs := nqp::list_i),
                  nqp::while(
                    nqp::islt_i(                          # still indices left
                      ($i = nqp::add_i($i,1)),$numind),
                    nqp::push_i($idxs,nqp::shift($indices))
                  ),
                  nqp::if(
                    nqp::elems($indices),
                    nqp::atposnd($reified,$idxs)          # bind at deeper level
                      .BIND-POS(|@indices,$value),
                    nqp::bindposnd($reified,$idxs,        # found it, bind here
                      $value)
                  )
                ),
                X::NotEnoughDimensions.new(               # fewer inds than dims
                  operation         => 'bind to',
                  got-dimensions    => $numind,
                  needed-dimensions => $numdims
                ).throw
              )
            )
        }

        sub MEMCPY(Mu \to, Mu \from) {
            class :: does Rakudo::Iterator::ShapeLeaf {
                has $!from;
                has $!desc;
                method INIT(Mu \to, Mu \from) {
                    nqp::stmts(
                      ($!from := nqp::getattr(from,List,'$!reified')),
                      ($!desc := nqp::getattr(from,Array,'$!descriptor')),
                      self.SET-SELF(to)
                    )
                }
                method new(Mu \to, Mu \from) { nqp::create(self).INIT(to,from) }
                method result(--> Nil) {
                    nqp::ifnull(
                      nqp::atposnd($!list,$!indices),
                      nqp::bindposnd($!list,$!indices,
                        nqp::p6scalarfromdesc($!desc))
                    ) = nqp::atposnd($!from,$!indices)
                }
            }.new(to,from).sink-all
        }
        sub INTCPY(Mu \to, Mu \from) {
            class :: does Rakudo::Iterator::ShapeLeaf {
                has $!from;
                method INIT(Mu \to, Mu \from) {
                    nqp::stmts(
                      ($!from := from),
                      self.SET-SELF(to)
                    )
                }
                method new(Mu \to, Mu \from) { nqp::create(self).INIT(to,from) }
                method result(--> Nil) {
                    nqp::ifnull(
                      nqp::atposnd($!list,$!indices),
                      nqp::bindposnd($!list,$!indices,nqp::p6scalarfromdesc(Mu))

                      ) = nqp::multidimref_i($!from,$!indices)




                }
            }.new(to,from).sink-all
        }
        sub NUMCPY(Mu \to, Mu \from) {
            class :: does Rakudo::Iterator::ShapeLeaf {
                has $!from;
                method INIT(Mu \to, Mu \from) {
                    nqp::stmts(
                      ($!from := from),
                      self.SET-SELF(to)
                    )
                }
                method new(Mu \to, Mu \from) { nqp::create(self).INIT(to,from) }
                method result(--> Nil) {
                    nqp::ifnull(
                      nqp::atposnd($!list,$!indices),
                      nqp::bindposnd($!list,$!indices,nqp::p6scalarfromdesc(Mu))

                      ) = nqp::multidimref_n($!from,$!indices)




                }
            }.new(to,from).sink-all
        }

        proto method STORE(|) { * }
        multi method STORE(::?CLASS:D: ::?CLASS:D \in) {
            nqp::if(
              in.shape eqv self.shape,
              nqp::stmts(
                MEMCPY(self,in),     # VM-supported memcpy-like thing?
                self
              ),
              X::Assignment::ArrayShapeMismatch.new(
                source-shape => in.shape,
                target-shape => self.shape
              ).throw
            )
        }
        multi method STORE(::?CLASS:D: array:D \in) {
            nqp::if(
              in.shape eqv self.shape,
              nqp::stmts(
                nqp::if(
                  nqp::istype(in.of,Int),
                  INTCPY(self,in),     # copy from native int
                  NUMCPY(self,in)      # copy from native num
                ),
                self
              ),
              X::Assignment::ArrayShapeMismatch.new(
                source-shape => in.shape,
                target-shape => self.shape
              ).throw
            )
        }
        multi method STORE(::?CLASS:D: Iterable:D \in) {
            class :: does Rakudo::Iterator::ShapeBranch {
                has $!iterators;
                has $!desc;
                method INIT(\to,\from) {
                    nqp::stmts(
                      self.SET-SELF(to),
                      ($!desc := nqp::getattr(to,Array,'$!descriptor')),
                      ($!iterators := nqp::setelems(
                        nqp::list(from.iterator),
                        nqp::add_i($!maxdim,1)
                      )),
                      self
                    )
                }
                method new(\to,\from) { nqp::create(self).INIT(to,from) }
                method done(--> Nil) {
                    nqp::unless(                        # verify lowest
                      nqp::atpos($!iterators,0).is-lazy # finite iterator
                        || nqp::eqaddr(                 # and something there
                             nqp::atpos($!iterators,0).pull-one,IterationEnd),
                      nqp::atposnd($!list,$!indices)    # boom!
                    )
                }
                method process(--> Nil) {
                    nqp::stmts(
                      (my int $i = $!level),
                      nqp::while(
                        nqp::isle_i(($i = nqp::add_i($i,1)),$!maxdim),
                        nqp::if(
                          nqp::eqaddr((my $item :=      # exhausted ?
                            nqp::atpos($!iterators,nqp::sub_i($i,1)).pull-one),
                            IterationEnd
                          ),
                          nqp::bindpos($!iterators,$i,  # add an empty one
                            Rakudo::Iterator.Empty),
                          nqp::if(                      # is it an iterator?
                            nqp::istype($item,Iterable) && nqp::isconcrete($item),
                            nqp::bindpos($!iterators,$i,$item.iterator),
                            X::Assignment::ToShaped.new(shape => self.dims).throw
                          )
                        )
                      ),
                      (my $iter := nqp::atpos($!iterators,$!maxdim)),
                      nqp::until(                       # loop over highest dim
                        nqp::eqaddr((my $pulled := $iter.pull-one),IterationEnd)
                          || nqp::isgt_i(nqp::atpos_i($!indices,$!maxdim),$!maxind),
                        nqp::stmts(
                          (nqp::ifnull(                 # containerize if needed
                            nqp::atposnd($!list,$!indices),
                            nqp::bindposnd($!list,$!indices,
                              nqp::p6scalarfromdesc($!desc))
                          ) = $pulled),
                          nqp::bindpos_i($!indices,$!maxdim,  # increment index
                            nqp::add_i(nqp::atpos_i($!indices,$!maxdim),1))
                        )
                      ),
                      nqp::unless(
                        nqp::eqaddr($pulled,IterationEnd) # if not exhausted
                          || nqp::isle_i(                 # and index too high
                               nqp::atpos_i($!indices,$!maxdim),$!maxind)
                          || $iter.is-lazy,               # and not lazy
                        nqp::atposnd($!list,$!indices)    # error
                      )
                    )
                }
            }.new(self,in).sink-all;
            self
        }
        multi method STORE(::?CLASS:D: Iterator:D \iterator) {
            class :: does Rakudo::Iterator::ShapeLeaf {
                has Mu $!iterator;
                has Mu $!desc;
                method INIT(\list,\iterator) {
                    nqp::stmts(
                      ($!iterator := iterator),
                      ($!desc := nqp::getattr(list,Array,'$!descriptor')),
                      self.SET-SELF(list)
                    )
                }
                method new(\list,\iter) { nqp::create(self).INIT(list,iter) }
                method result(--> Nil) {
                    nqp::unless(
                      nqp::eqaddr(
                        (my $pulled := $!iterator.pull-one),IterationEnd),
                      nqp::ifnull(
                        nqp::atposnd($!list,$!indices),
                        nqp::bindposnd($!list,$!indices,
                          nqp::p6scalarfromdesc($!desc))
                      ) = $pulled
                    )
                }
            }.new(self,iterator).sink-all;
            self
        }
        multi method STORE(::?CLASS:D: Mu \item) {
            X::Assignment::ToShaped.new(shape => self.shape).throw
        }

        multi method kv(::?CLASS:D:) {
            Seq.new(class :: does Rakudo::Iterator::ShapeLeaf {
                has int $!on-key;
                method result() is raw {
                    nqp::if(
                      ($!on-key = nqp::not_i($!on-key)),
                      nqp::stmts(
                        (my $result := self.indices),
                        (nqp::bindpos_i($!indices,$!maxdim,  # back 1 for next
                          nqp::sub_i(nqp::atpos_i($!indices,$!maxdim),1))),
                        $result
                      ),
                      nqp::atposnd($!list,$!indices)
                    )
                }
                # needs its own push-all since it fiddles with $!indices
                method push-all($target --> IterationEnd) {
                    nqp::until(
                      nqp::eqaddr((my $pulled := self.pull-one),IterationEnd),
                      $target.push($pulled)
                    )
                }
            }.new(self))
        }
        multi method pairs(::?CLASS:D:) {
            Seq.new(class :: does Rakudo::Iterator::ShapeLeaf {
                has Mu $!desc;
                method !INIT(\list) {
                    nqp::stmts(
                      ($!desc := nqp::getattr(list,Array,'$!descriptor')),
                      self.SET-SELF(list)
                    )
                }
                method new(Mu \list) { nqp::create(self)!INIT(list) }
                method result() {
                    Pair.new(
                      self.indices,
                      nqp::ifnull(
                        nqp::atposnd($!list,$!indices),
                        nqp::stmts(
                          # By the time the block gets executed, the $!indices
                          # may be at the next iteration already or even reset
                          # because we reached the end.  So we need to make
                          # a copy of the indices now.
                          (my $indices := nqp::clone($!indices)),
                          nqp::p6bindattrinvres(
                            (my $scalar := nqp::p6scalarfromdesc($!desc)),
                            Scalar,
                           '$!whence',
                            -> { nqp::bindposnd($!list,$indices,$scalar) }
                          )
                        )
                      )
                    )
                }
            }.new(self))
        }
        multi method antipairs(::?CLASS:D:) {
            Seq.new(class :: does Rakudo::Iterator::ShapeLeaf {
                method result() {
                    Pair.new(nqp::atposnd($!list,$!indices),self.indices)
                }
            }.new(self))
        }

        multi method List(::?CLASS:D:) {
            nqp::stmts(
              self.iterator.push-all(
                (my $list := nqp::create(IterationBuffer))),
              nqp::p6bindattrinvres(nqp::create(List),List,'$!reified',$list)
            )
        }

        method iterator(::?CLASS:D:) {
            class :: does Rakudo::Iterator::ShapeLeaf {
                has Mu $!desc;
                method !INIT(\list) {
                    nqp::stmts(
                      ($!desc := nqp::getattr(list,Array,'$!descriptor')),
                      self.SET-SELF(list)
                    )
                }
                method new(Mu \list) { nqp::create(self)!INIT(list) }
                method result() is raw {
                    nqp::ifnull(
                      nqp::atposnd($!list,$!indices),
                      nqp::stmts(
                        # By the time the block gets executed, the $!indices
                        # may be at the next iteration already or even reset
                        # because we reached the end.  So we need to make
                        # a copy of the indices now.
                        (my $indices := nqp::clone($!indices)),
                        nqp::p6bindattrinvres(
                          (my $scalar := nqp::p6scalarfromdesc($!desc)),
                          Scalar,
                         '$!whence',
                          -> { nqp::bindposnd($!list,$indices,$scalar) }
                       )
                     )
                   )
                }
            }.new(self)
        }

        # A shaped array isn't lazy, these methods don't need to go looking
        # into the "todo".
        method eager() { self }

        method sum() is nodal { self.Any::sum }
        multi method elems(::?CLASS:D:) {
            nqp::elems(nqp::getattr(self,List,'$!reified'))
        }

        method clone() {
            my \obj := nqp::create(self);
            nqp::bindattr(obj,Array,'$!descriptor',
              nqp::getattr(self,Array,'$!descriptor'));
            nqp::bindattr(obj,::?CLASS,'$!shape',
              nqp::getattr(self,::?CLASS,'$!shape'));
            nqp::p6bindattrinvres(obj,List,'$!reified',
              nqp::clone(nqp::getattr(self,List,'$!reified')))
        }
    }

#line 1 SETTING::src/core/Shaped1Array.pm
# this is actually part of the Array class

    my role Shaped1Array does ShapedArray {
        multi method AT-POS(::?CLASS:D: int \one) is raw {
            nqp::ifnull(
              nqp::atpos(
                nqp::getattr(self,List,'$!reified'),
                one),
              AT-POS-CONTAINER(self,one)
            )
        }
        multi method AT-POS(::?CLASS:D: Int:D \one) is raw {
            nqp::ifnull(
              nqp::atpos(
                nqp::getattr(self,List,'$!reified'),
                one),
              AT-POS-CONTAINER(self,one)
            )
        }
        sub AT-POS-CONTAINER(\array, int \one) is raw {
            nqp::p6bindattrinvres(
              (my $scalar := nqp::p6scalarfromdesc(
                nqp::getattr(array,Array,'$!descriptor'))),
              Scalar,
              '$!whence',
              -> { nqp::bindpos(
                     nqp::getattr(array,List,'$!reified'),
                     one, $scalar) }
            )
        }

        multi method ASSIGN-POS(::?CLASS:D: int \one, \value) {
            nqp::ifnull(
              nqp::atpos(
                nqp::getattr(self,List,'$!reified'),
                one),
              nqp::bindpos(
                nqp::getattr(self,List,'$!reified'),
                one,
                nqp::p6scalarfromdesc(nqp::getattr(self,Array,'$!descriptor')))
            ) = value
        }
        multi method ASSIGN-POS(::?CLASS:D: Int:D \one, \value) {
            nqp::ifnull(
              nqp::atpos(
                nqp::getattr(self,List,'$!reified'),
                one),
              nqp::bindpos(
                nqp::getattr(self,List,'$!reified'),
                one,
                nqp::p6scalarfromdesc(nqp::getattr(self,Array,'$!descriptor')))
            ) = value
        }

        multi method EXISTS-POS(::?CLASS:D: int \one) {
            nqp::p6bool(
              nqp::islt_i(one,nqp::elems(nqp::getattr(self,List,'$!reified')))
                && nqp::not_i(nqp::isnull(
                     nqp::atpos(nqp::getattr(self,List,'$!reified'),one)
              ))
            )
        }
        multi method EXISTS-POS(::?CLASS:D: Int:D \one) {
            nqp::p6bool(
              nqp::islt_i(one,nqp::elems(nqp::getattr(self,List,'$!reified')))
                && nqp::not_i(nqp::isnull(
                     nqp::atpos(nqp::getattr(self,List,'$!reified'),one)
              ))
            )
        }

        multi method DELETE-POS(::?CLASS:D: int \one) is raw {
            nqp::if(
              nqp::isnull(my $value := nqp::atpos(
                nqp::getattr(self,List,'$!reified'),
                one)),
              Nil,
              nqp::stmts(
                nqp::bindpos(
                  nqp::getattr(self,List,'$!reified'),
                  one, nqp::null),
                $value
              )
            )
        }
        multi method DELETE-POS(::?CLASS:D: Int:D \one) is raw {
            nqp::if(
              nqp::isnull(my $value := nqp::atpos(
                nqp::getattr(self,List,'$!reified'),
                one)),
              Nil,
              nqp::stmts(
                nqp::bindpos(
                  nqp::getattr(self,List,'$!reified'),
                  one, nqp::null),
                $value
              )
            )
        }

        multi method BIND-POS(::?CLASS:D: int \one, \value) {
            nqp::bindpos(
              nqp::getattr(self,List,'$!reified'),
              one, value
            )
        }
        multi method BIND-POS(::?CLASS:D: Int:D \one, \value) {
            nqp::bindpos(
              nqp::getattr(self,List,'$!reified'),
              one, value
            )
        }

        multi method STORE(::?CLASS:D: ::?CLASS:D \from) {
            nqp::stmts(
              (my $to   := nqp::getattr(self,List,'$!reified')),
              (my $from := nqp::getattr(from,List,'$!reified')),
              nqp::if(
                nqp::iseq_i(
                  (my int $elems = nqp::elems($to)),nqp::elems($from)),
                nqp::stmts(
                  (my $desc := nqp::getattr(self,Array,'$!descriptor')),
                  (my int $i = -1),
                  nqp::while(
                    nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                    # always create a new container in case the from list
                    # contains containers already existing in the to list
                    # e.g. after having done a .reverse or .rotate
                    nqp::bindpos($to,$i,nqp::p6scalarfromdesc($desc)) =
                      nqp::atpos($from,$i)
                  ),
                  self
                ),
                X::Assignment::ArrayShapeMismatch.new(
                  source-shape => from.shape,
                  target-shape => self.shape
                ).throw
              )
            )
        }
        multi method STORE(::?CLASS:D: Iterable:D \in) {
            nqp::stmts(
              (my \list := nqp::getattr(self,List,'$!reified')),
              (my \desc := nqp::getattr(self,Array,'$!descriptor')),
              (my \iter := in.iterator),
              (my int $elems = nqp::elems(list)),
              (my int $i = -1),
              nqp::until(
                nqp::eqaddr((my $pulled := iter.pull-one),IterationEnd)
                  || nqp::iseq_i(($i = nqp::add_i($i,1)),$elems),
                nqp::ifnull(
                  nqp::atpos(list,$i),
                  nqp::bindpos(list,$i,nqp::p6scalarfromdesc(desc))
                ) = $pulled
              ),
              nqp::unless(
                nqp::islt_i($i,$elems) || iter.is-lazy,
                nqp::atpos(list,$i) # too many values on non-lazy iter, error
              ),
              self
            )
        }
        multi method STORE(::?CLASS:D: Mu \item) {
            nqp::stmts(
              (nqp::ifnull(
                nqp::atpos(nqp::getattr(self,List,'$!reified'),0),
                nqp::bindpos(nqp::getattr(self,List,'$!reified'),0,
                  nqp::p6scalarfromdesc(
                    nqp::getattr(self,Array,'$!descriptor')))
              ) = item),
              self
            )
        }

        multi method keys(::?CLASS:D:) {
            Seq.new(Rakudo::Iterator.IntRange(0,self.shape.AT-POS(0) - 1))
        }
        multi method kv(::?CLASS:D:) {
            Seq.new(Rakudo::Iterator.KeyValue(self.iterator))
        }
        multi method pairs(::?CLASS:D:) {
            Seq.new(Rakudo::Iterator.Pair(self.iterator))
        }
        multi method antipairs(::?CLASS:D:) {
            Seq.new(Rakudo::Iterator.AntiPair(self.iterator))
        }

        method iterator(::?CLASS:D:) {
            class :: does Iterator {
                has Mu $!reified;
                has Mu $!desc;
                has int $!pos;
                method !SET-SELF(Mu \list) {
                    nqp::stmts(
                      ($!reified := nqp::getattr(list,List,'$!reified')),
                      ($!desc    := nqp::getattr(list,Array,'$!descriptor')),
                      ($!pos = -1),
                      self
                    )
                }
                method new(Mu \list) { nqp::create(self)!SET-SELF(list) }
                method pull-one() is raw {
                    nqp::if(
                      nqp::islt_i(
                        ($!pos = nqp::add_i($!pos,1)),
                        nqp::elems($!reified)
                      ),
                      nqp::ifnull(
                        nqp::atpos($!reified,$!pos),
                        nqp::p6bindattrinvres(
                          (my $scalar := nqp::p6scalarfromdesc($!desc)),
                          Scalar,
                          '$!whence',
                          -> { nqp::bindpos($!reified,$!pos,$scalar) }
                        )
                      ),
                      IterationEnd
                    )
                }
                method push-all($target --> IterationEnd) {
                    nqp::stmts(
                      (my int $elems = nqp::elems($!reified)),
                      (my int $i = $!pos),
                      nqp::while(
                        nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                        $target.push(
                          nqp::ifnull(
                            nqp::atpos($!reified,$i),
                            nqp::p6bindattrinvres(
                              (my $scalar := nqp::p6scalarfromdesc($!desc)),
                              Scalar,
                              '$!whence',
                              -> { nqp::bindpos($!reified,$i,$scalar) }
                            )
                          )
                        )
                      ),
                      ($!pos = $i)  # mark as done
                    )
                }
                method count-only() { nqp::p6box_i(nqp::elems($!reified)) }
                method bool-only()  { nqp::p6bool(nqp::elems($!reified)) }
                method sink-all(--> IterationEnd) {
                    $!pos = nqp::elems($!reified)
                }
            }.new(self)
        }

        method reverse(::?CLASS:D:) is nodal {
            Seq.new(nqp::if(
              (my int $elems = nqp::elems(
                my $from := nqp::getattr(self,List,'$!reified')
              )),
              nqp::stmts(
                (my int $last = nqp::sub_i($elems,1)),
                (my int $i = -1),
                (my $to := nqp::setelems(nqp::create(IterationBuffer),$elems)),
                nqp::while(
                  nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                  nqp::bindpos($to,nqp::sub_i($last,$i),
                    nqp::decont(nqp::atpos($from,$i)))
                ),
                Rakudo::Iterator.ReifiedList($to)
              ),
              Rakudo::Iterator.Empty
            ))
        }
        method rotate(::?CLASS:D: Int(Cool) $rotate = 1) is nodal {
            Rakudo::Internals.RotateListToList(
              self, $rotate, self.new(:shape(self.shape)))
        }
        method sum() is nodal { self.List::sum }
    }

#line 1 SETTING::src/core/Shaped2Array.pm
# this is actually part of the Array class

    my role Shaped2Array does ShapedArray {
        multi method AT-POS(::?CLASS:D: int \one, int \two) is raw {
            nqp::ifnull(
              nqp::atpos2d(
                nqp::getattr(self,List,'$!reified'),
                one, two),
              AT-POS-CONTAINER(self,one, two)
            )
        }
        multi method AT-POS(::?CLASS:D: Int:D \one, Int:D \two) is raw {
            nqp::ifnull(
              nqp::atpos2d(
                nqp::getattr(self,List,'$!reified'),
                one, two),
              AT-POS-CONTAINER(self,one, two)
            )
        }
        sub AT-POS-CONTAINER(\array, int \one, int \two) is raw {
            nqp::p6bindattrinvres(
              (my $scalar := nqp::p6scalarfromdesc(
                nqp::getattr(array,Array,'$!descriptor'))),
              Scalar,
              '$!whence',
              -> { nqp::bindpos2d(
                     nqp::getattr(array,List,'$!reified'),
                     one, two, $scalar) }
            )
        }

        multi method ASSIGN-POS(::?CLASS:D: int \one, int \two, \value) {
            nqp::ifnull(
              nqp::atpos2d(
                nqp::getattr(self,List,'$!reified'),
                one, two),
              nqp::bindpos2d(
                nqp::getattr(self,List,'$!reified'),
                one, two,
                nqp::p6scalarfromdesc(nqp::getattr(self,Array,'$!descriptor')))
            ) = value
        }
        multi method ASSIGN-POS(::?CLASS:D: Int:D \one, Int:D \two, \value) {
            nqp::ifnull(
              nqp::atpos2d(
                nqp::getattr(self,List,'$!reified'),
                one, two),
              nqp::bindpos2d(
                nqp::getattr(self,List,'$!reified'),
                one, two,
                nqp::p6scalarfromdesc(nqp::getattr(self,Array,'$!descriptor')))
            ) = value
        }

        multi method EXISTS-POS(::?CLASS:D: int \one, int \two) {
            nqp::p6bool(
              nqp::stmts(
                (my $dims :=
                  nqp::dimensions(nqp::getattr(self,List,'$!reified'))),
                nqp::islt_i(one,nqp::atpos_i($dims,0))
                  && nqp::islt_i(two,nqp::atpos_i($dims,1))
                    && nqp::not_i(nqp::isnull(
                         nqp::atpos2d(
                           nqp::getattr(self,List,'$!reified'),
                           one, two)
                       ))
              )
            )
        }
        multi method EXISTS-POS(::?CLASS:D: Int:D \one, Int:D \two) {
            nqp::p6bool(
              nqp::stmts(
                (my $dims :=
                  nqp::dimensions(nqp::getattr(self,List,'$!reified'))),
                nqp::islt_i(one,nqp::atpos_i($dims,0))
                  && nqp::islt_i(two,nqp::atpos_i($dims,1))
                    && nqp::not_i(nqp::isnull(
                         nqp::atpos2d(
                           nqp::getattr(self,List,'$!reified'),
                           one, two)
                       ))
              )
            )
        }

        multi method DELETE-POS(::?CLASS:D: int \one, int \two) is raw {
            nqp::if(
              nqp::isnull(my $value := nqp::atpos2d(
                nqp::getattr(self,List,'$!reified'),
                one, two)),
              Nil,
              nqp::stmts(
                nqp::bindpos2d(
                  nqp::getattr(self,List,'$!reified'),
                  one, two, nqp::null),
                $value
              )
            )
        }
        multi method DELETE-POS(::?CLASS:D: Int:D \one, Int:D \two) is raw {
            nqp::if(
              nqp::isnull(my $value := nqp::atpos2d(
                nqp::getattr(self,List,'$!reified'),
                one, two)),
              Nil,
              nqp::stmts(
                nqp::bindpos2d(
                  nqp::getattr(self,List,'$!reified'),
                  one, two, nqp::null),
                $value
              )
            )
        }

        multi method BIND-POS(::?CLASS:D: int \one, int \two, \value) {
            nqp::bindpos2d(
              nqp::getattr(self,List,'$!reified'),
              one, two, value
            )
        }
        multi method BIND-POS(::?CLASS:D: Int:D \one, Int:D \two, \value) {
            nqp::bindpos2d(
              nqp::getattr(self,List,'$!reified'),
              one, two, value
            )
        }
    }

#line 1 SETTING::src/core/Shaped3Array.pm
# this is actually part of the Array class

    my role Shaped3Array does ShapedArray {
        multi method AT-POS(::?CLASS:D: int \one, int \two, int \three) is raw {
            nqp::ifnull(
              nqp::atpos3d(
                nqp::getattr(self,List,'$!reified'),
                one, two, three),
              AT-POS-CONTAINER(self, one, two, three)
            )
        }
        multi method AT-POS(::?CLASS:D: Int:D \one, Int:D \two, Int:D \three) is raw {
            nqp::ifnull(
              nqp::atpos3d(
                nqp::getattr(self,List,'$!reified'),
                one, two, three),
              AT-POS-CONTAINER(self, one, two, three)
            )
        }
        sub AT-POS-CONTAINER(\array, int \one, int \two, int \three) is raw {
            nqp::p6bindattrinvres(
              (my $scalar := nqp::p6scalarfromdesc(
                nqp::getattr(array,Array,'$!descriptor'))),
              Scalar,
              '$!whence',
              -> { nqp::bindpos3d(
                     nqp::getattr(array,List,'$!reified'),
                     one, two, three, $scalar) }
            )
        }

        multi method ASSIGN-POS(::?CLASS:D: int \one, int \two, int \three, \value) {
            nqp::ifnull(
              nqp::atpos3d(
                nqp::getattr(self,List,'$!reified'),
                one, two, three),
              nqp::bindpos3d(
                nqp::getattr(self,List,'$!reified'),
                one, two, three,
                nqp::p6scalarfromdesc(nqp::getattr(self,Array,'$!descriptor')))
            ) = value
        }
        multi method ASSIGN-POS(::?CLASS:D: Int:D \one, Int:D \two, Int:D \three, \value) {
            nqp::ifnull(
              nqp::atpos3d(
                nqp::getattr(self,List,'$!reified'),
                one, two, three),
              nqp::bindpos3d(
                nqp::getattr(self,List,'$!reified'),
                one, two, three,
                nqp::p6scalarfromdesc(nqp::getattr(self,Array,'$!descriptor')))
            ) = value
        }

        multi method EXISTS-POS(::?CLASS:D: int \one, int \two, int \three) {
            nqp::p6bool(
              nqp::stmts(
                (my $dims :=
                  nqp::dimensions(nqp::getattr(self,List,'$!reified'))),
                nqp::islt_i(one,nqp::atpos_i($dims,0))
                  && nqp::islt_i(two,nqp::atpos_i($dims,1))
                    && nqp::not_i(nqp::isnull(
                         nqp::atpos3d(
                           nqp::getattr(self,List,'$!reified'),
                           one, two, three)
                       ))
              )
            )
        }
        multi method EXISTS-POS(::?CLASS:D: Int:D \one, Int:D \two, Int:D \three) {
            nqp::p6bool(
              nqp::stmts(
                (my $dims :=
                  nqp::dimensions(nqp::getattr(self,List,'$!reified'))),
                nqp::islt_i(one,nqp::atpos_i($dims,0))
                  && nqp::islt_i(two,nqp::atpos_i($dims,1))
                    && nqp::islt_i(three,nqp::atpos_i($dims,2))
                      && nqp::not_i(nqp::isnull(
                           nqp::atpos3d(
                             nqp::getattr(self,List,'$!reified'),
                             one, two, three)
                         ))
              )
            )
        }

        multi method DELETE-POS(::?CLASS:D: int \one, int \two, int \three) is raw {
            nqp::if(
              nqp::isnull(my $value := nqp::atpos3d(
                nqp::getattr(self,List,'$!reified'),
                one, two, three)),
              Nil,
              nqp::stmts(
                nqp::bindpos3d(
                  nqp::getattr(self,List,'$!reified'),
                  one, two, three, nqp::null),
                $value
              )
            )
        }
        multi method DELETE-POS(::?CLASS:D: Int:D \one, Int:D \two, Int:D \three) is raw {
            nqp::if(
              nqp::isnull(my $value := nqp::atpos3d(
                nqp::getattr(self,List,'$!reified'),
                one, two, three)),
              Nil,
              nqp::stmts(
                nqp::bindpos3d(
                  nqp::getattr(self,List,'$!reified'),
                  one, two, three, nqp::null),
                $value
              )
            )
        }

        multi method BIND-POS(::?CLASS:D: int \one, int \two, int \three, \value) {
            nqp::bindpos3d(
              nqp::getattr(self,List,'$!reified'),
              one, two, three, value
            )
        }
        multi method BIND-POS(::?CLASS:D: Int:D \one, Int:D \two, Int:D \three, \value) {
            nqp::bindpos3d(
              nqp::getattr(self,List,'$!reified'),
              one, two, three, value
            )
        }
    }

#line 1 SETTING::src/core/ShapedNArray.pm
# this is actually part of the Array class

    constant dim2role :=
      nqp::list(ShapedArray,Shaped1Array,Shaped2Array,Shaped3Array);

    sub set-shape(\base, \shape) is raw {
        nqp::stmts(
          (my $shape := nqp::decont(nqp::if(
            nqp::istype(shape,List),
            shape,
            shape.list
          ))),
          nqp::if(
            (my int $dims = $shape.elems),  # reifies
            nqp::stmts(
              nqp::unless(
                nqp::iseq_i($dims,1)
                  && nqp::istype(                 # ignore single [*] shape
                       nqp::atpos(nqp::getattr($shape,List,'$!reified'),0),
                       Whatever),
                nqp::stmts(
                  (my $what := base.WHAT.^mixin(
                    nqp::atpos(dim2role,nqp::isle_i($dims,3) && $dims))
                  ),
                  nqp::if(                        # correct name if needed
                    nqp::isne_s($what.^name,base.^name),
                    $what.^set_name(base.^name)
                  ),
                  nqp::p6bindattrinvres(
                    nqp::p6bindattrinvres(
                      nqp::create($what),List,'$!reified',
                        Rakudo::Internals.SHAPED-ARRAY-STORAGE(
                          $shape,nqp::knowhow,Mu)),
                    $what,'$!shape',$shape)
                ),
                nqp::create(base.WHAT)
              )
            ),
            X::NotEnoughDimensions.new(
              operation         => 'create',
              got-dimensions    => 0,
              needed-dimensions => '',
            ).throw
          )
        )
    }

#line 1 SETTING::src/core/TypedArray.pm
# this is actually part of the Array class

    my role TypedArray[::TValue] does Positional[TValue] {

        proto method new(|) { * }
        multi method new(:$shape!) {
            set-descriptor(nqp::if(
              nqp::defined($shape),
              set-shape(self,$shape),
              nqp::if(
                Metamodel::EnumHOW.ACCEPTS($shape.HOW),
                set-shape(self,$shape.^elems),
                nqp::create(self)
              )
            ))
        }
        multi method new() {
            set-descriptor(nqp::create(self))
        }
        multi method new(\values, :$shape!) {
            set-descriptor(nqp::if(
              nqp::defined($shape),
              set-shape(self,$shape),
              nqp::if(
                Metamodel::EnumHOW.ACCEPTS($shape.HOW),
                set-shape(self,$shape.^elems),
                nqp::create(self)
              )
            )).STORE(values)
        }
        multi method new(\values) {
            set-descriptor(nqp::create(self)).STORE(values)
        }
        multi method new(**@values is raw, :$shape!) {
            set-descriptor(nqp::if(
              nqp::defined($shape),
              set-shape(self,$shape),
              nqp::if(
                Metamodel::EnumHOW.ACCEPTS($shape.HOW),
                set-shape(self,$shape.^elems),
                nqp::create(self)
              )
            )).STORE(@values)
        }
        multi method new(**@values is raw) {
            set-descriptor(nqp::create(self)).STORE(@values)
        }

        sub set-descriptor(\list) is raw {
            nqp::stmts(
              nqp::bindattr(list,Array,'$!descriptor',
                Perl6::Metamodel::ContainerDescriptor.new(
                  :of(TValue), :rw(1), :default(TValue))
              ),
              list
            )
        }

        # must have a proto here to hide the candidates in Array
        # otherwise we could bind any value to the Array
        proto method BIND-POS(|) { * }

        # these BIND-POSses are identical to Array's, except for bindval
        multi method BIND-POS(Array:D: int $pos, TValue \bindval) is raw {
            nqp::if(
              nqp::islt_i($pos,0),
              Failure.new(X::OutOfRange.new(
                :what($*INDEX // 'Index'),:got($pos),:range<0..^Inf>)),
              nqp::stmts(
                nqp::if(
                  nqp::getattr(self,List,'$!reified').DEFINITE,
                  nqp::if(
                    (nqp::isge_i(
                      $pos,nqp::elems(nqp::getattr(self,List,'$!reified')))
                        && nqp::getattr(self,List,'$!todo').DEFINITE),
                    nqp::getattr(self,List,'$!todo').reify-at-least(
                      nqp::add_i($pos,1)),
                  ),
                  nqp::bindattr(self,List,'$!reified',nqp::create(IterationBuffer))
                ),
                nqp::bindpos(nqp::getattr(self,List,'$!reified'),$pos,bindval)
              )
            )
        }
        # because this is a very hot path, we copied the code from the int candidate
        multi method BIND-POS(Array:D: Int:D $pos, TValue \bindval) is raw {
            nqp::if(
              nqp::islt_i($pos,0),
              Failure.new(X::OutOfRange.new(
                :what($*INDEX // 'Index'),:got($pos),:range<0..^Inf>)),
              nqp::stmts(
                nqp::if(
                  nqp::getattr(self,List,'$!reified').DEFINITE,
                  nqp::if(
                    (nqp::isge_i(
                      $pos,nqp::elems(nqp::getattr(self,List,'$!reified')))
                        && nqp::getattr(self,List,'$!todo').DEFINITE),
                    nqp::getattr(self,List,'$!todo').reify-at-least(
                      nqp::add_i($pos,1)),
                  ),
                  nqp::bindattr(self,List,'$!reified',nqp::create(IterationBuffer))
                ),
                nqp::bindpos(nqp::getattr(self,List,'$!reified'),$pos,bindval)
              )
            )
        }

        multi method perl(::?CLASS:D \SELF:) {
            my $args = self.map({ ($_ // TValue).perl(:arglist) }).join(', ');
            'Array[' ~ TValue.perl ~ '].new(' ~ $args ~ ')';
        }
    }
    method ^parameterize(Mu:U \arr, Mu:U \t, |c) {
        if c.elems == 0 {
            my $what := arr.^mixin(TypedArray[t]);
            # needs to be done in COMPOSE phaser when that works
            $what.^set_name("{arr.^name}[{t.^name}]");
            $what;
        }
        else {
            die "Can only type-constrain Array with [ValueType]"
        }
    }
}

#========== closed down the Array class started in src/core/Array.pm  ==========

#line 1 SETTING::src/core/array_operators.pm
# The [...] term creates an Array.
proto circumfix:<[ ]>(|) { * }
multi circumfix:<[ ]>() {
    nqp::create(Array)
}
multi circumfix:<[ ]>(Iterable:D \iterable) {
    my $reified;
    nqp::if(
      nqp::iscont(iterable),
      nqp::p6bindattrinvres(
        nqp::create(Array),List,'$!reified',
        nqp::stmts(
          nqp::push(
            ($reified := nqp::create(IterationBuffer)),
            nqp::assign(nqp::p6scalarfromdesc(nqp::null),iterable)
          ),
          $reified
        )
      ),
      nqp::if(
        nqp::eqaddr(iterable.WHAT,List),
        nqp::if(
          iterable.is-lazy,
          Array.from-iterator(iterable.iterator),
          nqp::stmts(     # immutable List
            (my int $elems = iterable.elems),  # reifies
            (my $params  := nqp::getattr(iterable,List,'$!reified')),
            (my int $i    = -1),
            ($reified := nqp::setelems(nqp::create(IterationBuffer),$elems)),
            nqp::while(
              nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
              nqp::bindpos($reified,$i,nqp::assign(
                nqp::p6scalarfromdesc(nqp::null),nqp::atpos($params,$i))
              )
            ),
            nqp::p6bindattrinvres(nqp::create(Array),List,'$!reified',$reified)
          ),
        ),
        Array.from-iterator(iterable.iterator)
      )
    )
}
multi circumfix:<[ ]>(Mu \x) {   # really only for [$foo]
    nqp::p6bindattrinvres(
      nqp::create(Array),List,'$!reified',
      nqp::stmts(
        nqp::push(
          (my $reified := nqp::create(IterationBuffer)),
          nqp::assign(nqp::p6scalarfromdesc(nqp::null),x)
        ),
        $reified
      )
    )
}

proto sub pop(@) {*}
multi sub pop(@a) { @a.pop }

proto sub shift(@) {*}
multi sub shift(@a) { @a.shift }

sub push   (\a, |elems) { a.push:    |elems }
sub append (\a, |elems) { a.append:  |elems }
sub unshift(\a, |elems) { a.unshift: |elems }
sub prepend(\a, |elems) { a.prepend: |elems }

sub splice(@arr, |c)         { @arr.splice(|c) }

#line 1 SETTING::src/core/native_array.pm
my class X::MustBeParametric  { ... }
my class X::TooManyDimensions { ... }
my class X::TypeCheck::Assignment { ... }

my class array does Iterable {

    multi method new(array:)      { self!create }
    multi method new(array: @v)   { self!create.STORE(@v) }
    multi method new(array: **@v) { self!create.STORE(@v) }

    multi method new(array: :$shape!)       { self!create-ws($shape) }
    multi method new(array: @v, :$shape!)   { self!create-ws($shape).STORE(@v) }
    multi method new(array: **@v, :$shape!) { self!create-ws($shape).STORE(@v) }

    method !create() {
        nqp::isnull(nqp::typeparameterized(self))
         ?? X::MustBeParametric.new(:type(self)).throw
         !! nqp::create(self)
    }
    method !create-ws($shape) {
        nqp::isnull(nqp::typeparameterized(self))
          ?? X::MustBeParametric.new(:type(self)).throw
          !! nqp::isconcrete($shape)
            ?? self!shaped($shape)
            !! Metamodel::EnumHOW.ACCEPTS($shape.HOW)
              ?? self!shaped($shape.^elems)
              !! nqp::create(self)
    }

    proto method STORE(|) { * }
    multi method STORE(array:D: *@values) { self.STORE(@values) }

    multi method push(array:D:    **@values) { self.append(@values) }
    multi method append(array:D:   *@values) { self.append(@values) }
    multi method unshift(array:D: **@values) { self.unshift(@values) }
    multi method prepend(array:D:  *@values) { self.unshift(@values) }

    sub EQV_DIMENSIONS(Mu \one, Mu \two) is raw {
        nqp::iseq_i(     # much faster than one.shape eqv two.shape
          (my int $dims = nqp::elems(
            my $onedims := nqp::dimensions(one)
          )),
          nqp::elems(my $twodims := nqp::dimensions(two))
        ) && nqp::stmts(
          (my int $i = -1),
          nqp::while(
            nqp::islt_i(($i = nqp::add_i($i,1)),$dims)
              && nqp::iseq_i(
                   nqp::atpos_i($onedims,$i),
                   nqp::atpos_i($twodims,$i)
            ),
            nqp::null
          ),
          nqp::iseq_i($i,$dims)
        )
    }

    my role strarray[::T] does Positional[T] is array_type(T) {
#- start of generated part of strarray role -----------------------------------
#- Generated on 2017-10-26T01:53:35Z by tools/build/makeNATIVE_ARRAY.pl6
#- PLEASE DON'T CHANGE ANYTHING BELOW THIS LINE

        multi method AT-POS(strarray:D: int $idx) is raw {
            nqp::atposref_s(self, $idx)
        }
        multi method AT-POS(strarray:D: Int:D $idx) is raw {
            nqp::atposref_s(self, $idx)
        }

        multi method ASSIGN-POS(strarray:D: int $idx, str $value) {
            nqp::bindpos_s(self, $idx, $value)
        }
        multi method ASSIGN-POS(strarray:D: Int:D $idx, str $value) {
            nqp::bindpos_s(self, $idx, $value)
        }
        multi method ASSIGN-POS(strarray:D: int $idx, Str:D $value) {
            nqp::bindpos_s(self, $idx, $value)
        }
        multi method ASSIGN-POS(strarray:D: Int:D $idx, Str:D $value) {
            nqp::bindpos_s(self, $idx, $value)
        }
        multi method ASSIGN-POS(strarray:D: Any $idx, Mu \value) {
            X::TypeCheck.new(
                operation => "assignment to str array element #$idx",
                got       => value,
                expected  => T,
            ).throw;
        }

        multi method STORE(strarray:D: $value) {
            nqp::setelems(self,1);
            nqp::bindpos_s(self, 0, nqp::unbox_s($value));
            self
        }
        multi method STORE(strarray:D: str @values) {
            nqp::setelems(self,@values.elems);
            nqp::splice(self,@values,0,@values.elems)
        }
        multi method STORE(strarray:D: @values) {
            my int $elems = @values.elems;
            nqp::setelems(self, $elems);

            my int $i = -1;
            nqp::bindpos_s(self, $i,
              nqp::unbox_s(@values.AT-POS($i)))
              while nqp::islt_i($i = nqp::add_i($i,1),$elems);
            self
        }

        multi method push(strarray:D: str $value) {
            nqp::push_s(self, $value);
            self
        }
        multi method push(strarray:D: Str:D $value) {
            nqp::push_s(self, $value);
            self
        }
        multi method push(strarray:D: Mu \value) {
            X::TypeCheck.new(
                operation => 'push to str array',
                got       => value,
                expected  => T,
            ).throw;
        }
        multi method append(strarray:D: str $value) {
            nqp::push_s(self, $value);
            self
        }
        multi method append(strarray:D: Str:D $value) {
            nqp::push_s(self, $value);
            self
        }
        multi method append(strarray:D: strarray:D $values) is default {
            nqp::splice(self,$values,nqp::elems(self),0)
        }
        multi method append(strarray:D: @values) {
            fail X::Cannot::Lazy.new(:action<append>, :what(self.^name))
              if @values.is-lazy;
            nqp::push_s(self, $_) for flat @values;
            self
        }

        method pop(strarray:D: --> str) {
            nqp::elems(self) > 0
              ?? nqp::pop_s(self)
              !! die X::Cannot::Empty.new(:action<pop>, :what(self.^name));
        }

        method shift(strarray:D: --> str) {
            nqp::elems(self) > 0
              ?? nqp::shift_s(self)
              !! die X::Cannot::Empty.new(:action<shift>, :what(self.^name));
        }

        multi method unshift(strarray:D: str $value) {
            nqp::unshift_s(self, $value);
            self
        }
        multi method unshift(strarray:D: Str:D $value) {
            nqp::unshift_s(self, $value);
            self
        }
        multi method unshift(strarray:D: @values) {
            fail X::Cannot::Lazy.new(:action<unshift>, :what(self.^name))
              if @values.is-lazy;
            nqp::unshift_s(self, @values.pop) while @values;
            self
        }
        multi method unshift(strarray:D: Mu \value) {
            X::TypeCheck.new(
                operation => 'unshift to str array',
                got       => value,
                expected  => T,
            ).throw;
        }

        multi method splice(strarray:D: $offset=0, $size=Whatever, *@values) {
            fail X::Cannot::Lazy.new(:action('splice in'))
              if @values.is-lazy;

            my $elems = self.elems;
            my int $o = nqp::istype($offset,Callable)
              ?? $offset($elems)
              !! nqp::istype($offset,Whatever)
                ?? $elems
                !! $offset.Int;
            X::OutOfRange.new(
              :what('Offset argument to splice'),
              :got($o),
              :range("0..$elems"),
            ).fail if $o < 0 || $o > $elems; # one after list allowed for "push"

            my int $s = nqp::istype($size,Callable)
              ?? $size($elems - $o)
              !! !defined($size) || nqp::istype($size,Whatever)
                 ?? $elems - ($o min $elems)
                 !! $size.Int;
            X::OutOfRange.new(
              :what('Size argument to splice'),
              :got($s),
              :range("0..^{$elems - $o}"),
            ).fail if $s < 0;

            my @ret := nqp::create(self);
            my int $i = $o;
            my int $n = ($elems min $o + $s) - 1;
            while $i <= $n {
                nqp::push_s(@ret, nqp::atpos_s(self, $i));
                $i = $i + 1;
            }

            my @splicees := nqp::create(self);
            nqp::push_s(@splicees, @values.shift) while @values;
            nqp::splice(self, @splicees, $o, $s);
            @ret;
        }

        multi method min(strarray:D:) {
            nqp::if(
              (my int $elems = self.elems),
              nqp::stmts(
                (my int $i),
                (my str $min = nqp::atpos_s(self,0)),
                nqp::while(
                  nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                  nqp::if(
                    nqp::islt_s(nqp::atpos_s(self,$i),$min),
                    ($min = nqp::atpos_s(self,$i))
                  )
                ),
                $min
              ),
              Inf
            )
        }
        multi method max(strarray:D:) {
            nqp::if(
              (my int $elems = self.elems),
              nqp::stmts(
                (my int $i),
                (my str $max = nqp::atpos_s(self,0)),
                nqp::while(
                  nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                  nqp::if(
                    nqp::isgt_s(nqp::atpos_s(self,$i),$max),
                    ($max = nqp::atpos_s(self,$i))
                  )
                ),
                $max
              ),
              -Inf
            )
        }
        multi method minmax(strarray:D:) {
            nqp::if(
              (my int $elems = self.elems),
              nqp::stmts(
                (my int $i),
                (my str $min =
                  my str $max = nqp::atpos_s(self,0)),
                nqp::while(
                  nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                  nqp::if(
                    nqp::islt_s(nqp::atpos_s(self,$i),$min),
                    ($min = nqp::atpos_s(self,$i)),
                    nqp::if(
                      nqp::isgt_s(nqp::atpos_s(self,$i),$max),
                      ($max = nqp::atpos_s(self,$i))
                    )
                  )
                ),
                Range.new($min,$max)
              ),
              Range.new(Inf,-Inf)
            )
        }

        method iterator(strarray:D:) {
            class :: does Iterator {
                has int $!i;
                has $!array;    # Native array we're iterating

                method !SET-SELF(\array) {
                    $!array := nqp::decont(array);
                    $!i = -1;
                    self
                }
                method new(\array) { nqp::create(self)!SET-SELF(array) }

                method pull-one() is raw {
                    ($!i = $!i + 1) < nqp::elems($!array)
                      ?? nqp::atposref_s($!array,$!i)
                      !! IterationEnd
                }
                method push-all($target --> IterationEnd) {
                    my int $i     = $!i;
                    my int $elems = nqp::elems($!array);
                    $target.push(nqp::atposref_s($!array,$i))
                      while ($i = $i + 1) < $elems;
                    $!i = $i;
                }
            }.new(self)
        }
        method reverse(strarray:D:) is nodal {
            nqp::stmts(
              (my int $elems = nqp::elems(self)),
              (my int $last  = nqp::sub_i($elems,1)),
              (my int $i     = -1),
              (my $to := nqp::clone(self)),
              nqp::while(
                nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                nqp::bindpos_s($to,nqp::sub_i($last,$i),
                  nqp::atpos_s(self,$i))
              ),
              $to
            )
        }
        method rotate(strarray:D: Int(Cool) $rotate = 1) is nodal {
            nqp::stmts(
              (my int $elems = nqp::elems(self)),
              (my $to := nqp::clone(self)),
              (my int $i = -1),
              (my int $j =
                nqp::mod_i(nqp::sub_i(nqp::sub_i($elems,1),$rotate),$elems)),
              nqp::if(nqp::islt_i($j,0),($j = nqp::add_i($j,$elems))),
              nqp::while(
                nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                nqp::bindpos_s(
                  $to,
                  ($j = nqp::mod_i(nqp::add_i($j,1),$elems)),
                  nqp::atpos_s(self,$i)
                ),
              ),
              $to
            )
        }
        multi method sort(strarray:D:) {
            Rakudo::Sorting.MERGESORT-str(nqp::clone(self))
        }
#- PLEASE DON'T CHANGE ANYTHING ABOVE THIS LINE
#- end of generated part of strarray role -------------------------------------

        method join(strarray:D: $delim = '') {

            my str $empty = "";
            my int $elems = nqp::elems(self);
            my int $i     = -1;
            nqp::bindpos_s(self,$i,$empty)
              if nqp::isnull_s(nqp::atposref_s(self,$i))
              while nqp::islt_i(++$i,$elems);

            nqp::join($delim.Str,self)
        }
    }

    my role intarray[::T] does Positional[T] is array_type(T) {
#- start of generated part of intarray role -----------------------------------
#- Generated on 2017-10-26T01:53:35Z by tools/build/makeNATIVE_ARRAY.pl6
#- PLEASE DON'T CHANGE ANYTHING BELOW THIS LINE

        multi method AT-POS(intarray:D: int $idx) is raw {
            nqp::atposref_i(self, $idx)
        }
        multi method AT-POS(intarray:D: Int:D $idx) is raw {
            nqp::atposref_i(self, $idx)
        }

        multi method ASSIGN-POS(intarray:D: int $idx, int $value) {
            nqp::bindpos_i(self, $idx, $value)
        }
        multi method ASSIGN-POS(intarray:D: Int:D $idx, int $value) {
            nqp::bindpos_i(self, $idx, $value)
        }
        multi method ASSIGN-POS(intarray:D: int $idx, Int:D $value) {
            nqp::bindpos_i(self, $idx, $value)
        }
        multi method ASSIGN-POS(intarray:D: Int:D $idx, Int:D $value) {
            nqp::bindpos_i(self, $idx, $value)
        }
        multi method ASSIGN-POS(intarray:D: Any $idx, Mu \value) {
            X::TypeCheck.new(
                operation => "assignment to int array element #$idx",
                got       => value,
                expected  => T,
            ).throw;
        }

        multi method STORE(intarray:D: $value) {
            nqp::setelems(self,1);
            nqp::bindpos_i(self, 0, nqp::unbox_i($value));
            self
        }
        multi method STORE(intarray:D: int @values) {
            nqp::setelems(self,@values.elems);
            nqp::splice(self,@values,0,@values.elems)
        }
        multi method STORE(intarray:D: @values) {
            my int $elems = @values.elems;
            nqp::setelems(self, $elems);

            my int $i = -1;
            nqp::bindpos_i(self, $i,
              nqp::unbox_i(@values.AT-POS($i)))
              while nqp::islt_i($i = nqp::add_i($i,1),$elems);
            self
        }

        multi method push(intarray:D: int $value) {
            nqp::push_i(self, $value);
            self
        }
        multi method push(intarray:D: Int:D $value) {
            nqp::push_i(self, $value);
            self
        }
        multi method push(intarray:D: Mu \value) {
            X::TypeCheck.new(
                operation => 'push to int array',
                got       => value,
                expected  => T,
            ).throw;
        }
        multi method append(intarray:D: int $value) {
            nqp::push_i(self, $value);
            self
        }
        multi method append(intarray:D: Int:D $value) {
            nqp::push_i(self, $value);
            self
        }
        multi method append(intarray:D: intarray:D $values) is default {
            nqp::splice(self,$values,nqp::elems(self),0)
        }
        multi method append(intarray:D: @values) {
            fail X::Cannot::Lazy.new(:action<append>, :what(self.^name))
              if @values.is-lazy;
            nqp::push_i(self, $_) for flat @values;
            self
        }

        method pop(intarray:D: --> int) {
            nqp::elems(self) > 0
              ?? nqp::pop_i(self)
              !! die X::Cannot::Empty.new(:action<pop>, :what(self.^name));
        }

        method shift(intarray:D: --> int) {
            nqp::elems(self) > 0
              ?? nqp::shift_i(self)
              !! die X::Cannot::Empty.new(:action<shift>, :what(self.^name));
        }

        multi method unshift(intarray:D: int $value) {
            nqp::unshift_i(self, $value);
            self
        }
        multi method unshift(intarray:D: Int:D $value) {
            nqp::unshift_i(self, $value);
            self
        }
        multi method unshift(intarray:D: @values) {
            fail X::Cannot::Lazy.new(:action<unshift>, :what(self.^name))
              if @values.is-lazy;
            nqp::unshift_i(self, @values.pop) while @values;
            self
        }
        multi method unshift(intarray:D: Mu \value) {
            X::TypeCheck.new(
                operation => 'unshift to int array',
                got       => value,
                expected  => T,
            ).throw;
        }

        multi method splice(intarray:D: $offset=0, $size=Whatever, *@values) {
            fail X::Cannot::Lazy.new(:action('splice in'))
              if @values.is-lazy;

            my $elems = self.elems;
            my int $o = nqp::istype($offset,Callable)
              ?? $offset($elems)
              !! nqp::istype($offset,Whatever)
                ?? $elems
                !! $offset.Int;
            X::OutOfRange.new(
              :what('Offset argument to splice'),
              :got($o),
              :range("0..$elems"),
            ).fail if $o < 0 || $o > $elems; # one after list allowed for "push"

            my int $s = nqp::istype($size,Callable)
              ?? $size($elems - $o)
              !! !defined($size) || nqp::istype($size,Whatever)
                 ?? $elems - ($o min $elems)
                 !! $size.Int;
            X::OutOfRange.new(
              :what('Size argument to splice'),
              :got($s),
              :range("0..^{$elems - $o}"),
            ).fail if $s < 0;

            my @ret := nqp::create(self);
            my int $i = $o;
            my int $n = ($elems min $o + $s) - 1;
            while $i <= $n {
                nqp::push_i(@ret, nqp::atpos_i(self, $i));
                $i = $i + 1;
            }

            my @splicees := nqp::create(self);
            nqp::push_i(@splicees, @values.shift) while @values;
            nqp::splice(self, @splicees, $o, $s);
            @ret;
        }

        multi method min(intarray:D:) {
            nqp::if(
              (my int $elems = self.elems),
              nqp::stmts(
                (my int $i),
                (my int $min = nqp::atpos_i(self,0)),
                nqp::while(
                  nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                  nqp::if(
                    nqp::islt_i(nqp::atpos_i(self,$i),$min),
                    ($min = nqp::atpos_i(self,$i))
                  )
                ),
                $min
              ),
              Inf
            )
        }
        multi method max(intarray:D:) {
            nqp::if(
              (my int $elems = self.elems),
              nqp::stmts(
                (my int $i),
                (my int $max = nqp::atpos_i(self,0)),
                nqp::while(
                  nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                  nqp::if(
                    nqp::isgt_i(nqp::atpos_i(self,$i),$max),
                    ($max = nqp::atpos_i(self,$i))
                  )
                ),
                $max
              ),
              -Inf
            )
        }
        multi method minmax(intarray:D:) {
            nqp::if(
              (my int $elems = self.elems),
              nqp::stmts(
                (my int $i),
                (my int $min =
                  my int $max = nqp::atpos_i(self,0)),
                nqp::while(
                  nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                  nqp::if(
                    nqp::islt_i(nqp::atpos_i(self,$i),$min),
                    ($min = nqp::atpos_i(self,$i)),
                    nqp::if(
                      nqp::isgt_i(nqp::atpos_i(self,$i),$max),
                      ($max = nqp::atpos_i(self,$i))
                    )
                  )
                ),
                Range.new($min,$max)
              ),
              Range.new(Inf,-Inf)
            )
        }

        method iterator(intarray:D:) {
            class :: does Iterator {
                has int $!i;
                has $!array;    # Native array we're iterating

                method !SET-SELF(\array) {
                    $!array := nqp::decont(array);
                    $!i = -1;
                    self
                }
                method new(\array) { nqp::create(self)!SET-SELF(array) }

                method pull-one() is raw {
                    ($!i = $!i + 1) < nqp::elems($!array)
                      ?? nqp::atposref_i($!array,$!i)
                      !! IterationEnd
                }
                method push-all($target --> IterationEnd) {
                    my int $i     = $!i;
                    my int $elems = nqp::elems($!array);
                    $target.push(nqp::atposref_i($!array,$i))
                      while ($i = $i + 1) < $elems;
                    $!i = $i;
                }
            }.new(self)
        }
        method reverse(intarray:D:) is nodal {
            nqp::stmts(
              (my int $elems = nqp::elems(self)),
              (my int $last  = nqp::sub_i($elems,1)),
              (my int $i     = -1),
              (my $to := nqp::clone(self)),
              nqp::while(
                nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                nqp::bindpos_i($to,nqp::sub_i($last,$i),
                  nqp::atpos_i(self,$i))
              ),
              $to
            )
        }
        method rotate(intarray:D: Int(Cool) $rotate = 1) is nodal {
            nqp::stmts(
              (my int $elems = nqp::elems(self)),
              (my $to := nqp::clone(self)),
              (my int $i = -1),
              (my int $j =
                nqp::mod_i(nqp::sub_i(nqp::sub_i($elems,1),$rotate),$elems)),
              nqp::if(nqp::islt_i($j,0),($j = nqp::add_i($j,$elems))),
              nqp::while(
                nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                nqp::bindpos_i(
                  $to,
                  ($j = nqp::mod_i(nqp::add_i($j,1),$elems)),
                  nqp::atpos_i(self,$i)
                ),
              ),
              $to
            )
        }
        multi method sort(intarray:D:) {
            Rakudo::Sorting.MERGESORT-int(nqp::clone(self))
        }
#- PLEASE DON'T CHANGE ANYTHING ABOVE THIS LINE
#- end of generated part of intarray role -------------------------------------

        method join(intarray:D: $delim = '') {
            my int $elems = nqp::elems(self);
            my $list     := nqp::setelems(nqp::list_s,$elems);
            my int $i     = -1;

            nqp::bindpos_s($list,$i,
              nqp::tostr_I(nqp::p6box_i(nqp::atpos_i(self,$i))))
              while nqp::islt_i(++$i,$elems);

            nqp::join($delim.Str,$list)
        }

        multi method STORE(intarray:D: Range:D $range) {
            nqp::if(
              $range.is-int,
              nqp::stmts(
                (my int $val = $range.min + $range.excludes-min),
                (my int $max = $range.max - $range.excludes-max),
                nqp::setelems(self, nqp::add_i(nqp::sub_i($max,$val),1)),
                (my int $i = -1),
                ($val = nqp::sub_i($val,1)),
                nqp::while(
                  nqp::isle_i(($val = nqp::add_i($val,1)),$max),
                  nqp::bindpos_i(self,($i = nqp::add_i($i,1)),$val)
                ),
                self
              ),
              (die "Can only initialize an int array with an int Range")
            )
        }
    }

    my role numarray[::T] does Positional[T] is array_type(T) {
#- start of generated part of numarray role -----------------------------------
#- Generated on 2017-10-26T01:53:35Z by tools/build/makeNATIVE_ARRAY.pl6
#- PLEASE DON'T CHANGE ANYTHING BELOW THIS LINE

        multi method AT-POS(numarray:D: int $idx) is raw {
            nqp::atposref_n(self, $idx)
        }
        multi method AT-POS(numarray:D: Int:D $idx) is raw {
            nqp::atposref_n(self, $idx)
        }

        multi method ASSIGN-POS(numarray:D: int $idx, num $value) {
            nqp::bindpos_n(self, $idx, $value)
        }
        multi method ASSIGN-POS(numarray:D: Int:D $idx, num $value) {
            nqp::bindpos_n(self, $idx, $value)
        }
        multi method ASSIGN-POS(numarray:D: int $idx, Num:D $value) {
            nqp::bindpos_n(self, $idx, $value)
        }
        multi method ASSIGN-POS(numarray:D: Int:D $idx, Num:D $value) {
            nqp::bindpos_n(self, $idx, $value)
        }
        multi method ASSIGN-POS(numarray:D: Any $idx, Mu \value) {
            X::TypeCheck.new(
                operation => "assignment to num array element #$idx",
                got       => value,
                expected  => T,
            ).throw;
        }

        multi method STORE(numarray:D: $value) {
            nqp::setelems(self,1);
            nqp::bindpos_n(self, 0, nqp::unbox_n($value));
            self
        }
        multi method STORE(numarray:D: num @values) {
            nqp::setelems(self,@values.elems);
            nqp::splice(self,@values,0,@values.elems)
        }
        multi method STORE(numarray:D: @values) {
            my int $elems = @values.elems;
            nqp::setelems(self, $elems);

            my int $i = -1;
            nqp::bindpos_n(self, $i,
              nqp::unbox_n(@values.AT-POS($i)))
              while nqp::islt_i($i = nqp::add_i($i,1),$elems);
            self
        }

        multi method push(numarray:D: num $value) {
            nqp::push_n(self, $value);
            self
        }
        multi method push(numarray:D: Num:D $value) {
            nqp::push_n(self, $value);
            self
        }
        multi method push(numarray:D: Mu \value) {
            X::TypeCheck.new(
                operation => 'push to num array',
                got       => value,
                expected  => T,
            ).throw;
        }
        multi method append(numarray:D: num $value) {
            nqp::push_n(self, $value);
            self
        }
        multi method append(numarray:D: Num:D $value) {
            nqp::push_n(self, $value);
            self
        }
        multi method append(numarray:D: numarray:D $values) is default {
            nqp::splice(self,$values,nqp::elems(self),0)
        }
        multi method append(numarray:D: @values) {
            fail X::Cannot::Lazy.new(:action<append>, :what(self.^name))
              if @values.is-lazy;
            nqp::push_n(self, $_) for flat @values;
            self
        }

        method pop(numarray:D: --> num) {
            nqp::elems(self) > 0
              ?? nqp::pop_n(self)
              !! die X::Cannot::Empty.new(:action<pop>, :what(self.^name));
        }

        method shift(numarray:D: --> num) {
            nqp::elems(self) > 0
              ?? nqp::shift_n(self)
              !! die X::Cannot::Empty.new(:action<shift>, :what(self.^name));
        }

        multi method unshift(numarray:D: num $value) {
            nqp::unshift_n(self, $value);
            self
        }
        multi method unshift(numarray:D: Num:D $value) {
            nqp::unshift_n(self, $value);
            self
        }
        multi method unshift(numarray:D: @values) {
            fail X::Cannot::Lazy.new(:action<unshift>, :what(self.^name))
              if @values.is-lazy;
            nqp::unshift_n(self, @values.pop) while @values;
            self
        }
        multi method unshift(numarray:D: Mu \value) {
            X::TypeCheck.new(
                operation => 'unshift to num array',
                got       => value,
                expected  => T,
            ).throw;
        }

        multi method splice(numarray:D: $offset=0, $size=Whatever, *@values) {
            fail X::Cannot::Lazy.new(:action('splice in'))
              if @values.is-lazy;

            my $elems = self.elems;
            my int $o = nqp::istype($offset,Callable)
              ?? $offset($elems)
              !! nqp::istype($offset,Whatever)
                ?? $elems
                !! $offset.Int;
            X::OutOfRange.new(
              :what('Offset argument to splice'),
              :got($o),
              :range("0..$elems"),
            ).fail if $o < 0 || $o > $elems; # one after list allowed for "push"

            my int $s = nqp::istype($size,Callable)
              ?? $size($elems - $o)
              !! !defined($size) || nqp::istype($size,Whatever)
                 ?? $elems - ($o min $elems)
                 !! $size.Int;
            X::OutOfRange.new(
              :what('Size argument to splice'),
              :got($s),
              :range("0..^{$elems - $o}"),
            ).fail if $s < 0;

            my @ret := nqp::create(self);
            my int $i = $o;
            my int $n = ($elems min $o + $s) - 1;
            while $i <= $n {
                nqp::push_n(@ret, nqp::atpos_n(self, $i));
                $i = $i + 1;
            }

            my @splicees := nqp::create(self);
            nqp::push_n(@splicees, @values.shift) while @values;
            nqp::splice(self, @splicees, $o, $s);
            @ret;
        }

        multi method min(numarray:D:) {
            nqp::if(
              (my int $elems = self.elems),
              nqp::stmts(
                (my int $i),
                (my num $min = nqp::atpos_n(self,0)),
                nqp::while(
                  nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                  nqp::if(
                    nqp::islt_n(nqp::atpos_n(self,$i),$min),
                    ($min = nqp::atpos_n(self,$i))
                  )
                ),
                $min
              ),
              Inf
            )
        }
        multi method max(numarray:D:) {
            nqp::if(
              (my int $elems = self.elems),
              nqp::stmts(
                (my int $i),
                (my num $max = nqp::atpos_n(self,0)),
                nqp::while(
                  nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                  nqp::if(
                    nqp::isgt_n(nqp::atpos_n(self,$i),$max),
                    ($max = nqp::atpos_n(self,$i))
                  )
                ),
                $max
              ),
              -Inf
            )
        }
        multi method minmax(numarray:D:) {
            nqp::if(
              (my int $elems = self.elems),
              nqp::stmts(
                (my int $i),
                (my num $min =
                  my num $max = nqp::atpos_n(self,0)),
                nqp::while(
                  nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                  nqp::if(
                    nqp::islt_n(nqp::atpos_n(self,$i),$min),
                    ($min = nqp::atpos_n(self,$i)),
                    nqp::if(
                      nqp::isgt_n(nqp::atpos_n(self,$i),$max),
                      ($max = nqp::atpos_n(self,$i))
                    )
                  )
                ),
                Range.new($min,$max)
              ),
              Range.new(Inf,-Inf)
            )
        }

        method iterator(numarray:D:) {
            class :: does Iterator {
                has int $!i;
                has $!array;    # Native array we're iterating

                method !SET-SELF(\array) {
                    $!array := nqp::decont(array);
                    $!i = -1;
                    self
                }
                method new(\array) { nqp::create(self)!SET-SELF(array) }

                method pull-one() is raw {
                    ($!i = $!i + 1) < nqp::elems($!array)
                      ?? nqp::atposref_n($!array,$!i)
                      !! IterationEnd
                }
                method push-all($target --> IterationEnd) {
                    my int $i     = $!i;
                    my int $elems = nqp::elems($!array);
                    $target.push(nqp::atposref_n($!array,$i))
                      while ($i = $i + 1) < $elems;
                    $!i = $i;
                }
            }.new(self)
        }
        method reverse(numarray:D:) is nodal {
            nqp::stmts(
              (my int $elems = nqp::elems(self)),
              (my int $last  = nqp::sub_i($elems,1)),
              (my int $i     = -1),
              (my $to := nqp::clone(self)),
              nqp::while(
                nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                nqp::bindpos_n($to,nqp::sub_i($last,$i),
                  nqp::atpos_n(self,$i))
              ),
              $to
            )
        }
        method rotate(numarray:D: Int(Cool) $rotate = 1) is nodal {
            nqp::stmts(
              (my int $elems = nqp::elems(self)),
              (my $to := nqp::clone(self)),
              (my int $i = -1),
              (my int $j =
                nqp::mod_i(nqp::sub_i(nqp::sub_i($elems,1),$rotate),$elems)),
              nqp::if(nqp::islt_i($j,0),($j = nqp::add_i($j,$elems))),
              nqp::while(
                nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                nqp::bindpos_n(
                  $to,
                  ($j = nqp::mod_i(nqp::add_i($j,1),$elems)),
                  nqp::atpos_n(self,$i)
                ),
              ),
              $to
            )
        }
        multi method sort(numarray:D:) {
            Rakudo::Sorting.MERGESORT-num(nqp::clone(self))
        }
#- PLEASE DON'T CHANGE ANYTHING ABOVE THIS LINE
#- end of generated part of numarray role -------------------------------------

        multi method STORE(numarray:D: Range:D $range) {
            my num $val = $range.min;
            $val = $val + 1 if $range.excludes-min;
            my num $max = $range.max;
            $max = $max - 1 if $range.excludes-max;
            fail X::Cannot::Lazy.new(:action<initialize>,:what(self.^name))
              if $val == -Inf || $max == Inf;

            nqp::setelems(self, ($max - $val + 1).Int );
            my int $i;
            while $val <= $max {
                nqp::bindpos_n(self, $i, $val);
                $val = $val + 1;
                $i   = $i   + 1;
            }
            self
        }
    }

    role shapedarray does Rakudo::Internals::ShapedArrayCommon {
        method shape() {
            nqp::stmts(
              (my $idims := nqp::dimensions(self)),
              (my int $dims = nqp::elems($idims)),
              (my $odims  := nqp::setelems(nqp::create(IterationBuffer),$dims)),
              (my int $i = -1),
              nqp::while(
                nqp::islt_i(($i = nqp::add_i($i,1)),$dims),
                nqp::bindpos($odims,$i,nqp::atpos_i($idims,$i))
              ),
              nqp::p6bindattrinvres(nqp::create(List),List,'$!reified',$odims)
            )
        }

        multi method EXISTS-POS(::?CLASS:D: **@indices) {
            nqp::p6bool(
              nqp::stmts(
                (my int $numdims = nqp::numdimensions(self)),
                (my int $numind  = @indices.elems),      # reifies
                (my $indices := nqp::getattr(@indices,List,'$!reified')),
                nqp::if(
                  nqp::isle_i($numind,$numdims),
                  nqp::stmts(
                    (my $dims := nqp::dimensions(self)),
                    (my int $i = -1),
                    nqp::while(
                      nqp::islt_i(($i = nqp::add_i($i,1)),$numind)
                        && nqp::isge_i(nqp::atpos($indices,$i),0)
                        && nqp::islt_i(
                             nqp::atpos($indices,$i),
                             nqp::atpos_i($dims,$i)
                           ),
                      nqp::null
                    ),
                    nqp::iseq_i($i,$numind)
                  )
                )
              )
            )
        }

        proto method STORE(|) { * }
        multi method STORE(::?CLASS:D: Mu \item) {
            X::Assignment::ToShaped.new(shape => self.shape).throw
        }
    }

#- start of generated part of shapedintarray role -----------------------------
#- Generated on 2017-10-16T15:04:46+02:00 by tools/build/makeNATIVE_SHAPED_ARRAY.pl6
#- PLEASE DON'T CHANGE ANYTHING BELOW THIS LINE

    role shapedintarray does shapedarray {
        multi method AT-POS(::?CLASS:D: **@indices) is raw {
            nqp::if(
              nqp::iseq_i(
                (my int $numdims = nqp::numdimensions(self)),
                (my int $numind  = @indices.elems),  # reifies
              ),
              nqp::stmts(
                (my $indices := nqp::getattr(@indices,List,'$!reified')),
                (my $idxs := nqp::list_i),
                nqp::while(                          # native index list
                  nqp::isge_i(($numdims = nqp::sub_i($numdims,1)),0),
                  nqp::push_i($idxs,nqp::shift($indices))
                ),

                nqp::multidimref_i(self,$idxs)




              ),
              nqp::if(
                nqp::isgt_i($numind,$numdims),
                X::TooManyDimensions.new(
                  operation => 'access',
                  got-dimensions => $numind,
                  needed-dimensions => $numdims
                ).throw,
                X::NYI.new(
                  feature => "Partially dimensioned views of shaped arrays"
                ).throw
              )
            )
        }

        multi method ASSIGN-POS(::?CLASS:D: **@indices) {
            nqp::stmts(
              (my int $value = @indices.pop),
              nqp::if(
                nqp::iseq_i(
                  (my int $numdims = nqp::numdimensions(self)),
                  (my int $numind  = @indices.elems),  # reifies
                ),
                nqp::stmts(
                  (my $indices := nqp::getattr(@indices,List,'$!reified')),
                  (my $idxs := nqp::list_i),
                  nqp::while(                          # native index list
                    nqp::isge_i(($numdims = nqp::sub_i($numdims,1)),0),
                    nqp::push_i($idxs,nqp::shift($indices))
                  ),
                  nqp::bindposnd_i(self, $idxs, $value)
                ),
                nqp::if(
                  nqp::isgt_i($numind,$numdims),
                  X::TooManyDimensions,
                  X::NotEnoughDimensions
                ).new(
                  operation => 'assign to',
                  got-dimensions => $numind,
                  needed-dimensions => $numdims
                ).throw
              )
            )
        }

        sub NATCPY(Mu \to, Mu \from) is raw {
            class :: does Rakudo::Iterator::ShapeLeaf {
                has Mu $!from;
                method INIT(Mu \to, Mu \from) {
                    nqp::stmts(
                      ($!from := from),
                      self.SET-SELF(to)
                    )
                }
                method new(Mu \to, Mu \from) {
                    nqp::create(self).INIT(to,from)
                }
                method result(--> Nil) {
                    nqp::bindposnd_i($!list,$!indices,

                      nqp::multidimref_i($!from,$!indices))




                }
            }.new(to,from).sink-all;
            to
        }
        sub OBJCPY(Mu \to, Mu \from) is raw {
            class :: does Rakudo::Iterator::ShapeLeaf {
                has Mu $!from;
                method INIT(Mu \to, Mu \from) {
                    nqp::stmts(
                      ($!from := nqp::getattr(from,List,'$!reified')),
                      self.SET-SELF(to)
                    )
                }
                method new(Mu \to, Mu \from) {
                    nqp::create(self).INIT(to,from)
                }
                method result(--> Nil) {
                    nqp::bindposnd_i($!list,$!indices,
                      nqp::atposnd($!from,$!indices))
                }
            }.new(to,from).sink-all;
            to
        }
        sub ITERCPY(Mu \to, Mu \from) is raw {
            class :: does Rakudo::Iterator::ShapeBranch {
                has $!iterators;
                method INIT(\to,\from) {
                    nqp::stmts(
                      self.SET-SELF(to),
                      ($!iterators := nqp::setelems(
                        nqp::list(from.iterator),
                        nqp::add_i($!maxdim,1)
                      )),
                      self
                    )
                }
                method new(\to,\from) { nqp::create(self).INIT(to,from) }
                method done(--> Nil) {
                    nqp::unless(                        # verify lowest
                      nqp::atpos($!iterators,0).is-lazy # finite iterator
                        || nqp::eqaddr(                 # and something there
                             nqp::atpos($!iterators,0).pull-one,IterationEnd),
                      nqp::atposnd_i($!list,$!indices)    # boom!
                    )
                }
                method process(--> Nil) {
                    nqp::stmts(
                      (my int $i = $!level),
                      nqp::while(
                        nqp::isle_i(($i = nqp::add_i($i,1)),$!maxdim),
                        nqp::if(
                          nqp::eqaddr((my $item :=      # exhausted ?
                            nqp::atpos($!iterators,nqp::sub_i($i,1)).pull-one),
                            IterationEnd
                          ),
                          nqp::bindpos($!iterators,$i,  # add an empty one
                            Rakudo::Iterator.Empty),
                          nqp::if(                      # is it an iterator?
                            nqp::istype($item,Iterable) && nqp::isconcrete($item),
                            nqp::bindpos($!iterators,$i,$item.iterator),
                            X::Assignment::ToShaped.new(shape => $!dims).throw
                          )
                        )
                      ),
                      (my $iter := nqp::atpos($!iterators,$!maxdim)),
                      nqp::until(                       # loop over highest dim
                        nqp::eqaddr((my $pulled := $iter.pull-one),IterationEnd)
                          || nqp::isgt_i(nqp::atpos_i($!indices,$!maxdim),$!maxind),
                        nqp::stmts(
                          nqp::bindposnd_i($!list,$!indices,$pulled),
                          nqp::bindpos_i($!indices,$!maxdim,  # increment index
                            nqp::add_i(nqp::atpos_i($!indices,$!maxdim),1))
                        )
                      ),
                      nqp::unless(
                        nqp::eqaddr($pulled,IterationEnd) # if not exhausted
                          || nqp::isle_i(                 # and index too high
                               nqp::atpos_i($!indices,$!maxdim),$!maxind)
                          || $iter.is-lazy,               # and not lazy
                        nqp::atposnd_i($!list,$!indices)  # boom!
                      )
                    )
                }
            }.new(to,from).sink-all;
            to
        }

        multi method STORE(::?CLASS:D: ::?CLASS:D \from) {
            nqp::if(
              EQV_DIMENSIONS(self,from),
              NATCPY(self,from),
              X::Assignment::ArrayShapeMismatch.new(
                source-shape => from.shape,
                target-shape => self.shape
              ).throw
            )
        }
        multi method STORE(::?CLASS:D: array:D \from) {
            nqp::if(
              nqp::istype(from.of,Int),
              nqp::if(
                EQV_DIMENSIONS(self,from),
                NATCPY(self,from),
                X::Assignment::ArrayShapeMismatch.new(
                  source-shape => from.shape,
                  target-shape => self.shape
                ).throw
              ),
              X::TypeCheck::Assignment.new(
                symbol   => self.^name ~ '[' ~ self.shape.join(';') ~ ']',
                expected => Int,
                got      => from.of
              ).throw
            )
        }
        multi method STORE(::?CLASS:D: Iterable:D \from) {
            nqp::if(
              nqp::can(from,'shape'),
              nqp::if(
                from.shape eqv self.shape,
                OBJCPY(self,from),
                X::Assignment::ArrayShapeMismatch.new(
                    source-shape => from.shape,
                    target-shape => self.shape
                ).throw
              ),
              ITERCPY(self,from)
            )
        }
        method iterator(::?CLASS:D:) {
            class :: does Rakudo::Iterator::ShapeLeaf {
                method result() is raw {

                    nqp::multidimref_i($!list,nqp::clone($!indices))




                }
            }.new(self)
        }
        multi method kv(::?CLASS:D:) {
            Seq.new(class :: does Rakudo::Iterator::ShapeLeaf {
                has int $!on-key;
                method result() is raw {
                    nqp::if(
                      ($!on-key = nqp::not_i($!on-key)),
                      nqp::stmts(
                        (my $result := self.indices),
                        (nqp::bindpos_i($!indices,$!maxdim,  # back 1 for next
                          nqp::sub_i(nqp::atpos_i($!indices,$!maxdim),1))),
                        $result
                      ),

                      nqp::multidimref_i($!list,nqp::clone($!indices))




                    )
                }
                # needs its own push-all since it fiddles with $!indices
                method push-all($target --> IterationEnd) {
                    nqp::until(
                      nqp::eqaddr((my $pulled := self.pull-one),IterationEnd),
                      $target.push($pulled)
                    )
                }
            }.new(self))
        }
        multi method pairs(::?CLASS:D:) {
            Seq.new(class :: does Rakudo::Iterator::ShapeLeaf {
                method result() {
                    Pair.new(
                      self.indices,

                      nqp::multidimref_i($!list,nqp::clone($!indices))




                    )
                }
            }.new(self))
        }
        multi method antipairs(::?CLASS:D:) {
            Seq.new(class :: does Rakudo::Iterator::ShapeLeaf {
                method result() {
                    Pair.new(nqp::atposnd_i($!list,$!indices),self.indices)
                }
            }.new(self))
        }
    }  # end of shapedintarray role

    role shaped1intarray does shapedintarray {
        multi method AT-POS(::?CLASS:D: int \one) is raw {
           nqp::atposref_i(self,one)
        }
        multi method AT-POS(::?CLASS:D: Int:D \one) is raw {
           nqp::atposref_i(self,one)
        }

        multi method ASSIGN-POS(::?CLASS:D: int \one, int \value) {
            nqp::bindpos_i(self,one,value)
        }
        multi method ASSIGN-POS(::?CLASS:D: Int:D \one, int \value) {
            nqp::bindpos_i(self,one,value)
        }
        multi method ASSIGN-POS(::?CLASS:D: int \one, Int:D \value) {
            nqp::bindpos_i(self,one,value)
        }
        multi method ASSIGN-POS(::?CLASS:D: Int:D \one, Int:D \value) {
            nqp::bindpos_i(self,one,value)
        }

        multi method EXISTS-POS(::?CLASS:D: int \one) {
            nqp::p6bool(
              nqp::isge_i(one,0) && nqp::islt_i(one,nqp::elems(self))
            )
        }
        multi method EXISTS-POS(::?CLASS:D: Int:D \one) {
            nqp::p6bool(
              nqp::isge_i(one,0) && nqp::islt_i(one,nqp::elems(self))
            )
        }

        multi method STORE(::?CLASS:D: ::?CLASS:D \from) {
            nqp::if(
              nqp::iseq_i((my int $elems = nqp::elems(self)),nqp::elems(from)),
              nqp::stmts(
                (my int $i = -1),
                nqp::while(
                  nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                  nqp::bindpos_i(self,$i,nqp::atpos_i(from,$i))
                ),
                self
              ),
              X::Assignment::ArrayShapeMismatch.new(
                source-shape => from.shape,
                target-shape => self.shape
              ).throw
            )
        }
        multi method STORE(::?CLASS:D: Iterable:D \in) {
            nqp::stmts(
              (my \iter := in.iterator),
              (my int $elems = nqp::elems(self)),
              (my int $i = -1),
              nqp::until(
                nqp::eqaddr((my $pulled := iter.pull-one),IterationEnd)
                  || nqp::iseq_i(($i = nqp::add_i($i,1)),$elems),
                nqp::bindpos_i(self,$i,$pulled)
              ),
              nqp::unless(
                nqp::islt_i($i,$elems) || iter.is-lazy,
                nqp::atpos_i(list,$i) # too many values on non-lazy it
              ),
              self
            )
        }
        multi method STORE(::?CLASS:D: Int:D \item) {
            nqp::stmts(
              nqp::bindpos_i(self,0,item),
              self
            )
        }
        method iterator(::?CLASS:D:) {
            class :: does Iterator {
                has Mu $!list;
                has int $!pos;
                method !SET-SELF(Mu \list) {
                    nqp::stmts(
                      ($!list := list),
                      ($!pos = -1),
                      self
                    )
                }
                method new(Mu \list) { nqp::create(self)!SET-SELF(list) }
                method pull-one() is raw {
                    nqp::if(
                      nqp::islt_i(
                        ($!pos = nqp::add_i($!pos,1)),
                        nqp::elems($!list)
                      ),
                      nqp::atposref_i($!list,$!pos),
                      IterationEnd
                    )
                }
                method push-all($target --> IterationEnd) {
                    nqp::stmts(
                      (my int $elems = nqp::elems($!list)),
                      (my int $pos = $!pos),
                      nqp::while(
                        nqp::islt_i(($pos = nqp::add_i($pos,1)),$elems),
                        $target.push(nqp::atpos_i($!list,$pos))
                      ),
                      ($!pos = $pos)
                    )
                }
                method count-only() { nqp::p6box_i(nqp::elems($!list)) }
                method bool-only()  { nqp::p6bool(nqp::elems($!list)) }
                method sink-all(--> IterationEnd) {
                    $!pos = nqp::elems($!list)
                }
            }.new(self)
        }
        multi method kv(::?CLASS:D:) {
            my int $i = -1;
            my int $elems = nqp::add_i(nqp::elems(self),nqp::elems(self));
            Seq.new(Rakudo::Iterator.Callable({
                nqp::if(
                  nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                  nqp::if(
                    nqp::bitand_i($i,1),
                    nqp::atposref_i(self,nqp::bitshiftr_i($i,1)),
                    nqp::bitshiftr_i($i,1)
                  ),
                  IterationEnd
                )
            }))
        }
        multi method pairs(::?CLASS:D:) {
            my int $i = -1;
            my int $elems = nqp::elems(self);
            Seq.new(Rakudo::Iterator.Callable({
                nqp::if(
                  nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                  Pair.new($i,nqp::atposref_i(self,$i)),
                  IterationEnd
                )
            }))
        }
        multi method antipairs(::?CLASS:D:) {
            Seq.new(Rakudo::Iterator.AntiPair(self.iterator))
        }
        method reverse(::?CLASS:D:) is nodal {
            nqp::stmts(
              (my int $elems = nqp::elems(self)),
              (my int $last  = nqp::sub_i($elems,1)),
              (my int $i     = -1),
              (my $to := nqp::clone(self)),
              nqp::while(
                nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                nqp::bindpos_i($to,nqp::sub_i($last,$i),
                  nqp::atpos_i(self,$i))
              ),
              $to
            )
        }
        method rotate(::?CLASS:D: Int(Cool) $rotate = 1) is nodal {
            nqp::stmts(
              (my int $elems = nqp::elems(self)),
              (my $to := nqp::clone(self)),
              (my int $i = -1),
              (my int $j =
                nqp::mod_i(nqp::sub_i(nqp::sub_i($elems,1),$rotate),$elems)),
              nqp::if(nqp::islt_i($j,0),($j = nqp::add_i($j,$elems))),
              nqp::while(
                nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                nqp::bindpos_i(
                  $to,
                  ($j = nqp::mod_i(nqp::add_i($j,1),$elems)),
                  nqp::atpos_i(self,$i)
                ),
              ),
              $to
            )
        }
    } # end of shaped1intarray role

    role shaped2intarray does shapedintarray {
        multi method AT-POS(::?CLASS:D: int \one, int \two) is raw {

            nqp::multidimref_i(self,nqp::list_i(one, two))




        }
        multi method AT-POS(::?CLASS:D: Int:D \one, Int:D \two) is raw {

            nqp::multidimref_i(self,nqp::list_i(one, two))




        }

        multi method ASSIGN-POS(::?CLASS:D: int \one, int \two, Int:D \value) {
            nqp::bindpos2d_i(self,one,two,value)
        }
        multi method ASSIGN-POS(::?CLASS:D: Int:D \one, Int:D \two, Int:D \value) {
            nqp::bindpos2d_i(self,one,two,value)
        }

        multi method EXISTS-POS(::?CLASS:D: int \one, int \two) {
            nqp::p6bool(
              nqp::isge_i(one,0)
                && nqp::isge_i(two,0)
                && nqp::islt_i(one,nqp::atpos_i(nqp::dimensions(self),0))
                && nqp::islt_i(two,nqp::atpos_i(nqp::dimensions(self),1))
            )
        }
        multi method EXISTS-POS(::?CLASS:D: Int:D \one, Int:D \two) {
            nqp::p6bool(
              nqp::isge_i(one,0)
                && nqp::isge_i(two,0)
                && nqp::islt_i(one,nqp::atpos_i(nqp::dimensions(self),0))
                && nqp::islt_i(two,nqp::atpos_i(nqp::dimensions(self),1))
            )
        }
    } # end of shaped2intarray role

    role shaped3intarray does shapedintarray {
        multi method AT-POS(::?CLASS:D: int \one, int \two, int \three) is raw {

            nqp::multidimref_i(self,nqp::list_i(one, two, three))




        }
        multi method AT-POS(::?CLASS:D: Int:D \one, Int:D \two, Int:D \three) is raw {

            nqp::multidimref_i(self,nqp::list_i(one, two, three))




        }

        multi method ASSIGN-POS(::?CLASS:D: int \one, int \two, int \three, Int:D \value) {
            nqp::bindpos3d_i(self,one,two,three,value)
        }
        multi method ASSIGN-POS(::?CLASS:D: Int:D \one, Int:D \two, Int:D \three, Int:D \value) {
            nqp::bindpos3d_i(self,one,two,three,value)
        }

        multi method EXISTS-POS(::?CLASS:D: int \one, int \two, int \three) {
            nqp::p6bool(
              nqp::isge_i(one,0)
                && nqp::isge_i(two,0)
                && nqp::isge_i(three,0)
                && nqp::islt_i(one,nqp::atpos_i(nqp::dimensions(self),0))
                && nqp::islt_i(two,nqp::atpos_i(nqp::dimensions(self),1))
                && nqp::islt_i(three,nqp::atpos_i(nqp::dimensions(self),2))
            )
        }
        multi method EXISTS-POS(::?CLASS:D: Int:D \one, Int:D \two, Int:D \three) {
            nqp::p6bool(
              nqp::isge_i(one,0)
                && nqp::isge_i(two,0)
                && nqp::isge_i(three,0)
                && nqp::islt_i(one,nqp::atpos_i(nqp::dimensions(self),0))
                && nqp::islt_i(two,nqp::atpos_i(nqp::dimensions(self),1))
                && nqp::islt_i(three,nqp::atpos_i(nqp::dimensions(self),2))
            )
        }
    } # end of shaped3intarray role
#- PLEASE DON'T CHANGE ANYTHING ABOVE THIS LINE
#- end of generated part of shapedintarray role -------------------------------

#- start of generated part of shapednumarray role -----------------------------
#- Generated on 2017-10-16T15:04:46+02:00 by tools/build/makeNATIVE_SHAPED_ARRAY.pl6
#- PLEASE DON'T CHANGE ANYTHING BELOW THIS LINE

    role shapednumarray does shapedarray {
        multi method AT-POS(::?CLASS:D: **@indices) is raw {
            nqp::if(
              nqp::iseq_i(
                (my int $numdims = nqp::numdimensions(self)),
                (my int $numind  = @indices.elems),  # reifies
              ),
              nqp::stmts(
                (my $indices := nqp::getattr(@indices,List,'$!reified')),
                (my $idxs := nqp::list_i),
                nqp::while(                          # native index list
                  nqp::isge_i(($numdims = nqp::sub_i($numdims,1)),0),
                  nqp::push_i($idxs,nqp::shift($indices))
                ),

                nqp::multidimref_n(self,$idxs)




              ),
              nqp::if(
                nqp::isgt_i($numind,$numdims),
                X::TooManyDimensions.new(
                  operation => 'access',
                  got-dimensions => $numind,
                  needed-dimensions => $numdims
                ).throw,
                X::NYI.new(
                  feature => "Partially dimensioned views of shaped arrays"
                ).throw
              )
            )
        }

        multi method ASSIGN-POS(::?CLASS:D: **@indices) {
            nqp::stmts(
              (my num $value = @indices.pop),
              nqp::if(
                nqp::iseq_i(
                  (my int $numdims = nqp::numdimensions(self)),
                  (my int $numind  = @indices.elems),  # reifies
                ),
                nqp::stmts(
                  (my $indices := nqp::getattr(@indices,List,'$!reified')),
                  (my $idxs := nqp::list_i),
                  nqp::while(                          # native index list
                    nqp::isge_i(($numdims = nqp::sub_i($numdims,1)),0),
                    nqp::push_i($idxs,nqp::shift($indices))
                  ),
                  nqp::bindposnd_n(self, $idxs, $value)
                ),
                nqp::if(
                  nqp::isgt_i($numind,$numdims),
                  X::TooManyDimensions,
                  X::NotEnoughDimensions
                ).new(
                  operation => 'assign to',
                  got-dimensions => $numind,
                  needed-dimensions => $numdims
                ).throw
              )
            )
        }

        sub NATCPY(Mu \to, Mu \from) is raw {
            class :: does Rakudo::Iterator::ShapeLeaf {
                has Mu $!from;
                method INIT(Mu \to, Mu \from) {
                    nqp::stmts(
                      ($!from := from),
                      self.SET-SELF(to)
                    )
                }
                method new(Mu \to, Mu \from) {
                    nqp::create(self).INIT(to,from)
                }
                method result(--> Nil) {
                    nqp::bindposnd_n($!list,$!indices,

                      nqp::multidimref_n($!from,$!indices))




                }
            }.new(to,from).sink-all;
            to
        }
        sub OBJCPY(Mu \to, Mu \from) is raw {
            class :: does Rakudo::Iterator::ShapeLeaf {
                has Mu $!from;
                method INIT(Mu \to, Mu \from) {
                    nqp::stmts(
                      ($!from := nqp::getattr(from,List,'$!reified')),
                      self.SET-SELF(to)
                    )
                }
                method new(Mu \to, Mu \from) {
                    nqp::create(self).INIT(to,from)
                }
                method result(--> Nil) {
                    nqp::bindposnd_n($!list,$!indices,
                      nqp::atposnd($!from,$!indices))
                }
            }.new(to,from).sink-all;
            to
        }
        sub ITERCPY(Mu \to, Mu \from) is raw {
            class :: does Rakudo::Iterator::ShapeBranch {
                has $!iterators;
                method INIT(\to,\from) {
                    nqp::stmts(
                      self.SET-SELF(to),
                      ($!iterators := nqp::setelems(
                        nqp::list(from.iterator),
                        nqp::add_i($!maxdim,1)
                      )),
                      self
                    )
                }
                method new(\to,\from) { nqp::create(self).INIT(to,from) }
                method done(--> Nil) {
                    nqp::unless(                        # verify lowest
                      nqp::atpos($!iterators,0).is-lazy # finite iterator
                        || nqp::eqaddr(                 # and something there
                             nqp::atpos($!iterators,0).pull-one,IterationEnd),
                      nqp::atposnd_n($!list,$!indices)    # boom!
                    )
                }
                method process(--> Nil) {
                    nqp::stmts(
                      (my int $i = $!level),
                      nqp::while(
                        nqp::isle_i(($i = nqp::add_i($i,1)),$!maxdim),
                        nqp::if(
                          nqp::eqaddr((my $item :=      # exhausted ?
                            nqp::atpos($!iterators,nqp::sub_i($i,1)).pull-one),
                            IterationEnd
                          ),
                          nqp::bindpos($!iterators,$i,  # add an empty one
                            Rakudo::Iterator.Empty),
                          nqp::if(                      # is it an iterator?
                            nqp::istype($item,Iterable) && nqp::isconcrete($item),
                            nqp::bindpos($!iterators,$i,$item.iterator),
                            X::Assignment::ToShaped.new(shape => $!dims).throw
                          )
                        )
                      ),
                      (my $iter := nqp::atpos($!iterators,$!maxdim)),
                      nqp::until(                       # loop over highest dim
                        nqp::eqaddr((my $pulled := $iter.pull-one),IterationEnd)
                          || nqp::isgt_i(nqp::atpos_i($!indices,$!maxdim),$!maxind),
                        nqp::stmts(
                          nqp::bindposnd_n($!list,$!indices,$pulled),
                          nqp::bindpos_i($!indices,$!maxdim,  # increment index
                            nqp::add_i(nqp::atpos_i($!indices,$!maxdim),1))
                        )
                      ),
                      nqp::unless(
                        nqp::eqaddr($pulled,IterationEnd) # if not exhausted
                          || nqp::isle_i(                 # and index too high
                               nqp::atpos_i($!indices,$!maxdim),$!maxind)
                          || $iter.is-lazy,               # and not lazy
                        nqp::atposnd_n($!list,$!indices)  # boom!
                      )
                    )
                }
            }.new(to,from).sink-all;
            to
        }

        multi method STORE(::?CLASS:D: ::?CLASS:D \from) {
            nqp::if(
              EQV_DIMENSIONS(self,from),
              NATCPY(self,from),
              X::Assignment::ArrayShapeMismatch.new(
                source-shape => from.shape,
                target-shape => self.shape
              ).throw
            )
        }
        multi method STORE(::?CLASS:D: array:D \from) {
            nqp::if(
              nqp::istype(from.of,Num),
              nqp::if(
                EQV_DIMENSIONS(self,from),
                NATCPY(self,from),
                X::Assignment::ArrayShapeMismatch.new(
                  source-shape => from.shape,
                  target-shape => self.shape
                ).throw
              ),
              X::TypeCheck::Assignment.new(
                symbol   => self.^name ~ '[' ~ self.shape.join(';') ~ ']',
                expected => Num,
                got      => from.of
              ).throw
            )
        }
        multi method STORE(::?CLASS:D: Iterable:D \from) {
            nqp::if(
              nqp::can(from,'shape'),
              nqp::if(
                from.shape eqv self.shape,
                OBJCPY(self,from),
                X::Assignment::ArrayShapeMismatch.new(
                    source-shape => from.shape,
                    target-shape => self.shape
                ).throw
              ),
              ITERCPY(self,from)
            )
        }
        method iterator(::?CLASS:D:) {
            class :: does Rakudo::Iterator::ShapeLeaf {
                method result() is raw {

                    nqp::multidimref_n($!list,nqp::clone($!indices))




                }
            }.new(self)
        }
        multi method kv(::?CLASS:D:) {
            Seq.new(class :: does Rakudo::Iterator::ShapeLeaf {
                has int $!on-key;
                method result() is raw {
                    nqp::if(
                      ($!on-key = nqp::not_i($!on-key)),
                      nqp::stmts(
                        (my $result := self.indices),
                        (nqp::bindpos_i($!indices,$!maxdim,  # back 1 for next
                          nqp::sub_i(nqp::atpos_i($!indices,$!maxdim),1))),
                        $result
                      ),

                      nqp::multidimref_n($!list,nqp::clone($!indices))




                    )
                }
                # needs its own push-all since it fiddles with $!indices
                method push-all($target --> IterationEnd) {
                    nqp::until(
                      nqp::eqaddr((my $pulled := self.pull-one),IterationEnd),
                      $target.push($pulled)
                    )
                }
            }.new(self))
        }
        multi method pairs(::?CLASS:D:) {
            Seq.new(class :: does Rakudo::Iterator::ShapeLeaf {
                method result() {
                    Pair.new(
                      self.indices,

                      nqp::multidimref_n($!list,nqp::clone($!indices))




                    )
                }
            }.new(self))
        }
        multi method antipairs(::?CLASS:D:) {
            Seq.new(class :: does Rakudo::Iterator::ShapeLeaf {
                method result() {
                    Pair.new(nqp::atposnd_n($!list,$!indices),self.indices)
                }
            }.new(self))
        }
    }  # end of shapednumarray role

    role shaped1numarray does shapednumarray {
        multi method AT-POS(::?CLASS:D: int \one) is raw {
           nqp::atposref_n(self,one)
        }
        multi method AT-POS(::?CLASS:D: Int:D \one) is raw {
           nqp::atposref_n(self,one)
        }

        multi method ASSIGN-POS(::?CLASS:D: int \one, num \value) {
            nqp::bindpos_n(self,one,value)
        }
        multi method ASSIGN-POS(::?CLASS:D: Int:D \one, num \value) {
            nqp::bindpos_n(self,one,value)
        }
        multi method ASSIGN-POS(::?CLASS:D: int \one, Num:D \value) {
            nqp::bindpos_n(self,one,value)
        }
        multi method ASSIGN-POS(::?CLASS:D: Int:D \one, Num:D \value) {
            nqp::bindpos_n(self,one,value)
        }

        multi method EXISTS-POS(::?CLASS:D: int \one) {
            nqp::p6bool(
              nqp::isge_i(one,0) && nqp::islt_i(one,nqp::elems(self))
            )
        }
        multi method EXISTS-POS(::?CLASS:D: Int:D \one) {
            nqp::p6bool(
              nqp::isge_i(one,0) && nqp::islt_i(one,nqp::elems(self))
            )
        }

        multi method STORE(::?CLASS:D: ::?CLASS:D \from) {
            nqp::if(
              nqp::iseq_i((my int $elems = nqp::elems(self)),nqp::elems(from)),
              nqp::stmts(
                (my int $i = -1),
                nqp::while(
                  nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                  nqp::bindpos_n(self,$i,nqp::atpos_n(from,$i))
                ),
                self
              ),
              X::Assignment::ArrayShapeMismatch.new(
                source-shape => from.shape,
                target-shape => self.shape
              ).throw
            )
        }
        multi method STORE(::?CLASS:D: Iterable:D \in) {
            nqp::stmts(
              (my \iter := in.iterator),
              (my int $elems = nqp::elems(self)),
              (my int $i = -1),
              nqp::until(
                nqp::eqaddr((my $pulled := iter.pull-one),IterationEnd)
                  || nqp::iseq_i(($i = nqp::add_i($i,1)),$elems),
                nqp::bindpos_n(self,$i,$pulled)
              ),
              nqp::unless(
                nqp::islt_i($i,$elems) || iter.is-lazy,
                nqp::atpos_n(list,$i) # too many values on non-lazy it
              ),
              self
            )
        }
        multi method STORE(::?CLASS:D: Num:D \item) {
            nqp::stmts(
              nqp::bindpos_n(self,0,item),
              self
            )
        }
        method iterator(::?CLASS:D:) {
            class :: does Iterator {
                has Mu $!list;
                has int $!pos;
                method !SET-SELF(Mu \list) {
                    nqp::stmts(
                      ($!list := list),
                      ($!pos = -1),
                      self
                    )
                }
                method new(Mu \list) { nqp::create(self)!SET-SELF(list) }
                method pull-one() is raw {
                    nqp::if(
                      nqp::islt_i(
                        ($!pos = nqp::add_i($!pos,1)),
                        nqp::elems($!list)
                      ),
                      nqp::atposref_n($!list,$!pos),
                      IterationEnd
                    )
                }
                method push-all($target --> IterationEnd) {
                    nqp::stmts(
                      (my int $elems = nqp::elems($!list)),
                      (my int $pos = $!pos),
                      nqp::while(
                        nqp::islt_i(($pos = nqp::add_i($pos,1)),$elems),
                        $target.push(nqp::atpos_n($!list,$pos))
                      ),
                      ($!pos = $pos)
                    )
                }
                method count-only() { nqp::p6box_i(nqp::elems($!list)) }
                method bool-only()  { nqp::p6bool(nqp::elems($!list)) }
                method sink-all(--> IterationEnd) {
                    $!pos = nqp::elems($!list)
                }
            }.new(self)
        }
        multi method kv(::?CLASS:D:) {
            my int $i = -1;
            my int $elems = nqp::add_i(nqp::elems(self),nqp::elems(self));
            Seq.new(Rakudo::Iterator.Callable({
                nqp::if(
                  nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                  nqp::if(
                    nqp::bitand_i($i,1),
                    nqp::atposref_n(self,nqp::bitshiftr_i($i,1)),
                    nqp::bitshiftr_i($i,1)
                  ),
                  IterationEnd
                )
            }))
        }
        multi method pairs(::?CLASS:D:) {
            my int $i = -1;
            my int $elems = nqp::elems(self);
            Seq.new(Rakudo::Iterator.Callable({
                nqp::if(
                  nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                  Pair.new($i,nqp::atposref_n(self,$i)),
                  IterationEnd
                )
            }))
        }
        multi method antipairs(::?CLASS:D:) {
            Seq.new(Rakudo::Iterator.AntiPair(self.iterator))
        }
        method reverse(::?CLASS:D:) is nodal {
            nqp::stmts(
              (my int $elems = nqp::elems(self)),
              (my int $last  = nqp::sub_i($elems,1)),
              (my int $i     = -1),
              (my $to := nqp::clone(self)),
              nqp::while(
                nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                nqp::bindpos_n($to,nqp::sub_i($last,$i),
                  nqp::atpos_n(self,$i))
              ),
              $to
            )
        }
        method rotate(::?CLASS:D: Int(Cool) $rotate = 1) is nodal {
            nqp::stmts(
              (my int $elems = nqp::elems(self)),
              (my $to := nqp::clone(self)),
              (my int $i = -1),
              (my int $j =
                nqp::mod_i(nqp::sub_i(nqp::sub_i($elems,1),$rotate),$elems)),
              nqp::if(nqp::islt_i($j,0),($j = nqp::add_i($j,$elems))),
              nqp::while(
                nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                nqp::bindpos_n(
                  $to,
                  ($j = nqp::mod_i(nqp::add_i($j,1),$elems)),
                  nqp::atpos_n(self,$i)
                ),
              ),
              $to
            )
        }
    } # end of shaped1numarray role

    role shaped2numarray does shapednumarray {
        multi method AT-POS(::?CLASS:D: int \one, int \two) is raw {

            nqp::multidimref_n(self,nqp::list_i(one, two))




        }
        multi method AT-POS(::?CLASS:D: Int:D \one, Int:D \two) is raw {

            nqp::multidimref_n(self,nqp::list_i(one, two))




        }

        multi method ASSIGN-POS(::?CLASS:D: int \one, int \two, Num:D \value) {
            nqp::bindpos2d_n(self,one,two,value)
        }
        multi method ASSIGN-POS(::?CLASS:D: Int:D \one, Int:D \two, Num:D \value) {
            nqp::bindpos2d_n(self,one,two,value)
        }

        multi method EXISTS-POS(::?CLASS:D: int \one, int \two) {
            nqp::p6bool(
              nqp::isge_i(one,0)
                && nqp::isge_i(two,0)
                && nqp::islt_i(one,nqp::atpos_i(nqp::dimensions(self),0))
                && nqp::islt_i(two,nqp::atpos_i(nqp::dimensions(self),1))
            )
        }
        multi method EXISTS-POS(::?CLASS:D: Int:D \one, Int:D \two) {
            nqp::p6bool(
              nqp::isge_i(one,0)
                && nqp::isge_i(two,0)
                && nqp::islt_i(one,nqp::atpos_i(nqp::dimensions(self),0))
                && nqp::islt_i(two,nqp::atpos_i(nqp::dimensions(self),1))
            )
        }
    } # end of shaped2numarray role

    role shaped3numarray does shapednumarray {
        multi method AT-POS(::?CLASS:D: int \one, int \two, int \three) is raw {

            nqp::multidimref_n(self,nqp::list_i(one, two, three))




        }
        multi method AT-POS(::?CLASS:D: Int:D \one, Int:D \two, Int:D \three) is raw {

            nqp::multidimref_n(self,nqp::list_i(one, two, three))




        }

        multi method ASSIGN-POS(::?CLASS:D: int \one, int \two, int \three, Num:D \value) {
            nqp::bindpos3d_n(self,one,two,three,value)
        }
        multi method ASSIGN-POS(::?CLASS:D: Int:D \one, Int:D \two, Int:D \three, Num:D \value) {
            nqp::bindpos3d_n(self,one,two,three,value)
        }

        multi method EXISTS-POS(::?CLASS:D: int \one, int \two, int \three) {
            nqp::p6bool(
              nqp::isge_i(one,0)
                && nqp::isge_i(two,0)
                && nqp::isge_i(three,0)
                && nqp::islt_i(one,nqp::atpos_i(nqp::dimensions(self),0))
                && nqp::islt_i(two,nqp::atpos_i(nqp::dimensions(self),1))
                && nqp::islt_i(three,nqp::atpos_i(nqp::dimensions(self),2))
            )
        }
        multi method EXISTS-POS(::?CLASS:D: Int:D \one, Int:D \two, Int:D \three) {
            nqp::p6bool(
              nqp::isge_i(one,0)
                && nqp::isge_i(two,0)
                && nqp::isge_i(three,0)
                && nqp::islt_i(one,nqp::atpos_i(nqp::dimensions(self),0))
                && nqp::islt_i(two,nqp::atpos_i(nqp::dimensions(self),1))
                && nqp::islt_i(three,nqp::atpos_i(nqp::dimensions(self),2))
            )
        }
    } # end of shaped3numarray role
#- PLEASE DON'T CHANGE ANYTHING ABOVE THIS LINE
#- end of generated part of shapednumarray role -------------------------------

#- start of generated part of shapedstrarray role -----------------------------
#- Generated on 2017-10-16T15:04:46+02:00 by tools/build/makeNATIVE_SHAPED_ARRAY.pl6
#- PLEASE DON'T CHANGE ANYTHING BELOW THIS LINE

    role shapedstrarray does shapedarray {
        multi method AT-POS(::?CLASS:D: **@indices) is raw {
            nqp::if(
              nqp::iseq_i(
                (my int $numdims = nqp::numdimensions(self)),
                (my int $numind  = @indices.elems),  # reifies
              ),
              nqp::stmts(
                (my $indices := nqp::getattr(@indices,List,'$!reified')),
                (my $idxs := nqp::list_i),
                nqp::while(                          # native index list
                  nqp::isge_i(($numdims = nqp::sub_i($numdims,1)),0),
                  nqp::push_i($idxs,nqp::shift($indices))
                ),

                nqp::multidimref_s(self,$idxs)




              ),
              nqp::if(
                nqp::isgt_i($numind,$numdims),
                X::TooManyDimensions.new(
                  operation => 'access',
                  got-dimensions => $numind,
                  needed-dimensions => $numdims
                ).throw,
                X::NYI.new(
                  feature => "Partially dimensioned views of shaped arrays"
                ).throw
              )
            )
        }

        multi method ASSIGN-POS(::?CLASS:D: **@indices) {
            nqp::stmts(
              (my str $value = @indices.pop),
              nqp::if(
                nqp::iseq_i(
                  (my int $numdims = nqp::numdimensions(self)),
                  (my int $numind  = @indices.elems),  # reifies
                ),
                nqp::stmts(
                  (my $indices := nqp::getattr(@indices,List,'$!reified')),
                  (my $idxs := nqp::list_i),
                  nqp::while(                          # native index list
                    nqp::isge_i(($numdims = nqp::sub_i($numdims,1)),0),
                    nqp::push_i($idxs,nqp::shift($indices))
                  ),
                  nqp::bindposnd_s(self, $idxs, $value)
                ),
                nqp::if(
                  nqp::isgt_i($numind,$numdims),
                  X::TooManyDimensions,
                  X::NotEnoughDimensions
                ).new(
                  operation => 'assign to',
                  got-dimensions => $numind,
                  needed-dimensions => $numdims
                ).throw
              )
            )
        }

        sub NATCPY(Mu \to, Mu \from) is raw {
            class :: does Rakudo::Iterator::ShapeLeaf {
                has Mu $!from;
                method INIT(Mu \to, Mu \from) {
                    nqp::stmts(
                      ($!from := from),
                      self.SET-SELF(to)
                    )
                }
                method new(Mu \to, Mu \from) {
                    nqp::create(self).INIT(to,from)
                }
                method result(--> Nil) {
                    nqp::bindposnd_s($!list,$!indices,

                      nqp::multidimref_s($!from,$!indices))




                }
            }.new(to,from).sink-all;
            to
        }
        sub OBJCPY(Mu \to, Mu \from) is raw {
            class :: does Rakudo::Iterator::ShapeLeaf {
                has Mu $!from;
                method INIT(Mu \to, Mu \from) {
                    nqp::stmts(
                      ($!from := nqp::getattr(from,List,'$!reified')),
                      self.SET-SELF(to)
                    )
                }
                method new(Mu \to, Mu \from) {
                    nqp::create(self).INIT(to,from)
                }
                method result(--> Nil) {
                    nqp::bindposnd_s($!list,$!indices,
                      nqp::atposnd($!from,$!indices))
                }
            }.new(to,from).sink-all;
            to
        }
        sub ITERCPY(Mu \to, Mu \from) is raw {
            class :: does Rakudo::Iterator::ShapeBranch {
                has $!iterators;
                method INIT(\to,\from) {
                    nqp::stmts(
                      self.SET-SELF(to),
                      ($!iterators := nqp::setelems(
                        nqp::list(from.iterator),
                        nqp::add_i($!maxdim,1)
                      )),
                      self
                    )
                }
                method new(\to,\from) { nqp::create(self).INIT(to,from) }
                method done(--> Nil) {
                    nqp::unless(                        # verify lowest
                      nqp::atpos($!iterators,0).is-lazy # finite iterator
                        || nqp::eqaddr(                 # and something there
                             nqp::atpos($!iterators,0).pull-one,IterationEnd),
                      nqp::atposnd_s($!list,$!indices)    # boom!
                    )
                }
                method process(--> Nil) {
                    nqp::stmts(
                      (my int $i = $!level),
                      nqp::while(
                        nqp::isle_i(($i = nqp::add_i($i,1)),$!maxdim),
                        nqp::if(
                          nqp::eqaddr((my $item :=      # exhausted ?
                            nqp::atpos($!iterators,nqp::sub_i($i,1)).pull-one),
                            IterationEnd
                          ),
                          nqp::bindpos($!iterators,$i,  # add an empty one
                            Rakudo::Iterator.Empty),
                          nqp::if(                      # is it an iterator?
                            nqp::istype($item,Iterable) && nqp::isconcrete($item),
                            nqp::bindpos($!iterators,$i,$item.iterator),
                            X::Assignment::ToShaped.new(shape => $!dims).throw
                          )
                        )
                      ),
                      (my $iter := nqp::atpos($!iterators,$!maxdim)),
                      nqp::until(                       # loop over highest dim
                        nqp::eqaddr((my $pulled := $iter.pull-one),IterationEnd)
                          || nqp::isgt_i(nqp::atpos_i($!indices,$!maxdim),$!maxind),
                        nqp::stmts(
                          nqp::bindposnd_s($!list,$!indices,$pulled),
                          nqp::bindpos_i($!indices,$!maxdim,  # increment index
                            nqp::add_i(nqp::atpos_i($!indices,$!maxdim),1))
                        )
                      ),
                      nqp::unless(
                        nqp::eqaddr($pulled,IterationEnd) # if not exhausted
                          || nqp::isle_i(                 # and index too high
                               nqp::atpos_i($!indices,$!maxdim),$!maxind)
                          || $iter.is-lazy,               # and not lazy
                        nqp::atposnd_s($!list,$!indices)  # boom!
                      )
                    )
                }
            }.new(to,from).sink-all;
            to
        }

        multi method STORE(::?CLASS:D: ::?CLASS:D \from) {
            nqp::if(
              EQV_DIMENSIONS(self,from),
              NATCPY(self,from),
              X::Assignment::ArrayShapeMismatch.new(
                source-shape => from.shape,
                target-shape => self.shape
              ).throw
            )
        }
        multi method STORE(::?CLASS:D: array:D \from) {
            nqp::if(
              nqp::istype(from.of,Str),
              nqp::if(
                EQV_DIMENSIONS(self,from),
                NATCPY(self,from),
                X::Assignment::ArrayShapeMismatch.new(
                  source-shape => from.shape,
                  target-shape => self.shape
                ).throw
              ),
              X::TypeCheck::Assignment.new(
                symbol   => self.^name ~ '[' ~ self.shape.join(';') ~ ']',
                expected => Str,
                got      => from.of
              ).throw
            )
        }
        multi method STORE(::?CLASS:D: Iterable:D \from) {
            nqp::if(
              nqp::can(from,'shape'),
              nqp::if(
                from.shape eqv self.shape,
                OBJCPY(self,from),
                X::Assignment::ArrayShapeMismatch.new(
                    source-shape => from.shape,
                    target-shape => self.shape
                ).throw
              ),
              ITERCPY(self,from)
            )
        }
        method iterator(::?CLASS:D:) {
            class :: does Rakudo::Iterator::ShapeLeaf {
                method result() is raw {

                    nqp::multidimref_s($!list,nqp::clone($!indices))




                }
            }.new(self)
        }
        multi method kv(::?CLASS:D:) {
            Seq.new(class :: does Rakudo::Iterator::ShapeLeaf {
                has int $!on-key;
                method result() is raw {
                    nqp::if(
                      ($!on-key = nqp::not_i($!on-key)),
                      nqp::stmts(
                        (my $result := self.indices),
                        (nqp::bindpos_i($!indices,$!maxdim,  # back 1 for next
                          nqp::sub_i(nqp::atpos_i($!indices,$!maxdim),1))),
                        $result
                      ),

                      nqp::multidimref_s($!list,nqp::clone($!indices))




                    )
                }
                # needs its own push-all since it fiddles with $!indices
                method push-all($target --> IterationEnd) {
                    nqp::until(
                      nqp::eqaddr((my $pulled := self.pull-one),IterationEnd),
                      $target.push($pulled)
                    )
                }
            }.new(self))
        }
        multi method pairs(::?CLASS:D:) {
            Seq.new(class :: does Rakudo::Iterator::ShapeLeaf {
                method result() {
                    Pair.new(
                      self.indices,

                      nqp::multidimref_s($!list,nqp::clone($!indices))




                    )
                }
            }.new(self))
        }
        multi method antipairs(::?CLASS:D:) {
            Seq.new(class :: does Rakudo::Iterator::ShapeLeaf {
                method result() {
                    Pair.new(nqp::atposnd_s($!list,$!indices),self.indices)
                }
            }.new(self))
        }
    }  # end of shapedstrarray role

    role shaped1strarray does shapedstrarray {
        multi method AT-POS(::?CLASS:D: int \one) is raw {
           nqp::atposref_s(self,one)
        }
        multi method AT-POS(::?CLASS:D: Int:D \one) is raw {
           nqp::atposref_s(self,one)
        }

        multi method ASSIGN-POS(::?CLASS:D: int \one, str \value) {
            nqp::bindpos_s(self,one,value)
        }
        multi method ASSIGN-POS(::?CLASS:D: Int:D \one, str \value) {
            nqp::bindpos_s(self,one,value)
        }
        multi method ASSIGN-POS(::?CLASS:D: int \one, Str:D \value) {
            nqp::bindpos_s(self,one,value)
        }
        multi method ASSIGN-POS(::?CLASS:D: Int:D \one, Str:D \value) {
            nqp::bindpos_s(self,one,value)
        }

        multi method EXISTS-POS(::?CLASS:D: int \one) {
            nqp::p6bool(
              nqp::isge_i(one,0) && nqp::islt_i(one,nqp::elems(self))
            )
        }
        multi method EXISTS-POS(::?CLASS:D: Int:D \one) {
            nqp::p6bool(
              nqp::isge_i(one,0) && nqp::islt_i(one,nqp::elems(self))
            )
        }

        multi method STORE(::?CLASS:D: ::?CLASS:D \from) {
            nqp::if(
              nqp::iseq_i((my int $elems = nqp::elems(self)),nqp::elems(from)),
              nqp::stmts(
                (my int $i = -1),
                nqp::while(
                  nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                  nqp::bindpos_s(self,$i,nqp::atpos_s(from,$i))
                ),
                self
              ),
              X::Assignment::ArrayShapeMismatch.new(
                source-shape => from.shape,
                target-shape => self.shape
              ).throw
            )
        }
        multi method STORE(::?CLASS:D: Iterable:D \in) {
            nqp::stmts(
              (my \iter := in.iterator),
              (my int $elems = nqp::elems(self)),
              (my int $i = -1),
              nqp::until(
                nqp::eqaddr((my $pulled := iter.pull-one),IterationEnd)
                  || nqp::iseq_i(($i = nqp::add_i($i,1)),$elems),
                nqp::bindpos_s(self,$i,$pulled)
              ),
              nqp::unless(
                nqp::islt_i($i,$elems) || iter.is-lazy,
                nqp::atpos_s(list,$i) # too many values on non-lazy it
              ),
              self
            )
        }
        multi method STORE(::?CLASS:D: Str:D \item) {
            nqp::stmts(
              nqp::bindpos_s(self,0,item),
              self
            )
        }
        method iterator(::?CLASS:D:) {
            class :: does Iterator {
                has Mu $!list;
                has int $!pos;
                method !SET-SELF(Mu \list) {
                    nqp::stmts(
                      ($!list := list),
                      ($!pos = -1),
                      self
                    )
                }
                method new(Mu \list) { nqp::create(self)!SET-SELF(list) }
                method pull-one() is raw {
                    nqp::if(
                      nqp::islt_i(
                        ($!pos = nqp::add_i($!pos,1)),
                        nqp::elems($!list)
                      ),
                      nqp::atposref_s($!list,$!pos),
                      IterationEnd
                    )
                }
                method push-all($target --> IterationEnd) {
                    nqp::stmts(
                      (my int $elems = nqp::elems($!list)),
                      (my int $pos = $!pos),
                      nqp::while(
                        nqp::islt_i(($pos = nqp::add_i($pos,1)),$elems),
                        $target.push(nqp::atpos_s($!list,$pos))
                      ),
                      ($!pos = $pos)
                    )
                }
                method count-only() { nqp::p6box_i(nqp::elems($!list)) }
                method bool-only()  { nqp::p6bool(nqp::elems($!list)) }
                method sink-all(--> IterationEnd) {
                    $!pos = nqp::elems($!list)
                }
            }.new(self)
        }
        multi method kv(::?CLASS:D:) {
            my int $i = -1;
            my int $elems = nqp::add_i(nqp::elems(self),nqp::elems(self));
            Seq.new(Rakudo::Iterator.Callable({
                nqp::if(
                  nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                  nqp::if(
                    nqp::bitand_i($i,1),
                    nqp::atposref_s(self,nqp::bitshiftr_i($i,1)),
                    nqp::bitshiftr_i($i,1)
                  ),
                  IterationEnd
                )
            }))
        }
        multi method pairs(::?CLASS:D:) {
            my int $i = -1;
            my int $elems = nqp::elems(self);
            Seq.new(Rakudo::Iterator.Callable({
                nqp::if(
                  nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                  Pair.new($i,nqp::atposref_s(self,$i)),
                  IterationEnd
                )
            }))
        }
        multi method antipairs(::?CLASS:D:) {
            Seq.new(Rakudo::Iterator.AntiPair(self.iterator))
        }
        method reverse(::?CLASS:D:) is nodal {
            nqp::stmts(
              (my int $elems = nqp::elems(self)),
              (my int $last  = nqp::sub_i($elems,1)),
              (my int $i     = -1),
              (my $to := nqp::clone(self)),
              nqp::while(
                nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                nqp::bindpos_s($to,nqp::sub_i($last,$i),
                  nqp::atpos_s(self,$i))
              ),
              $to
            )
        }
        method rotate(::?CLASS:D: Int(Cool) $rotate = 1) is nodal {
            nqp::stmts(
              (my int $elems = nqp::elems(self)),
              (my $to := nqp::clone(self)),
              (my int $i = -1),
              (my int $j =
                nqp::mod_i(nqp::sub_i(nqp::sub_i($elems,1),$rotate),$elems)),
              nqp::if(nqp::islt_i($j,0),($j = nqp::add_i($j,$elems))),
              nqp::while(
                nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
                nqp::bindpos_s(
                  $to,
                  ($j = nqp::mod_i(nqp::add_i($j,1),$elems)),
                  nqp::atpos_s(self,$i)
                ),
              ),
              $to
            )
        }
    } # end of shaped1strarray role

    role shaped2strarray does shapedstrarray {
        multi method AT-POS(::?CLASS:D: int \one, int \two) is raw {

            nqp::multidimref_s(self,nqp::list_i(one, two))




        }
        multi method AT-POS(::?CLASS:D: Int:D \one, Int:D \two) is raw {

            nqp::multidimref_s(self,nqp::list_i(one, two))




        }

        multi method ASSIGN-POS(::?CLASS:D: int \one, int \two, Str:D \value) {
            nqp::bindpos2d_s(self,one,two,value)
        }
        multi method ASSIGN-POS(::?CLASS:D: Int:D \one, Int:D \two, Str:D \value) {
            nqp::bindpos2d_s(self,one,two,value)
        }

        multi method EXISTS-POS(::?CLASS:D: int \one, int \two) {
            nqp::p6bool(
              nqp::isge_i(one,0)
                && nqp::isge_i(two,0)
                && nqp::islt_i(one,nqp::atpos_i(nqp::dimensions(self),0))
                && nqp::islt_i(two,nqp::atpos_i(nqp::dimensions(self),1))
            )
        }
        multi method EXISTS-POS(::?CLASS:D: Int:D \one, Int:D \two) {
            nqp::p6bool(
              nqp::isge_i(one,0)
                && nqp::isge_i(two,0)
                && nqp::islt_i(one,nqp::atpos_i(nqp::dimensions(self),0))
                && nqp::islt_i(two,nqp::atpos_i(nqp::dimensions(self),1))
            )
        }
    } # end of shaped2strarray role

    role shaped3strarray does shapedstrarray {
        multi method AT-POS(::?CLASS:D: int \one, int \two, int \three) is raw {

            nqp::multidimref_s(self,nqp::list_i(one, two, three))




        }
        multi method AT-POS(::?CLASS:D: Int:D \one, Int:D \two, Int:D \three) is raw {

            nqp::multidimref_s(self,nqp::list_i(one, two, three))




        }

        multi method ASSIGN-POS(::?CLASS:D: int \one, int \two, int \three, Str:D \value) {
            nqp::bindpos3d_s(self,one,two,three,value)
        }
        multi method ASSIGN-POS(::?CLASS:D: Int:D \one, Int:D \two, Int:D \three, Str:D \value) {
            nqp::bindpos3d_s(self,one,two,three,value)
        }

        multi method EXISTS-POS(::?CLASS:D: int \one, int \two, int \three) {
            nqp::p6bool(
              nqp::isge_i(one,0)
                && nqp::isge_i(two,0)
                && nqp::isge_i(three,0)
                && nqp::islt_i(one,nqp::atpos_i(nqp::dimensions(self),0))
                && nqp::islt_i(two,nqp::atpos_i(nqp::dimensions(self),1))
                && nqp::islt_i(three,nqp::atpos_i(nqp::dimensions(self),2))
            )
        }
        multi method EXISTS-POS(::?CLASS:D: Int:D \one, Int:D \two, Int:D \three) {
            nqp::p6bool(
              nqp::isge_i(one,0)
                && nqp::isge_i(two,0)
                && nqp::isge_i(three,0)
                && nqp::islt_i(one,nqp::atpos_i(nqp::dimensions(self),0))
                && nqp::islt_i(two,nqp::atpos_i(nqp::dimensions(self),1))
                && nqp::islt_i(three,nqp::atpos_i(nqp::dimensions(self),2))
            )
        }
    } # end of shaped3strarray role
#- PLEASE DON'T CHANGE ANYTHING ABOVE THIS LINE
#- end of generated part of shapedstrarray role -------------------------------

    method ^parameterize(Mu:U \arr, Mu:U \t) {
        my $t := nqp::decont(t);
        my int $kind = nqp::objprimspec($t);
        my $what;

        if $kind == 1 {
            $what := arr.^mixin(intarray[$t]);
        }
        elsif $kind == 2 {
            $what := arr.^mixin(numarray[$t]);
        }
        elsif $kind == 3 {
            $what := arr.^mixin(strarray[$t]);
        }
        else {
            die "Can only parameterize array with a native type, not {t.^name}";
        }

        $what.^set_name("{arr.^name}[{t.^name}]");
        $what;
    }

    # poor man's 3x4 matrix
    constant typedim2role := nqp::list(nqp::null,
      nqp::list(shapedintarray,shaped1intarray,shaped2intarray,shaped3intarray),
      nqp::list(shapednumarray,shaped1numarray,shaped2numarray,shaped3numarray),
      nqp::list(shapedstrarray,shaped1strarray,shaped2strarray,shaped3strarray)
    );

    method !shaped(\shape) {
        nqp::if(
          (my int $dims = shape.elems),   # reifies
          nqp::stmts(
            # Calculate new meta-object (probably hitting caches in most cases).
            (my \shaped-type = self.WHAT.^mixin(
              nqp::atpos(
                nqp::atpos(typedim2role,nqp::objprimspec(my \T = self.of)),
                nqp::isle_i($dims,3) && $dims
              )
            )),
            nqp::if(   # set name if needed
              nqp::isne_s(shaped-type.^name,self.WHAT.^name),
              shaped-type.^set_name(self.WHAT.^name)
            ),
            # Allocate array storage for this shape, based on calculated type.
            Rakudo::Internals.SHAPED-ARRAY-STORAGE(shape,shaped-type.HOW,T)
          ),
          X::NotEnoughDimensions.new(
            operation         => 'create',
            got-dimensions    => $dims,
            needed-dimensions => '',
          ).throw
        )
    }

    method BIND-POS(|) {
        die "Cannot bind to a natively typed array";
    }
    method DELETE-POS(|) {
        die "Cannot delete from a natively typed array";
    }

    proto method ASSIGN-POS(|) { * } # Hide candidates from Any
    multi method ASSIGN-POS(Any:U \SELF: \pos, Mu \assignee) { # auto-viv
       SELF.AT-POS(pos) = assignee;
    }
    multi method ASSIGN-POS(Any:D: Any:U \pos, Mu \assignee) { # undefined idx
        die "Cannot use '{pos.^name}' as an index";
    }

    multi method EXISTS-POS(array:D: int $idx) {
        $idx >= 0 && $idx < nqp::elems(self)
    }
    multi method EXISTS-POS(array:D: Int $idx) {
        $idx >= 0 && $idx < nqp::elems(self)
    }

    multi method Bool(array:D:)    { nqp::p6bool(nqp::elems(self)) }
    multi method Numeric(array:D:) { nqp::elems(self) }
    multi method Str(array:D:)     { self.join(' ') }

    multi method elems(array:D:)    { nqp::elems(self) }
    method shape() { (*,) }
    proto method Int(|) { * }
    multi method Int(array:D:)      { nqp::elems(self) }
    multi method end(array:D:)      { nqp::elems(self) - 1 }

    method eager() { self }
    method flat()  { Seq.new(self.iterator) }
    method list()  { List.from-iterator(self.iterator) }
    method sink(--> Nil) { }

    multi method gist(array:D:) {
        self.map(-> $elem {
            given ++$ {
                when 101 { '...' }
                when 102 { last }
                default  { $elem.gist }
            }
        } ).join: ' ';
    }

    multi method perl(array:D:) {
        'array[' ~ self.of.perl ~ '].new(' ~
            self.map(*.perl).join(', ') ~ ')'
    }

    method FLATTENABLE_LIST() { self }
    method FLATTENABLE_HASH() { nqp::hash() }

    method iterator() {
        nqp::die('iterator must be provided by native array parameterization role')
    }
}

#line 1 SETTING::src/core/Pair.pm
my class Pair does Associative {
    has $.key is default(Nil);
    has $.value is rw is default(Nil);
    has Mu $!WHICH;

    proto method new(|) { * }
    # This candidate is needed because it currently JITS better
    multi method new(Pair: Cool:D \key, Mu \value) {
        my \p := nqp::p6bindattrinvres(
          nqp::create(self),Pair,'$!key',nqp::decont(key));
        nqp::bindattr(p,Pair,'$!value',value);
        p
    }
    multi method new(Pair: Mu \key, Mu \value) {
        my \p := nqp::p6bindattrinvres(
          nqp::create(self),Pair,'$!key',nqp::decont(key));
        nqp::bindattr(p,Pair,'$!value',value);
        p
    }
    multi method new(Pair: Mu :$key!, Mu :$value!) {
        my \p := nqp::p6bindattrinvres(
          nqp::create(self),Pair,'$!key',$key);
        nqp::bindattr(p,Pair,'$!value',$value);
        p
    }

    multi method WHICH(Pair:D:) {
        nqp::unless(
          $!WHICH,
          ($!WHICH := nqp::if(
            nqp::iscont($!value),
            callsame,
            nqp::box_s(
              "Pair|" ~ $!key.WHICH ~ "|" ~ $!value.WHICH,
              ObjAt
            )
          ))
        )
    }

    multi method ACCEPTS(Pair:D: %h) {
        $!value.ACCEPTS(%h.AT-KEY($!key));
    }
    multi method ACCEPTS(Pair:D: Pair:D $p) {
        $!value.ACCEPTS(nqp::getattr(nqp::decont($p),Pair,'$!value'));
    }
    multi method ACCEPTS(Pair:D: Mu $other) {
        $other."$!key"().Bool === $!value.Bool
    }

    method Pair() { self }
    method antipair(Pair:D:) { self.new($!value,$!key) }
    method freeze(Pair:D:) { $!value := nqp::decont($!value) }

    method iterator(Pair:D:) {
        Rakudo::Iterator.OneValue(self)
    }
    multi method keys(Pair:D:) {
        Seq.new(Rakudo::Iterator.OneValue($!key))
    }
    multi method kv(Pair:D:) {
        Seq.new(Rakudo::Iterator.TwoValues($!key,$!value))
    }
    multi method values(Pair:D:) {
        Seq.new(Rakudo::Iterator.OneValue($!value))
    }
    multi method pairs(Pair:D:) {
        Seq.new(Rakudo::Iterator.OneValue(self))
    }
    multi method antipairs(Pair:D:) {
        Seq.new(Rakudo::Iterator.OneValue(self.new($!value,$!key)))
    }
    multi method invert(Pair:D:) {
        Seq.new(Rakudo::Iterator.Invert(self.iterator))
    }

    multi method Str(Pair:D:) { $!key ~ "\t" ~ $!value }

    multi method gist(Pair:D:) {
        self.gistseen('Pair', {
            nqp::istype($!key, Pair)
              ?? '(' ~ $!key.gist ~ ') => ' ~ $!value.gist
              !! $!key.gist ~ ' => ' ~ $!value.gist;
        })
    }

    multi method perl(Pair:D: :$arglist) {
        self.perlseen('Pair', -> :$arglist {
            nqp::istype($!key, Str) && nqp::isconcrete($!key)
              ?? !$arglist && $!key ~~ /^ [<alpha>\w*] +% <[\-']> $/
                ?? nqp::istype($!value,Bool) && nqp::isconcrete($!value)
                   ?? ':' ~ '!' x !$!value ~ $!key
                   !! ':' ~ $!key ~ '(' ~ $!value.perl ~ ')'
                !! $!key.perl ~ ' => ' ~ $!value.perl
              !! nqp::istype($!key, Numeric)
                   && nqp::isconcrete($!key)
                   && !(nqp::istype($!key,Num) && nqp::isnanorinf($!key))
                ?? $!key.perl ~ ' => ' ~ $!value.perl
                !! '(' ~ $!key.perl ~ ') => ' ~ $!value.perl
        }, :$arglist)
    }

    method fmt($format = "%s\t%s") {
        sprintf($format, $!key, $!value);
    }

    multi method AT-KEY(Pair:D: $key)     { $key eq $!key ?? $!value !! Nil }
    multi method EXISTS-KEY(Pair:D: $key) { $key eq $!key }

    method FLATTENABLE_LIST() { nqp::list() }
    method FLATTENABLE_HASH() { nqp::hash($!key.Str, $!value) }
}

multi sub infix:<eqv>(Pair:D \a, Pair:D \b) {
    nqp::p6bool(
      nqp::eqaddr(a,b)
        || (nqp::eqaddr(a.WHAT,b.WHAT)
             && a.key   eqv b.key
             && a.value eqv b.value)
    )
}

multi sub infix:<cmp>(Pair:D \a, Pair:D \b) {
    (a.key cmp b.key) || (a.value cmp b.value)
}

sub infix:=>(Mu $key, Mu \value) is pure {
    Pair.new($key, value)
}

sub pair(Mu $key, \value) is pure {
    Pair.new($key, value)
}

#line 1 SETTING::src/core/Map.pm
my class X::Hash::Store::OddNumber { ... }

my class Map does Iterable does Associative { # declared in BOOTSTRAP
    # my class Map is Iterable is Cool
    #   has Mu $!storage;

    multi method WHICH(Map:D:) {
        (nqp::istype(self.WHAT,Map) ?? 'Map|' !! (self.^name ~ '|'))
          ~ self.keys.sort.map( { $_.WHICH ~ '(' ~ self.AT-KEY($_) ~ ')' } )
    }
    method new(*@args) {
        @args
          ?? nqp::create(self).STORE(@args)
          !! nqp::create(self)
    }

    multi method Map(Map:) { self }

    multi method Hash(Map:U:) { Hash }
    multi method Hash(Map:D:) {
        if nqp::defined($!storage) && nqp::elems($!storage) {
            my $hash       := nqp::create(Hash);
            my $storage    := nqp::bindattr($hash,Map,'$!storage',nqp::hash);
            my $descriptor := nqp::null;
            my $iter       := nqp::iterator(nqp::getattr(self,Map,'$!storage'));
            nqp::while(
              $iter,
              nqp::bindkey($storage,nqp::iterkey_s(nqp::shift($iter)),
                nqp::p6scalarfromdesc($descriptor) =
                  nqp::decont(nqp::iterval($iter))
              )
            );
            $hash
        }
        else {
            nqp::create(Hash)
        }
    }

    multi method Bool(Map:D:) {
        nqp::p6bool(nqp::defined($!storage) && nqp::elems($!storage));
    }
    method elems(Map:D:) {
        nqp::p6box_i(nqp::defined($!storage) && nqp::elems($!storage));
    }
    multi method Int(Map:D:)     { self.elems }
    multi method Numeric(Map:D:) { self.elems }
    multi method Str(Map:D:)     { self.sort.join("\n") }

    method IterationBuffer() {
        nqp::stmts(
          (my $buffer := nqp::create(IterationBuffer)),
          nqp::if(
            nqp::defined($!storage) && nqp::elems($!storage),
            nqp::stmts(
              (my $iterator := nqp::iterator($!storage)),
              nqp::setelems($buffer,nqp::elems($!storage)),
              (my int $i = -1),
              nqp::while(
                $iterator,
                nqp::bindpos($buffer,($i = nqp::add_i($i,1)),
                  Pair.new(
                    nqp::iterkey_s(nqp::shift($iterator)),
                    nqp::iterval($iterator)
                  )
                )
              )
            )
          ),
          $buffer
        )
    }

    method List() {
        nqp::p6bindattrinvres(
          nqp::create(List),List,'$!reified',self.IterationBuffer)
    }

    multi method sort(Map:D:) {
        Seq.new(
          Rakudo::Iterator.ReifiedList(
            Rakudo::Sorting.MERGESORT-REIFIED-LIST-AS(
              nqp::p6bindattrinvres(
                nqp::create(List),List,'$!reified',self.IterationBuffer
              ),
              { nqp::getattr(nqp::decont($^a),Pair,'$!key') }
            )
          )
        )
    }

    multi method ACCEPTS(Map:D: Any $topic) {
        self.EXISTS-KEY($topic.any);
    }

    multi method ACCEPTS(Map:D: Cool:D $topic) {
        self.EXISTS-KEY($topic);
    }

    multi method ACCEPTS(Map:D: Positional $topic) {
        self.EXISTS-KEY($topic.any);
    }

    multi method ACCEPTS(Map:D: Regex $topic) {
        so self.keys.any.match($topic);
    }

    multi method ACCEPTS(Map:D: Map:D \m --> Bool) {
    	self eqv m;
    }

    multi method EXISTS-KEY(Map:D: Str:D \key) {
        nqp::p6bool(
          nqp::defined($!storage) && nqp::existskey($!storage,key)
        )
    }
    multi method EXISTS-KEY(Map:D: \key) {
        nqp::p6bool(
          nqp::defined($!storage) && nqp::existskey($!storage,key.Str)
        )
    }

    multi method gist(Map:D:) {
        self.^name ~ '.new((' ~ self.sort.map({
            state $i = 0;
            ++$i == 101 ?? '...'
                !! $i == 102 ?? last()
                    !! .gist
        }).join(', ') ~ '))'
    }

    multi method perl(Map:D \SELF:) {
        my $p = self.^name ~ '.new((' ~ self.sort.map({.perl}).join(',') ~ '))';
        nqp::iscont(SELF) ?? '$(' ~ $p ~ ')' !! $p
    }

    method iterator(Map:D:) {
        class :: does Rakudo::Iterator::Mappy {
            method pull-one() {
                nqp::if(
                  $!iter,
                  nqp::stmts(
                    nqp::shift($!iter),
                    Pair.new(nqp::iterkey_s($!iter), nqp::iterval($!iter))
                  ),
                  IterationEnd
                )
            }
            method push-all($target --> IterationEnd) {
                nqp::while(
                  $!iter,
                  nqp::stmts(  # doesn't sink
                     nqp::shift($!iter),
                     $target.push(
                       Pair.new(nqp::iterkey_s($!iter), nqp::iterval($!iter)))
                  )
                )
            }
        }.new(self)
    }
    method list(Map:D:) { Seq.new(self.iterator) }
    multi method pairs(Map:D:) { Seq.new(self.iterator) }
    multi method keys(Map:D:) { Seq.new(Rakudo::Iterator.Mappy-keys(self)) }
    multi method values(Map:D:) { Seq.new(Rakudo::Iterator.Mappy-values(self)) }

    multi method kv(Map:D:) {
        Seq.new(class :: does Rakudo::Iterator::Mappy {
            has int $!on-value;

            method pull-one() is raw {
                nqp::if(
                  $!on-value,
                  nqp::stmts(
                    ($!on-value = 0),
                    nqp::iterval($!iter)
                  ),
                  nqp::if(
                    $!iter,
                    nqp::stmts(
                      ($!on-value = 1),
                      nqp::iterkey_s(nqp::shift($!iter))
                    ),
                    IterationEnd
                  )
                )
            }
            method skip-one() {
                nqp::if(
                  $!on-value,
                  nqp::not_i($!on-value = 0), # skipped a value
                  nqp::if(
                    $!iter,                   # if false, we didn't skip
                    nqp::stmts(               # skipped a key
                      nqp::shift($!iter),
                      ($!on-value = 1)
                    )
                  )
                )
            }
            method push-all($target --> IterationEnd) {
                nqp::while(  # doesn't sink
                  $!iter,
                  nqp::stmts(
                    $target.push(nqp::iterkey_s(nqp::shift($!iter))),
                    $target.push(nqp::iterval($!iter))
                  )
                )
            }
            method count-only() {
                nqp::mul_i(nqp::elems($!hash),2)
            }
        }.new(self))
    }
    multi method antipairs(Map:D:) {
        Seq.new(class :: does Rakudo::Iterator::Mappy {
            method pull-one() {
                nqp::if(
                  $!iter,
                  nqp::stmts(
                    nqp::shift($!iter),
                    Pair.new( nqp::iterval($!iter), nqp::iterkey_s($!iter) )
                  ),
                  IterationEnd
                );
            }
            method push-all($target --> IterationEnd) {
                nqp::while(
                  $!iter,
                  nqp::stmts(  # doesn't sink
                    nqp::shift($!iter),
                    $target.push(
                      Pair.new( nqp::iterval($!iter), nqp::iterkey_s($!iter) ))
                  )
                )
            }
        }.new(self))
    }
    multi method invert(Map:D:) {
        Seq.new(Rakudo::Iterator.Invert(self.iterator))
    }

    multi method AT-KEY(Map:D: Str:D \key) is raw {
        nqp::defined($!storage)
          ?? nqp::ifnull(nqp::atkey($!storage,nqp::unbox_s(key)),Nil)
          !! Nil
    }
    multi method AT-KEY(Map:D: \key) is raw {
        nqp::defined($!storage)
          ?? nqp::ifnull(nqp::atkey($!storage,nqp::unbox_s(key.Str)),Nil)
          !! Nil
    }

    method !STORE_MAP(\map --> Nil) {
        nqp::if(
          nqp::defined(my $other := nqp::getattr(map,Map,'$!storage')),
          nqp::stmts(
            (my $iter := nqp::iterator($other)),
            nqp::while(
              $iter,
              self.STORE_AT_KEY(
                nqp::iterkey_s(nqp::shift($iter)),nqp::iterval($iter)
              )
            )
          )
        )
    }

    method STORE(\to_store) {
        my $temp := nqp::p6bindattrinvres(
          nqp::clone(self),   # make sure we get a possible descriptor as well
          Map,
          '$!storage',
          my $storage := nqp::hash
        );
        my $iter := to_store.iterator;
        my Mu $x;
        my Mu $y;

        nqp::until(
          nqp::eqaddr(($x := $iter.pull-one),IterationEnd),
          nqp::if(
            nqp::istype($x,Pair),
            $temp.STORE_AT_KEY(
              nqp::getattr(nqp::decont($x),Pair,'$!key'),
              nqp::getattr(nqp::decont($x),Pair,'$!value')
            ),
            nqp::if(
              (nqp::istype($x,Map) && nqp::not_i(nqp::iscont($x))),
              $temp!STORE_MAP($x),
              nqp::if(
                nqp::eqaddr(($y := $iter.pull-one),IterationEnd),
                nqp::if(
                  nqp::istype($x,Failure),
                  $x.throw,
                  X::Hash::Store::OddNumber.new(
                    found => nqp::add_i(nqp::mul_i(nqp::elems($storage),2),1),
                    last  => $x
                  ).throw
                ),
                $temp.STORE_AT_KEY($x,$y)
              )
            )
          )
        );

        nqp::p6bindattrinvres(self,Map,'$!storage',$storage)
    }

    proto method STORE_AT_KEY(|) { * }
    multi method STORE_AT_KEY(Str:D \key, Mu \value --> Nil) {
        nqp::bindkey($!storage, nqp::unbox_s(key), nqp::decont(value))
    }
    multi method STORE_AT_KEY(\key, Mu \value --> Nil) {
        nqp::bindkey($!storage, nqp::unbox_s(key.Str), nqp::decont(value))
    }

    method Capture(Map:D:) {
        nqp::defined($!storage)
          ?? nqp::p6bindattrinvres(
               nqp::create(Capture),Capture,'%!hash',$!storage)
          !! nqp::create(Capture)
    }

    method FLATTENABLE_LIST() { nqp::list() }
    method FLATTENABLE_HASH() {
        nqp::defined($!storage)
          ?? $!storage
          !! nqp::bindattr(self,Map,'$!storage',nqp::hash)
    }

    method fmt(Map: Cool $format = "%s\t\%s", $sep = "\n") {
        nqp::iseq_i(nqp::sprintfdirectives( nqp::unbox_s($format.Stringy)),1)
          ?? self.keys.fmt($format, $sep)
          !! self.pairs.fmt($format, $sep)
    }

    method hash() { self }
    method clone(Map:D:) is raw { self }

    multi method roll(Map:D:) {
        nqp::if(
          $!storage && nqp::elems($!storage),
          nqp::stmts(
            (my int $i = nqp::add_i(nqp::elems($!storage).rand.floor,1)),
            (my $iter := nqp::iterator($!storage)),
            nqp::while(
              nqp::shift($iter) && ($i = nqp::sub_i($i,1)),
              nqp::null
            ),
            Pair.new(nqp::iterkey_s($iter),nqp::iterval($iter))
          ),
          Nil
        )
    }
    multi method roll(Map:D: Callable:D $calculate) {
        self.roll( $calculate(self.elems) )
    }
    multi method roll(Map:D: Whatever $) { self.roll(Inf) }
    multi method roll(Map:D: $count) {
        Seq.new(nqp::if(
          $!storage && nqp::elems($!storage) && $count > 0,
          class :: does Iterator {
              has $!storage;
              has $!keys;
              has $!pairs;
              has $!count;

              method !SET-SELF(\hash,\count) {
                  nqp::stmts(
                    ($!storage := nqp::getattr(hash,Map,'$!storage')),
                    ($!count = $count),
                    (my int $i = nqp::elems($!storage)),
                    (my $iter := nqp::iterator($!storage)),
                    ($!keys := nqp::setelems(nqp::list_s,$i)),
                    ($!pairs := nqp::setelems(nqp::list,$i)),
                    nqp::while(
                      nqp::isge_i(($i = nqp::sub_i($i,1)),0),
                      nqp::bindpos_s($!keys,$i,
                        nqp::iterkey_s(nqp::shift($iter)))
                    ),
                    self
                  )
              }
              method new(\h,\c) { nqp::create(self)!SET-SELF(h,c) }
              method pull-one() {
                  nqp::if(
                    $!count,
                    nqp::stmts(
                      --$!count,  # must be HLL to handle Inf
                      nqp::ifnull(
                        nqp::atpos(
                          $!pairs,
                          (my int $i = nqp::elems($!keys).rand.floor)
                        ),
                        nqp::bindpos($!pairs,$i,
                          Pair.new(
                            nqp::atpos_s($!keys,$i),
                            nqp::atkey($!storage,nqp::atpos_s($!keys,$i))
                          )
                        )
                      )
                    ),
                    IterationEnd
                  )
              }
              method is-lazy() { $!count == Inf }
          }.new(self,$count),
          Rakudo::Iterator.Empty
        ))
    }

    multi method pick(Map:D:) { self.roll }

    multi method Set(Map:D:)     {
        nqp::create(Set).SET-SELF(Rakudo::QuantHash.COERCE-MAP-TO-SET(self))
    }
    multi method SetHash(Map:D:)     {
        nqp::create(SetHash).SET-SELF(Rakudo::QuantHash.COERCE-MAP-TO-SET(self))
    }
    multi method Bag(Map:D:)     {
        nqp::create(Bag).SET-SELF(Rakudo::QuantHash.COERCE-MAP-TO-BAG(self))
    }
    multi method BagHash(Map:D:)     {
        nqp::create(BagHash).SET-SELF(Rakudo::QuantHash.COERCE-MAP-TO-BAG(self))
    }
    multi method Mix(Map:D:)     {
        nqp::create(Mix).SET-SELF(Rakudo::QuantHash.COERCE-MAP-TO-MIX(self))
    }
    multi method MixHash(Map:D:)     {
        nqp::create(MixHash).SET-SELF(Rakudo::QuantHash.COERCE-MAP-TO-MIX(self))
    }
}

multi sub infix:<eqv>(Map:D \a, Map:D \b) {

    class NotEQV { }

    nqp::p6bool(
      nqp::unless(
        nqp::eqaddr(a,b),
        nqp::if(                                 # not comparing with self
          nqp::eqaddr(a.WHAT,b.WHAT),
          nqp::if(                               # same types
            (my $amap := nqp::getattr(nqp::decont(a),Map,'$!storage'))
              && (my int $elems = nqp::elems($amap)),
            nqp::if(                             # elems on left
              (my $bmap := nqp::getattr(nqp::decont(b),Map,'$!storage'))
                && nqp::iseq_i($elems,nqp::elems($bmap)),
              nqp::stmts(                        # same elems on right
                (my $iter := nqp::iterator($amap)),
                nqp::while(
                  $iter && infix:<eqv>(
                    nqp::iterval(nqp::shift($iter)),
                    nqp::ifnull(nqp::atkey($bmap,nqp::iterkey_s($iter)),NotEQV)
                  ),
                  ($elems = nqp::sub_i($elems,1))
                ),
                nqp::not_i($elems)               # ok if none left
              )
            ),
            nqp::isfalse(                        # nothing on left
              ($bmap := nqp::getattr(nqp::decont(b),Map,'$!storage'))
                && nqp::elems($bmap)             # something on right: fail
            )
          )
        )
      )
    )
}

#line 1 SETTING::src/core/Hash.pm
my class X::Invalid::ComputedValue { ... };

my class Hash { # declared in BOOTSTRAP
    # my class Hash is Map
    #     has Mu $!descriptor;

    multi method WHICH(Hash:D:) { self.Mu::WHICH }
    multi method Hash(Hash:) {
        self
    }
    multi method Map(Hash:U:) { Map }
    multi method Map(Hash:D: :$view) {
        my $hash := nqp::getattr(self,Map,'$!storage');

        # empty
        if nqp::not_i(nqp::defined($hash)) {
            nqp::create(Map)
        }

        # view, assuming no change in hash
        elsif $view {
            nqp::p6bindattrinvres(nqp::create(Map),Map,'$!storage',$hash)
        }

        # make cow copy
        else {
            my $map  := nqp::hash;
            my \iter := nqp::iterator($hash);
            my str $key;
            nqp::while(
              iter,
              nqp::bindkey(
                $map,
                ($key = nqp::iterkey_s(nqp::shift(iter))),
                nqp::decont(nqp::atkey($hash,$key))
              )
            );
            nqp::p6bindattrinvres(nqp::create(Map),Map,'$!storage',$map)
        }
    }
    method clone(Hash:D:) is raw {
        nqp::p6bindattrinvres(
          nqp::create(self),Map,'$!storage',
          nqp::clone(nqp::getattr(self,Map,'$!storage'))
        )
    }

    multi method AT-KEY(Hash:D: Str:D \key) is raw {
        nqp::if(
          nqp::getattr(self,Map,'$!storage').DEFINITE,
          nqp::ifnull(
            nqp::atkey(nqp::getattr(self,Map,'$!storage'),
              nqp::unbox_s(key)),
            nqp::p6bindattrinvres(
              (my \v := nqp::p6scalarfromdesc($!descriptor)),
              Scalar,
              '$!whence',
              -> { nqp::bindkey(nqp::getattr(self,Map,'$!storage'),
                     nqp::unbox_s(key),v) }
            )
          ),
          nqp::p6bindattrinvres(
            (my \vv := nqp::p6scalarfromdesc($!descriptor)),
            Scalar,
            '$!whence',
            -> { nqp::bindkey(
                   nqp::if(
                     nqp::getattr(self,Map,'$!storage').DEFINITE,
                     nqp::getattr(self,Map,'$!storage'),
                     nqp::bindattr(self,Map,'$!storage',nqp::hash)
                   ),
                   nqp::unbox_s(key),vv)
               }
          )
        )
    }
    multi method AT-KEY(Hash:D: \key) is raw {
        nqp::if(
          nqp::getattr(self,Map,'$!storage').DEFINITE,
          nqp::ifnull(
            nqp::atkey(nqp::getattr(self,Map,'$!storage'),
              nqp::unbox_s(key.Str)),
            nqp::p6bindattrinvres(
              (my \v := nqp::p6scalarfromdesc($!descriptor)),
              Scalar,
              '$!whence',
              -> { nqp::bindkey(nqp::getattr(self,Map,'$!storage'),
                       nqp::unbox_s(key.Str),v) }
            )
          ),
          nqp::p6bindattrinvres(
            (my \vv := nqp::p6scalarfromdesc($!descriptor)),
            Scalar,
            '$!whence',
            -> { nqp::bindkey(
                   nqp::if(
                     nqp::getattr(self,Map,'$!storage').DEFINITE,
                     nqp::getattr(self,Map,'$!storage'),
                     nqp::bindattr(self,Map,'$!storage',nqp::hash)
                   ),
                   nqp::unbox_s(key.Str),vv)
               }
          )
        )
    }

    multi method STORE_AT_KEY(Str:D \key, Mu \x --> Nil) {
        nqp::bindkey(
          nqp::getattr(self,Map,'$!storage'),
          nqp::unbox_s(key),
          (nqp::p6scalarfromdesc($!descriptor) = x),
        )
    }
    multi method STORE_AT_KEY(\key, Mu \x --> Nil) {
        nqp::bindkey(
          nqp::getattr(self,Map,'$!storage'),
          nqp::unbox_s(key.Str),
          (nqp::p6scalarfromdesc($!descriptor) = x),
        )
    }

    multi method ASSIGN-KEY(Hash:D: Str:D \key, Mu \assignval) is raw {
        nqp::if(
          nqp::getattr(self,Map,'$!storage').DEFINITE,
          (nqp::ifnull(
             nqp::atkey(
               nqp::getattr(self,Map,'$!storage'),
               nqp::unbox_s(key)
             ),
             nqp::bindkey(
               nqp::getattr(self,Map,'$!storage'),
               nqp::unbox_s(key),
               nqp::p6scalarfromdesc($!descriptor)
             )
          ) = assignval),
          nqp::bindkey(
            nqp::bindattr(self,Map,'$!storage',nqp::hash),
            nqp::unbox_s(key),
            nqp::p6scalarfromdesc($!descriptor) = assignval
          )
        )
    }
    multi method ASSIGN-KEY(Hash:D: \key, Mu \assignval) is raw {
        nqp::if(
          nqp::getattr(self,Map,'$!storage').DEFINITE,
          (nqp::ifnull(
             nqp::atkey(
               nqp::getattr(self,Map,'$!storage'),
               nqp::unbox_s(key.Str)
             ),
             nqp::bindkey(
               nqp::getattr(self,Map,'$!storage'),
               nqp::unbox_s(key.Str),
               nqp::p6scalarfromdesc($!descriptor)
             )
          ) = assignval),
          nqp::bindkey(
            nqp::bindattr(self,Map,'$!storage',nqp::hash),
            nqp::unbox_s(key.Str),
            nqp::p6scalarfromdesc($!descriptor) = assignval
          )
        )
    }

    # for some reason, this can't be turned into a multi without
    # making setting compilation get very confused indeed
    method BIND-KEY(Hash:D: \key, Mu \bindval) is raw {
        nqp::bindattr(self,Map,'$!storage',nqp::hash)
          unless nqp::defined(nqp::getattr(self,Map,'$!storage'));
        nqp::bindkey(nqp::getattr(self,Map,'$!storage'),
          nqp::unbox_s(nqp::istype(key,Str) ?? key !! key.Str), bindval)
    }

    multi method DELETE-KEY(Hash:U: --> Nil) { }
    multi method DELETE-KEY(Hash:D: Str:D \key) {
        nqp::if(
          (nqp::getattr(self,Map,'$!storage').DEFINITE
            && nqp::existskey(nqp::getattr(self,Map,'$!storage'),
                 nqp::unbox_s(key))),
          nqp::stmts(
            (my $value = nqp::atkey(nqp::getattr(self,Map,'$!storage'),
               nqp::unbox_s(key))),
            nqp::deletekey(nqp::getattr(self,Map,'$!storage'),
              nqp::unbox_s(key)),
            $value
          ),
          nqp::p6scalarfromdesc($!descriptor)
        )
    }
    multi method DELETE-KEY(Hash:D: \key) {
        nqp::stmts(
          (my str $key = nqp::unbox_s(key.Str)),
          nqp::if(
            (nqp::getattr(self,Map,'$!storage').DEFINITE
              && nqp::existskey(nqp::getattr(self,Map,'$!storage'),$key)),
            nqp::stmts(
              (my $value = nqp::atkey(nqp::getattr(self,Map,'$!storage'),$key)),
              nqp::deletekey(nqp::getattr(self,Map,'$!storage'),$key),
              $value
            ),
            nqp::p6scalarfromdesc($!descriptor)
          )
        )
    }

    multi method perl(Hash:D \SELF:) {
        SELF.perlseen(self.^name, {
            '$' x nqp::iscont(SELF)  # self is always deconted
            ~ '{' ~ self.sort.map({.perl}).join(', ') ~ '}'
        })
    }

    multi method gist(Hash:D:) {
        self.gistseen(self.^name, {
            '{' ~
            self.sort.map({
                state $i = 0;
                ++$i == 101 ?? '...'
                    !! $i == 102 ?? last()
                        !! .gist
            }).join(', ')
            ~ '}'
        })
    }

    multi method DUMP(Hash:D: :$indent-step = 4, :%ctx) {
        nqp::if(
          %ctx,
          self.DUMP-OBJECT-ATTRS(
            nqp::list(
              '$!descriptor',
              $!descriptor,
              '$!storage',
              nqp::getattr(nqp::decont(self),Map,'$!storage')
            ),
            :$indent-step,
            :%ctx
          ),
          DUMP(self, :$indent-step)
        )
    }

    # introspection
    method name() {
        nqp::isnull($!descriptor) ?? Nil !! $!descriptor.name
    }
    method keyof() {
        Str(Any)
    }
    method of() {
        nqp::isnull($!descriptor) ?? Mu !! $!descriptor.of
    }
    method default() {
        nqp::isnull($!descriptor) ?? Any !! $!descriptor.default
    }
    method dynamic() {
        nqp::isnull($!descriptor) ?? False !! nqp::p6bool($!descriptor.dynamic)
    }

    method push(+values) {
        fail X::Cannot::Lazy.new(:action<push>, :what(self.^name))
          if values.is-lazy;

        my $previous;
        my int $has_previous = 0;

        nqp::if(
          $has_previous,
          nqp::stmts(
            self!_push_construct($previous,$_),
            ($has_previous = 0)
          ),
          nqp::if(
            nqp::istype($_,Pair),
            self!_push_construct(.key,.value),
            nqp::stmts(
              ($previous := $_),
              ($has_previous = 1)
            )
          )
        ) for values;

        warn "Trailing item in {self.^name}.push" if $has_previous;
        self
    }

    method append(+values) {
        fail X::Cannot::Lazy.new(:action<append>, :what(self.^name))
          if values.is-lazy;

        my $previous;
        my int $has_previous = 0;

        nqp::if(
          $has_previous,
          nqp::stmts(
            self!_append_construct($previous,$_),
            ($has_previous = 0)
          ),
          nqp::if(
            nqp::istype($_,Pair),
            self!_append_construct(.key,.value),
            nqp::stmts(
              ($previous := $_),
              ($has_previous = 1)
            )
          )
        ) for values;

        warn "Trailing item in {self.^name}.append" if $has_previous;
        self
    }

    proto method classify-list(|) { * }
    multi method classify-list( &test, \list, :&as ) {
        fail X::Cannot::Lazy.new(:action<classify>) if list.is-lazy;
        my \iter = (nqp::istype(list, Iterable) ?? list !! list.list).iterator;
        my $value := iter.pull-one;
        unless $value =:= IterationEnd {
            my $tested := test($value);

            # multi-level classify
            if nqp::istype($tested, Iterable) {
                my $els = $tested.elems;
                loop {
                    my @keys = @$tested;
                    @keys == $els or X::Invalid::ComputedValue.new(
                            :name<mapper>,
                            :method<classify-list>,
                            :value('an item with different number of elements '
                                ~ 'in it than previous items'),
                            :reason('all values need to have the same number '
                                ~ 'of elements. Mixed-level classification is '
                                ~ 'not supported.'),
                        ).throw;
                    my $last := @keys.pop;
                    my $hash  = self;
                    $hash = $hash{$_} //= self.new for @keys;
                    $hash{$last}.push(&as ?? as($value) !! $value);
                    last if ($value := iter.pull-one) =:= IterationEnd;
                    $tested := test($value);
                };
            }
            # just a simple classify
            else {
                loop {
                    self{$tested}.push(&as ?? as($value) !! $value);
                    last if ($value := iter.pull-one) =:= IterationEnd;
                    nqp::istype(($tested := test($value)), Iterable)
                        and X::Invalid::ComputedValue.new(
                            :name<mapper>,
                            :method<classify-list>,
                            :value('an item with different number of elements '
                                ~ 'in it than previous items'),
                            :reason('all values need to have the same number '
                                ~ 'of elements. Mixed-level classification is '
                                ~ 'not supported.'),
                        ).throw;
                };
            }
        }
        self;
    }
    multi method classify-list( %test, |c ) {
        self.classify-list( { %test{$^a} }, |c );
    }
    multi method classify-list( @test, |c ) {
        self.classify-list( { @test[$^a] }, |c );
    }
    multi method classify-list(&test, **@list, |c) {
        self.classify-list(&test, @list, |c);
    }

    proto method categorize-list(|) { * }
    multi method categorize-list( &test, \list, :&as ) {
       fail X::Cannot::Lazy.new(:action<categorize>) if list.is-lazy;
        my \iter = (nqp::istype(list, Iterable) ?? list !! list.list).iterator;
        my $value := iter.pull-one;
        unless $value =:= IterationEnd {
            my $tested := test($value);

            # multi-level categorize
            if nqp::istype($tested[0],Iterable) {
                my $els = $tested[0].elems;
                loop {
                    for $tested.cache -> $cat {
                       my @keys = @$cat or next;
                       my $last := @keys.pop;
                       my $hash  = self;
                       $hash = $hash{$_} //= self.new for @keys;
                       $hash{$last}.push(&as ?? as($value) !! $value);
                    }

                    last if ($value := iter.pull-one) =:= IterationEnd;
                    $tested := test($value);

                    nqp::istype($tested[0],Iterable)
                        and $els == $tested[0]
                        or X::Invalid::ComputedValue.new(
                            :name<mapper>,
                            :method<categorize-list>,
                            :value('an item with different number of elements '
                                ~ 'in it than previous items'),
                            :reason('all values need to have the same number '
                                ~ 'of elements. Mixed-level classification is '
                                ~ 'not supported.'),
                        ).throw;
                }
            }
            # simple categorize
            else {
                loop {
                    self{$_}.push(&as ?? as($value) !! $value)
                        for @$tested;
                    last if ($value := iter.pull-one) =:= IterationEnd;
                    nqp::istype(($tested := test($value))[0], Iterable)
                        and X::Invalid::ComputedValue.new(
                            :name<mapper>,
                            :method<categorize-list>,
                            :value('an item with different number of elements '
                                ~ 'in it than previous items'),
                            :reason('all values need to have the same number '
                                ~ 'of elements. Mixed-level classification is '
                                ~ 'not supported.'),
                        ).throw;
                };
            }
       }
       self;
    }
    multi method categorize-list( %test, |c ) {
        self.categorize-list( { %test{$^a} }, |c );
    }
    multi method categorize-list( @test, |c ) {
        self.categorize-list( { @test[$^a] }, |c );
    }
    multi method categorize-list( &test, **@list, |c ) {
        self.categorize-list( &test, @list, |c );
    }

    # push a value onto a hash slot, constructing an array if necessary
    method !_push_construct(Mu $key, Mu \value --> Nil) {
        self.EXISTS-KEY($key)
          ?? self.AT-KEY($key).^isa(Array)
            ?? self.AT-KEY($key).push(value)
            !! self.ASSIGN-KEY($key,[self.AT-KEY($key),value])
          !! self.ASSIGN-KEY($key,value)
    }

    # append values into a hash slot, constructing an array if necessary
    method !_append_construct(Mu $key, Mu \value --> Nil) {
        self.EXISTS-KEY($key)
          ?? self.AT-KEY($key).^isa(Array)
            ?? self.AT-KEY($key).append(|value)
            !! self.ASSIGN-KEY($key,[|self.AT-KEY($key),|value])
          !! self.ASSIGN-KEY($key,value)
    }

    my role TypedHash[::TValue] does Associative[TValue] {
        # These ASSIGN-KEY candidates are only needed because of:
        #   my Int %h; try %h<a> = "foo"; dd %h
        # leaving an uninitialized Int for key <a> in the hash.  If
        # we could live with that, then these candidates can be
        # removed.  However, there are spectest covering this
        # eventuality, so to appease roast, we need these.
        multi method ASSIGN-KEY(::?CLASS:D: Str:D \key, Mu \assignval) is raw {
            nqp::if(
              nqp::getattr(self,Map,'$!storage').DEFINITE,
              nqp::if(
                nqp::existskey(
                  nqp::getattr(self,Map,'$!storage'),
                  nqp::unbox_s(key)
                ),
                (nqp::atkey(
                  nqp::getattr(self,Map,'$!storage'),
                  nqp::unbox_s(key)
                ) = assignval),
                nqp::bindkey(
                  nqp::getattr(self,Map,'$!storage'),
                  nqp::unbox_s(key),
                  nqp::p6scalarfromdesc(
                    nqp::getattr(self,Hash,'$!descriptor')) = assignval
                )
              ),
              nqp::bindkey(
                nqp::bindattr(self,Map,'$!storage',nqp::hash),
                nqp::unbox_s(key),
                nqp::p6scalarfromdesc(
                  nqp::getattr(self,Hash,'$!descriptor')) = assignval
              )
            )
        }
        multi method ASSIGN-KEY(::?CLASS:D: \key, Mu \assignval) is raw {
            nqp::stmts(
              (my str $key = nqp::unbox_s(key.Str)),
              nqp::if(
                nqp::getattr(self,Map,'$!storage').DEFINITE,
                nqp::if(
                  nqp::existskey(
                    nqp::getattr(self,Map,'$!storage'),
                    $key
                  ),
                  (nqp::atkey(
                    nqp::getattr(self,Map,'$!storage'),
                    $key
                  ) = assignval),
                  nqp::bindkey(
                    nqp::getattr(self,Map,'$!storage'),
                    nqp::unbox_s(key.Str),
                    nqp::p6scalarfromdesc(
                      nqp::getattr(self,Hash,'$!descriptor')) = assignval
                  )
                ),
                nqp::bindkey(
                  nqp::bindattr(self,Map,'$!storage',nqp::hash),
                  $key,
                  nqp::p6scalarfromdesc(
                    nqp::getattr(self,Hash,'$!descriptor')) = assignval
                )
              )
            )
        }
        multi method perl(::?CLASS:D \SELF:) {
            SELF.perlseen('Hash', {
                '$' x nqp::iscont(SELF)  # self is always deconted
                ~ (self.elems
                   ?? "(my {TValue.perl} % = {
                        self.sort.map({.perl}).join(', ')
                       })"
                   !! "(my {TValue.perl} %)"
                  )
            })
        }
    }
    my role TypedHash[::TValue, ::TKey] does Associative[TValue] {
        method keyof () { TKey }
        method AT-KEY(::?CLASS:D: TKey \key) is raw {
            nqp::if(
              nqp::getattr(self,Map,'$!storage').DEFINITE,
              nqp::if(
                nqp::existskey(nqp::getattr(self,Map,'$!storage'),
                  (my str $which = nqp::unbox_s(key.WHICH))),
                nqp::getattr(
                  nqp::atkey(nqp::getattr(self,Map,'$!storage'),$which),
                  Pair,'$!value'),
                nqp::p6bindattrinvres(
                  (my \v := nqp::p6scalarfromdesc(
                    nqp::getattr(self,Hash,'$!descriptor'))),
                  Scalar,
                  '$!whence',
                  -> { nqp::bindkey(nqp::getattr(self,Map,'$!storage'),
                         $which,Pair.new(key,v)); v }
                )
              ),
              nqp::p6bindattrinvres(
                (my \vv := nqp::p6scalarfromdesc(
                  nqp::getattr(self,Hash,'$!descriptor'))),
                Scalar,
                '$!whence',
                -> { nqp::bindkey(
                       nqp::if(
                         nqp::getattr(self,Map,'$!storage').DEFINITE,
                         nqp::getattr(self,Map,'$!storage'),
                         nqp::bindattr(self,Map,'$!storage',nqp::hash)
                       ),
                       nqp::unbox_s(key.WHICH), Pair.new(key,vv)); vv }
              )
            )
        }

        method STORE_AT_KEY(TKey \key, TValue \x --> Nil) {
            nqp::bindkey(
              nqp::getattr(self,Map,'$!storage'),
              nqp::unbox_s(key.WHICH),
              Pair.new(
                key,
                nqp::p6scalarfromdesc(nqp::getattr(self,Hash,'$!descriptor'))
                = x
              )
            )
        }

        method ASSIGN-KEY(::?CLASS:D: TKey \key, TValue \assignval) is raw {
            nqp::if(
              nqp::getattr(self,Map,'$!storage').DEFINITE,
              nqp::if(
                nqp::existskey(nqp::getattr(self,Map,'$!storage'),
                  my str $which = nqp::unbox_s(key.WHICH)),
                (nqp::getattr(
                  nqp::atkey(nqp::getattr(self,Map,'$!storage'),$which),
                  Pair,'$!value') = assignval),
                nqp::getattr(
                  (nqp::bindkey(nqp::getattr(self,Map,'$!storage'),$which,
                    Pair.new(key,nqp::p6scalarfromdesc(
                      nqp::getattr(self,Hash,'$!descriptor')) = assignval))),
                  Pair,'$!value')
              ),
              nqp::getattr(
                (nqp::bindkey(nqp::bindattr(self,Map,'$!storage',nqp::hash),
                  nqp::unbox_s(key.WHICH),
                  Pair.new(key,nqp::p6scalarfromdesc(
                    nqp::getattr(self,Hash,'$!descriptor')) = assignval))),
                Pair,'$!value')
            )
        }

        method BIND-KEY(TKey \key, TValue \bindval) is raw {
            nqp::getattr(
              nqp::if(
                nqp::getattr(self,Map,'$!storage').DEFINITE,
                nqp::bindkey(nqp::getattr(self,Map,'$!storage'),
                  nqp::unbox_s(key.WHICH),
                  Pair.new(key,bindval)),
                nqp::bindkey(nqp::bindattr(self,Map,'$!storage',nqp::hash),
                  nqp::unbox_s(key.WHICH),
                  Pair.new(key,bindval))
              ),
              Pair,'$!value'
            )
        }

        method EXISTS-KEY(TKey \key) {
            nqp::p6bool(
              nqp::defined(nqp::getattr(self,Map,'$!storage'))
                && nqp::existskey(nqp::getattr(self,Map,'$!storage'),key.WHICH)
            )
        }

        method DELETE-KEY(TKey \key) {
            nqp::if(
              (nqp::getattr(self,Map,'$!storage').DEFINITE
                && nqp::existskey(nqp::getattr(self,Map,'$!storage'),
                     (my str $which = key.WHICH))),
              nqp::stmts(
                (my TValue $value =
                  nqp::getattr(
                    nqp::atkey(nqp::getattr(self,Map,'$!storage'),$which),
                    Pair,'$!value')),
                 nqp::deletekey(nqp::getattr(self,Map,'$!storage'),$which),
                 $value
              ),
              TValue
            )
        }

        method FLATTENABLE_HASH() {
            nqp::stmts(
              (my $flattened := nqp::hash),
              nqp::if(
                (my $raw := nqp::getattr(self,Map,'$!storage'))
                 && (my $iter := nqp::iterator($raw)),
                nqp::while(
                  $iter,
                  nqp::bindkey(
                    $flattened,
                    nqp::if(
                      nqp::istype(
                        (my $key := nqp::getattr(
                          nqp::iterval(nqp::shift($iter)),
                          Pair,
                          '$!key'
                        )),
                        Str,
                      ),
                      $key,
                      $key.Str
                    ),
                    nqp::getattr(nqp::iterval($iter),Pair,'$!value')
                  )
                )
              ),
              $flattened
            )
        }

        method IterationBuffer() {
            nqp::stmts(
              (my $buffer := nqp::create(IterationBuffer)),
              nqp::if(
                nqp::defined(
                  nqp::getattr(self,Map,'$!storage')
                ) && nqp::elems(
                  nqp::getattr(self,Map,'$!storage')
                ),
                nqp::stmts(
                  (my $iterator := nqp::iterator(
                    nqp::getattr(self,Map,'$!storage')
                  )),
                  nqp::setelems($buffer,nqp::elems(
                    nqp::getattr(self,Map,'$!storage')
                  )),
                  (my int $i = -1),
                  nqp::while(
                    $iterator,
                    nqp::bindpos($buffer,($i = nqp::add_i($i,1)),
                      nqp::iterval(nqp::shift($iterator)))
                  )
                )
              ),
              $buffer
            )
        }

        method keys() {
            Seq.new(class :: does Rakudo::Iterator::Mappy {
                method pull-one() {
                    nqp::if(
                      $!iter,
                      nqp::getattr(nqp::iterval(nqp::shift($!iter)),
                        Pair,'$!key'),
                      IterationEnd
                    )
                 }
            }.new(self))
        }
        method values() {
            Seq.new(class :: does Rakudo::Iterator::Mappy {
                method pull-one() {
                    nqp::if(
                      $!iter,
                      nqp::getattr(nqp::iterval(nqp::shift($!iter)),
                        Pair,'$!value'),
                      IterationEnd
                    )
                 }
            }.new(self))
        }
        method kv() {
            Seq.new(Rakudo::Iterator.Mappy-kv-from-pairs(self))
        }
        method iterator() { Rakudo::Iterator.Mappy-values(self) }
        method antipairs() {
            Seq.new(class :: does Rakudo::Iterator::Mappy {
                method pull-one() {
                    nqp::if(
                      $!iter,
                      nqp::iterval(nqp::shift($!iter)).antipair,
                      IterationEnd
                    )
                 }
            }.new(self))
        }
        multi method roll(::?CLASS:D:) {
            nqp::if(
              (my $raw := nqp::getattr(self,Map,'$!storage')) && nqp::elems($raw),
              nqp::stmts(
                (my int $i = nqp::add_i(nqp::elems($raw).rand.floor,1)),
                (my $iter := nqp::iterator($raw)),
                nqp::while(
                  nqp::shift($iter) && ($i = nqp::sub_i($i,1)),
                  nqp::null
                ),
                nqp::iterval($iter)
              ),
              Nil
            )
        }
        multi method roll(::?CLASS:D: Callable:D $calculate) {
            self.roll( $calculate(self.elems) )
        }
        multi method roll(::?CLASS:D: Whatever $) { self.roll(Inf) }
        multi method roll(::?CLASS:D: $count) {
            Seq.new(nqp::if(
              (my $raw := nqp::getattr(self,Map,'$!storage'))
                && nqp::elems($raw) && $count > 0,
              class :: does Iterator {
                  has $!storage;
                  has $!keys;
                  has $!count;

                  method !SET-SELF(\hash,\count) {
                      nqp::stmts(
                        ($!storage := nqp::getattr(hash,Map,'$!storage')),
                        ($!count = $count),
                        (my $iter := nqp::iterator($!storage)),
                        ($!keys := nqp::list_s),
                        nqp::while(
                          $iter,
                          nqp::push_s($!keys,nqp::iterkey_s(nqp::shift($iter)))
                        ),
                        self
                      )
                  }
                  method new(\h,\c) { nqp::create(self)!SET-SELF(h,c) }
                  method pull-one() {
                      nqp::if(
                        $!count,
                        nqp::stmts(
                          --$!count,  # must be HLL to handle Inf
                          nqp::atkey(
                            $!storage,
                            nqp::atpos_s($!keys,nqp::elems($!keys).rand.floor)
                          )
                        ),
                        IterationEnd
                      )
                  }
                  method is-lazy() { $!count == Inf }
              }.new(self,$count),
              Rakudo::Iterator.Empty
            ))
        }
        multi method perl(::?CLASS:D \SELF:) {
            SELF.perlseen('Hash', {
                my $TKey-perl   := TKey.perl;
                my $TValue-perl := TValue.perl;
                $TKey-perl eq 'Any' && $TValue-perl eq 'Mu'
                  ?? ( '$(' x nqp::iscont(SELF)
                        ~ ':{' ~ SELF.sort.map({.perl}).join(', ') ~ '}'
                        ~ ')' x nqp::iscont(SELF)
                     )
                  !! '$' x nqp::iscont(SELF)
                     ~ (self.elems
                          ?? "(my $TValue-perl %\{$TKey-perl\} = {
                                self.sort.map({.perl}).join(', ')
                             })"
                          !! "(my $TValue-perl %\{$TKey-perl\})"
                     )
            })
        }

        # gotta force capture keys to strings or binder fails
        method Capture() {
            nqp::defined(nqp::getattr(self,Map,'$!storage'))
              ?? do {
                     my $cap := nqp::create(Capture);
                     my $h := nqp::hash();
                     for self.kv -> \k, \v {
                         nqp::bindkey($h,
                           nqp::unbox_s(nqp::istype(k,Str) ?? k !! k.Str),
                           v)
                     }
                     nqp::bindattr($cap,Capture,'%!hash',$h);
                     $cap
                 }
              !! nqp::create(Capture)
        }
        method Map() { self.pairs.Map }
    }

    method ^parameterize(Mu:U \hash, Mu:U \t, |c) {
        if c.elems == 0 {
            my $what := hash.^mixin(TypedHash[t]);
            # needs to be done in COMPOSE phaser when that works
            $what.^set_name("{hash.^name}[{t.^name}]");
            $what;
        }
        elsif c.elems == 1 {
            my $what := hash.^mixin(TypedHash[t, c[0].WHAT]);
            # needs to be done in COMPOSE phaser when that works
            $what.^set_name("{hash.^name}[{t.^name},{c[0].^name}]");
            $what;
        }
        else {
            die "Can only type-constrain Hash with [ValueType] or [ValueType,KeyType]";
        }
    }
}


sub circumfix:<{ }>(*@elems) { my % = @elems }
sub hash(*@a, *%h) { my % = flat @a, %h }

# XXX parse hangs with ordinary sub declaration
BEGIN my &circumfix:<:{ }> = sub (*@elems) { Hash.^parameterize(Mu,Any).new(@elems) }

#line 1 SETTING::src/core/Stash.pm
my class Stash { # declared in BOOTSTRAP
    # class Stash is Hash
    #     has str $!longname;

    multi method AT-KEY(Stash:D: Str:D $key) is raw {
        nqp::if(
          nqp::getattr(self,Map,'$!storage')
            && nqp::existskey(nqp::getattr(self,Map,'$!storage'),$key),
          nqp::atkey(nqp::getattr(self,Map,'$!storage'),$key),
          nqp::p6bindattrinvres(
            my $v,Scalar,'$!whence',
            -> { nqp::bindkey(
                   nqp::getattr(self,Map,'$!storage')
                     || nqp::bindattr(self,Map,'$!storage',nqp::hash),
                   $key,
                   $v
                 )
               }
          )
        )
    }
    multi method AT-KEY(Stash:D: Str() $key, :$global_fallback!) is raw {
        nqp::if(
          nqp::getattr(self,Map,'$!storage')
            && nqp::existskey(nqp::getattr(self,Map,'$!storage'),$key),
          nqp::atkey(nqp::getattr(self,Map,'$!storage'),$key),
          nqp::if(
            $global_fallback,
            nqp::if(
              nqp::existskey(GLOBAL.WHO,$key),
              nqp::atkey(GLOBAL.WHO,$key),
              Failure.new("Could not find symbol '$key'")
            ),
            nqp::p6bindattrinvres(
              my $v,Scalar,'$!whence',
              -> { nqp::bindkey(
                     nqp::getattr(self,Map,'$!storage')
                       || nqp::bindattr(self,Map,'$!storage',nqp::hash),
                     $key,
                     $v
                 )
                 }
            )
          )
        )
    }

    method package_at_key(Stash:D: str $key) {
        my Mu $storage := nqp::defined(nqp::getattr(self, Map, '$!storage')) ??
            nqp::getattr(self, Map, '$!storage') !!
            nqp::bindattr(self, Map, '$!storage', nqp::hash());
        if nqp::existskey($storage, nqp::unbox_s($key)) {
            nqp::atkey($storage, $key)
        }
        else {
            my $pkg := Metamodel::PackageHOW.new_type(:name($key));
            $pkg.^compose;
            nqp::bindkey($storage, $key, $pkg)
        }
    }

    multi method gist(Stash:D:) {
        self.Str
    }

    multi method Str(Stash:D:) {
        nqp::isnull_s($!longname) ?? '<anon>' !! $!longname
    }

    method merge-symbols(Stash:D: Hash $globalish) { # NQP gives a Hash, not a Stash
        nqp::gethllsym('perl6','ModuleLoader').merge_globals(self,$globalish)
          unless $globalish === Stash;
    }
}

#line 1 SETTING::src/core/Label.pm
my class Label {
    has Str $!name;
    has Str $!file;
    has Int $!line;
    has Str $!prematch;
    has Str $!postmatch;
    method new(:$name, :$line, :$prematch, :$postmatch) {
        # XXX Register in &?BLOCK.labels when we have &?BLOCK.
        my $obj := nqp::create(self);
        nqp::bindattr($obj, Label, '$!name',      $name);
        nqp::bindattr($obj, Label, '$!file',
          nqp::p6box_s(nqp::ifnull(nqp::getlexdyn('$?FILES'), '<unknown>')));
        nqp::bindattr($obj, Label, '$!line',      $line);
        nqp::bindattr($obj, Label, '$!prematch',  nqp::p6box_s($prematch));
        nqp::bindattr($obj, Label, '$!postmatch', nqp::p6box_s($postmatch));
        $obj
    }
    method name() {
        $!name
    }

    method goto(*@)  { X::NYI.new(:feature("{self.^name}.goto()")).throw }
    method leave(*@) { X::NYI.new(:feature("{self.^name}.leave()")).throw }

    multi method gist(Label:D:) {
        my ($red,$clear,$green,$yellow,$eject) = Rakudo::Internals.error-rcgye;
        "Label<$!name>(at $!file:$!line, '$green$!prematch$yellow$eject$red$!name$green$!postmatch$clear')"
    }

    method Int() { nqp::where(nqp::decont(self)) }

    method next() {
        my Mu $ex := nqp::newexception();
        nqp::setpayload($ex, nqp::decont(self));
        nqp::setextype($ex, nqp::const::CONTROL_NEXT + nqp::const::CONTROL_LABELED);
        nqp::throw($ex);
    }
    method redo() {
        my Mu $ex := nqp::newexception();
        nqp::setpayload($ex, nqp::decont(self));
        nqp::setextype($ex, nqp::const::CONTROL_REDO + nqp::const::CONTROL_LABELED);
        nqp::throw($ex);
    }
    method last() {
        my Mu $ex := nqp::newexception();
        nqp::setpayload($ex, nqp::decont(self));
        nqp::setextype($ex, nqp::const::CONTROL_LAST + nqp::const::CONTROL_LABELED);
        nqp::throw($ex);
    }
}

#line 1 SETTING::src/core/PseudoStash.pm
my class X::Bind { ... }
my class X::Caller::NotDynamic { ... }

my class PseudoStash is Map {
    has Mu $!ctx;
    has int $!mode;

    # Lookup modes.
    my int constant PICK_CHAIN_BY_NAME = 0;
    my int constant STATIC_CHAIN       = 1;
    my int constant DYNAMIC_CHAIN      = 2;
    my int constant PRECISE_SCOPE      = 4;
    my int constant REQUIRE_DYNAMIC    = 8;

    method new() {
        my $obj := nqp::create(self);
        my $ctx := nqp::ctxcaller(nqp::ctx());
        nqp::bindattr($obj, PseudoStash, '$!ctx', $ctx);
        nqp::bindattr($obj, Map, '$!storage', nqp::ctxlexpad($ctx));
        $obj
    }

    my %pseudoers =
        'MY' => sub ($cur) {
            my $stash := nqp::clone($cur);
            nqp::bindattr_i($stash, PseudoStash, '$!mode', PRECISE_SCOPE);
            nqp::setwho(
                Metamodel::ModuleHOW.new_type(:name('MY')),
                $stash);
        },
        'CORE' => sub ($cur) {
            my Mu $ctx := nqp::getattr(nqp::decont($cur), PseudoStash, '$!ctx');
            until nqp::existskey(nqp::ctxlexpad($ctx), '!CORE_MARKER') {
                $ctx := nqp::ctxouterskipthunks($ctx);
            }
            my $stash := nqp::create(PseudoStash);
            nqp::bindattr($stash, Map, '$!storage', nqp::ctxlexpad($ctx));
            nqp::bindattr($stash, PseudoStash, '$!ctx', $ctx);
            nqp::bindattr_i($stash, PseudoStash, '$!mode', PRECISE_SCOPE);
            nqp::setwho(
                Metamodel::ModuleHOW.new_type(:name('CORE')),
                $stash);
        },
        'CALLER' => sub ($cur) {
            my Mu $ctx := nqp::ctxcallerskipthunks(
                nqp::getattr(nqp::decont($cur), PseudoStash, '$!ctx'));
            my $stash := nqp::create(PseudoStash);
            nqp::bindattr($stash, Map, '$!storage', nqp::ctxlexpad($ctx));
            nqp::bindattr($stash, PseudoStash, '$!ctx', $ctx);
            nqp::bindattr_i($stash, PseudoStash, '$!mode', PRECISE_SCOPE +| REQUIRE_DYNAMIC);
            nqp::setwho(
                Metamodel::ModuleHOW.new_type(:name('CALLER')),
                $stash);
        },
        'OUTER' => sub ($cur) {
            my Mu $ctx := nqp::ctxouterskipthunks(
                nqp::getattr(nqp::decont($cur), PseudoStash, '$!ctx'));
            my $stash := nqp::create(PseudoStash);
            nqp::bindattr($stash, Map, '$!storage', nqp::ctxlexpad($ctx));
            nqp::bindattr($stash, PseudoStash, '$!ctx', $ctx);
            nqp::bindattr_i($stash, PseudoStash, '$!mode', PRECISE_SCOPE);
            nqp::setwho(
                Metamodel::ModuleHOW.new_type(:name('OUTER')),
                $stash);
        },
        'LEXICAL' => sub ($cur) {
            my $stash := nqp::clone($cur);
            nqp::bindattr_i($stash, PseudoStash, '$!mode', STATIC_CHAIN);
            nqp::setwho(
                Metamodel::ModuleHOW.new_type(:name('LEXICAL')),
                $stash);
        },
        'OUTERS' => sub ($cur) {
            my Mu $ctx := nqp::ctxouterskipthunks(
                nqp::getattr(nqp::decont($cur), PseudoStash, '$!ctx'));
            my $stash := nqp::create(PseudoStash);
            nqp::bindattr($stash, Map, '$!storage', nqp::ctxlexpad($ctx));
            nqp::bindattr($stash, PseudoStash, '$!ctx', $ctx);
            nqp::bindattr_i($stash, PseudoStash, '$!mode', STATIC_CHAIN);
            nqp::setwho(
                Metamodel::ModuleHOW.new_type(:name('OUTERS')),
                $stash);
        },
        'DYNAMIC' => sub ($cur) {
            my $stash := nqp::clone($cur);
            nqp::bindattr_i($stash, PseudoStash, '$!mode', DYNAMIC_CHAIN);
            nqp::setwho(
                Metamodel::ModuleHOW.new_type(:name('DYNAMIC')),
                $stash);
        },
        'CALLERS' => sub ($cur) {
            my Mu $ctx := nqp::ctxcallerskipthunks(
                nqp::getattr(nqp::decont($cur), PseudoStash, '$!ctx'));
            my $stash := nqp::create(PseudoStash);
            nqp::bindattr($stash, Map, '$!storage', nqp::ctxlexpad($ctx));
            nqp::bindattr($stash, PseudoStash, '$!ctx', $ctx);
            nqp::bindattr_i($stash, PseudoStash, '$!mode', DYNAMIC_CHAIN +| REQUIRE_DYNAMIC);
            nqp::setwho(
                Metamodel::ModuleHOW.new_type(:name('CALLERS')),
                $stash);
        },
        'UNIT' => sub ($cur) {
            my Mu $ctx := nqp::getattr(nqp::decont($cur), PseudoStash, '$!ctx');
            until nqp::existskey(nqp::ctxlexpad($ctx), '!UNIT_MARKER') {
                $ctx := nqp::ctxouterskipthunks($ctx);
            }
            my $stash := nqp::create(PseudoStash);
            nqp::bindattr($stash, Map, '$!storage',nqp::ctxlexpad($ctx));
            nqp::bindattr($stash, PseudoStash, '$!ctx', $ctx);
            nqp::bindattr_i($stash, PseudoStash, '$!mode', PRECISE_SCOPE);
            nqp::setwho(
                Metamodel::ModuleHOW.new_type(:name('UNIT')),
                $stash);
        },
        'SETTING' => sub ($cur) {
            # Same as UNIT, but go a little further out (two steps, for
            # internals reasons).
            my Mu $ctx := nqp::getattr(nqp::decont($cur), PseudoStash, '$!ctx');
            until nqp::existskey(nqp::ctxlexpad($ctx), '!UNIT_MARKER') {
                $ctx := nqp::ctxouterskipthunks($ctx);
            }
            $ctx := nqp::ctxouter(nqp::ctxouter($ctx));
            my $stash := nqp::create(PseudoStash);
            nqp::bindattr($stash, Map, '$!storage', nqp::ctxlexpad($ctx));
            nqp::bindattr($stash, PseudoStash, '$!ctx', $ctx);
            nqp::bindattr_i($stash, PseudoStash, '$!mode', STATIC_CHAIN);
            nqp::setwho(
                Metamodel::ModuleHOW.new_type(:name('SETTING')),
                $stash);
        },
        'CLIENT' => sub ($cur) {
            my $pkg := nqp::getlexrel(
                nqp::getattr(nqp::decont($cur), PseudoStash, '$!ctx'),
                '$?PACKAGE');
            die "GLOBAL can have no client package" if $pkg.^name eq "GLOBAL";
            my Mu $ctx := nqp::ctxcallerskipthunks(
                nqp::getattr(nqp::decont($cur), PseudoStash, '$!ctx'));
            while nqp::getlexrel($ctx, '$?PACKAGE') === $pkg {
                $ctx := nqp::ctxcallerskipthunks($ctx);
                die "No client package found" unless $ctx;
            }
            my $stash := nqp::create(PseudoStash);
            nqp::bindattr($stash, Map, '$!storage', nqp::ctxlexpad($ctx));
            nqp::bindattr($stash, PseudoStash, '$!ctx', $ctx);
            nqp::bindattr_i($stash, PseudoStash, '$!mode', PRECISE_SCOPE +| REQUIRE_DYNAMIC);
            nqp::setwho(
                Metamodel::ModuleHOW.new_type(:name('CLIENT')),
                $stash);
        },
        'OUR' => sub ($cur) {
            nqp::getlexrel(
                nqp::getattr(nqp::decont($cur), PseudoStash, '$!ctx'),
                '$?PACKAGE')
        };

    multi method AT-KEY(PseudoStash:D: Str() $key) is raw {
        nqp::if(
          %pseudoers.EXISTS-KEY($key),
          %pseudoers.AT-KEY($key)(self),
          nqp::if(
            nqp::bitand_i($!mode,PRECISE_SCOPE),
            nqp::stmts(
              (my Mu $res := nqp::if(
                nqp::existskey(
                  nqp::getattr(self,Map,'$!storage'),nqp::unbox_s($key)),
                nqp::atkey(
                  nqp::getattr(self,Map,'$!storage'),nqp::unbox_s($key)),
                Nil
              )),
              nqp::if(
                (nqp::not_i(nqp::eqaddr($res,Nil))
                  && nqp::bitand_i($!mode,REQUIRE_DYNAMIC)),
                nqp::if(
                  (try nqp::not_i($res.VAR.dynamic)),
                  X::Caller::NotDynamic.new(symbol => $key).throw
                )
              ),
              $res
            ),
            nqp::if(
              nqp::bitand_i(
                $!mode,nqp::bitor_i(DYNAMIC_CHAIN,PICK_CHAIN_BY_NAME)
                ) && nqp::iseq_i(nqp::ord(nqp::unbox_s($key),1),42),  # "*"
              nqp::ifnull(
                nqp::getlexreldyn(
                  nqp::getattr(self,PseudoStash,'$!ctx'),nqp::unbox_s($key)),
                Nil
              ),
              nqp::ifnull(                                    # STATIC_CHAIN
                nqp::getlexrel(
                  nqp::getattr(self,PseudoStash,'$!ctx'),nqp::unbox_s($key)),
                Nil
              )
            )
          )
        )
    }

    method BIND-KEY(Str() $key, \value) is raw {
        nqp::if(
          %pseudoers.EXISTS-KEY($key),
          X::Bind.new(target => "pseudo-package $key").throw,
          nqp::if(
            nqp::bitand_i($!mode,PRECISE_SCOPE),
            nqp::bindkey(
              nqp::getattr(self,Map,'$!storage'),nqp::unbox_s($key),value),
            nqp::if(
              nqp::bitand_i(
                $!mode,nqp::bitor_i(DYNAMIC_CHAIN,PICK_CHAIN_BY_NAME)
              ) && nqp::iseq_i(nqp::ord(nqp::unbox_s($key),1),42),  # "*"
              (die "Binding to dynamic variables not yet implemented"),
              (die "This case of binding is not yet implemented") # STATIC_CHAIN
            )
          )
        )
    }

    # for some reason we get a ambiguous dispatch error by making this a multi
    method EXISTS-KEY(PseudoStash:D: Str() $key) {
        nqp::unless(
          %pseudoers.EXISTS-KEY($key),
          nqp::p6bool(
            nqp::if(
              nqp::bitand_i($!mode,PRECISE_SCOPE),
              nqp::existskey(
                nqp::getattr(self,Map,'$!storage'),nqp::unbox_s($key)),
              nqp::if(
                nqp::bitand_i(
                  $!mode,nqp::bitor_i(DYNAMIC_CHAIN,PICK_CHAIN_BY_NAME)
                ) && nqp::iseq_i(nqp::ord(nqp::unbox_s($key),1),42),  # "*"
                nqp::not_i(
                  nqp::isnull(
                    nqp::getlexreldyn(
                      nqp::getattr(self, PseudoStash, '$!ctx'),
                      nqp::unbox_s($key)))),
                nqp::not_i(           # STATIC_CHAIN
                  nqp::isnull(
                    nqp::getlexrel(
                      nqp::getattr(self, PseudoStash, '$!ctx'),
                      nqp::unbox_s($key))))
              )
            )
          )
        )
    }
}

#line 1 SETTING::src/core/Parameter.pm
my class Parameter { # declared in BOOTSTRAP
    # class Parameter is Any
    #     has str $!variable_name
    #     has @!named_names
    #     has @!type_captures
    #     has int $!flags
    #     has Mu $!nominal_type
    #     has @!post_constraints
    #     has Mu $!coerce_type
    #     has str $!coerce_method
    #     has Signature $!sub_signature
    #     has Code $!default_value
    #     has Mu $!container_descriptor;
    #     has Mu $!attr_package;
    #     has Mu $!why;

    my constant $SIG_ELEM_BIND_CAPTURE       = 1;
    my constant $SIG_ELEM_BIND_PRIVATE_ATTR  = 2;
    my constant $SIG_ELEM_BIND_PUBLIC_ATTR   = 4;
    my constant $SIG_ELEM_SLURPY_POS         = 8;
    my constant $SIG_ELEM_SLURPY_NAMED       = 16;
    my constant $SIG_ELEM_SLURPY_LOL         = 32;
    my constant $SIG_ELEM_INVOCANT           = 64;
    my constant $SIG_ELEM_MULTI_INVOCANT     = 128;
    my constant $SIG_ELEM_IS_RW              = 256;
    my constant $SIG_ELEM_IS_COPY            = 512;
    my constant $SIG_ELEM_IS_RAW             = 1024;
    my constant $SIG_ELEM_IS_OPTIONAL        = 2048;
    my constant $SIG_ELEM_ARRAY_SIGIL        = 4096;
    my constant $SIG_ELEM_HASH_SIGIL         = 8192;
    my constant $SIG_ELEM_IS_CAPTURE         = 32768;
    my constant $SIG_ELEM_UNDEFINED_ONLY     = 65536;
    my constant $SIG_ELEM_DEFINED_ONLY       = 131072;
    my constant $SIG_ELEM_SLURPY_ONEARG      = 16777216;
    my constant $SIG_ELEM_CODE_SIGIL         = 33554432;

    my constant $SIG_ELEM_IS_NOT_POSITIONAL = $SIG_ELEM_SLURPY_POS
                                           +| $SIG_ELEM_SLURPY_NAMED
                                           +| $SIG_ELEM_IS_CAPTURE;
    my constant $SIG_ELEM_IS_SLURPY = $SIG_ELEM_SLURPY_POS
                                   +| $SIG_ELEM_SLURPY_NAMED
                                   +| $SIG_ELEM_SLURPY_LOL
                                   +| $SIG_ELEM_SLURPY_ONEARG;
    my constant $SIG_ELEM_IS_NOT_READONLY = $SIG_ELEM_IS_RW
                                         +| $SIG_ELEM_IS_COPY
                                         +| $SIG_ELEM_IS_RAW;

    method name() {
        nqp::isnull_s($!variable_name) ?? Nil !! $!variable_name
    }
    method usage-name() {
        nqp::iseq_i(nqp::index('@$%&',nqp::substr($!variable_name,0,1)),-1)
          ?? $!variable_name
          !! nqp::substr($!variable_name,1)
    }

    method sigil() {
        nqp::bitand_i($!flags,$SIG_ELEM_IS_CAPTURE)
          ?? '|'
          !! nqp::isnull_s($!variable_name)
            ?? nqp::bitand_i($!flags,$SIG_ELEM_ARRAY_SIGIL)
              ?? '@'
              !!  nqp::bitand_i($!flags,$SIG_ELEM_HASH_SIGIL)
                ?? '%'
                !! nqp::bitand_i($!flags,$SIG_ELEM_CODE_SIGIL)
                  ?? '&'
                  !! nqp::bitand_i($!flags,$SIG_ELEM_IS_RAW)
                    ?? '\\'
                    !! '$'
            !! nqp::bitand_i($!flags,$SIG_ELEM_IS_RAW) && nqp::iseq_i(
                 nqp::index('@$%&',nqp::substr($!variable_name,0,1)),-1)
              ?? '\\'
              !! nqp::substr($!variable_name,0,1)
    }

    method twigil() {
        nqp::bitand_i($!flags,$SIG_ELEM_BIND_PUBLIC_ATTR)
          ?? '.'
          !! nqp::bitand_i($!flags,$SIG_ELEM_BIND_PRIVATE_ATTR)
            ?? '!'
            !! ''
    }
    method modifier() {
        nqp::bitand_i($!flags,$SIG_ELEM_DEFINED_ONLY)
          ?? ':D'
          !! nqp::bitand_i($!flags,$SIG_ELEM_UNDEFINED_ONLY)
            ?? ':U'
            !! ''
    }

    method constraint_list() {
        nqp::isnull(@!post_constraints) ?? () !!
            nqp::hllize(@!post_constraints)
    }

    method constraints() {
        all(nqp::isnull(@!post_constraints) ?? () !!
            nqp::hllize(@!post_constraints))
    }

    method type() { $!nominal_type }
    method named_names() {
        nqp::if(
          @!named_names && (my int $elems = nqp::elems(@!named_names)),
          nqp::stmts(
            (my $buf := nqp::setelems(nqp::create(IterationBuffer),$elems)),
            (my int $i = -1),
            nqp::while(
              nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
              nqp::bindpos($buf,$i,nqp::atpos_s(@!named_names,$i))
            ),
            nqp::p6bindattrinvres(nqp::create(List),List,'$!reified',$buf)
          ),
          nqp::create(List)
        )
    }
    method named() {
        nqp::p6bool(
          @!named_names || nqp::bitand_i($!flags,$SIG_ELEM_SLURPY_NAMED)
        )
    }

    method positional() {
        nqp::p6bool(
          nqp::isnull(@!named_names)
          && nqp::iseq_i(nqp::bitand_i($!flags,$SIG_ELEM_IS_NOT_POSITIONAL),0)
        )
    }

    method slurpy() {
        nqp::p6bool(nqp::bitand_i($!flags,$SIG_ELEM_IS_SLURPY))
    }
    method optional() {
        nqp::p6bool(nqp::bitand_i($!flags,$SIG_ELEM_IS_OPTIONAL))
    }
    method raw() {
        nqp::p6bool(nqp::bitand_i($!flags,$SIG_ELEM_IS_RAW))
    }
    method capture() {
        nqp::p6bool(nqp::bitand_i($!flags,$SIG_ELEM_IS_CAPTURE))
    }
    method rw() {
        nqp::p6bool(nqp::bitand_i($!flags,$SIG_ELEM_IS_RW))
    }
    method onearg() {
        nqp::p6bool(nqp::bitand_i($!flags,$SIG_ELEM_SLURPY_ONEARG))
    }
    method copy() {
        nqp::p6bool(nqp::bitand_i($!flags,$SIG_ELEM_IS_COPY))
    }
    method readonly() {
        nqp::p6bool(
          nqp::iseq_i(nqp::bitand_i($!flags,$SIG_ELEM_IS_NOT_READONLY),0)
        )
    }
    method invocant() {
        nqp::p6bool(nqp::bitand_i($!flags,$SIG_ELEM_INVOCANT))
    }
    method multi-invocant() {
        nqp::p6bool(nqp::bitand_i($!flags,$SIG_ELEM_MULTI_INVOCANT))
    }
    method default() {
        nqp::isnull($!default_value)
          ?? Any
          !! nqp::istype($!default_value,Code)
            ?? $!default_value
            !! { $!default_value }
    }
    method type_captures() {
        nqp::if(
          @!type_captures && (my int $elems = nqp::elems(@!type_captures)),
          nqp::stmts(
            (my $buf := nqp::setelems(nqp::create(IterationBuffer),$elems)),
            (my int $i = -1),
            nqp::while(
              nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
              nqp::bindpos($buf,$i,nqp::atpos_s(@!type_captures,$i))
            ),
            nqp::p6bindattrinvres(nqp::create(List),List,'$!reified',$buf)
          ),
          nqp::create(List)
        )
    }

    method !flags() { $!flags }

    multi method ACCEPTS(Parameter:D: Parameter:D \other) {

        # we're us
        my \o := nqp::decont(other);
        return True if self =:= o;

        # nominal type is acceptable
        if $!nominal_type.ACCEPTS(nqp::getattr(o,Parameter,'$!nominal_type')) {
            my $oflags := nqp::getattr(o,Parameter,'$!flags');

            # flags are not same, so we need to look more in depth
            if nqp::isne_i($!flags,$oflags) {

                # here not defined only, or both defined only
                return False
                  unless nqp::isle_i(
                    nqp::bitand_i($!flags,$SIG_ELEM_DEFINED_ONLY),
                    nqp::bitand_i($oflags,$SIG_ELEM_DEFINED_ONLY))

                # here not undefined only, or both undefined only
                  && nqp::isle_i(
                    nqp::bitand_i($!flags,$SIG_ELEM_UNDEFINED_ONLY),
                    nqp::bitand_i($oflags,$SIG_ELEM_UNDEFINED_ONLY))

                # here is rw, or both is rw
                  && nqp::isle_i(
                    nqp::bitand_i($!flags,$SIG_ELEM_IS_RW),
                    nqp::bitand_i($oflags,$SIG_ELEM_IS_RW))

                # other is optional, or both are optional
                  && nqp::isle_i(
                    nqp::bitand_i($oflags,$SIG_ELEM_IS_OPTIONAL),
                    nqp::bitand_i($!flags,$SIG_ELEM_IS_OPTIONAL))

                # other is slurpy positional, or both are slurpy positional
                  && nqp::isle_i(
                    nqp::bitand_i($oflags,$SIG_ELEM_SLURPY_POS),
                    nqp::bitand_i($!flags,$SIG_ELEM_SLURPY_POS))

                # other is slurpy named, or both are slurpy named
                  && nqp::isle_i(
                    nqp::bitand_i($oflags,$SIG_ELEM_SLURPY_NAMED),
                    nqp::bitand_i($!flags,$SIG_ELEM_SLURPY_NAMED))

                # other is slurpy one arg, or both are slurpy one arg
                  && nqp::isle_i(
                    nqp::bitand_i($oflags,$SIG_ELEM_SLURPY_ONEARG),
                    nqp::bitand_i($!flags,$SIG_ELEM_SLURPY_ONEARG))

                # here is part of MMD, or both are part of MMD
                  && nqp::isle_i(
                    nqp::bitand_i($!flags,$SIG_ELEM_MULTI_INVOCANT),
                    nqp::bitand_i($oflags,$SIG_ELEM_MULTI_INVOCANT));
            }
        }

        # nominal type not same
        else {
            return False;
        }

        # have nameds here
        my $onamed_names := nqp::getattr(o,Parameter,'@!named_names');
        if @!named_names {

            # nameds there
            if $onamed_names {

                # too many nameds there, can never be subset
                my int $elems = nqp::elems(@!named_names);
                return False
                  if nqp::isgt_i(nqp::elems($onamed_names),$elems);

                # set up lookup hash
                my $lookup := nqp::hash;
                my int $i   = -1;
                nqp::bindkey($lookup,nqp::atpos_s(@!named_names,$i),1)
                  while nqp::islt_i(++$i,$elems);

                # make sure the other nameds are all here
                $elems = nqp::elems($onamed_names);
                $i     = -1;
                return False unless
                  nqp::existskey($lookup,nqp::atpos_s($onamed_names,$i))
                  while nqp::islt_i(++$i,$elems);
            }
        }

        # no nameds here, but we do there (implies not a subset)
        elsif $onamed_names {
            return False;
        }

        # we have sub sig and not the same
        my $osub_signature := nqp::getattr(o,Parameter,'$!sub_signature');
        if $!sub_signature {
            return False
              unless $osub_signature
              && $!sub_signature.ACCEPTS($osub_signature);
        }

        # no sub sig, but other has one
        elsif $osub_signature {
            return False;
        }

        # we have a post constraint
        if nqp::islist(@!post_constraints) {

            # callable means runtime check, so no match
            return False
              if nqp::istype(nqp::atpos(@!post_constraints,0),Callable);

            # other doesn't have a post constraint
            my Mu $opc := nqp::getattr(o,Parameter,'@!post_constraints');
            return False unless nqp::islist($opc);

            # other post constraint is a Callable, so runtime check, so no match
            return False if nqp::istype(nqp::atpos($opc,0),Callable);

            # not same literal value
            return False
              unless nqp::atpos(@!post_constraints,0).ACCEPTS(
                nqp::atpos($opc,0));
        }

        # we don't, other *does* have a post constraint
        elsif nqp::islist(nqp::getattr(o,Parameter,'@!post_constraints')) {
            return False;
        }

        # it's a match!
        True;
    }

    multi method perl(Parameter:D: Mu:U :$elide-type = Any, :&where = -> $ { 'where { ... }' }) {
        my $perl = '';
        my $rest = '';
        my $type = $!nominal_type.^name;
        my $modifier = self.modifier;

        $perl ~= "::$_ " for @($.type_captures);
        if $!flags +& $SIG_ELEM_ARRAY_SIGIL or
            $!flags +& $SIG_ELEM_HASH_SIGIL or
            $!flags +& $SIG_ELEM_CODE_SIGIL {
            $type ~~ / .*? \[ <( .* )> \] $$/;
            $perl ~= $/ ~ $modifier if $/;
        }
        elsif $modifier or
                !nqp::eqaddr(nqp::decont($!nominal_type), nqp::decont($elide-type)) {
            $perl ~= $type ~ $modifier;
        }
        my $name = $.name;
        if $name {
            if $!flags +& $SIG_ELEM_IS_CAPTURE {
                $name = '|' ~ $name;
            } elsif $!flags +& $SIG_ELEM_IS_RAW {
                $name = '\\' ~ $name without '@$%&'.index(substr($name,0,1));
            }
        } else {
            if $!flags +& $SIG_ELEM_IS_CAPTURE {
                $name = '|';
            } elsif $!flags +& $SIG_ELEM_ARRAY_SIGIL {
                $name = '@';
            } elsif $!flags +& $SIG_ELEM_HASH_SIGIL {
                $name = '%';
            } elsif $!flags +& $SIG_ELEM_CODE_SIGIL {
                $name = '&';
            } else {
                $name = '$';
            }
        }
        my $default = self.default();
        if self.slurpy {
            $name = ($!flags +& $SIG_ELEM_SLURPY_ONEARG ?? '+' !! ($!flags +& $SIG_ELEM_SLURPY_LOL ?? "**" !! "*") ~ $name);
        } elsif self.named {
            my $name1 := substr($name,1);
            if @(self.named_names).first({$_ && $_ eq $name1}) {
                $name = ':' ~ $name;
            }
            for @(self.named_names).grep({$_ && $_ ne $name1}) {
                $name = ':' ~ $_ ~ '(' ~ $name ~ ')';
            }
            $name ~= '!' unless self.optional;
        } elsif self.optional && !$default {
            $name ~= '?';
        }
        if $!flags +& $SIG_ELEM_IS_RW {
            $rest ~= ' is rw';
        } elsif $!flags +& $SIG_ELEM_IS_COPY {
            $rest ~= ' is copy';
        }
        if $!flags +& $SIG_ELEM_IS_RAW {
            # Do not emit cases of anonymous '\' which we cannot reparse
            # This is all due to unspace.
            $rest ~= ' is raw' unless $name.starts-with('\\');
        }
        unless nqp::isnull($!sub_signature) {
            my $sig = $!sub_signature.perl();
            $sig ~~ s/^^ ':'//;
            $rest ~= ' ' ~ $sig;
        }
        unless nqp::isnull(@!post_constraints) {
            my $where = &where(self);
            return Nil without $where;
            $rest ~= " $where";
        }
        $rest ~= " = $!default_value.perl()" if $default;
        if $name or $rest {
            $perl ~= ($perl ?? ' ' !! '') ~ $name;
        }
        $perl ~ $rest;
    }

    method sub_signature(Parameter:D:) {
        nqp::isnull($!sub_signature) ?? Any !! $!sub_signature
    }

    method set_why($why --> Nil) {
        $!why := $why;
    }

    method set_default(Code:D $default --> Nil) {
        $!default_value := $default;
    }
}

multi sub infix:<eqv>(Parameter:D \a, Parameter:D \b) {

    # we're us
    return True if a =:= b;

    # different container type
    return False unless a.WHAT =:= b.WHAT;

    # different nominal or coerce type
    my $acoerce := nqp::getattr(a,Parameter,'$!coerce_type');
    my $bcoerce := nqp::getattr(b,Parameter,'$!coerce_type');
    return False
      unless nqp::iseq_s(
          nqp::getattr(a,Parameter,'$!nominal_type').^name,
          nqp::getattr(b,Parameter,'$!nominal_type').^name
        )
      && nqp::iseq_s(
          nqp::isnull($acoerce) ?? "" !! $acoerce.^name,
          nqp::isnull($bcoerce) ?? "" !! $bcoerce.^name
        );

    # different flags
    return False
      if nqp::isne_i(
        nqp::getattr(a,Parameter,'$!flags'),
        nqp::getattr(b,Parameter,'$!flags')
      );

    # first is named
    if a.named {

        # other is not named
        return False unless b.named;

        # not both actually have a name (e.g. *%_ doesn't)
        my $anames := nqp::getattr(a.named_names,List,'$!reified');
        my $bnames := nqp::getattr(b.named_names,List,'$!reified');
        my int $adefined = nqp::defined($anames);
        return False if nqp::isne_i($adefined,nqp::defined($bnames));

        # not same basic name
        return False
          if $adefined
          && nqp::isne_s(nqp::atpos($anames,0),nqp::atpos($bnames,0));
    }

    # unnamed vs named
    elsif b.named {
        return False;
    }

    # first has a post constraint
    my Mu $pca := nqp::getattr(a,Parameter,'@!post_constraints');
    if nqp::islist($pca) {

        # callable means runtime check, so no match
        return False if nqp::istype(nqp::atpos($pca,0),Callable);

        # second doesn't have a post constraint
        my Mu $pcb := nqp::getattr(b,Parameter,'@!post_constraints');
        return False unless nqp::islist($pcb);

        # second is a Callable, so runtime check, so no match
        return False if nqp::istype(nqp::atpos($pcb,0),Callable);

        # not same literal value
        return False unless nqp::atpos($pca,0) eqv nqp::atpos($pcb,0);
    }

    # first doesn't, second *does* have a post constraint
    elsif nqp::islist(nqp::getattr(b,Parameter,'@!post_constraints')) {
        return False;
    }

    # it's a match
    True
}

#line 1 SETTING::src/core/Signature.pm
my class X::Cannot::Capture { ... }

my class Signature { # declared in BOOTSTRAP
    # class Signature is Any
    #   has @!params;             # VM's array of parameters
    #   has Mu $!returns;         # return type
    #   has int $!arity;          # arity
    #   has Num $!count;          # count
    #   has Code $!code;

    multi method ACCEPTS(Signature:D: Mu \topic) {
        nqp::p6bool(try self.ACCEPTS: topic.Capture)
    }
    multi method ACCEPTS(Signature:D: Capture $topic) {
        nqp::p6bool(nqp::p6isbindable(self, nqp::decont($topic)));
    }
    multi method ACCEPTS(Signature:D: Signature:D $topic) {
        my $sclass = self.params.classify({.named});
        my $tclass = $topic.params.classify({.named});
        my @spos := $sclass{False} // ();
        my @tpos := $tclass{False} // ();

        while @spos {
            my $s;
            my $t;
            last unless @tpos && ($t = @tpos.shift);
            $s=@spos.shift;
            if $s.slurpy or $s.capture {
                @spos=();
                @tpos=();
                last;
            }
            if $t.slurpy or $t.capture {
                return False unless any(@spos) ~~ {.slurpy or .capture};
                @spos=();
                @tpos=();
                last;
            }
            if not $s.optional {
                return False if $t.optional
            }
            return False unless $t ~~ $s;
        }
        return False if @tpos;
        if @spos {
            return False unless @spos[0].optional or @spos[0].slurpy or @spos[0].capture;
        }

        for flat ($sclass{True} // ()).grep({!.optional and !.slurpy}) -> $this {
            my $other;
            return False unless $other=($tclass{True} // ()).grep(
                {!.optional and $_ ~~ $this });
            return False unless +$other == 1;
        }

        my $here=($sclass{True}:v).SetHash;
        my $hasslurpy=($sclass{True} // ()).grep({.slurpy});
        $here{@$hasslurpy} :delete;
        $hasslurpy .= Bool;
        for flat @($tclass{True} // ()) -> $other {
            my $this;

            if $other.slurpy {
                return False if any($here.keys) ~~ -> Any $_ { !(.type =:= Mu) };
                return $hasslurpy;
            }
            if $this=$here.keys.grep( -> $t { $other ~~ $t }) {
                $here{$this[0]} :delete;
            }
            else {
                return False unless $hasslurpy;
            }
        }
        return False unless self.returns =:= $topic.returns;
        True;
    }

    method Capture() { die X::Cannot::Capture.new: :what(self) }

    method arity() {
        $!arity
    }

    method count() {
        $!count
    }

    method params() {
        nqp::p6bindattrinvres(nqp::create(List), List, '$!reified',
            nqp::clone(@!params));
    }

    method !gistperl(Signature:D: $perl, Mu:U :$elide-type = Mu,
                     :&where = -> $ { 'where { ... }' } ) {
        # Opening.
        my $text = $perl ?? ':(' !! '(';

        # Parameters.
        if self.params.Array -> @params {
            $text ~= @params.shift.perl(:$elide-type) ~ ': '
                if @params[0].invocant;
            $text ~= ';; '
                if !@params[0].multi-invocant;

            my $sep = '';
            for @params.kv -> $i, $param {
                my $parmstr = $param.perl(:$elide-type, :&where);
                return Nil without $parmstr;
                $text ~= $sep ~ $parmstr;

                # Remove sigils from anon typed scalars, leaving type only
                $text .= subst(/ ' $'$/,'') unless $perl;

                $sep = $param.multi-invocant && !@params[$i+1].?multi-invocant
                  ?? ';; '
                  !! ', '
            }
        }
        if !nqp::isnull($!returns) && !($!returns =:= Mu) {
            $text = $text ~ ' --> ' ~ $!returns.perl
        }
        # Closer.
        $text ~ ')'
    }

    method !deftype(Signature:D:) {
         !nqp::isnull($!code) && $!code ~~ Routine ?? Any !! Mu
    }

    multi method perl(Signature:D:) {
        self!gistperl(True, :elide-type(self!deftype))
    }
    multi method gist(Signature:D:) {
        self!gistperl(False, :elide-type(self!deftype))
    }
}

multi sub infix:<eqv>(Signature:D \a, Signature:D \b) {

    # we're us
    return True if a =:= b;

    # different container type
    return False unless a.WHAT =:= b.WHAT;

    # arity or count mismatch
    return False if a.arity != b.arity || a.count != b.count;

    # different number of parameters or no parameters
    my $ap := nqp::getattr(a.params,List,'$!reified');
    my $bp := nqp::getattr(b.params,List,'$!reified');
    my int $elems = nqp::elems($ap);
    return False if nqp::isne_i($elems,nqp::elems($bp));
    return True unless $elems;

    # compare all positionals
    my int $i = -1;
    Nil
      while nqp::islt_i(++$i,$elems)
        && nqp::atpos($ap,$i) eqv nqp::atpos($bp,$i);

    # not all matching positionals
    if nqp::islt_i($i,$elems) {

        # not all same and different number of positionals
        return False
          if (!nqp::atpos($ap,$i).named || !nqp::atpos($bp,$i).named);

        # create lookup table
        my int $j = $i = $i - 1;
        my $lookup := nqp::hash;
        while nqp::islt_i(++$j,$elems) {
            my $p  := nqp::atpos($ap,$j);
            my $nn := nqp::getattr($p,Parameter,'@!named_names');
            my str $key =
              nqp::isnull($nn) ?? '' !! nqp::elems($nn) ?? nqp::atpos_s($nn,0) !! '';
            die "Found named parameter '{
              nqp::chars($key) ?? $key !! '(unnamed)'
            }' twice in signature {a.perl}: {$p.perl} vs {nqp::atkey($lookup,$key).perl}"
              if nqp::existskey($lookup,$key);
            nqp::bindkey($lookup,$key,$p);
        }

        # named variable mismatch
        while nqp::islt_i(++$i,$elems) {
            my $p  := nqp::atpos($bp,$i);
            my $nn := nqp::getattr($p,Parameter,'@!named_names');
            my str $key = nqp::defined($nn) && nqp::elems($nn)
              ?? nqp::atpos_s($nn,0)
              !! '';

            # named param doesn't exist in other or is not equivalent
            return False
              unless nqp::existskey($lookup,$key)
                && $p eqv nqp::atkey($lookup,$key);
        }
    }

    # it's a match
    True
}

Perl6::Metamodel::Configuration.set_multi_sig_comparator(
    -> \a, \b { a.signature eqv b.signature }
);

#line 1 SETTING::src/core/Rational.pm
my role Rational[::NuT = Int, ::DeT = ::("NuT")] does Real {
    has NuT $.numerator   = 0;
    has DeT $.denominator = 1;

    multi method WHICH(Rational:D:) {
        nqp::box_s(
          nqp::concat(
            nqp::if(
              nqp::eqaddr(self.WHAT,Rational),
              'Rational|',
              nqp::concat(nqp::unbox_s(self.^name), '|')
            ),
            nqp::concat(
              nqp::tostr_I($!numerator),
              nqp::concat('/', nqp::tostr_I($!denominator))
            )
          ),
          ObjAt
        )
    }

    method new(NuT \nu = 0, DeT \de = 1) {
        my $new := nqp::create(self);

        # 0 denominator take it verbatim to support Inf/-Inf/NaN
        if de == 0 {
            nqp::bindattr($new,::?CLASS,'$!numerator',  nqp::decont(nu));
            nqp::bindattr($new,::?CLASS,'$!denominator',nqp::decont(de));
        }

        # normalize
        else {
            my $gcd        := nu gcd de;
            my $numerator   = nu div $gcd;
            my $denominator = de div $gcd;
            if $denominator < 0 {
                $numerator   = -$numerator;
                $denominator = -$denominator;
            }
            nqp::bindattr($new,::?CLASS,'$!numerator',  nqp::decont($numerator));
            nqp::bindattr($new,::?CLASS,'$!denominator',nqp::decont($denominator));
        }

        $new
    }

    method nude() { self.REDUCE-ME; $!numerator, $!denominator }
    method Num() {
        nqp::istype($!numerator,Int)
          ?? nqp::p6box_n(nqp::div_In(
               nqp::decont($!numerator),
               nqp::decont($!denominator)
             ))
          !! $!numerator
    }

    method floor(Rational:D:) {
        $!denominator == 1
            ?? $!numerator
            !! $!numerator div $!denominator
    }

    method ceiling(Rational:D:) {
        self.REDUCE-ME;
        $!denominator == 1
            ?? $!numerator
            !! ($!numerator div $!denominator + 1)
    }

    method Int() {
        $!denominator
            ?? self.truncate
            !! fail X::Numeric::DivideByZero.new:
                   :details('when coercing Rational to Int')
    }
    method Bridge() { self.Num }
    method Range(::?CLASS:U:) { Range.new(-Inf, Inf) }
    method isNaN {
        nqp::p6bool(
            nqp::isfalse(self.numerator) && nqp::isfalse(self.denominator)
        )
    }

    multi method Str(::?CLASS:D:) {
        if nqp::istype($!numerator,Int) {
            my $whole  = self.abs.floor;
            my $fract  = self.abs - $whole;

            # fight floating point noise issues RT#126016
            if $fract.Num == 1e0 { $whole++; $fract = 0 }

            my $result = nqp::if(
                nqp::islt_I($!numerator, 0), '-', ''
            ) ~ $whole;

            if $fract {
                my $precision = $!denominator < 100_000
                    ?? 6 !! $!denominator.Str.chars + 1;

                my $fract-result = '';
                while $fract and $fract-result.chars < $precision {
                    $fract *= 10;
                    given $fract.floor {
                        $fract-result ~= $_;
                        $fract        -= $_;
                    }
                }
                $fract-result++ if 2*$fract >= 1; # round off fractional result

                $result ~= '.' ~ $fract-result;
            }
            $result
        }
        else {
            $!numerator.Str
        }
    }

    method base($base, Any $digits? is copy) {
        # XXX TODO: this $base check can be delegated to Int.base once Num/0 gives Inf/NaN,
        # instead of throwing (which happens in the .log() call before we reach Int.base
        2 <= $base <= 36 or Failure.new(X::OutOfRange.new(
            what => "base argument to base", :got($base), :range<2..36>)
        );

        my $prec;
        if $digits ~~ Whatever {
            $digits = Nil;
            $prec = 2**63;
        }
        elsif $digits.defined {
            $digits = $digits.Int;
            if $digits > 0 {
                $prec = $digits;
            }
            elsif $digits == 0 {
                return self.round.base($base)
            }
            else {
                fail X::OutOfRange.new(
                    :what('digits argument to base'), :got($digits),
                    :range<0..^Inf>,
                )
            }
        }
        else {
            $prec = ($!denominator < $base**6 ?? 6 !! $!denominator.log($base).ceiling + 1);
        }

        my $sign  = nqp::if( nqp::islt_I($!numerator, 0), '-', '' );
        my $whole = self.abs.floor;
        my $fract = self.abs - $whole;

        # fight floating point noise issues RT#126016
        if $fract.Num == 1e0 { $whole++; $fract = 0 }

        my $result = $sign ~ $whole.base($base);
        my @conversion := <0 1 2 3 4 5 6 7 8 9
                           A B C D E F G H I J
                           K L M N O P Q R S T
                           U V W X Y Z>;

        my @fract-digits;
        while @fract-digits < $prec and ($digits // $fract) {
            $fract *= $base;
            my $digit = $fract.floor;
            push @fract-digits, $digit;
            $fract -= $digit;
        }

        # Round the final number, based on the remaining fractional part
        if 2*$fract >= 1 {
            for @fract-digits-1 ... 0 -> $n {
                last if ++@fract-digits[$n] < $base;
                @fract-digits[$n] = 0;
                $result = $sign ~ ($whole+1).base($base) if $n == 0;
            }
        }

        @fract-digits
            ?? $result ~ '.' ~ @conversion[@fract-digits].join
            !! $result;
    }

    method base-repeating($base = 10) {
        return ~self, '' if self.narrow ~~ Int;
        my @quotients;
        my @remainders;
        my %remainders;
        push @quotients, [div] my ($nu, $de) = abs(self).nude;
        loop {
            push @remainders, $nu %= $de;
            last if %remainders{$nu}++ or $nu == 0;
            $nu *= $base;
            push @quotients, $nu div $de;
        }
        @quotients.=map(*.base($base));
        my @cycle = $nu
          ?? splice(@quotients, @remainders.first($nu,:k) + 1)
          !! ();
        splice @quotients, 1, 0, '.';
        '-' x (self < 0) ~ @quotients.join, @cycle.join;
    }

    method succ {
        self.new($!numerator + $!denominator, $!denominator);
    }

    method pred {
        self.new($!numerator - $!denominator, $!denominator);
    }

    method norm() { self.REDUCE-ME; self }

    method narrow(::?CLASS:D:) {
        self.REDUCE-ME;
        $!denominator == 1
            ?? $!numerator
            !! self;
    }

    method REDUCE-ME(--> Nil) {
        if $!denominator > 1 {
            my $gcd = $!denominator gcd $!numerator;
            if $gcd > 1 {
                nqp::bindattr(self, self.WHAT, '$!numerator',     $!numerator   div $gcd);
                nqp::bindattr(self, self.WHAT, '$!denominator',   $!denominator div $gcd);
            }
        }
    }
}

#line 1 SETTING::src/core/Rat.pm
# XXX: should be Rational[Int, UInt64]
my class Rat is Cool does Rational[Int, Int] {
    method Rat   (Rat:D: Real $?) { self }
    method FatRat(Rat:D: Real $?) { FatRat.new($!numerator, $!denominator); }
    multi method perl(Rat:D:) {
        if $!denominator == 1 {
            $!numerator ~ '.0'
        }
        else {
            my $d = $!denominator;
            unless $d == 0 {
                $d = $d div 5 while $d %% 5;
                $d = $d div 2 while $d %% 2;
                self.REDUCE-ME;
            }
            if $d == 1 and (my $b := self.base(10,*)).Numeric === self {
                $b;
            }
            else {
                '<' ~ $!numerator ~ '/' ~ $!denominator ~ '>'
            }
        }
    }
}

my class FatRat is Cool does Rational[Int, Int] {
    method FatRat(FatRat:D: Real $?) { self }
    method Rat   (FatRat:D: Real $?) {
        $!denominator < $UINT64_UPPER
          ?? Rat.new($!numerator, $!denominator)
          !! Failure.new("Cannot convert from FatRat to Rat because denominator is too big")
    }
    multi method perl(FatRat:D:) {
        "FatRat.new($!numerator, $!denominator)";
    }
}

sub DIVIDE_NUMBERS(Int:D \nu, Int:D \de, $t1, $t2) {
    my Int $gcd         := de == 0 ?? 1 !! nu gcd de;
    my Int $numerator   := nu div $gcd;
    my Int $denominator := de div $gcd;
    my $r;
    if $denominator < 0 {
        $numerator   := -$numerator;
        $denominator := -$denominator;
    }
    if nqp::istype($t1, FatRat) || nqp::istype($t2, FatRat) {
        $r := nqp::create(FatRat);
        nqp::bindattr($r, FatRat, '$!numerator',   nqp::decont($numerator));
        nqp::bindattr($r, FatRat, '$!denominator', nqp::decont($denominator));
    } elsif $denominator < $UINT64_UPPER {
        $r := nqp::create(Rat);
        nqp::bindattr($r, Rat, '$!numerator',   nqp::decont($numerator));
        nqp::bindattr($r, Rat, '$!denominator', nqp::decont($denominator));
    } else {
        $r := nqp::p6box_n(nqp::div_In(
                nqp::decont($numerator),
                nqp::decont($denominator)
            )
        );
    }
    $r;
}

sub DON'T_DIVIDE_NUMBERS(Int:D \nu, Int:D \de, $t1, $t2) {
    my $r;
    if nqp::istype($t1, FatRat) || nqp::istype($t2, FatRat) {
        $r := nqp::create(FatRat);
        nqp::bindattr($r, FatRat, '$!numerator',   nqp::decont(nu));
        nqp::bindattr($r, FatRat, '$!denominator', nqp::decont(de));
    } else {
        $r := nqp::create(Rat);
        nqp::bindattr($r, Rat, '$!numerator',   nqp::decont(nu));
        nqp::bindattr($r, Rat, '$!denominator', nqp::decont(de));
    }
    $r;
}

multi sub prefix:<->(Rat:D \a) {
    Rat.new(-a.numerator, a.denominator);
}
multi sub prefix:<->(FatRat:D \a) {
    FatRat.new(-a.numerator, a.denominator);
}

multi sub infix:<+>(Rational \a, Rational \b) {
    if a.denominator == b.denominator {
        DON'T_DIVIDE_NUMBERS(a.numerator + b.numerator, a.denominator, a, b);
    }
    else {
        my Int $gcd := a.denominator gcd b.denominator;
        DIVIDE_NUMBERS(
            (a.numerator * (b.denominator div $gcd) + b.numerator * (a.denominator div $gcd)),
            ((a.denominator div $gcd) * b.denominator),
            a,
            b,
        );
    }
}
multi sub infix:<+>(Rational \a, Int \b) {
    DON'T_DIVIDE_NUMBERS(
        (a.numerator + b * a.denominator),
        a.denominator,
        a,
        b,
    );
}
multi sub infix:<+>(Int \a, Rational \b) {
    DON'T_DIVIDE_NUMBERS(
        (a * b.denominator + b.numerator),
        b.denominator,
        a,
        b,
    );
}

multi sub infix:<->(Rational \a, Rational \b) {
    if a.denominator == b.denominator {
        DON'T_DIVIDE_NUMBERS(a.numerator - b.numerator, a.denominator, a, b);
    }
    else {
        my Int $gcd = a.denominator gcd b.denominator;
        DIVIDE_NUMBERS
            a.numerator * (b.denominator div $gcd) - b.numerator * (a.denominator div $gcd),
            (a.denominator div $gcd) * b.denominator,
            a,
            b;
    }
}

multi sub infix:<->(Rational \a, Int \b) {
    DON'T_DIVIDE_NUMBERS
        a.numerator - b * a.denominator,
        a.denominator,
        a,
        b;
}

multi sub infix:<->(Int \a, Rational \b) {
    DON'T_DIVIDE_NUMBERS
        a * b.denominator - b.numerator,
        b.denominator,
        a,
        b;
}

multi sub infix:<*>(Rational \a, Rational \b) {
    DIVIDE_NUMBERS
        a.numerator * b.numerator,
        a.denominator * b.denominator,
        a,
        b;
}

multi sub infix:<*>(Rational \a, Int \b) {
    DIVIDE_NUMBERS
        a.numerator * b,
        a.denominator,
        a,
        b;
}

multi sub infix:<*>(Int \a, Rational \b) {
    DIVIDE_NUMBERS
        a * b.numerator,
        b.denominator,
        a,
        b;
}

multi sub infix:</>(Rational \a, Rational \b) {
    DIVIDE_NUMBERS
        a.numerator * b.denominator,
        a.denominator * b.numerator,
        a,
        b;
}

multi sub infix:</>(Rational \a, Int \b) {
    DIVIDE_NUMBERS
        a.numerator,
        a.denominator * b,
        a,
        b;
}

multi sub infix:</>(Int \a, Rational \b) {
    b.REDUCE-ME; # RT #126391: [BUG] Bad "divide by 0" error message
    DIVIDE_NUMBERS
        b.denominator * a,
        b.numerator,
        a,
        b;
}

multi sub infix:</>(Int \a, Int \b) {
    DIVIDE_NUMBERS a, b, a, b
}

multi sub infix:<%>(Rational \a, Int \b) {
    a - floor(a / b) * b
}

multi sub infix:<%>(Int \a, Rational \b) {
    a - floor(a / b) * b
}

multi sub infix:<%>(Rational \a, Rational \b) {
    a - floor(a / b) * b
}

multi sub infix:<**>(Rational \a, Int \b) {
    b >= 0
        ?? DIVIDE_NUMBERS
            (a.numerator ** b // fail (a.numerator.abs > a.denominator ?? X::Numeric::Overflow !! X::Numeric::Underflow).new),
            a.denominator ** b,  # we presume it likely already blew up on the numerator
            a,
            b
        !! DIVIDE_NUMBERS
            (a.denominator ** -b // fail (a.numerator.abs < a.denominator ?? X::Numeric::Overflow !! X::Numeric::Underflow).new),
            a.numerator ** -b,
            a,
            b
}

multi sub infix:<==>(Rational:D \a, Rational:D \b) {
    nqp::isfalse(a.denominator) || nqp::isfalse(b.denominator)
        ?? a.Num == b.Num
        !! a.numerator * b.denominator == b.numerator * a.denominator
}
multi sub infix:<==>(Rational:D \a, Int:D \b) {
    a.REDUCE-ME;
    a.numerator == b && a.denominator == 1
}
multi sub infix:<==>(Int:D \a, Rational:D \b) {
    b.REDUCE-ME;
    a == b.numerator && b.denominator == 1;
}
multi sub infix:<===>(Rational:D \a, Rational:D \b --> Bool:D) {
    # Check whether we have 0-denominator rationals as well. Those can
    # be `==` but have different numerator values and so should not `===` True.
    # Since we're already checking equality first, we only need to check the
    # zeroeness of the denominator of just one parameter
    a.WHAT =:= b.WHAT
        && (a == b || (a.isNaN && b.isNaN))
        && (a.denominator.Bool || a.numerator == b.numerator)
}

multi sub infix:<(Rational:D \a, Rational:D \b) {
    a.numerator * b.denominator < b.numerator * a.denominator
}
multi sub infix:<(Rational:D \a, Int:D \b) {
    a.numerator  < b * a.denominator
}
multi sub infix:<(Int:D \a, Rational:D \b) {
    a * b.denominator < b.numerator
}

multi sub infix:<=(Rational:D \a, Rational:D \b) {
    a.numerator * b.denominator <= b.numerator * a.denominator
}
multi sub infix:<=(Rational:D \a, Int:D \b) {
    a.numerator  <= b * a.denominator
}
multi sub infix:<=(Int:D \a, Rational:D \b) {
    a * b.denominator <= b.numerator
}
multi sub infix:(Rational:D \a, Rational:D \b) {
    a.numerator * b.denominator  b.numerator * a.denominator
}
multi sub infix:(Rational:D \a, Int:D \b) {
    a.numerator  b * a.denominator
}
multi sub infix:(Int:D \a, Rational:D \b) {
    a * b.denominator  b.numerator
}

multi sub infix:>(Rational:D \a, Rational:D \b) {
    a.numerator * b.denominator > b.numerator * a.denominator
}
multi sub infix:>(Rational:D \a, Int:D \b) {
    a.numerator  > b * a.denominator
}
multi sub infix:>(Int:D \a, Rational:D \b) {
    a * b.denominator > b.numerator
}

multi sub infix:>=(Rational:D \a, Rational:D \b) {
    a.numerator * b.denominator >= b.numerator * a.denominator
}
multi sub infix:>=(Rational:D \a, Int:D \b) {
    a.numerator  >= b * a.denominator
}
multi sub infix:>=(Int:D \a, Rational:D \b) {
    a * b.denominator >= b.numerator
}
multi sub infix:(Rational:D \a, Rational:D \b) {
    a.numerator * b.denominator  b.numerator * a.denominator
}
multi sub infix:(Rational:D \a, Int:D \b) {
    a.numerator  b * a.denominator
}
multi sub infix:(Int:D \a, Rational:D \b) {
    a * b.denominator  b.numerator
}

multi sub infix:<=>(Rational:D \a, Rational:D \b) {
    a.numerator * b.denominator <=> b.numerator * a.denominator
}
multi sub infix:<=>(Rational:D \a, Int:D \b) {
    a.numerator  <=> b * a.denominator
}
multi sub infix:<=>(Int:D \a, Rational:D \b) {
    a * b.denominator <=> b.numerator
}

#line 1 SETTING::src/core/Complex.pm
my class X::Numeric::Real { ... };
my class Complex is Cool does Numeric {
    has num $.re;
    has num $.im;

    method !SET-SELF(Num() \re, Num() \im) {
        $!re = re;
        $!im = im;
        self
    }
    proto method new(|) { * }
    multi method new() { self.new: 0, 0 }
    multi method new(Real \re, Real \im) { nqp::create(self)!SET-SELF(re, im) }

    multi method WHICH(Complex:D:) {
        nqp::box_s(
          nqp::concat(
            nqp::if(
              nqp::eqaddr(self.WHAT,Complex),
              'Complex|',
              nqp::concat(nqp::unbox_s(self.^name), '|')
            ),
            nqp::concat($!re, nqp::concat('|', $!im))
          ),
          ObjAt
        )
    }

    method reals(Complex:D:) {
        (self.re, self.im);
    }

    method isNaN(Complex:D:) {
        self.re.isNaN || self.im.isNaN;
    }

    method coerce-to-real(Complex:D: $exception-target) {
        $!im  0e0
          ?? $!re
          !! Failure.new(X::Numeric::Real.new(target => $exception-target, reason => "imaginary part not zero", source => self))
    }
    multi method Real(Complex:D:) { self.coerce-to-real(Real); }

    # should probably be eventually supplied by role Numeric
    method Num(Complex:D:) { self.coerce-to-real(Num).Num; }
    method Int(Complex:D:) { self.coerce-to-real(Int).Int; }
    method Rat(Complex:D: $epsilon?) {
        self.coerce-to-real(Rat).Rat( |($epsilon // Empty) );
    }
    method FatRat(Complex:D: $epsilon?) {
        self.coerce-to-real(FatRat).FatRat( |($epsilon // Empty) );
    }

    multi method Bool(Complex:D:) {
        $!re != 0e0 || $!im != 0e0;
    }

    method Complex() { self }
    multi method Str(Complex:D:) {
        nqp::concat(
          $!re,
          nqp::concat(
            nqp::if(nqp::iseq_i(nqp::ord($!im),45),'','+'),
            nqp::concat(
              $!im,
              nqp::if(nqp::isnanorinf($!im),'\\i','i')
            )
          )
        )
    }

    multi method perl(Complex:D:) {
        '<' ~ self.Str ~ '>';
    }
    method conj(Complex:D:) {
        Complex.new($.re, -$.im);
    }

    method abs(Complex $x:) {
        nqp::p6box_n(nqp::sqrt_n(
            nqp::add_n(
                nqp::mul_n($!re, $!re),
                nqp::mul_n($!im, $!im),
            )
        ))
    }

    method polar() {
        $.abs, $!im.atan2($!re);
    }
    multi method log(Complex:D:) {
        my Num ($mag, $angle) = self.polar;
        Complex.new($mag.log, $angle);
    }
    method cis(Complex:D:) {
        self.cos + self.sin*Complex.new(0,1)
    }
    method sqrt(Complex:D:) {
        my Num $abs = self.abs;
        my Num $re = (($abs + self.re)/2).sqrt;
        my Num $im = (($abs - self.re)/2).sqrt;
        Complex.new($re, self.im < 0 ?? -$im !! $im);
    }

    multi method exp(Complex:D:) {
        my Num $mag = $!re.exp;
        Complex.new($mag * $!im.cos, $mag * $!im.sin);
    }

    method roots(Complex:D: Int() $n) {
        return NaN if $n < 1;
        return self if $n == 1;
        for $!re, $!im {
            return NaN if $_ eq 'Inf' || $_ eq '-Inf' || $_ eq 'NaN';
        }

        my ($mag, $angle) = self.polar;
        $mag **= 1e0 / $n;
        (^$n).map: { $mag.unpolar( ($angle + $_ * 2e0 * pi) / $n) };
    }

    method sin(Complex:D:) {
        $!re.sin * $!im.cosh + ($!re.cos * $!im.sinh)i;
    }

    method asin(Complex:D:) {
        (Complex.new(0e0, -1e0) * log((self)i + sqrt(1e0 - self * self)));
    }

    method cos(Complex:D:) {
        $!re.cos * $!im.cosh - ($!re.sin * $!im.sinh)i;
    }

    method acos(Complex:D:) {
        (pi / 2e0) - self.asin;
    }

    method tan(Complex:D:) {
        self.sin / self.cos;
    }

    method atan(Complex:D:) {
        ((log(1e0 - (self)i) - log(1e0 + (self)i))i / 2e0);
    }

    method sec(Complex:D:) {
        1e0 / self.cos;
    }

    method asec(Complex:D:) {
        (1e0 / self).acos;
    }

    method cosec(Complex:D:) {
        1e0 / self.sin;
    }

    method acosec(Complex:D:) {
        (1e0 / self).asin;
    }

    method cotan(Complex:D:) {
        self.cos / self.sin;
    }

    method acotan(Complex:D:) {
        (1e0 / self).atan;
    }

    method sinh(Complex:D:) {
        -((Complex.new(0e0, 1e0) * self).sin)i;
    }

    method asinh(Complex:D:) {
        (self + sqrt(1e0 + self * self)).log;
    }

    method cosh(Complex:D:) {
        (Complex.new(0e0, 1e0) * self).cos;
    }

    method acosh(Complex:D:) {
        (self + sqrt(self * self - 1e0)).log;
    }

    method tanh(Complex:D:) {
        -((Complex.new(0e0, 1e0) * self).tan)i;
    }

    method atanh(Complex:D:) {
        (((1e0 + self) / (1e0 - self)).log / 2e0);
    }

    method sech(Complex:D:) {
        1e0 / self.cosh;
    }

    method asech(Complex:D:) {
        (1e0 / self).acosh;
    }

    method cosech(Complex:D:) {
        1e0 / self.sinh;
    }

    method acosech(Complex:D:) {
        (1e0 / self).asinh;
    }

    method cotanh(Complex:D:) {
        1e0 / self.tanh;
    }

    method acotanh(Complex:D:) {
        (1e0 / self).atanh;
    }

    method floor(Complex:D:) {
        Complex.new( self.re.floor, self.im.floor );
    }

    method ceiling(Complex:D:) {
        Complex.new( self.re.ceiling, self.im.ceiling );
    }

    proto method round(|) {*}
    multi method round(Complex:D:) {
        Complex.new( self.re.round, self.im.round );
    }
    multi method round(Complex:D: Real() $scale) {
        Complex.new( self.re.round($scale), self.im.round($scale) );
    }

    method truncate(Complex:D:) {
        Complex.new( self.re.truncate, self.im.truncate );
    }

    method narrow(Complex:D:) {
        self == 0e0 ?? 0 !!
        $!re == 0e0 ?? self !!
        $!im / $!re  0e0
            ?? $!re.narrow
            !! self;
    }
}

multi sub prefix:<->(Complex:D \a --> Complex:D) {
    my $new := nqp::create(Complex);
    nqp::bindattr_n( $new, Complex, '$!re',
        nqp::neg_n(
            nqp::getattr_n(nqp::decont(a), Complex, '$!re')
        )
    );
    nqp::bindattr_n( $new, Complex, '$!im',
        nqp::neg_n(
            nqp::getattr_n(nqp::decont(a), Complex, '$!im')
        )
    );
    $new;
}

multi sub abs(Complex:D \a --> Num:D) {
    my num $re = nqp::getattr_n(nqp::decont(a), Complex, '$!re');
    my num $im = nqp::getattr_n(nqp::decont(a), Complex, '$!im');
    nqp::p6box_n(nqp::sqrt_n(nqp::add_n(nqp::mul_n($re, $re), nqp::mul_n($im, $im))));
}

multi sub infix:<+>(Complex:D \a, Complex:D \b --> Complex:D) {
    my $new := nqp::create(Complex);
    nqp::bindattr_n( $new, Complex, '$!re',
        nqp::add_n(
            nqp::getattr_n(nqp::decont(a), Complex, '$!re'),
            nqp::getattr_n(nqp::decont(b), Complex, '$!re'),
        )
    );
    nqp::bindattr_n( $new, Complex, '$!im',
        nqp::add_n(
            nqp::getattr_n(nqp::decont(a), Complex, '$!im'),
            nqp::getattr_n(nqp::decont(b), Complex, '$!im'),
        )
    );
    $new;
}

multi sub infix:<+>(Complex:D \a, Num(Real) \b --> Complex:D) {
    my $new := nqp::create(Complex);
    nqp::bindattr_n( $new, Complex, '$!re',
        nqp::add_n(
            nqp::getattr_n(nqp::decont(a), Complex, '$!re'),
            nqp::unbox_n(b)
        )
    );
    nqp::bindattr_n($new, Complex, '$!im',
        nqp::getattr_n(nqp::decont(a), Complex, '$!im'),
    );
    $new
}

multi sub infix:<+>(Num(Real) \a, Complex:D \b --> Complex:D) {
    my $new := nqp::create(Complex);
    nqp::bindattr_n($new, Complex, '$!re',
        nqp::add_n(
            nqp::unbox_n(a),
            nqp::getattr_n(nqp::decont(b), Complex, '$!re'),
        )
    );
    nqp::bindattr_n($new, Complex, '$!im',
        nqp::getattr_n(nqp::decont(b), Complex, '$!im'),
    );
    $new;
}

multi sub infix:<->(Complex:D \a, Complex:D \b --> Complex:D) {
    my $new := nqp::create(Complex);
    nqp::bindattr_n( $new, Complex, '$!re',
        nqp::sub_n(
            nqp::getattr_n(nqp::decont(a), Complex, '$!re'),
            nqp::getattr_n(nqp::decont(b), Complex, '$!re'),
        )
    );
    nqp::bindattr_n($new, Complex, '$!im',
        nqp::sub_n(
            nqp::getattr_n(nqp::decont(a), Complex, '$!im'),
            nqp::getattr_n(nqp::decont(b), Complex, '$!im'),
        )
    );
    $new
}

multi sub infix:<->(Complex:D \a, Num(Real) \b --> Complex:D) {
    my $new := nqp::create(Complex);
    nqp::bindattr_n( $new, Complex, '$!re',
        nqp::sub_n(
            nqp::getattr_n(nqp::decont(a), Complex, '$!re'),
            b,
        )
    );
    nqp::bindattr_n($new, Complex, '$!im',
        nqp::getattr_n(nqp::decont(a), Complex, '$!im')
    );
    $new
}

multi sub infix:<->(Num(Real) \a, Complex:D \b --> Complex:D) {
    my $new := nqp::create(Complex);
    nqp::bindattr_n( $new, Complex, '$!re',
        nqp::sub_n(
            a,
            nqp::getattr_n(nqp::decont(b), Complex, '$!re'),
        )
    );
    nqp::bindattr_n($new, Complex, '$!im',
        nqp::neg_n(
            nqp::getattr_n(nqp::decont(b), Complex, '$!im')
        )
    );
    $new
}

multi sub infix:<*>(Complex:D \a, Complex:D \b --> Complex:D) {
    my num $a_re = nqp::getattr_n(nqp::decont(a), Complex, '$!re');
    my num $a_im = nqp::getattr_n(nqp::decont(a), Complex, '$!im');
    my num $b_re = nqp::getattr_n(nqp::decont(b), Complex, '$!re');
    my num $b_im = nqp::getattr_n(nqp::decont(b), Complex, '$!im');
    my $new := nqp::create(Complex);
    nqp::bindattr_n($new, Complex, '$!re',
        nqp::sub_n(nqp::mul_n($a_re, $b_re), nqp::mul_n($a_im, $b_im)),
    );
    nqp::bindattr_n($new, Complex, '$!im',
        nqp::add_n(nqp::mul_n($a_re, $b_im), nqp::mul_n($a_im, $b_re)),
    );
    $new;
}

multi sub infix:<*>(Complex:D \a, Num(Real) \b --> Complex:D) {
    my $new := nqp::create(Complex);
    my num $b_num = b;
    nqp::bindattr_n($new, Complex, '$!re',
        nqp::mul_n(
            nqp::getattr_n(nqp::decont(a), Complex, '$!re'),
            $b_num,
        )
    );
    nqp::bindattr_n($new, Complex, '$!im',
        nqp::mul_n(
            nqp::getattr_n(nqp::decont(a), Complex, '$!im'),
            $b_num,
        )
    );
    $new
}

multi sub infix:<*>(Num(Real) \a, Complex:D \b --> Complex:D) {
    my $new := nqp::create(Complex);
    my num $a_num = a;
    nqp::bindattr_n($new, Complex, '$!re',
        nqp::mul_n(
            $a_num,
            nqp::getattr_n(nqp::decont(b), Complex, '$!re'),
        )
    );
    nqp::bindattr_n($new, Complex, '$!im',
        nqp::mul_n(
            $a_num,
            nqp::getattr_n(nqp::decont(b), Complex, '$!im'),
        )
    );
    $new
}

multi sub infix:</>(Complex:D \a, Complex:D \b --> Complex:D) {
    my num $a_re = nqp::getattr_n(nqp::decont(a), Complex, '$!re');
    my num $a_im = nqp::getattr_n(nqp::decont(a), Complex, '$!im');
    my num $b_re = nqp::getattr_n(nqp::decont(b), Complex, '$!re');
    my num $b_im = nqp::getattr_n(nqp::decont(b), Complex, '$!im');
    my num $d    = nqp::add_n(nqp::mul_n($b_re, $b_re), nqp::mul_n($b_im, $b_im));
    my $new := nqp::create(Complex);
    nqp::bindattr_n($new, Complex, '$!re',
        nqp::div_n(
            nqp::add_n(nqp::mul_n($a_re, $b_re), nqp::mul_n($a_im, $b_im)),
            $d,
        )
    );
    nqp::bindattr_n($new, Complex, '$!im',
        nqp::div_n(
            nqp::sub_n(nqp::mul_n($a_im, $b_re), nqp::mul_n($a_re, $b_im)),
            $d,
        )
    );
    $new;
}

multi sub infix:</>(Complex:D \a, Real \b --> Complex:D) {
    Complex.new(a.re / b, a.im / b);
}

multi sub infix:</>(Real \a, Complex:D \b --> Complex:D) {
    Complex.new(a, 0e0) / b;
}

multi sub infix:<**>(Complex:D \a, Complex:D \b --> Complex:D) {
    (a.re == 0e0 && a.im == 0e0)
        ?? ( b.re == 0e0 && b.im == 0e0
                ?? Complex.new(1e0, 0e0)
                !! Complex.new(0e0, 0e0)
           )
        !! (b * a.log).exp
}
multi sub infix:<**>(Num(Real) \a, Complex:D \b --> Complex:D) {
    a == 0e0
        ?? ( b.re == 0e0 && b.im == 0e0
                ?? Complex.new(1e0, 0e0)
                !! Complex.new(0e0, 0e0)
           )
        !! (b * a.log).exp
}
multi sub infix:<**>(Complex:D \a, Num(Real) \b --> Complex:D) {
    b == 0e0 ?? Complex.new(1e0, 0e0) !! (b * a.log).exp
}

multi sub infix:<==>(Complex:D \a, Complex:D \b --> Bool:D) { a.re == b.re && a.im == b.im }
multi sub infix:<==>(Complex:D \a, Num(Real) \b --> Bool:D) { a.re == b    && a.im == 0e0  }
multi sub infix:<==>(Num(Real) \a, Complex:D \b --> Bool:D) { a    == b.re && 0e0  == b.im }
multi sub infix:<===>(Complex:D \a, Complex:D \b --> Bool:D) {
    a.WHAT =:= b.WHAT && a.re === b.re && a.im === b.im
}

multi sub infix:<>(Complex:D \a, Complex:D \b --> Bool:D) { a.re  b.re && a.im  b.im || a <=> b =:= Same }
multi sub infix:<>(Complex:D \a, Num(Real) \b --> Bool:D) { a  b.Complex }
multi sub infix:<>(Num(Real) \a, Complex:D \b --> Bool:D) { a.Complex  b }

# Meaningful only for sorting purposes, of course.
# We delegate to Real::cmp rather than <=> because parts might be NaN.
multi sub infix:<cmp>(Complex:D \a, Complex:D \b --> Order:D) { a.re cmp b.re || a.im cmp b.im }
multi sub infix:<cmp>(Num(Real) \a, Complex:D \b --> Order:D) { a cmp b.re || 0 cmp b.im }
multi sub infix:<cmp>(Complex:D \a, Num(Real) \b --> Order:D) { a.re cmp b || a.im cmp 0 }

multi sub infix:<=>(Complex:D \a, Complex:D \b --> Order:D) {
    my $tolerance = a && b
        ?? (a.re.abs + b.re.abs) / 2 * $*TOLERANCE  # Scale slop to average real parts.
        !! $*TOLERANCE;                             # Don't want tolerance 0 if either arg is 0.
    # Fail unless imaginary parts are relatively negligible, compared to real parts.
    infix:<>(a.im, 0e0, :$tolerance) && infix:<>(b.im, 0e0, :$tolerance)
      ?? a.re <=> b.re
      !! Failure.new(X::Numeric::Real.new(target => Real, reason => "Complex is not numerically orderable", source => "Complex"))
}
multi sub infix:<=>(Num(Real) \a, Complex:D \b --> Order:D) { a.Complex <=> b }
multi sub infix:<=>(Complex:D \a, Num(Real) \b --> Order:D) { a <=> b.Complex }

proto sub postfix:<i>(\a --> Complex:D) is pure { * }
multi sub postfix:<i>(Real      \a --> Complex:D) { Complex.new(0e0, a);     }
multi sub postfix:<i>(Complex:D \a --> Complex:D) { Complex.new(-a.im, a.re) }
multi sub postfix:<i>(Numeric   \a --> Complex:D) { a * Complex.new(0e0, 1e0) }
multi sub postfix:<i>(Cool      \a --> Complex:D) { a.Numeric * Complex.new(0e0, 1e0) }

constant i = Complex.new(0e0, 1e0);

#line 1 SETTING::src/core/Backtrace.pm
my class Exception { ... }

my class Backtrace { ... }
my class CompUnit::RepositoryRegistry is repr('Uninstantiable') { ... }

my $RAKUDO-VERBOSE-STACKFRAME;

my class Backtrace::Frame {
    has Str $.file;
    has Int $.line;
    has Mu  $.code;
    has Str $.subname;

    method !SET-SELF($!file,$!line,\code,$!subname) {
        $!code := code;
        self
    }
    multi method new(Backtrace::Frame: \file,\line,\code,\subname) {
        nqp::create(self)!SET-SELF(file,line,code,subname)
    }
    multi method new(Backtrace::Frame: |c) {
        self.bless(|c)
    }

    method subtype(Backtrace::Frame:D:) {
        my $s = $!code.^name.lc.split('+', 2).cache[0];
        $s eq 'mu' ?? '' !! $s;
    }

    method package(Backtrace::Frame:D:) {
        $.code.package;
    }

    multi method Str(Backtrace::Frame:D:) {
        my $s = self.subtype;
        $s ~= ' ' if $s.chars;
        my $text = "  in {$s}$.subname at {$.file} line $.line\n";

        if $RAKUDO-VERBOSE-STACKFRAME -> $extra {
            my $io = $!file.IO;
            if $io.e {
                my @lines = $io.lines;
                my $from = max $!line - $extra, 1;
                my $to   = min $!line + $extra, +@lines;
                for $from..$to -> $line {
                    my $star = $line == $!line ?? '*' !! ' ';
                    $text ~= "$line.fmt('%5d')$star @lines[$line - 1]\n";
                }
                $text ~= "\n";
            }
        }
        $text;
    }

    method is-hidden(Backtrace::Frame:D:) {
        ?$!code.?is-hidden-from-backtrace
    }
    method is-routine(Backtrace::Frame:D:) {
        nqp::p6bool(nqp::istype($!code,Routine))
    }
    method is-setting(Backtrace::Frame:D:) {
        $!file.starts-with("SETTING::")




          || $!file.ends-with("CORE.setting." ~ Rakudo::Internals.PRECOMP-EXT)

          || $!file.ends-with(".nqp")
    }
}

my class Backtrace {
    has Mu $!bt;
    has Mu $!frames;
    has Int $!bt-next;   # next bt index to vivify

    method !SET-SELF($!bt,$!bt-next) {
        once $RAKUDO-VERBOSE-STACKFRAME =
          +(%*ENV<RAKUDO_VERBOSE_STACKFRAME> // 0);
        $!frames := nqp::list;
        self
    }
    multi method new() {
        try X::AdHoc.new(:payload("Died")).throw;
        nqp::create(self)!SET-SELF(
          nqp::backtrace(nqp::getattr(nqp::decont($!),Exception,'$!ex')),
          1)
    }
    multi method new(Int:D $offset) {
        try X::AdHoc.new(:payload("Died")).throw;
        nqp::create(self)!SET-SELF(
          nqp::backtrace(nqp::getattr(nqp::decont($!),Exception,'$!ex')),
          1 + $offset)
    }
    multi method new(Mu \ex) {
        nqp::create(self)!SET-SELF(
          ex.^name eq 'BOOTException'
            ?? nqp::backtrace(nqp::decont(ex))
            !! nqp::backtrace(nqp::getattr(nqp::decont(ex),Exception,'$!ex')),
          0)
    }
    multi method new(Mu \ex, Int:D $offset) {
        nqp::create(self)!SET-SELF(
          ex.^name eq 'BOOTException'
            ?? nqp::backtrace(nqp::decont(ex))
            !! nqp::backtrace(nqp::getattr(nqp::decont(ex),Exception,'$!ex')),
          $offset)
    }
    # note that backtraces are nqp::list()s, marshalled to us as a List
    multi method new(List:D $bt) {
        nqp::create(self)!SET-SELF($bt,0)
    }
    multi method new(List:D $bt, Int:D $offset) {
        nqp::create(self)!SET-SELF($bt,$offset)
    }

    method AT-POS($pos) {
        return nqp::atpos($!frames,$pos) if nqp::existspos($!frames,$pos);

        my int $elems = $!bt.elems;
        return Nil if $!bt-next >= $elems; # bt-next can init > elems

        my int $todo = $pos - nqp::elems($!frames) + 1;
        return Nil if $todo < 1; # in case absurd $pos passed
        while $!bt-next < $elems {
            my $frame := $!bt.AT-POS($!bt-next++);
            my $sub := $frame<sub>;
            next unless defined $sub;

            my Mu $do := nqp::getattr(nqp::decont($sub), ForeignCode, '$!do');
            next if nqp::isnull($do);

            my $annotations := $frame<annotations>;
            next unless $annotations;

            my $file := $annotations<file>;
            next unless $file;

            if CompUnit::RepositoryRegistry.file-for-spec($file) -> $path {
                $file := $path.absolute;
            }

            next if $file.ends-with('BOOTSTRAP.nqp')
                 || $file.ends-with('QRegex.nqp')
                 || $file.ends-with('Perl6/Ops.nqp');
            if $file.ends-with('NQPHLL.nqp') || $file.ends-with('NQPHLL.moarvm') {
                # This could mean we're at the end of the interesting backtrace,
                # or it could mean that we're in something like sprintf (which
                # uses an NQP grammar to parse the format string).
                while $!bt-next < $elems {
                    my $frame := $!bt.AT-POS($!bt-next++);
                    my $annotations := $frame<annotations>;
                    next unless $annotations;
                    my $file := $annotations<file>;
                    next unless $file;
                    if $file.ends-with('.setting') {
                        $!bt-next--; # re-visit this frame
                        last;
                    }
                }
                next;
            }

            my $line := $annotations<line>;
            next unless $line;

            my $name := nqp::p6box_s(nqp::getcodename($do));
            if $name eq 'handle-begin-time-exceptions' {
                $!bt-next = $elems;
                last;
            }

            my $code;
            try {
                $code := nqp::getcodeobj($do);
                $code := Any unless nqp::istype($code, Mu);
            };

            nqp::push($!frames,
              Backtrace::Frame.new(
                $file,
                $line.Int,
                $code,
                $name.starts-with("_block") ?? '<anon>' !! $name,
              )
            );
            last unless $todo = $todo - 1;
        }

        # found something
        if nqp::existspos($!frames,$pos) {
            nqp::atpos($!frames,$pos);
        }

        # we've reached the end, don't show the last <unit-outer> if there is one
        else {
            nqp::pop($!frames) if $!frames;
            Nil;
        }
    }

    method next-interesting-index(Backtrace:D:
      Int $idx is copy = 0, :$named, :$noproto, :$setting) {
        ++$idx;

        while self.AT-POS($idx++) -> $cand {
            next if $cand.is-hidden;          # hidden is never interesting
            next if $noproto                  # no proto's please
              && $cand.code.?is_dispatcher;   #  if a dispatcher
            next if !$setting                 # no settings please
              && $cand.is-setting;            #  and in setting

            my $n := $cand.subname;
            next if $named && !$n;            # only want named ones and no name
            next if $n eq '<unit-outer>';     # outer calling context

            return $idx - 1;
        }
        Nil;
    }

    method outer-caller-idx(Backtrace:D: Int $startidx) {

        if self.AT-POS($startidx).code -> $start {
            my %outers;

            my $current = $start.outer;
            while $current.DEFINITE {
                %outers{$current.static_id} = $start;
                $current = $current.outer;
            }

            my @outers;
            my $i = $startidx;
            while self.AT-POS($i++) -> $cand {
                my $code = $cand.code;
                next unless $code.DEFINITE && %outers{$code.static_id}.DEFINITE;

                @outers.push: $i - 1;
                last if $cand.is-routine;
            }
            @outers;
        }

        else {
            $startidx.list;
        }
    }

    method nice(Backtrace:D: :$oneline) {
        my $setting = %*ENV<RAKUDO_BACKTRACE_SETTING>;
        try {
            my @frames;
            my Int $i = self.next-interesting-index(-1);
            while $i.defined {
                $i = self.next-interesting-index($i, :$setting) if $oneline;
                last unless $i.defined;

                my $prev = self.AT-POS($i);
                if $prev.is-routine {
                    @frames.push: $prev;
                } else {
                    my @outer_callers := self.outer-caller-idx($i);
                    my $target_idx = @outer_callers.keys.grep({self.AT-POS($i).code.^isa(Routine)})[0];
                    $target_idx    ||= @outer_callers[0] || $i;
                    my $current = self.AT-POS($target_idx);
                    @frames.append: $current.clone(line => $prev.line);
                    $i = $target_idx;
                }
                last if $oneline;
                $i = self.next-interesting-index($i, :$setting);
            }
            CATCH {
                default {
                    return "<Internal error while creating backtrace: $_.message() $_.backtrace.full().\n"
                        ~ "Please report this as a bug (mail to rakudobug@perl.org)\n",
                        ~ "and re-run with the --ll-exception command line option\n"
                        ~ "to get more information about your error>";
                }
            }
            @frames.join;
        }
    }

    multi method Str(Backtrace:D:)  { self.nice }
    multi method flat(Backtrace:D:) { self.list }
    multi method map(Backtrace:D: &block) {
        my $pos = 0;
        gather while self.AT-POS($pos++) -> $cand {
            take block($cand);
        }
    }
    multi method first(Backtrace:D: Mu $test) {
        my $pos = 0;
        while self.AT-POS($pos++) -> $cand {
            return-rw $cand if $cand ~~ $test;
        }
        Nil;
    }
    multi method list(Backtrace:D:) {
        self.AT-POS(100);  # will stop when done, do we need more than 100???
        nqp::p6bindattrinvres(nqp::create(List), List, '$!reified', $!frames)
    }

    method first-none-setting-line(Backtrace:D:) {
        (self.first({ !.is-hidden && !.is-setting }) // "\n").Str;
    }

    method concise(Backtrace:D:) {
        (self.grep({ !.is-hidden && .is-routine && !.is-setting }) // "\n").join;
    }

    method full(Backtrace:D:) { self.list.join }

    method summary(Backtrace:D:) {
        (self.grep({ !.is-hidden && (.is-routine || !.is-setting)}) // "\n").join;
    }

    method is-runtime (Backtrace:D:) {
        my $bt = $!bt;
        for $bt.keys {
            my $p6sub := $bt[$_]<sub>;
            if nqp::istype($p6sub, ForeignCode) {
                try {
                    my Mu $sub := nqp::getattr(nqp::decont($p6sub), ForeignCode, '$!do');
                    my str $name = nqp::getcodename($sub);
                    return True if nqp::iseq_s($name, 'THREAD-ENTRY');
                    return True if nqp::iseq_s($name, 'eval');
                    return True if nqp::iseq_s($name, 'print_control');
                    return False if nqp::iseq_s($name, 'compile');
                }
            }
        }
        False;
    }

}

#line 1 SETTING::src/core/StrDistance.pm
my class StrDistance is Cool {
    has Str $.before;
    has Str $.after;
    has Int $!distance;

    submethod BUILD(Str() :$!before, :$!after --> Nil) { }

    method Bool() {
        $.before ne $.after
    }

    method ACCEPTS(StrDistance:D: Mu \a) {
        self
    }

    method Numeric() {
        self.Int
    }

    method Str {
        $.after
    }

    multi method Int(StrDistance:D:) {
        $!distance //= do {
            my @s = *, |$.before.comb;
            my @t = *, |$.after.comb;
            my @d;
            @d[$_][ 0] = $_ for ^@s.end;
            @d[ 0][$_] = $_ for ^@t.end;

            my int $s_elems = @s.elems;
            my int $t_elems = @t.elems;
            loop (my int $i = 1; $i < $s_elems; $i = $i + 1) {
                loop (my int $j = 1; $j < $t_elems; $j = $j + 1) {
                    @d[$i][$j] = @s[$i] eq @t[$j]
                        ??   @d[$i-1][$j-1]    # No operation required when eq
                        !! ( @d[$i-1][$j  ],   # Deletion
                             @d[$i  ][$j-1],   # Insertion
                             @d[$i-1][$j-1],   # Substitution
                           ).min + 1;
                }
            }

            @d.tail.tail;
        }
    }
}

#line 1 SETTING::src/core/Exception.pm
my role X::Comp { ... }
my class X::ControlFlow { ... }

my class Exception {
    has $!ex;
    has $!bt;

    method backtrace(Exception:D:) {
        if $!bt { $!bt }
        elsif nqp::isconcrete($!ex) {
            $!bt := Backtrace.new($!ex);
        }
        else { '' }
    }

    # Only valid if .backtrace has not been called yet
    method vault-backtrace(Exception:D:) {
        nqp::isconcrete($!ex) && $!bt ?? Backtrace.new($!ex) !! ''
    }
    method reset-backtrace(Exception:D:) {
        $!ex := Nil
    }

    multi method Str(Exception:D:) {
        my $str;
        if nqp::isconcrete($!ex) {
            my str $message = nqp::getmessage($!ex);
            $str = nqp::isnull_s($message) ?? '' !! nqp::p6box_s($message);
        }
        $str ||= (try self.?message);
        $str = ~$str if defined $str;
        $str // "Something went wrong in {self.WHAT.gist}";
    }

    multi method gist(Exception:D:) {
        my $str;
        if nqp::isconcrete($!ex) {
            my str $message = nqp::getmessage($!ex);
            $str = nqp::isnull_s($message)
                ?? (try self.?message) // "Died with {self.^name}"
                !! nqp::p6box_s($message);
            $str ~= "\n";
            try $str ~= self.backtrace
              || Backtrace.new()
              || '  (no backtrace available)';
        }
        else {
            $str = (try self.?message) // "Unthrown {self.^name} with no message";
        }
        $str;
    }

    method throw(Exception:D: $bt?) {
        $!ex := nqp::newexception() unless nqp::isconcrete($!ex) and $bt;
        $!bt := $bt; # Even if !$bt
        nqp::setpayload($!ex, nqp::decont(self));
        nqp::throw($!ex)
    }
    method rethrow(Exception:D:) {
        unless nqp::isconcrete($!ex) {
            $!ex := nqp::newexception();
            try nqp::setmessage($!ex, self.message);
        }
        nqp::setpayload($!ex, nqp::decont(self));
        nqp::rethrow($!ex)
    }

    method resume(Exception:D: --> True) {
        nqp::resume($!ex);
    }

    method die(Exception:D:) { self.throw }
    method fail(Exception:D:) {
        try self.throw;
        my $fail := Failure.new($!);
        nqp::throwpayloadlexcaller(nqp::const::CONTROL_RETURN, $fail);
        CATCH { $fail.exception.throw }
    }

    method is-compile-time(--> False) { }
}

my class X::SecurityPolicy is Exception {}

my class X::SecurityPolicy::Eval is X::SecurityPolicy {
    has $.payload = "EVAL is a very dangerous function!!!";

    my role SlurpySentry { }

    method message() {
        do {
            # Remove spaces for die(*@msg)/fail(*@msg) forms
            given $.payload {
                when SlurpySentry {
                    $_.list.join;
                }
                default {
                    .Str;
                }
            }
        } ~ " (use the MONKEY-SEE-NO-EVAL pragma to override this error,\n"
          ~ "but only if you're VERY sure your data contains no injection attacks)";
    }
    method Numeric() { $.payload.Numeric }
    method from-slurpy (|cap) {
        self.new(:payload(cap does SlurpySentry))
    }
}

my class X::AdHoc is Exception {
    has $.payload = "Unexplained error";

    my role SlurpySentry { }

    method message() {
        # Remove spaces for die(*@msg)/fail(*@msg) forms
        given $.payload {
            when SlurpySentry {
                $_.list.join;
            }
            default {
                .Str;
            }
        }
    }
    method Numeric() { $.payload.Numeric }
    method from-slurpy (|cap) {
        self.new(:payload(cap does SlurpySentry))
    }
}

my class X::NQP::NotFound is Exception {
    has $.op;
    method message() {
        "Could not find nqp::$.op, did you forget 'use nqp;' ?"
    }
}
my class X::Dynamic::NotFound is Exception {
    has $.name;
    method message() {
        "Dynamic variable $.name not found";
    }
}
my class X::Method::NotFound is Exception {
    has Mu $.invocant;
    has $.method;
    has $.typename;
    has Bool $.private = False;
    method message() {
        my $message = $.private
          ?? "No such private method '!$.method' for invocant of type '$.typename'"
          !! "No such method '$.method' for invocant of type '$.typename'";

        my %suggestions;
        my int $max_length = do given $.method.chars {
            when 0..3 { 1 }
            when 4..8 { 2 }
            when 9..* { 3 }
        }

        if $.method eq 'length' {
            given $!invocant {
                when List { %suggestions{$_} = 0 for <elems> }
                when Cool { %suggestions{$_} = 0 for <chars codes>; }
                default   { %suggestions{$_} = 0 for <elems chars codes>; }
            }

        }
        elsif $.method eq 'bytes' {
            %suggestions<encode($encoding).bytes> = 0;
        }

        if nqp::can($!invocant.HOW, 'methods') {
            for $!invocant.^methods(:all)>>.name -> $method_name {
                my $dist = StrDistance.new(:before($.method), :after($method_name));
                if $dist <= $max_length {
                    %suggestions{$method_name} = $dist;
                }
            }
        }

        if nqp::can($!invocant.HOW, 'private_method_table') {
            for $!invocant.^private_method_table.keys -> $method_name {
                my $dist = StrDistance.new(:before($.method), :after($method_name));
                if $dist <= $max_length {
                    %suggestions{"!$method_name"} = $dist;
                }
            }
        }

        if +%suggestions == 1 {
            $message ~= ". Did you mean '%suggestions.keys()'?";
        }
        elsif +%suggestions > 1 {
            $message ~= ". Did you mean any of these?\n    { %suggestions.sort(*.value)>>.key.head(4).join("\n    ") }\n";
        }

        $message;
    }
}

my class X::Method::InvalidQualifier is Exception {
    has $.method;
    has $.invocant;
    has $.qualifier-type;
    method message() {
          "Cannot dispatch to method $.method on {$.qualifier-type.^name} "
        ~ "because it is not inherited or done by {$.invocant.^name}";
    }
}

my class X::Role::Parametric::NoSuchCandidate is Exception {
    has Mu $.role;
    method message {
        "No appropriate parametric role variant available for '"
        ~ $.role.^name
        ~ "'";
    }
}

my class X::Pragma::NoArgs is Exception {
    has $.name;
    method message { "The '$.name' pragma does not take any arguments." }
}
my class X::Pragma::CannotPrecomp is Exception {
    has $.what = 'This compilation unit';
    method message { "$.what may not be pre-compiled" }
}
my class X::Pragma::CannotWhat is Exception {
    has $.what;
    has $.name;
    method message { "'$.what $.name' is not an option." }
}
my class X::Pragma::MustOneOf is Exception {
    has $.name;
    has $.alternatives;
    method message { "'$.name' pragma expects one parameter out of $.alternatives." }
}
my class X::Pragma::UnknownArg is Exception {
    has $.name;
    has $.arg;
    method message { "Unknown argument '{$.arg.perl}' specified with the '$.name' pragma." }
}
my class X::Pragma::OnlyOne is Exception {
    has $.name;
    method message { "The '$.name' pragma only takes one argument." }
}

my role X::Control is Exception {
}
my class CX::Next does X::Control {
    method message() { "<next control exception>" }
}
my class CX::Redo does X::Control {
    method message() { "<redo control exception>" }
}
my class CX::Last does X::Control {
    method message() { "<last control exception>" }
}
my class CX::Take does X::Control {
    method message() { "<take control exception>" }
}
my class CX::Warn does X::Control {
    has $.message;
}
my class CX::Succeed does X::Control {
    method message() { "<succeed control exception>" }
}
my class CX::Proceed does X::Control {
    method message() { "<proceed control exception>" }
}
my class CX::Return does X::Control {
    method message() { "<return control exception>" }
}
my class CX::Emit does X::Control {
    method message() { "<emit control exception>" }
}
my class CX::Done does X::Control {
    method message() { "<done control exception>" }
}

sub EXCEPTION(|) {
    my Mu $vm_ex   := nqp::shift(nqp::p6argvmarray());
    my Mu $payload := nqp::getpayload($vm_ex);
    if nqp::p6bool(nqp::istype($payload, Exception)) {
        nqp::bindattr($payload, Exception, '$!ex', $vm_ex);
        $payload;
    } else {
        my int $type = nqp::getextype($vm_ex);
        my $ex;
        if $type +& nqp::const::CONTROL_NEXT {
            $ex := CX::Next.new();
        }
        elsif $type +& nqp::const::CONTROL_REDO {
            $ex := CX::Redo.new();
        }
        elsif $type +& nqp::const::CONTROL_LAST {
            $ex := CX::Last.new();
        }
        elsif $type == nqp::const::CONTROL_TAKE {
            $ex := CX::Take.new();
        }
        elsif $type == nqp::const::CONTROL_WARN {
            my str $message = nqp::getmessage($vm_ex);
            $message = 'Warning' if nqp::isnull_s($message) || $message eq '';
            $ex := CX::Warn.new(:$message);
        }
        elsif $type == nqp::const::CONTROL_SUCCEED {
            $ex := CX::Succeed.new();
        }
        elsif $type == nqp::const::CONTROL_PROCEED {
            $ex := CX::Proceed.new();
        }
        elsif $type == nqp::const::CONTROL_RETURN {
            $ex := CX::Return.new();
        }
        elsif $type == nqp::const::CONTROL_EMIT {
            $ex := CX::Emit.new();
        }
        elsif $type == nqp::const::CONTROL_DONE {
            $ex := CX::Done.new();
        }










        else {
            $ex := nqp::create(X::AdHoc);
            nqp::bindattr($ex, X::AdHoc, '$!payload', nqp::p6box_s(nqp::getmessage($vm_ex) // 'unknown exception'));
        }
        nqp::bindattr($ex, Exception, '$!ex', $vm_ex);
        $ex;
    }
}

my class X::Comp::AdHoc { ... }
sub COMP_EXCEPTION(|) {
    my Mu $vm_ex   := nqp::shift(nqp::p6argvmarray());
    my Mu $payload := nqp::getpayload($vm_ex);
    if nqp::p6bool(nqp::istype($payload, Exception)) {
        nqp::bindattr($payload, Exception, '$!ex', $vm_ex);
        $payload;
    } else {
        my $ex := nqp::create(X::Comp::AdHoc);
        nqp::bindattr($ex, Exception, '$!ex', $vm_ex);
        nqp::bindattr($ex, X::AdHoc, '$!payload', nqp::p6box_s(nqp::getmessage($vm_ex)));
        $ex;
    }
}


do {

    sub print_exception(|) {
        my Mu $ex := nqp::atpos(nqp::p6argvmarray(), 0);
        my $e := EXCEPTION($ex);

        if %*ENV<RAKUDO_EXCEPTIONS_HANDLER> -> $handler {
            my $class := ::("Exceptions::$handler");
            unless nqp::istype($class,Failure) {
                temp %*ENV<RAKUDO_EXCEPTIONS_HANDLER> = ""; # prevent looping
                return unless $class.process($e)
            }
        }

        try {
            my $v := $e.vault-backtrace;
            my Mu $err := $*ERR;

            $e.backtrace;  # This is where most backtraces actually happen
            if $e.is-compile-time || $e.backtrace && $e.backtrace.is-runtime {
                $err.say($e.gist);
                if $v and !$e.gist.ends-with($v.Str) {
                   $err.say("Actually thrown at:");
                   $err.say($v.Str);
                }
            }
            elsif Rakudo::Internals.VERBATIM-EXCEPTION(0) {
                $err.print($e.Str);
            }
            else {
                $err.say("===SORRY!===");
                $err.say($e.Str);
            }
            nqp::getcurhllsym('&THE_END')();
            CONTROL { when CX::Warn { .resume } }
        }
        if $! {
            nqp::rethrow(nqp::getattr(nqp::decont($!), Exception, '$!ex'));
            $ex
        }
    }

    sub print_control(|) {
        nqp::stmts(
          (my Mu $ex := nqp::atpos(nqp::p6argvmarray(),0)),
          (my int $type = nqp::getextype($ex)),
          (my $backtrace = Backtrace.new(nqp::backtrace($ex))),
          nqp::if(
            nqp::iseq_i($type,nqp::const::CONTROL_WARN),
            nqp::stmts(
              (my Mu $err := $*ERR),
              (my str $msg = nqp::getmessage($ex)),
              $err.say(nqp::if(nqp::chars($msg),$msg,"Warning")),
              $err.print($backtrace.first-none-setting-line),
              nqp::resume($ex)
            )
          )
        );

        my $label = $type +& nqp::const::CONTROL_LABELED ?? "labeled " !! "";
        if $type +& nqp::const::CONTROL_LAST {
            X::ControlFlow.new(illegal => "{$label}last", enclosing => 'loop construct', :$backtrace).throw;
        }
        elsif $type +& nqp::const::CONTROL_NEXT {
            X::ControlFlow.new(illegal => "{$label}next", enclosing => 'loop construct', :$backtrace).throw;
        }
        elsif $type +& nqp::const::CONTROL_REDO {
            X::ControlFlow.new(illegal => "{$label}redo", enclosing => 'loop construct', :$backtrace).throw;
        }
        elsif $type +& nqp::const::CONTROL_PROCEED {
            X::ControlFlow.new(illegal => 'proceed', enclosing => 'when clause', :$backtrace).throw;
        }
        elsif $type +& nqp::const::CONTROL_SUCCEED {
            # XXX: should work like leave() ?
            X::ControlFlow.new(illegal => 'succeed', enclosing => 'when clause', :$backtrace).throw;
        }
        elsif $type +& nqp::const::CONTROL_TAKE {
            X::ControlFlow.new(illegal => 'take', enclosing => 'gather', :$backtrace).throw;
        }
        elsif $type +& nqp::const::CONTROL_EMIT {
            X::ControlFlow.new(illegal => 'emit', enclosing => 'supply or react', :$backtrace).throw;
        }
        elsif $type +& nqp::const::CONTROL_DONE {
            X::ControlFlow.new(illegal => 'done', enclosing => 'supply or react', :$backtrace).throw;
        }
        else {
            X::ControlFlow.new(illegal => 'control exception', enclosing => 'handler', :$backtrace).throw;
        }
    }

    my Mu $comp := nqp::getcomp('perl6');
    $comp.^add_method('handle-exception',
        method (|) {
            my Mu $ex := nqp::atpos(nqp::p6argvmarray(), 1);
            print_exception($ex);
            nqp::exit(1);
            0;
        }
    );
    $comp.^add_method('handle-control',
        method (|) {
            my Mu $ex := nqp::atpos(nqp::p6argvmarray(), 1);
            print_control($ex);
            nqp::rethrow($ex);
        }
    );

}

my role X::OS is Exception {
    has $.os-error;
    method message() { $.os-error }
}

my role X::IO does X::OS { };

my class X::IO::Unknown does X::IO {
    has $.trying;
    method message { "Unknown IO error trying '$.trying'" }
}
my class X::IO::Rename does X::IO {
    has $.from;
    has $.to;
    method message() {
        "Failed to rename '$.from' to '$.to': $.os-error"
    }
}

my class X::IO::Copy does X::IO {
    has $.from;
    has $.to;
    method message() {
        "Failed to copy '$.from' to '$.to': $.os-error"
    }
}

my class X::IO::Lock does X::IO {
    has $.lock-type;
    method message() { "Could not obtain $.lock-type lock: $.os-error" }
}

my class X::IO::Move does X::IO {
    has $.from;
    has $.to;
    method message() {
        "Failed to move '$.from' to '$.to': $.os-error"
    }
}

my class X::IO::DoesNotExist does X::IO {
    has $.path;
    has $.trying;
    method message() {
        "Failed to find '$.path' while trying to do '.$.trying'"
    }
}

my class X::IO::NotAFile does X::IO {
    has $.path;
    has $.trying;
    method message() {
        "'$.path' is not a regular file while trying to do '.$.trying'"
    }
}

my class X::IO::Null does X::IO {
    method message() {
        "Cannot use null character (U+0000) as part of the path"
    }
}

my class X::IO::Directory does X::IO {
    has $.path;
    has $.trying;
    has $.use;
    method message () {
        my $x = "'$.path' is a directory, cannot do '.$.trying' on a directory";
        if $.use { $x ~= ", try '{$.use}()' instead" }
        $x;
    }
}

my class X::IO::Symlink does X::IO {
    has $.target;
    has $.name;
    method message() {
        "Failed to create symlink called '$.name' on target '$.target': $.os-error"
    }
}

my class X::IO::Link does X::IO {
    has $.target;
    has $.name;
    method message() {
        "Failed to create link called '$.name' on target '$.target': $.os-error"
    }
}

my class X::IO::Mkdir does X::IO {
    has $.path;
    has $.mode;
    method message() {
        "Failed to create directory '$.path' with mode '0o{$.mode.fmt("%03o")}': $.os-error"
    }
}

my class X::IO::Chdir does X::IO {
    has $.path;
    method message() {
        "Failed to change the working directory to '$.path': $.os-error"
    }
}

my class X::IO::Dir does X::IO {
    has $.path;
    method message() {
        "Failed to get the directory contents of '$.path': $.os-error"
    }
}

my class X::IO::Cwd does X::IO {
    method message() {
        "Failed to get the working directory: $.os-error"
    }
}

my class X::IO::Flush does X::IO {
    method message() {
        "Cannot flush handle: $.os-error"
    }
}

my class X::IO::NotAChild does X::IO {
    has $.path;
    has $.child;
    method message() {
      "Path {$.child.perl} is not a child of path {$.path.perl}"
    }
}

my class X::IO::Resolve does X::IO {
    has $.path;
    method message() { "Failed to completely resolve {$.path.perl}" }
}

my class X::IO::Rmdir does X::IO {
    has $.path;
    method message() {
        "Failed to remove the directory '$.path': $.os-error"
    }
}

my class X::IO::Unlink does X::IO {
    has $.path;
    method message() {
        "Failed to remove the file '$.path': $.os-error"
    }
}

my class X::IO::Chmod does X::IO {
    has $.path;
    has $.mode;
    method message() {
        "Failed to set the mode of '$.path' to '0o{$.mode.fmt("%03o")}': $.os-error"
    }
}

my class X::IO::BinaryAndEncoding does X::IO {
    method message { "Cannot open a handle in binary mode (:bin) and also specify an encoding" }
}

my class X::IO::BinaryMode does X::IO {
    has $.trying;
    method message { "Cannot do '$.trying' on a handle in binary mode" }
}

my role X::Comp is Exception {
    has $.filename;
    has $.pos;
    has $.line;
    has $.column;
    has @.modules;
    has $.is-compile-time = False;
    has $.pre;
    has $.post;
    has @.highexpect;
    multi method gist(::?CLASS:D: :$sorry = True, :$expect = True) {
        if $.is-compile-time {
            my ($red,$clear,$green,$yellow,$eject) =
              Rakudo::Internals.error-rcgye;
            my $r = $sorry ?? self.sorry_heading() !! "";
            $r ~= $.filename eq '<unknown file>'
              ?? $.line == 1
                ?? $.message
                !! "$.message\nat line $.line"
              !! "$.message\nat $.filename():$.line";
            $r ~= "\n------> $green$.pre$yellow$eject$red$.post$clear" if defined $.pre;
            if $expect && @.highexpect {
                $r ~= "\n    expecting any of:";
                for flat @.highexpect.list {
                    $r ~= "\n        $_";
                }
            }
            for @.modules.reverse[1..*] {
                my $line = nqp::p6box_i($_<line>);
                $r ~= $_<module>.defined
                        ?? "\n  from module $_<module> ($_<filename> line $line)"
                        !! "\n  from $_<filename> line $line";
            }
            $r;
        }
        else {
            self.Exception::gist;
        }
    }
    method sorry_heading() {
        my ($red, $clear) = Rakudo::Internals.error-rcgye;
        "$red==={$clear}SORRY!$red===$clear Error while compiling{
          $.filename eq '<unknown file>'
            ?? ':'
            !! " $.filename"
        }\n"
    }
    method SET_FILE_LINE($file, $line) {
        $!filename = $file;
        $!line     = $line;
        $!is-compile-time = True;
    }
}

my class X::Comp::Group is Exception {
    has $.panic;
    has @.sorrows;
    has @.worries;

    method is-compile-time(--> True) { }

    multi method gist(::?CLASS:D:) {
        my $r = "";
        if $.panic || @.sorrows {
            my ($red, $clear) = Rakudo::Internals.error-rcgye;
            $r ~= "$red==={$clear}SORRY!$red===$clear\n";
            for @.sorrows {
                $r ~= .gist(:!sorry, :!expect) ~ "\n";
            }
            if $.panic {
                $r ~= $.panic.gist(:!sorry) ~ "\n";
            }
        }
        if @.worries {
            $r ~= $.panic || @.sorrows
                ?? "Other potential difficulties:\n"
                !! "Potential difficulties:\n";
            for @.worries {
                $r ~= .gist(:!sorry, :!expect).indent(4) ~ "\n";
            }
        }
        $r
    }

    method message() {
        my @m;
        for @.sorrows {
            @m.append(.message);
        }
        if $.panic {
            @m.append($.panic.message);
        }
        for @.worries {
            @m.append(.message);
        }
        @m.join("\n")
    }
}

my role X::MOP is Exception { }

my class X::Comp::BeginTime does X::Comp {
    has str $.use-case;
    has $.exception;

    method message() {
        $!exception ~~ X::MOP
            ?? $!exception.message
            !! "An exception occurred while $!use-case"
    }

    multi method gist(::?CLASS:D: :$sorry = True) {
        my $r = $sorry ?? self.sorry_heading() !! "";
        $r ~= "$.message\nat $.filename():$.line";
        for @.modules.reverse[1..*] {
            my $line = nqp::p6box_i($_<line>);
            $r ~= $_<module>.defined
                    ?? "\n  from module $_<module> ($_<filename> line $line)"
                    !! "\n  from $_<filename> line $line";
        }
        unless $!exception ~~ X::MOP {
            $r ~= "\nException details:\n" ~ $!exception.gist.indent(2);
        }
        $r;
    }
}

# XXX a hack for getting line numbers from exceptions from the metamodel
my class X::Comp::AdHoc is X::AdHoc does X::Comp {
    method is-compile-time(--> True) { }
}

my class X::Comp::FailGoal does X::Comp {
    has $.dba;
    has $.goal;
    has $.line-real;

    method is-compile-time(--> True) { }

    method message { "Unable to parse expression in $.dba; couldn't find final $.goal"
                     ~ " (corresponding starter was at line $.line-real)" }
}

my role X::Syntax does X::Comp { }
my role X::Pod                 { }

my class X::NYI is Exception {
    has $.feature;
    has $.did-you-mean;
    method message() {
        my $msg = "$.feature not yet implemented. Sorry.";
        $msg ~= "\nDid you mean: {$.did-you-mean.gist}?" if $.did-you-mean;
        $msg
    }
}
my class X::Comp::NYI is X::NYI does X::Comp { };
my class X::NYI::Available is X::NYI {
    has @.available = die("Must give :available<modules> for installation. ");
    method available-str {
        my @a = @.available;
        my $a = @a.pop;
        @a ?? (@a.join(', ') || (), $a).join(" or ") !! $a;
    }
    method message() {
        "Please install { self.available-str } for $.feature support. "
    }
}
my class X::NYI::BigInt is Exception {
    has $.op;
    has $.big;
    has $.side = 'right';
    method message() {
        "Big integer $!big not yet supported on {$!side}hand side of '$!op' operator"
    }
}
my class X::Experimental does X::Comp {
    has $.feature;
    has $.use = $!feature;
    method message() { "Use of $.feature is experimental; please 'use experimental :$.use'" }
}

my class X::Worry is Exception { }
my class X::Worry::P5 is X::Worry { }
my class X::Worry::P5::Reference is X::Worry::P5 {
    method message {
q/To pass an array, hash or sub to a function in Perl 6, just pass it as is.
For other uses of Perl 5's ref operator consider binding with ::= instead.
Parenthesize as \\(...) if you intended a capture of a single variable./
    }
}
my class X::Worry::P5::BackReference is X::Worry::P5 {
    method message {
q/To refer to a positional match capture, just use $0 (numbering starts at 0).
Parenthesize as \\(...) if you intended a capture of a single numeric value./
    }
}
my class X::Worry::P5::LeadingZero is X::Worry::P5 {
    has $.value;
    method message {
        'Leading 0 has no meaning. If you meant to create an octal number'
        ~ ", use '0o' prefix" ~ (




            $!value.comb.grep(*.unival > 7)

                ?? ", but note that $!value is not a valid octal number"
                !! "; like, '0o$!value'"
        ) ~ '. If you meant to create a string, please add quotation marks.'
    }
}
my class X::Worry::Precedence::Range is X::Worry {
    has $.action;
    method message {
"To $!action a range, parenthesize the whole range.
(Or parenthesize the whole endpoint expression, if you meant that.)"
    }
}

my class X::Trait::Invalid is Exception {
    has $.type;       # is, will, of etc.
    has $.subtype;    # wrong subtype being tried
    has $.declaring;  # variable, sub, parameter, etc.
    has $.name;       # '$foo', '@bar', etc.
    method message () {
        "Cannot use '$.type $.subtype' on $.declaring '$.name'."
    }
}

my class X::Trait::Unknown is Exception {
    has $.type;       # is, will, of etc.
    has $.subtype;    # wrong subtype being tried
    has $.declaring;  # variable, sub, parameter, etc.
    method message () {
        "Can't use unknown trait '$.type $.subtype' in a$.declaring declaration."
    }
}
my class X::Comp::Trait::Unknown is X::Trait::Unknown does X::Comp { };

my class X::Trait::NotOnNative is Exception {
    has $.type;       # is, will, of etc.
    has $.subtype;    # wrong subtype being tried
    has $.native;     # type of native (optional)
    method message () {
        "Can't use trait '$.type $.subtype' on a native"
          ~ ( $.native ?? " $.native." !! "." );
    }
}
my class X::Comp::Trait::NotOnNative is X::Trait::NotOnNative does X::Comp { };

my class X::Trait::Scope is Exception {
    has $.type;       # is, will, of etc.
    has $.subtype;    # export
    has $.declaring;  # type name of the object
    has $.scope;      # not supported (but used) scope
    has $.supported;  # hint about what is allowed instead
    method message () {
        "Can't apply trait '$.type $.subtype' on a $.scope scoped $.declaring."
        ~ ( $.supported ?? " Only {$.supported.join(' and ')} scoped {$.declaring}s are supported." !! '' );
    }
}
my class X::Comp::Trait::Scope is X::Trait::Scope does X::Comp { };

my class X::OutOfRange is Exception {
    has $.what = 'Argument';
    has $.got = '<unknown>';
    has $.range = '<unknown>';
    has $.comment;
    method message() {
        my $result = $.comment.defined
           ?? "$.what out of range. Is: $.got, should be in $.range.gist(); $.comment"
           !! "$.what out of range. Is: $.got, should be in $.range.gist()";
        $result;
    }
}

my class X::Buf::AsStr is Exception {
    has $.method;
    method message() {
        "Cannot use a Buf as a string, but you called the $.method method on it";
    }
}
my class X::Buf::Pack is Exception {
    has $.directive;
    method message() {
        "Unrecognized directive '$.directive'";
    }
}

my class X::Buf::Pack::NonASCII is Exception {
    has $.char;
    method message() {
        "non-ASCII character '$.char' while processing an 'A' template in pack";
    }
}

my class X::Signature::Placeholder does X::Comp {
    has $.placeholder;
    method message() {
        "Placeholder variable '$.placeholder' cannot override existing signature";
    }
}

my class X::Placeholder::Block does X::Comp {
    has $.placeholder;
    method message() {
        "Placeholder variable $.placeholder may not be used here because the surrounding block takes no signature";
    }
}

my class X::Placeholder::NonPlaceholder does X::Comp {
    has $.variable_name;
    has $.placeholder;
    has $.decl;
    method message() {
        my $decl = $!decl ?? ' ' ~ $!decl !! '';
        "$!variable_name has already been used as a non-placeholder in the surrounding$decl block,\n" ~
        "  so you will confuse the reader if you suddenly declare $!placeholder here"
    }
}

my class X::Placeholder::Mainline is X::Placeholder::Block {
    method message() {
        "Cannot use placeholder parameter $.placeholder outside of a sub or block"
    }
}

my class X::Placeholder::Attribute is X::Placeholder::Block {
    method message() {
        "Cannot use placeholder parameter $.placeholder in an attribute initializer"
    }
}

my class X::Undeclared does X::Comp {
    has $.what = 'Variable';
    has $.symbol;
    has @.suggestions;
    method message() {
        my $message := "$.what '$.symbol' is not declared";
        if +@.suggestions == 1 {
            $message := "$message. Did you mean '@.suggestions[0]'?";
        } elsif +@.suggestions > 1 {
            $message := "$message. Did you mean any of these?\n    { @.suggestions.join("\n    ") }\n";
        }
        $message;
    }
}

my class X::Attribute::Undeclared is X::Undeclared {
    has $.package-kind;
    has $.package-name;

    method message() {
        "Attribute $.symbol not declared in $.package-kind $.package-name";
    }
}

my class X::Attribute::Regex is X::Undeclared {
    method message() {
        "Attribute $.symbol not available inside of a regex, since regexes are methods on Cursor.\n" ~
            "Consider storing the attribute in a lexical, and using that in the regex.";
    }
}

my class X::Undeclared::Symbols does X::Comp {
    has %.post_types;
    has %.unk_types;
    has %.unk_routines;
    has %.routine_suggestion;
    has %.type_suggestion;
    multi method gist(X::Undeclared::Symbols:D: :$sorry = True) {
        ($sorry ?? self.sorry_heading() !! "") ~ self.message
    }
    method message(X::Undeclared::Symbols:D:) {
        sub l(@l) {
            my @lu = @l.map({ nqp::hllize($_) }).unique.sort;
            'used at line' ~ (@lu == 1 ?? ' ' !! 's ') ~ @lu.join(', ')
        }
        sub s(@s) {
            "Did you mean '{ @s.join("', '") }'?";
        }
        my $r = "";
        if %.post_types {
            $r ~= "Illegally post-declared type" ~ (%.post_types.elems == 1 ?? "" !! "s") ~ ":\n";
            for %.post_types.sort(*.key) {
                $r ~= "    $_.key() &l($_.value)\n";
            }
        }
        if %.unk_types {
            $r ~= "Undeclared name" ~ (%.unk_types.elems == 1 ?? "" !! "s") ~ ":\n";
            for %.unk_types.sort(*.key) {
                $r ~= "    $_.key() &l($_.value)";
                if +%.type_suggestion{$_.key()} {
                    $r ~= ". " ~ s(%.type_suggestion{$_.key()});
                }
                $r ~= "\n";
            }
        }
        if %.unk_routines {
            my $obs = {
                y => "tr",
                qr => "rx",
                local => "temp (or dynamic var)",
                new => "method call syntax",
                foreach => "for",
            }
            $r ~= "Undeclared routine" ~ (%.unk_routines.elems == 1 ?? "" !! "s") ~ ":\n";
            for %.unk_routines.sort(*.key) {
                $r ~= "    $_.key() &l($_.value)";
                $r ~= " (in Perl 6 please use " ~ $obs{$_.key()} ~ " instead)" if $obs{$_.key()};
                if +%.routine_suggestion{$_.key()}.list {
                    $r ~= ". " ~ s(%.routine_suggestion{$_.key()}.list);
                }
                $r ~= "\n";
            }
        }
        $r
    }
}

my class X::Redeclaration does X::Comp {
    has $.symbol;
    has $.postfix = '';
    has $.what    = 'symbol';
    method message() {
        "Redeclaration of $.what '$.symbol'"
          ~ (" $.postfix" if $.postfix)
          ~ (" (did you mean to declare a multi-sub?)" if $.what eq 'routine');
    }
}

my class X::Redeclaration::Outer does X::Comp {
    has $.symbol;
    method message() {
        "Lexical symbol '$.symbol' is already bound to an outer symbol;\n" ~
        "the implicit outer binding must be rewritten as OUTER::<$.symbol>\n" ~
        "before you can unambiguously declare a new '$.symbol' in this scope";
    }
}

my class X::Dynamic::Postdeclaration does X::Comp {
    has $.symbol;
    method message() {
        "Illegal post-declaration of dynamic variable '$.symbol';\n" ~
        "earlier access must be written as CALLERS::<$.symbol>\n" ~
        "if that's what you meant"
    }
}

my class X::Dynamic::Package does X::Comp {
    has $.symbol;
    method message() {
        "Dynamic variables cannot have package-like names, like $!symbol"
    }
}

my class X::Import::Redeclaration does X::Comp {
    has @.symbols;
    has $.source-package-name;
    method message() {
        @.symbols == 1
            ?? "Cannot import symbol @.symbols[0] from $.source-package-name, because it already exists in this lexical scope"
            !! ("Cannot import the following symbols from $.source-package-name, because they already exist in this lexical scope: ", @.symbols.join(', '));
    }
}

my class X::Import::OnlystarProto does X::Comp {
    has @.symbols;
    has $.source-package-name;
    method message() {
        @.symbols == 1
            ?? "Cannot import symbol @.symbols[0] from $.source-package-name, only onlystar-protos can be merged"
            !! ("Cannot import the following symbols from $.source-package-name, only onlystar-protos can be merged: ", @.symbols.join(', '));
    }
}

my class X::PoisonedAlias does X::Comp {
    has $.alias;
    has $.package-type = 'package';
    has $.package-name;
    method message() {
        "Cannot use poisoned alias $!alias, because it was declared by several {$!package-type}s." ~
        ($!package-name ?? "\nPlease access it via explicit package name like: {$!package-name}::{$!alias}" !! '')
    }
}

my class X::Phaser::Multiple does X::Comp {
    has $.block;
    method message() { "Only one $.block block is allowed" }
}

my class X::Obsolete does X::Comp {
    has $.old;
    has $.replacement; # can't call it $.new, collides with constructor
    has $.when = 'in Perl 6';
    method message() { "Unsupported use of $.old; $.when please use $.replacement" }
}

my class X::Parameter::Default does X::Comp {
    has $.how;
    has $.parameter;
    method message() {
        $.parameter
            ?? "Cannot put default on $.how parameter $.parameter"
            !! "Cannot put default on anonymous $.how parameter";
    }
}

my class X::Parameter::Default::TypeCheck does X::Comp {
    has $.got is default(Nil);
    has $.expected is default(Nil);
    method message() {
        "Default value '$.got.gist()' will never bind to a parameter of type $.expected.^name()"
    }
}

my class X::Parameter::AfterDefault does X::Syntax {
    has $.type;
    has $.modifier;
    has $.default;
    method message() {
        "The $.type \"$.modifier\" came after the default value\n"
        ~ "(did you mean \"...$.modifier $.default\"?)"
    }
}

my class X::Parameter::Placeholder does X::Comp {
    has $.parameter;
    has $.right;
    method message() {
        "In signature parameter, placeholder variables like $.parameter are illegal\n"
        ~ "you probably meant a named parameter: '$.right'";
    }
}

my class X::Parameter::Twigil does X::Comp {
    has $.parameter;
    has $.twigil;
    method message() {
        "In signature parameter $.parameter, it is illegal to use the $.twigil twigil";
    }
}

my class X::Parameter::MultipleTypeConstraints does X::Comp {
    has $.parameter;
    method message() {
        ($.parameter ?? "Parameter $.parameter" !! 'A parameter')
        ~ " may only have one prefix type constraint";
    }
}

my class X::Parameter::BadType does X::Comp {
    has Mu $.type;
    method message() {
        my $what = ~$!type.HOW.WHAT.^name.match(/ .* '::' <(.*)> HOW/) // 'Namespace';
        "$what $!type.^name() is insufficiently type-like to qualify a parameter"
    }
}

my class X::Parameter::WrongOrder does X::Comp {
    has $.misplaced;
    has $.parameter;
    has $.after;
    method message() {
        "Cannot put $.misplaced parameter $.parameter after $.after parameters";
    }
}

my class X::Parameter::InvalidConcreteness is Exception {
    has $.expected;
    has $.got;
    has $.routine;
    has $.param;
    has Bool $.should-be-concrete;
    has Bool $.param-is-invocant;

    method message() {
        $!routine = '<anon>' if not $!routine.defined or $!routine eq '';
        $!param   = '<anon>' if not $!param.defined   or $!param   eq '';
        my $beginning  = $!param-is-invocant  ?? 'Invocant of method' !! "Parameter '$!param' of routine";
        my $must-be    = $!should-be-concrete ?? 'an object instance' !! 'a type object';
        my $not-a      = $!should-be-concrete ?? 'a type object'      !! 'an object instance';
        my $suggestion = $!should-be-concrete ?? '.new'               !! 'multi';

        "$beginning '$!routine' must be $must-be of type '$!expected', not $not-a of type '$!got'.  Did you forget a '$suggestion'?"
    }
}

my class X::Parameter::InvalidType does X::Comp {
    has $.typename;
    has @.suggestions;
    method message() {
        my $msg := "Invalid typename '$.typename' in parameter declaration.";
        if +@.suggestions > 0 {
            $msg := $msg ~ " Did you mean '" ~ @.suggestions.join("', '") ~ "'?";
        }
        $msg;
    }
}

my class X::Parameter::RW is Exception {
    has $.got;
    has $.symbol;
    method message() {
        "Parameter '$.symbol' expected a writable container, but got $.got.^name() value"
    }
}

my class X::Parameter::TypedSlurpy does X::Comp {
    has $.kind;
    method message() {
        "Slurpy $.kind parameters with type constraints are not supported"
    }
}

my class X::Signature::NameClash does X::Comp {
    has $.name;
    method message() {
        "Name $.name used for more than one named parameter";
    }
}

my class X::Method::Private::Permission does X::Comp {
    has $.method;
    has $.source-package;
    has $.calling-package;
    method message() {
        "Cannot call private method '$.method' on package $.source-package because it does not trust $.calling-package";
    }
}

my class X::Method::Private::Unqualified does X::Comp {
    has $.method;
    method message() {
        "Private method call to $.method must be fully qualified with the package containing the method";
    }
}

my class X::Adverb is Exception {
    has $.what;
    has $.source;
    has @.unexpected;
    has @.nogo;
    method message {
        my $text = '';
        if @!unexpected.elems -> $elems {
            $text = $elems > 1
              ?? "$elems unexpected adverbs (@.unexpected[])"
              !! "Unexpected adverb '@!unexpected[0]'"
        }
        if @!nogo {
            $text ~= $text ?? " and u" !! "U";
            $text ~= "nsupported combination of adverbs (@.nogo[])";
        }
        $text ~ " passed to $!what on $!source";
    }
    method unexpected { @!unexpected.sort }
    method nogo       { @!nogo.sort }
}

my class X::Bind is Exception {
    has $.target;
    method message() {
        $.target.defined
            ?? "Cannot bind to $.target"
            !! 'Cannot use bind operator with this left-hand side'
    }
}
my class X::Bind::NativeType does X::Comp {
    has $.name;
    method message() {
        "Cannot bind to natively typed variable '$.name'; use assignment instead"
    }
}
my class X::Bind::Slice is Exception  {
    has $.type;
    method message() {
        "Cannot bind to {$.type.^name} slice";
    }
}
my class X::Bind::ZenSlice is X::Bind::Slice {
    method message() {
        "Cannot bind to {$.type.^name} zen slice";
    }
}

my class X::Subscript::Negative is Exception {
    has $.index;
    has $.type;
    method message() {
        "Calculated index ({$.index}) is negative, but {$.type.^name} allows only 0-based indexing";
    }
}

my class X::Invalid::Value is Exception {
    has $.method;
    has $.name;
    has $.value;
    method message {
        "Invalid value '$.value' for :$.name on method $.method"
    }
}

my class X::Invalid::ComputedValue is Exception {
    has $.method;
    has $.name;
    has $.value;
    has $.reason;
    method message {
        "$.name {"on $.method " if $.method}computed to $.value,"
            ~ " which cannot be used"
            ~ (" because $.reason" if $.reason);
    }
}

my class X::Value::Dynamic does X::Comp {
    has $.what;
    method message() { "$.what value must be known at compile time" }
}

my class X::Syntax::Name::Null does X::Syntax {
    method message() { 'Name component may not be null'; }
}

my class X::Syntax::UnlessElse does X::Syntax {
    has $.keyword;
    method message() { qq|"unless" does not take "$!keyword", please rewrite using "if"| }
}

my class X::Syntax::WithoutElse does X::Syntax {
    has $.keyword;
    method message() { qq|"without" does not take "$!keyword", please rewrite using "with"| }
}

my class X::Syntax::KeywordAsFunction does X::Syntax {
    has $.word;
    has $.needparens;
    method message {
        "Word '$.word' interpreted as '{$.word}()' function call; please use whitespace "
            ~ ($.needparens ?? 'around the parens' !! 'instead of parens')
    }
}

my class X::Syntax::Malformed::Elsif does X::Syntax {
    has $.what = 'else if';
    method message() { qq{In Perl 6, please use "elsif' instead of "$.what"} }
}

my class X::Syntax::Reserved does X::Syntax {
    has $.reserved;
    has $.instead = '';
    method message() { "The $.reserved is reserved$.instead" }
}

my class X::Syntax::P5 does X::Syntax {
    method message() { 'This appears to be Perl 5 code' }
}

my class X::Syntax::NegatedPair does X::Syntax {
    has $.key;
    method message() { "Argument not allowed on negated pair with key '$.key'" }
}

my class X::Syntax::Variable::Numeric does X::Syntax {
    has $.what = 'variable';
    method message() { "Cannot declare a numeric $.what" }
}

my class X::Syntax::Variable::Match does X::Syntax {
    method message() { 'Cannot declare a match variable' }
}

my class X::Syntax::Variable::Initializer does X::Syntax {
    has $.name = '<anon>';
    method message() { "Cannot use variable $!name in declaration to initialize itself" }
}


my class X::Syntax::Variable::Twigil does X::Syntax {
    has $.what = 'variable';
    has $.twigil;
    has $.scope;
    has $.additional = '';
    method message() { "Cannot use $.twigil twigil on '$.scope' $.what$.additional" }
}

my class X::Syntax::Variable::IndirectDeclaration does X::Syntax {
    method message() { 'Cannot declare a variable by indirect name (use a hash instead?)' }
}

my class X::Syntax::Variable::BadType does X::Comp {
    has Mu $.type;
    method message() {
        my $what = ~$!type.HOW.WHAT.^name.match(/ .* '::' <(.*)> HOW/) // 'Namespace';
        "$what $!type.^name() is insufficiently type-like to qualify a variable"
    }
}

my class X::Syntax::Variable::ConflictingTypes does X::Comp {
    has Mu $.outer;
    has Mu $.inner;
    method message() {
        "$!inner.^name() not allowed here; variable list already declared with type $!outer.^name()"
    }
}

my class X::Syntax::Augment::WithoutMonkeyTyping does X::Syntax {
    method message() { "augment not allowed without 'use MONKEY-TYPING'" };
}

my class X::Syntax::Augment::Illegal does X::Syntax {
    has $.package;
    method message() { "Cannot augment $.package because it is closed" };
}

my class X::Syntax::Augment::Adverb does X::Syntax {
    method message() { "Cannot put adverbs on a typename when augmenting" }
}

my class X::Syntax::Type::Adverb does X::Syntax {
    has $.adverb;
    method message() { "Cannot use adverb $.adverb on a type name (only 'ver' and 'auth' are understood)" }
}

my class X::Syntax::Argument::MOPMacro does X::Syntax {
    has $.macro;
    method message() { "Cannot give arguments to $.macro" };
}

my class X::Role::Initialization is Exception {
    has $.role;
    method message() { "Can only supply an initialization value for a role if it has a single public attribute, but this is not the case for '{$.role.^name}'" }
}

my class X::Syntax::Comment::Embedded does X::Syntax {
    method message() { "Opening bracket required for #` comment" }
}

my class X::Syntax::Pod::BeginWithoutIdentifier does X::Syntax does X::Pod {
    method message() {
        '=begin must be followed by an identifier; (did you mean "=begin pod"?)'
    }
}

my class X::Syntax::Pod::BeginWithoutEnd does X::Syntax does X::Pod {
    has $.type;
    has $.spaces;
    has $.instead;
    method message() {
        if $.instead {
            qq{Expected "=end $.type" to terminate "=begin $.type"; found "=end $.instead" instead.}
        } else {
            "'=begin' not terminated by matching '$.spaces=end $.type'"
        }
    }
}

my class X::Syntax::Confused does X::Syntax {
    has $.reason = 'unknown';
    method message() { $.reason eq 'unknown' ?? 'Confused' !! $.reason }
}

my class X::Syntax::Malformed does X::Syntax {
    has $.what;
    method message() { "Malformed $.what" }
}
my class X::Syntax::Missing does X::Syntax {
    has $.what;
    method message() { "Missing $.what" }
}
my class X::Syntax::BlockGobbled does X::Syntax {
    has $.what;
    method message() {
        my $looks_like_type = $.what ~~ /'::' | <[A..Z]><[a..z]>+/;
        $.what ~~ /^'is '/
            ?? "Trait '$.what' needs whitespace before block"
            !! "{ $.what ?? "Function '$.what'" !! 'Expression' } needs parens to avoid gobbling block" ~
                    ($looks_like_type ?? " (or perhaps it's a class that's not declared or available in this scope?)" !! "");
    };
}

my class X::Syntax::ConditionalOperator::PrecedenceTooLoose does X::Syntax {
    has $.operator;
    method message() { "Precedence of $.operator is too loose to use inside ?? !!; please parenthesize" }
}

my class X::Syntax::ConditionalOperator::SecondPartGobbled does X::Syntax {
    method message() { "Your !! was gobbled by the expression in the middle; please parenthesize" }
}

my class X::Syntax::ConditionalOperator::SecondPartInvalid does X::Syntax {
    has $.second-part;
    method message() { "Please use !! rather than $.second-part" }
}

my class X::Syntax::Perl5Var does X::Syntax {
    has $.name;
    my %m =
      '$*'  => '^^ and $$',
      '$"'  => '.join() method',
      '$$'  => '$*PID',
      '$('  => '$*GID',
      '$)'  => '$*EGID',
      '$<'  => '$*UID',
      '$>'  => '$*EUID',
      '$;'  => 'real multidimensional hashes',
      '$&'  => '$<>',
      '$`'  => '$/.prematch',
      '$\'' => '$/.postmatch',
      '$,'  => '$*OUT.output_field_separator()',
      '$.'  => "the .kv method on e.g. .lines",
      '$/'  => "the filehandle's .nl-in attribute",
      '$\\' => "the filehandle's .nl-out attribute",
      '$|'  => ':autoflush on open',
      '$?'  => '$! for handling child errors also',
      '$@'  => '$!',
      '$#'  => '.fmt',
      '$['  => 'user-defined array indices',
      '$]'  => '$*PERL.version or $*PERL.compiler.version',

      '$^C' => 'COMPILING namespace',
      '$^D' => '$*DEBUGGING',
      '$^E' => '$!.extended_os_error',
      '$^F' => '$*SYSTEM_FD_MAX',
      '$^H' => '$?FOO variables',
      '$^I' => '$*INPLACE',
      '$^M' => 'a global form such as $*M',
      '$^N' => '$/[*-1]',
      '$^O' => 'VM.osname',
      '$^R' => 'an explicit result variable',
      '$^S' => 'context function',
      '$^T' => '$*INIT-INSTANT',
      '$^V' => '$*PERL.version or $*PERL.compiler.version',
      '$^W' => '$*WARNING',
      '$^X' => '$*EXECUTABLE-NAME',

      '$:'  => 'Form module',
      '$-'  => 'Form module',
      '$+'  => 'Form module',
      '$='  => 'Form module',
      '$%'  => 'Form module',
      '$^'  => 'Form module',
      '$~'  => 'Form module',
      '$^A' => 'Form module',
      '$^L' => 'Form module',

      '@-'  => '.from method',
      '@+'  => '.to method',

      '%-'  => '.from method',
      '%+'  => '.to method',
      '%^H' => '$?FOO variables',
    ;
    method message() {
        my $v = $.name ~~ m/ <[ $ @ % & ]> [ \^ <[ A..Z ]> | \W ] /;
        $v
          ?? %m{~$v}
            ?? "Unsupported use of $v variable; in Perl 6 please use {%m{~$v}}"
            !! "Unsupported use of $v variable"
          !! 'Weird unrecognized variable name: ' ~ $.name;
    }
}

my class X::Syntax::Self::WithoutObject does X::Syntax {
    method message() { "'self' used where no object is available" }
}
my class X::Syntax::VirtualCall does X::Syntax {
    has $.call;
    method message() { "Virtual method call $.call may not be used on partially constructed object (maybe you mean {$.call.subst('.','!')} for direct attribute access here?)" }
}
my class X::Syntax::NoSelf does X::Syntax {
    has $.variable;
    method message() { "Variable $.variable used where no 'self' is available" }
}

my class X::Syntax::Number::RadixOutOfRange does X::Syntax {
    has $.radix;
    method message() { "Radix $.radix out of range (allowed: 2..36)" }
}

my class X::Syntax::Number::IllegalDecimal does X::Syntax {
    method message() { "Decimal point must be followed by digit" }
}

my class X::Syntax::Number::LiteralType does X::Syntax {
    has $.varname;
    has $.vartype;
    has $.value;
    has $.valuetype;
    has $.suggestiontype;

    method message() {
        my $vartype := $!vartype.WHAT.^name;
        my $value := $!value.perl;
        my $val = "Cannot assign a literal of type {$.valuetype} ($value) to a variable of type $vartype. You can declare the variable to be of type $.suggestiontype, or try to coerce the value with { $value ~ '.' ~ $vartype } or $vartype\($value\)";
        try $val ~= ", or just write the value as " ~ $!value."$vartype"().perl;
        $val;
    }
}

my class X::Syntax::NonAssociative does X::Syntax {
    has $.left;
    has $.right;
    method message() {
        "Operators '$.left' and '$.right' are non-associative and require parentheses";
    }
}

my class X::Syntax::NonListAssociative is X::Syntax::NonAssociative {
    method message() {
        "Only identical operators may be list associative; since '$.left' and '$.right' differ, they are non-associative and you need to clarify with parentheses";
    }
}

my class X::Syntax::CannotMeta does X::Syntax {
    has $.meta;
    has $.operator;
    has $.reason;
    has $.dba;
    method message() {
        "Cannot $.meta $.operator because $.dba operators are $.reason";
    }
}

my class X::Syntax::Adverb does X::Syntax {
    has $.what;

    method message() { "You can't adverb " ~ $.what }
}

my class X::Syntax::Regex::Adverb does X::Syntax {
    has $.adverb;
    has $.construct;
    method message() { "Adverb $.adverb not allowed on $.construct" }
}

my class X::Syntax::Regex::UnrecognizedMetachar does X::Syntax {
    has $.metachar;
    method message() { "Unrecognized regex metacharacter $.metachar (must be quoted to match literally)" }
}

my class X::Syntax::Regex::UnrecognizedModifier does X::Syntax {
    has $.modifier;
    method message() { "Unrecognized regex modifier :$.modifier" }
}

my class X::Syntax::Regex::NullRegex does X::Syntax {
    method message() { 'Null regex not allowed' }
}

my class X::Syntax::Regex::MalformedRange does X::Syntax {
    method message() {
        'Malformed Range. If attempting to use variables for end points, '
        ~ 'wrap the entire range in curly braces.'
    }
}

my class X::Syntax::Regex::Unspace does X::Syntax {
    has $.char;
    method message { "No unspace allowed in regex; if you meant to match the literal character, " ~
        "please enclose in single quotes ('" ~ $.char ~ "') or use a backslashed form like \\x" ~
        sprintf('%02x', $.char.ord)
    }
}

my class X::Syntax::Regex::Unterminated does X::Syntax {
    method message { 'Regex not terminated.' }
}

my class X::Syntax::Regex::SpacesInBareRange does X::Syntax {
    method message { 'Spaces not allowed in bare range.' }
}

my class X::Syntax::Regex::QuantifierValue does X::Syntax {
    has $.inf;
    has $.non-numeric;
    has $.non-numeric-range;
    has $.empty-range;
    method message {
        $!inf
          && 'Minimum quantity to match for quantifier cannot be Inf.'
            ~ ' Did you mean to use + or * quantifiers instead of **?'
        || $!non-numeric-range
          && 'Cannot use Range with non-Numeric or NaN end points as quantifier'
        || $!non-numeric
          && 'Cannot use non-Numeric or NaN value as quantifier'
        || $!empty-range
          && 'Cannot use empty Range as quantifier'
        || 'Invalid quantifier value'
    }
}

my class X::Syntax::Regex::SolitaryQuantifier does X::Syntax {
    method message { 'Quantifier quantifies nothing' }
}

my class X::Syntax::Regex::NonQuantifiable does X::Syntax {
    method message { 'Can only quantify a construct that produces a match' }
}

my class X::Syntax::Regex::SolitaryBacktrackControl does X::Syntax {
    method message { "Backtrack control ':' does not seem to have a preceding atom to control" }
}

my class X::Syntax::Regex::Alias::LongName does X::Syntax {
    method message() { "Can only alias to a short name (without '::')"; }
}

my class X::Syntax::Term::MissingInitializer does X::Syntax {
    method message { 'Term definition requires an initializer' }
}

my class X::Syntax::Variable::MissingInitializer does X::Syntax {
    has $.type;
    has $.implicit;
    method message {
        $.implicit ??
            "Variable definition of type $.type (implicit $.implicit) requires an initializer" !!
            "Variable definition of type $.type requires an initializer"
    }
}

my class X::Syntax::AddCategorical::TooFewParts does X::Syntax {
    has $.category;
    has $.needs;
    method message() { "Not enough symbols provided for categorical of type $.category; needs $.needs" }
}

my class X::Syntax::AddCategorical::TooManyParts does X::Syntax {
    has $.category;
    has $.needs;
    method message() { "Too many symbols provided for categorical of type $.category; needs only $.needs" }
}

my class X::Syntax::Signature::InvocantMarker does X::Syntax {
    method message() {
        "Can only use : as invocant marker in a signature after the first parameter"
    }
}

my class X::Syntax::Signature::InvocantNotAllowed does X::Syntax {
    method message() {
        "Can only use the : invocant marker in the signature for a method"
    }
}

my class X::Syntax::Extension::Category does X::Syntax {
    has $.category;
    method message() {
        "Cannot add tokens of category '$.category'";
    }
}

my class X::Syntax::Extension::Null does X::Syntax {
    method message() {
        "Null operator is not allowed";
    }
}

my class X::Syntax::Extension::TooComplex does X::Syntax {
    has $.name;
    method message() {
        "Colon pair value '$.name' too complex to use in name";
    }
}

my class X::Syntax::Extension::SpecialForm does X::Syntax {
    has $.category;
    has $.opname;
    has $.hint;
    method message() {
        "Cannot override $.category operator '$.opname', as it is a special form " ~
            "handled directly by the compiler" ~ ($!hint ?? "\n$!hint" !! "")
    }
}

my class X::Syntax::InfixInTermPosition does X::Syntax {
    has $.infix;
    method message() {
        "Preceding context expects a term, but found infix {$.infix.trim} instead";
    }
}

my class X::Syntax::DuplicatedPrefix does X::Syntax {
    has $.prefixes;
    method message() {
        my $prefix = substr($.prefixes,0,1);
        "Expected a term, but found either infix $.prefixes or redundant prefix $prefix\n"
        ~ "  (to suppress this message, please use a space like $prefix $prefix)";
    }
}

my class X::Attribute::Package does X::Comp {
    has $.package-kind;
    has $.name;
    method message() { "A $.package-kind cannot have attributes, but you tried to declare '$.name'" }
}
my class X::Attribute::NoPackage does X::Comp {
    has $.name;
    method message() { "You cannot declare attribute '$.name' here; maybe you'd like a class or a role?" }
}
my class X::Attribute::Required does X::MOP {
    has $.name;
    has $.why;
    method message() {
        $.why && nqp::istype($.why,Str)
          ?? "The attribute '$.name' is required because $.why,\nbut you did not provide a value for it."
          !! "The attribute '$.name' is required, but you did not provide a value for it."
    }
}
my class X::Attribute::Scope::Package does X::Comp {
    has $.scope;
    has $.allowed;
    has $.disallowed;
    method message() { "Cannot use {$.scope}-scoped attribute in $.disallowed"
        ~ ($.allowed ?? ", only $.allowed." !! ".") }
}
my class X::Declaration::Scope does X::Comp {
    has $.scope;
    has $.declaration;
    method message() { "Cannot use '$.scope' with $.declaration declaration" }
}

my class X::Declaration::Scope::Multi is X::Declaration::Scope {
    method message() {
        "Cannot use '$.scope' with individual multi candidates. Please declare an {$.scope}-scoped proto instead";
    }
}

my class X::Declaration::OurScopeInRole does X::Comp {
    has $.declaration;
    method message() {
        "Cannot declare our-scoped $.declaration inside of a role\n" ~
        "(the scope inside of a role is generic, so there is no unambiguous\n" ~
        "package to install the symbol in)"
    }
}

my class X::Anon::Multi does X::Comp {
    has $.multiness;
    has $.routine-type = 'routine';
    method message() { "An anonymous $.routine-type may not take a $.multiness declarator" }
}
my class X::Anon::Augment does X::Comp {
    has $.package-kind;
    method message() { "Cannot augment anonymous $.package-kind" }
}
my class X::Augment::NoSuchType does X::Comp {
    has $.package-kind;
    has $.package;
    method message() { "You tried to augment $.package-kind $.package, but it does not exist" }
}

my class X::Routine::Unwrap is Exception {
    method message() { "Cannot unwrap routine: invalid wrap handle" }
}

my class X::Constructor::Positional is Exception {
    has $.type;
    method message() { "Default constructor for '" ~ $.type.^name ~ "' only takes named arguments" }
}

my class X::Hash::Store::OddNumber is Exception {
    has $.found;
    has $.last;
    method message() {
        my $msg =
          "Odd number of elements found where hash initializer expected";
        if $.found == 1 {
            $msg ~= $.last
              ?? ":\nOnly saw: $.last.perl()"
              !! ":\nOnly saw 1 element"
        }
        else {
            $msg ~= ":\nFound $.found (implicit) elements";
            $msg ~= ":\nLast element seen: $.last.perl()" if $.last;
        }
    }
}

my class X::Pairup::OddNumber is Exception {
    method message() { "Odd number of elements found for .pairup()" }
}

my class X::Match::Bool is Exception {
    has $.type;
    method message() { "Cannot use Bool as Matcher with '" ~ $.type ~ "'.  Did you mean to use \$_ inside a block?" }
}

my class X::LibEmpty does X::Comp {
    method message { q/Repository specification can not be an empty string.  Did you mean 'use lib "."' ?/ }
}
my class X::LibNone does X::Comp {
    method message { q/Must specify at least one repository.  Did you mean 'use lib "lib"' ?/ }
}
my class X::Package::UseLib does X::Comp {
    has $.what;
    method message { "Cannot 'use lib' inside a $.what" }
}
my class X::Package::Stubbed does X::Comp {
    has @.packages;
    method message() {
        "The following packages were stubbed but not defined:\n    "
        ~ @.packages.join("\n    ");
    }

    # The unnamed named param is here so this candidate, rather than
    # the one from X::Comp is used. (is it a bug that this is needed?
    # No idea: https://irclog.perlgeek.de/perl6-dev/2017-09-14#i_15164569 )
    multi method gist(::?CLASS:D: :$) {
        $.message;
    }
}

my class X::Phaser::PrePost is Exception {
    has $.phaser = 'PRE';
    has $.condition;
    method message {
        my $what = $.phaser eq 'PRE' ?? 'Precondition' !! 'Postcondition';
        $.condition.defined
            ?? "$what '$.condition.trim()' failed"
            !! "$what failed";
    }
}

my class X::Str::InvalidCharName is Exception {
    has $.name;
    method message() {
        $!name.chars ?? "Unrecognized character name [{$!name}]"
                     !! "Cannot use empty name as character name"
    }
}

my class X::Str::Numeric is Exception {
    has $.source;
    has $.pos;
    has $.reason;
    method source-indicator {
        my ($red,$clear,$green,$,$eject) = Rakudo::Internals.error-rcgye;
        my sub escape($str) { $str.perl.substr(1).chop }
        join '', "in '",
                $green,
                escape(substr($.source,0, $.pos)),
                $eject,
                $red,
                escape(substr($.source,$.pos)),
                $clear,
                "' (indicated by ",
                $eject,
                $clear,
                ")",
                ;
    }
    method message() {
        "Cannot convert string to number: $.reason $.source-indicator";
    }
}

my class X::Str::Match::x is Exception {
    has $.got is default(Nil);
    method message() {
        "in Str.match, got invalid value of type {$.got.^name} for :x, must be Int or Range"
    }
}

my class X::Str::Subst::Adverb is Exception {
    has $.name;
    has $.got;
    method message() {
        "Cannot use :$.name adverb in Str.subst, got $.got"
    }
}

my class X::Str::Trans::IllegalKey is Exception {
    has $.key;
    method message {
        "in Str.trans, got illegal substitution key of type {$.key.^name} (should be a Regex or Str)"
    }
}
my class X::Str::Trans::InvalidArg is Exception {
    has $.got is default(Nil);
    method message() {
        "Only Pair objects are allowed as arguments to Str.trans, got {$.got.^name}";
    }
}

my class X::Str::Sprintf::Directives::Count is Exception {
    has int $.args-used;
    has num $.args-have;
    method message() {
        "Your printf-style directives specify "
        ~ ($.args-used == 1 ?? "1 argument, but "
                            !! "$.args-used arguments, but ")
        ~ ($.args-have < 1      ?? "no argument was"
            !! $.args-have == 1 ?? "1 argument was"
                                !! "$.args-have arguments were")
        ~ " supplied";
    }
}

my class X::Str::Sprintf::Directives::Unsupported is Exception {
    has $.directive;
    has $.sequence;
    method message() {
        "Directive $.directive is not valid in sprintf format sequence $.sequence"
    }
}

my class X::Str::Sprintf::Directives::BadType is Exception {
    has $.type;
    has $.directive;
    method message() {
        "Directive $.directive not applicable for type $.type"
    }
}

my role X::Encoding is Exception { }

my class X::Encoding::Unknown does X::Encoding {
    has $.name;
    method message() {
        "Unknown string encoding '$.name'"
    }
}

my class X::Encoding::AlreadyRegistered does X::Encoding {
    has $.name;
    method message() {
        "An encoding with name '$.name' has already been registered"
    }
}

my class X::Range::InvalidArg is Exception {
    has $.got is default(Nil);
    method message() {
        "{$.got.^name} objects are not valid endpoints for Ranges";
    }
}

my class X::Sequence::Deduction is Exception {
    has $.from;
    method message() {
        $!from ?? "Unable to deduce arithmetic or geometric sequence from $!from (or did you really mean '..'?)"
               !! 'Unable to deduce sequence for some unfathomable reason'
    }
}

my class X::Cannot::Lazy is Exception {
    has $.action;
    has $.what;
    method message() {
        $.what
          ?? "Cannot $.action a lazy list onto a $.what"
          !! "Cannot $.action a lazy list";
    }
}
my class X::Cannot::Empty is Exception {
    has $.action;
    has $.what;
    method message() {
        "Cannot $.action from an empty $.what";
    }
}
my class X::Cannot::New is Exception {
    has $.class;
    method message() {
        "Cannot make a {$.class.^name} object using .new";
    }
}
my class X::Cannot::Capture is Exception {
    has $.what;
    method message() {
        "Cannot unpack or Capture `$!what.gist()`.\n"
          ~ "To create a Capture, add parentheses: \\(...)\n"
          ~ 'If unpacking in a signature, perhaps you needlessly used'
          ~ ' parentheses? -> ($x) {} vs. -> $x {}';
    }
}

my class X::Backslash::UnrecognizedSequence does X::Syntax {
    has $.sequence;
    method message() { "Unrecognized backslash sequence: '\\$.sequence'" }
}

my class X::Backslash::NonVariableDollar does X::Syntax {
    method message() { "Non-variable \$ must be backslashed" }
}

my class X::ControlFlow is Exception {
    has $.illegal;   # something like 'next'
    has $.enclosing; # ....  outside a loop
    has $.backtrace; # where the bogus control flow op was

    method backtrace() {
        $!backtrace || nextsame();
    }

    method message() { "$.illegal without $.enclosing" }
}
my class X::ControlFlow::Return is X::ControlFlow {
    method illegal()   { 'return'  }
    method enclosing() { 'Routine' }
    method message()   { 'Attempt to return outside of any Routine' }
}

my class X::Composition::NotComposable does X::Comp {
    has $.target-name;
    has $.composer;
    method message() {
        $!composer.^name ~ " is not composable, so $!target-name cannot compose it";
    }
}

my class X::TypeCheck is Exception {
    has $.operation;
    has $.got is default(Nil);
    has $.expected is default(Nil);
    method gotn() {
        my $perl = (try $!got.perl) // "?";
        $perl = "$perl.substr(0,21)..." if $perl.chars > 24;
        (try $!got.^name eq $!expected.^name
          ?? $perl
          !! "$!got.^name() ($perl)"
        ) // "?"
    }
    method expectedn() {
        (try $!got.^name eq $!expected.^name
          ?? $!expected.perl
          !! $!expected.^name
        ) // "?"
    }
    method priors() {
        (try nqp::isconcrete($!got) && $!got ~~ Failure)
          ?? "Earlier failure:\n " ~ $!got.mess ~ "\nFinal error:\n "
          !! ''
    }
    method message() {
        self.priors() ~
        "Type check failed in $.operation; expected $.expectedn but got $.gotn";
    }
}

my class X::TypeCheck::Binding is X::TypeCheck {
    has $.symbol;
    method operation { 'binding' }
    method message() {
        my $to = $.symbol.defined && $.symbol ne '$'
            ?? " to '$.symbol'"
            !! "";
        my $expected = (try nqp::eqaddr($.expected,$.got))
            ?? "expected type $.expectedn cannot be itself"
            !! "expected $.expectedn but got $.gotn";
        self.priors() ~ "Type check failed in $.operation$to; $expected";
    }
}
my class X::TypeCheck::Binding::Parameter is X::TypeCheck::Binding {
    has Parameter $.parameter;
    has Bool $.constraint;
    method expectedn() {
        $.constraint && $.expected ~~ Code
            ?? 'anonymous constraint to be met'
            !! callsame()
    }
    method message() {
        my $to = $.symbol.defined && $.symbol ne '$'
            ?? " to parameter '$.symbol'"
            !! " to anonymous parameter";
        my $expected = (try nqp::eqaddr($.expected,$.got))
            ?? "expected type $.expectedn cannot be itself"
            !! "expected $.expectedn but got $.gotn";
        my $what-check = $.constraint ?? 'Constraint type' !! 'Type';
        self.priors() ~ "$what-check check failed in $.operation$to; $expected";
    }
}
my class X::TypeCheck::Return is X::TypeCheck {
    method operation { 'returning' }
    method message() {
        my $expected = $.expected =:= $.got
            ?? "expected return type $.expectedn cannot be itself " ~
               "(perhaps $.operation a :D type object?)"
            !! "expected $.expectedn but got $.gotn";
        self.priors() ~
        "Type check failed for return value; $expected";
    }
}
my class X::TypeCheck::Assignment is X::TypeCheck {
    has $.symbol;
    method operation { 'assignment' }
    method message {
        my $to = $.symbol.defined && $.symbol ne '$'
            ?? " to $.symbol" !! "";
        my $expected = $.expected =:= $.got
            ?? "expected type $.expectedn cannot be itself " ~
               "(perhaps Nil was assigned to a :D which had no default?)"
            !! "expected $.expectedn but got $.gotn";
        self.priors() ~ "Type check failed in assignment$to; $expected";
    }
}
my class X::TypeCheck::Argument is X::TypeCheck {
    has $.protoguilt;
    has @.arguments;
    has $.objname;
    has $.signature;
    method message {
            my $multi = $!signature ~~ /\n/ // '';
            "Calling {$!objname}({ join(', ', @!arguments) }) will never work with " ~ (
                $!protoguilt ?? 'proto signature ' !!
                $multi       ?? 'any of these multi signatures:' !!
                                'declared signature '
            ) ~ $!signature;
    }
}

my class X::TypeCheck::Splice is X::TypeCheck does X::Comp {
    has $.action;
    method message {
        self.priors() ~
        "Type check failed in {$.action}; expected $.expectedn but got $.gotn";
    }

}

my class X::Assignment::RO is Exception {
    has $.value = "value";
    method message {
        "Cannot modify an immutable {$.value.^name} ({$.value.gist})"
    }
    method typename { $.value.^name }
}

my class X::Assignment::RO::Comp does X::Comp {
    has $.variable;
    method message {
        "Cannot assign to readonly variable {$.variable}"
    }
}

my class X::Immutable is Exception {
    has $.typename;
    has $.method;
    method message {
        "Cannot call '$.method' on an immutable '$.typename'";
    }
}

my class X::NoDispatcher is Exception {
    has $.redispatcher;
    method message() {
        "$.redispatcher is not in the dynamic scope of a dispatcher";
    }
}

my class X::Localizer::NoContainer is Exception {
    has $.localizer;
    method message() {
        "Can only use '$.localizer' on a container";
    }
}

my class X::Mixin::NotComposable is Exception {
    has $.target;
    has $.rolish;
    method message() {
        "Cannot mix in non-composable type {$.rolish.^name} into object of type {$.target.^name}";
    }
}

my class X::Inheritance::Unsupported does X::Comp {
    # note that this exception is thrown before the child type object
    # has been composed, so it's useless to carry it around. Use the
    # name instead.
    has $.child-typename;
    has $.parent;
    method message {
        $!parent.^name ~ ' does not support inheritance, so '
        ~ $!child-typename ~ ' cannot inherit from it';
    }
}

my class X::Inheritance::UnknownParent is Exception {
    has $.child;
    has $.parent;
    has @.suggestions is rw;

    method message {
        my $message := "'" ~ $.child ~ "' cannot inherit from '" ~ $.parent ~ "' because it is unknown.";
        if +@.suggestions > 1 {
            $message := $message ~ "\nDid you mean one of these?\n    '" ~ @.suggestions.join("'\n    '") ~ "'\n";
        } elsif +@.suggestions == 1 {
            $message := $message ~ "\nDid you mean '" ~ @.suggestions[0] ~ "'?\n";
        }
        $message;
    }
}

my class X::Inheritance::SelfInherit is Exception {
    has $.name;

    method message {
        "'$.name' cannot inherit from itself."
    }
}

my class X::Export::NameClash does X::Comp {
    has $.symbol;
    method message() {
        "A symbol '$.symbol' has already been exported";
    }
}

my class X::HyperOp::NonDWIM is Exception {
    has &.operator;
    has $.left-elems;
    has $.right-elems;
    has $.recursing;
    method message() {
        "Lists on either side of non-dwimmy hyperop of &.operator.name() are not of the same length"
        ~ " while recursing" x +$.recursing
        ~ "\nleft: $.left-elems elements, right: $.right-elems elements";
    }
}

my class X::HyperOp::Infinite is Exception {
    has &.operator;
    has $.side;
    method message() {
        $.side eq "both"
            ?? "Lists on both sides of hyperop of &.operator.name() are known to be infinite"
            !! "List on $.side side of hyperop of &.operator.name() is known to be infinite"
    }
}

my class X::Set::Coerce is Exception {
    has $.thing;
    method message {
        "Cannot coerce object of type {$.thing.^name} to Set. To create a one-element set, pass it to the 'set' function";
    }
}


my role X::Temporal is Exception { }
my class X::Temporal::InvalidFormat does X::Temporal {
    has $.invalid-str;
    has $.target = 'Date';
    has $.format;
    method message() {
        "Invalid $.target string '$.invalid-str'; use $.format instead";
    }
}
my class X::DateTime::TimezoneClash does X::Temporal {
    method message() {
        'DateTime.new(Str): :timezone argument not allowed with a timestamp offset';
    }
}
my class X::DateTime::InvalidDeltaUnit does X::Temporal {
    has $.unit;
    method message() {
        "Cannot use unit $.unit with Date.delta";
    }
}

my class X::Eval::NoSuchLang is Exception {
    has $.lang;
    method message() {
        "No compiler available for language '$.lang'";
    }
}

my class X::Import::MissingSymbols is Exception {
    has $.from;
    has @.missing;
    method message() {
        "Trying to import from '$.from', but the following symbols are missing: "
            ~ @.missing.join(', ');
    }
}

my class X::Import::NoSuchTag is Exception {
    has $.source-package;
    has $.tag;
    method message() {
        "Error while importing from '$.source-package': no such tag '$.tag'"
    }
}

my class X::Import::Positional is Exception {
    has $.source-package;
    method message() {
        "Error while importing from '$.source-package':\n"
        ~ "no EXPORT sub, but you provided positional argument in the 'use' statement"
    }
}

my class X::Numeric::CannotConvert is Exception {
    has $.target;
    has $.reason;
    has $.source;

    method message() {
        "Cannot convert $!source to {$!target // $!target.perl}: $!reason";
    }

}
my class X::Numeric::Real is X::Numeric::CannotConvert {}

my class X::Numeric::DivideByZero is Exception {
    has $.using;
    has $.details;
    has $.numerator;
    method message() {
        "Attempt to divide{$.numerator ?? " $.numerator" !! ''} by zero"
          ~ ( $.using ?? " using $.using" !! '' )
          ~ ( " $_" with $.details );
    }
}

my class X::Numeric::Overflow is Exception {
    method message() { "Numeric overflow" }
}

my class X::Numeric::Underflow is Exception {
    method message() { "Numeric underflow" }
}

my class X::Numeric::Confused is Exception {
    has $.num;
    has $.base;
    method message() {
        "This call only converts base-$.base strings to numbers; value "
        ~ "{$.num.perl} is of type {$.num.WHAT.^name}, so cannot be converted!"
        ~ (
            "\n(If you really wanted to convert {$.num.perl} to a base-$.base"
                ~ " string, use {$.num.perl}.base($.base) instead.)"
            if $.num.^can('base')
        );
    }
}

my class X::PseudoPackage::InDeclaration does X::Comp {
    has $.pseudo-package;
    has $.action;
    method message() {
        "Cannot use pseudo package $.pseudo-package in $.action";
    }
}

my class X::NoSuchSymbol is Exception {
    has $.symbol;
    method message { "No such symbol '$.symbol'" }
}

my class X::Item is Exception {
    has $.aggregate;
    has $.index;
    method message { "Cannot index {$.aggregate.^name} with $.index" }
}

my class X::Multi::Ambiguous is Exception {
    has $.dispatcher;
    has @.ambiguous;
    has $.capture;
    method message {
        join "\n",
            "Ambiguous call to '$.dispatcher.name()'; these signatures all match:",
            @.ambiguous.map(*.signature.perl)
    }
}

my class X::Multi::NoMatch is Exception {
    has $.dispatcher;
    has $.capture;
    method message {
        my @cand = $.dispatcher.dispatchees.map(*.signature.gist);
        my @un-rw-cand;
        if first / 'is rw' /, @cand {
            my $rw-capture = Capture.new(
                :list( $!capture.list.map({ my $ = $_ })                  ),
                :hash( $!capture.hash.map({ .key => my $ = .value }).hash ),
            );
            @un-rw-cand = $.dispatcher.dispatchees.signature.grep({
                $rw-capture ~~ $^cand
            }).gist;
        }

        my $where = so first / where /, @cand;
        my @bits;
        my @priors;
        if $.capture {
            for $.capture.list {
                try @bits.push($where ?? .perl !! .WHAT.perl );
                @bits.push($_.^name) if $!;
                when Failure {
                    @priors.push(" " ~ .mess);
                }
            }
            for $.capture.hash {
                if .value ~~ Failure {
                    @priors.push(" " ~ .value.mess);
                }
                if .value ~~ Bool {
                    @bits.push(':' ~ ('!' x !.value) ~ .key);
                }
                else {
                    try @bits.push(":$(.key)\($($where ?? .value.?perl !! .value.WHAT.?perl ))");
                    @bits.push(':' ~ .value.^name) if $!;
                }
            }
        }
        else {
            @bits.push('...');
        }
        if @cand && @cand[0] ~~ /': '/ {
            my $invocant = @bits.shift;
            my $first = @bits ?? @bits.shift !! '';
            @bits.unshift($invocant ~ ': ' ~ $first);
        }
        my $cap = '(' ~ @bits.join(", ") ~ ')';
        @priors = flat "Earlier failures:\n", @priors, "\nFinal error:\n " if @priors;
        @priors.join ~ "Cannot resolve caller $.dispatcher.name()$cap; " ~ (
            @un-rw-cand
            ?? "the following candidates\nmatch the type but require "
                ~ 'mutable arguments:' ~  join("\n    ", '', @un-rw-cand) ~ (
                        "\n\nThe following do not match for other reasons:"
                        ~  join("\n    ", '', sort keys @cand  @un-rw-cand)
                    unless @cand == @un-rw-cand
                )
            !! ( @cand
                 ??  join "\n    ", 'none of these signatures match:', @cand
                 !! "Routine does not have any candidates. Is only the proto defined?"
               )
        );
    }
}

my class X::Caller::NotDynamic is Exception {
    has $.symbol;
    method message() {
        "Cannot access '$.symbol' through CALLER, because it is not declared as dynamic";
    }
}

my class X::Inheritance::NotComposed does X::MOP {
    # normally, we try very hard to capture the types
    # and not just their names. But in this case, both types
    # involved aren't composed yet, so they basically aren't
    # usable at all.
    has $.child-name;
    has $.parent-name;
    method message() {
        "'$.child-name' cannot inherit from '$.parent-name' because '$.parent-name' isn't composed yet"
            ~ ' (maybe it is stubbed)';
    }
}

my class X::PhaserExceptions is Exception {
    has @.exceptions;
    method message() {
        "Multiple exceptions were thrown by LEAVE/POST phasers"
    }
    multi method gist(X::PhaserExceptions:D:) {
        join "\n", flat
            "Multiple exceptions were thrown by LEAVE/POST phasers\n",
            @!exceptions>>.gist>>.indent(4)
    }
}






nqp::bindcurhllsym('P6EX', BEGIN nqp::hash(

  'X::TypeCheck::Binding',
  -> Mu $got, Mu $expected, $symbol? {
      X::TypeCheck::Binding.new(:$got, :$expected, :$symbol).throw;
  },
  'X::TypeCheck::Binding::Parameter',
  -> Mu $got, Mu $expected, $symbol, $parameter, $is-constraint? {
      my $constraint = $is-constraint ?? True !! False;
      X::TypeCheck::Binding::Parameter.new(:$got, :$expected, :$symbol, :$parameter, :$constraint).throw;
  },
  'X::TypeCheck::Assignment',
  -> Mu $symbol, Mu $got, Mu $expected {
      X::TypeCheck::Assignment.new(:$symbol, :$got, :$expected).throw;
  },
  'X::TypeCheck::Return',
  -> Mu $got, Mu $expected {
      X::TypeCheck::Return.new(:$got, :$expected).throw;
  },
  'X::Assignment::RO',
  -> $value = "value" {
      X::Assignment::RO.new(:$value).throw;
  },
  'X::ControlFlow::Return',
  {
      X::ControlFlow::Return.new().throw;
  },
  'X::NoDispatcher',
  -> $redispatcher {
      X::NoDispatcher.new(:$redispatcher).throw;
  },
  'X::Method::NotFound',
  -> Mu $invocant, $method, $typename, $private = False {
      X::Method::NotFound.new(:$invocant, :$method, :$typename, :$private).throw
  },
  'X::Multi::Ambiguous',
  -> $dispatcher, @ambiguous, $capture {
      X::Multi::Ambiguous.new(:$dispatcher, :@ambiguous, :$capture).throw
  },
  'X::Multi::NoMatch',
  -> $dispatcher, $capture {
      X::Multi::NoMatch.new(:$dispatcher, :$capture).throw
  },
  'X::Role::Initialization',
  -> $role {
      X::Role::Initialization.new(:$role).throw
  },
  'X::Role::Parametric::NoSuchCandidate',
  -> Mu $role {
      X::Role::Parametric::NoSuchCandidate.new(:$role).throw;
  },
  'X::Inheritance::NotComposed',
  -> $child-name, $parent-name {
      X::Inheritance::NotComposed.new(:$child-name, :$parent-name).throw;
  },
  'X::Parameter::RW',
  -> Mu $got, $symbol {
      X::Parameter::RW.new(:$got, :$symbol).throw;
  },
  'X::PhaserExceptions',
  -> @exceptions {
      X::PhaserExceptions.new(exceptions =>
        @exceptions.map(-> Mu \e { EXCEPTION(e) })).throw;
  },
  'X::Trait::Invalid',
  -> $type, $subtype, $declaring, $name {
      X::Trait::Invalid.new(:$type, :$subtype, :$declaring, :$name).throw;
  },
  'X::Parameter::InvalidConcreteness',
  -> $expected, $got, $routine, $param, Bool() $should-be-concrete, Bool() $param-is-invocant {
      X::Parameter::InvalidConcreteness.new(:$expected, :$got, :$routine, :$param, :$should-be-concrete, :$param-is-invocant).throw;
  },
  'X::NYI',
  -> $feature {
      X::NYI.new(:$feature).throw;
  },
));

my class X::HyperWhatever::Multiple is Exception {
    method message() {
        "Multiple HyperWhatevers and Whatevers may not be used together"
    }
}

my class X::EXPORTHOW::InvalidDirective does X::Comp {
    has $.directive;
    method message() {
        "Unknown EXPORTHOW directive '$.directive' encountered during import"
    }
}

my class X::EXPORTHOW::NothingToSupersede does X::Comp {
    has $.declarator;
    method message() {
        "There is no package declarator '$.declarator' to supersede"
    }
}

my class X::EXPORTHOW::Conflict does X::Comp {
    has $.declarator;
    has $.directive;
    method message() {
        "'EXPORTHOW::{$.directive}::{$.declarator}' conflicts with an existing meta-object imported into this lexical scope"
    }
}

my class X::UnitScope::Invalid does X::Syntax {
    has $.what;
    has $.where;
    method message() {
        "A unit-scoped $.what definition is not allowed $.where;\n"
        ~ "Please use the block form."
    }
}

my class X::UnitScope::TooLate does X::Syntax {
    has $.what;
    method message() {
        "Too late for unit-scoped $.what definition;\n"
        ~ "Please use the block form."
    }
}

my class X::StubCode is Exception {
    has $.message = 'Stub code executed';
}

my class X::TooLateForREPR is X::Comp  {
    has $.type;
    method message() {
        "Cannot change REPR of $!type.^name() now (must be set at initial declaration)";
    }
}

my class X::MustBeParametric is Exception {
    has $.type;
    method message() {
        "$!type.^name() *must* be parameterized";
    }
}
my class X::NotParametric is Exception {
    has $.type;
    method message() {
        "$!type.^name() cannot be parameterized";
    }
}

my class X::InvalidType does X::Comp {
    has $.typename;
    has @.suggestions;
    method message() {
        my $msg := "Invalid typename '$.typename'";
        if +@.suggestions > 0 {
            $msg := $msg ~ ". Did you mean '" ~ @.suggestions.join("', '") ~ "'?";
        }
        $msg;
    }
}

my class X::InvalidTypeSmiley does X::Comp {
    has $.name;
    method message() {
        "Invalid type smiley '$.name' used in type name";
    }
}

my class X::Seq::Consumed is Exception {
    method message() {
        "This Seq has already been iterated, and its values consumed\n" ~
        "(you might solve this by adding .cache on usages of the Seq, or\n" ~
        "by assigning the Seq into an array)"
    }
}

my class X::Seq::NotIndexable is Exception {
    method message() {
        "Cannot index a Seq; coerce it to a list or assign it to an array first"
    }
}

my class X::WheneverOutOfScope is Exception {
    method message() {
        "Cannot have a 'whenever' block outside the scope of a 'supply' block"
    }
}

my class X::IllegalOnFixedDimensionArray is Exception {
    has $.operation;
    method message() {
        "Cannot $.operation a fixed-dimension array"
    }
}

my class X::NotEnoughDimensions is Exception {
    has $.operation;
    has $.got-dimensions;
    has $.needed-dimensions;
    method message() {
        "Cannot $.operation a $.needed-dimensions dimension array with only $.got-dimensions dimensions"
    }
}

my class X::TooManyDimensions is Exception {
    has $.operation;
    has $.got-dimensions;
    has $.needed-dimensions;
    method message() {
        "Cannot $.operation a $.needed-dimensions dimension array with $.got-dimensions dimensions"
    }
}

my class X::IllegalDimensionInShape is Exception {
    has $.dim;
    method message() {
        "Illegal dimension in shape: $.dim. All dimensions must be integers bigger than 0"
    }
}

my class X::Assignment::ArrayShapeMismatch is Exception {
    has $.target-shape;
    has $.source-shape;
    method message() {
        "Cannot assign an array of shape $.source-shape to an array of shape $.target-shape"
    }
}

my class X::Assignment::ToShaped is Exception {
    has $.shape;
    method message() {
        "Assignment to array with shape $.shape must provide structured data"
    }
}

my class X::Language::Unsupported is Exception {
    has $.version;
    method message() {
        "No compiler available for Perl $.version"
    }
}

my class X::Proc::Unsuccessful is Exception {
    has $.proc;
    method message() {
        "The spawned command '{$.proc.command[0]}' exited unsuccessfully (exit code: $.proc.exitcode())"
    }
}

class CompUnit::DependencySpecification { ... }
my class X::CompUnit::UnsatisfiedDependency is Exception {
    has CompUnit::DependencySpecification $.specification;

    my sub is-core($name) {
        my @parts = $name.split("::");
        my $ns := ::CORE.WHO;
        for @parts {
            return False unless $ns{$_}:exists;
            $ns := $ns{$_}.WHO;
        };
        True
    };

    method message() {
        my $name = $.specification.short-name;
        my $line = $.specification.source-line-number;
        is-core($name)
            ?? "{$name} is a builtin type, not an external module"
            !! "Could not find $.specification at line $line in:\n"
                ~ $*REPO.repo-chain.map(*.Str).join("\n").indent(4)
                ~ ($.specification ~~ / $<name>=.+ '::from' $ /
                    ?? "\n\nIf you meant to use the :from adverb, use"
                        ~ " a single colon for it: $<name>:from<...>\n"
                    !! ''
                )
    }
}

my class Exceptions::JSON {
    method process($ex) {
        $*ERR.print:
          Rakudo::Internals::JSON.to-json( $ex.^name => Hash.new(
            (message => $ex.?message),
            $ex.^attributes.grep(*.has_accessor).map: {
                with .name.substr(2) -> $attr {
                    $attr => (
                        (.defined and not $_ ~~ Real|Positional|Associative)
                        ?? .Str !! $_
                    ) given $ex."$attr"()
                }
            }
          ));
        False  # done processing
    }
}

#line 1 SETTING::src/core/Failure.pm
my class Failure is Nil {
    has $.exception;
    has $.backtrace;

    has int $!handled;





    method !SET-SELF($!exception) {
        $!backtrace = $!exception.backtrace || Backtrace.new(5);
        $!exception.reset-backtrace;
        self
    }

    multi method new() {
        my $stash := CALLER::;
        my $payload = $stash<$!>.DEFINITE ?? $stash<$!> !! "Failed";
        nqp::create(self)!SET-SELF(
          $payload ~~ Exception ?? $payload !! X::AdHoc.new(:$payload)
        )
    }
    multi method new(Exception:D \exception) {
        nqp::create(self)!SET-SELF(exception)
    }
    multi method new($payload) {
        nqp::create(self)!SET-SELF(X::AdHoc.new(:$payload))
    }
    multi method new(|cap (*@msg)) {
        nqp::create(self)!SET-SELF(X::AdHoc.from-slurpy(|cap))
    }

    submethod DESTROY () {
        note "WARNING: unhandled Failure detected in DESTROY. If you meant "
            ~ "to ignore it, you can mark it as handled by calling .Bool, "
            ~ ".so, .not, or .defined methods. The Failure was:\n" ~ self.mess
        unless $!handled;
    }

    # Marks the Failure has handled (since we're now fatalizing it) and throws.
    method !throw(Failure:D:) {
        $!handled = 1;
        $!exception.throw($!backtrace);
    }

    # Turns out multidimensional lookups are one way to leak unhandled failures, so
    # we'll just propagate the initial failure much as we propagate Nil on methods.
    method AT-POS(|) { self }
    method AT-KEY(|) { self }

    # TODO: should be Failure:D: multi just like method Bool,
    # but obscure problems prevent us from making Mu.defined
    # a multi. See http://irclog.perlgeek.de/perl6/2011-06-28#i_4016747
    method defined() {
        $!handled = 1 if nqp::isconcrete(self);
        Bool::False;
    }
    multi method Bool(Failure:D:) { $!handled = 1; Bool::False; }
    method handled() {
        Proxy.new(
          FETCH => {

              nqp::p6bool($!handled)




          },
          STORE => -> $, $value { $!handled = $value.Bool.Numeric }
       )
    }

    method Capture() {
        self.DEFINITE.not || $!handled
            ?? X::Cannot::Capture.new(what => self).throw
            !! self!throw
    }
    method Int(Failure:D:)        { $!handled ?? Int !! self!throw(); }
    method Num(Failure:D:)        { $!handled ?? NaN !! self!throw(); }
    method Numeric(Failure:D:)    { $!handled ?? NaN !! self!throw(); }

    method Set(Failure:D:)     { $!handled ?? Set.new(self)     !! self!throw }
    method SetHash(Failure:D:) { $!handled ?? SetHash.new(self) !! self!throw }
    method Bag(Failure:D:)     { $!handled ?? Bag.new(self)     !! self!throw }
    method BagHash(Failure:D:) { $!handled ?? BagHash.new(self) !! self!throw }
    method Mix(Failure:D:)     { $!handled ?? Mix.new(self)     !! self!throw }
    method MixHash(Failure:D:) { $!handled ?? MixHash.new(self) !! self!throw }

    multi method Str(Failure:D:)  { $!handled ?? $.mess !! self!throw(); }
    multi method gist(Failure:D:) { $!handled ?? $.mess !! self!throw(); }
    multi method gist(Failure:U:) { '(' ~ self.^name ~ ')' }
    multi method perl(Failure:D:) { self.Mu::perl() }
    multi method perl(Failure:U:) { self.^name }
    method mess (Failure:D:) {
        "(HANDLED) " x $!handled ~ self.exception.message ~ "\n" ~ self.backtrace;
    }

    method sink(Failure:D:) {
        self!throw() unless $!handled
    }
    method self(Failure:D:) {
        self!throw() unless $!handled;
        self
    }
    method CALL-ME(Failure:D: |) {
        self!throw()
    }
    method FALLBACK(Failure:D: *@) {
        self!throw()
    }
    method STORE(Failure:D: *@) {
        self!throw()
    }
}

proto sub fail(|) {*};
multi sub fail(--> Nil) {
    my $stash := CALLER::;
    my $payload = $stash<$!>.DEFINITE ?? $stash<$!> !! "Failed";

    my $fail := Failure.new( $payload ~~ Exception
      ?? $payload !! X::AdHoc.new(:$payload));

    nqp::throwpayloadlexcaller(nqp::const::CONTROL_RETURN, $fail);
    CATCH { $fail.exception.throw }
}
multi sub fail(Exception:U $e --> Nil) {
    my $fail := Failure.new(
        X::AdHoc.new(:payload("Failed with undefined " ~ $e.^name))
    );
    nqp::throwpayloadlexcaller(nqp::const::CONTROL_RETURN, $fail);
    CATCH { $fail.exception.throw }
}
multi sub fail($payload --> Nil) {
    my $fail := Failure.new( $payload ~~ Exception
      ?? $payload
      !! X::AdHoc.new(:$payload)
    );
    nqp::throwpayloadlexcaller(nqp::const::CONTROL_RETURN, $fail);
    CATCH { $fail.exception.throw }
}
multi sub fail(|cap (*@msg) --> Nil) {
    my $fail := Failure.new(X::AdHoc.from-slurpy(|cap));
    nqp::throwpayloadlexcaller(nqp::const::CONTROL_RETURN, $fail);
    CATCH { $fail.exception.throw }
}
multi sub fail(Failure:U $f --> Nil) {
    my $fail := Failure.new(
        X::AdHoc.new(:payload("Failed with undefined " ~ $f.^name))
    );
    nqp::throwpayloadlexcaller(nqp::const::CONTROL_RETURN, $fail);
    CATCH { $fail.exception.throw }
}
multi sub fail(Failure:D $fail --> Nil) {
    $fail.handled = 0;
    nqp::throwpayloadlexcaller(nqp::const::CONTROL_RETURN, $fail);
    CATCH { $fail.exception.throw }
}

multi sub die(Failure:D $f --> Nil) {
    $f.exception.throw
}
multi sub die(Failure:U $f --> Nil) {
    X::AdHoc.new(:payload("Died with undefined " ~ $f.^name)).throw;
}

#line 1 SETTING::src/core/Match.pm
my class Match is Capture is Cool does NQPMatchRole {
    my Mu $EMPTY_LIST := nqp::list();
    my Mu $NO_CAPS    := nqp::hash();
    my Mu $DID_MATCH  := nqp::create(NQPdidMATCH);

    # When nothing's `made`, we get an NQPMu that we'd like to replace
    # with Nil; all Rakudo objects typecheck as Mu, while NQPMu doesn't
    method ast()  { nqp::if(nqp::istype($!made, Mu),$!made,Nil) }
    method made() { nqp::if(nqp::istype($!made, Mu),$!made,Nil) }

    method STR() {
        nqp::if(
          nqp::istype(nqp::getattr(self,Match,'$!match'), NQPdidMATCH),
          self.Str,
          self!MATCH.Str
        )
    }

    method MATCH() {
        nqp::if(
          nqp::istype(nqp::getattr(self,Match,'$!match'), NQPdidMATCH),
          self,
          self!MATCH
        )
    }

    method !MATCH() {
        my int $from = nqp::getattr_i(self, Match, '$!from');
        my int $pos  = nqp::getattr_i(self, Match, '$!pos');
        my Mu $list;
        my Mu $hash := nqp::hash();
        if nqp::isge_i($pos, $from) {
            # For captures with lists, initialize the lists.
            my $caplist := $NO_CAPS;
            my $rxsub   := nqp::getattr(self, Match, '$!regexsub');
            my str $onlyname  = '';
            my int $namecount = 0;

            if nqp::not_i(nqp::isnull($rxsub)) {
                $caplist := nqp::can($rxsub, 'CAPS') ?? nqp::findmethod($rxsub, 'CAPS')($rxsub) !! nqp::null();
                if nqp::not_i(nqp::isnull($caplist)) && nqp::istrue($caplist) {
                    my $iter := nqp::iterator($caplist);
                    my str $name;
                    while $iter {
                        $namecount = nqp::add_i($namecount, 1);
                        if nqp::iterval(nqp::shift($iter)) >= 2 {
                            $name = nqp::iterkey_s($iter);
                            $onlyname = $name if nqp::iseq_i($namecount, 1);
                            nqp::iscclass(nqp::const::CCLASS_NUMERIC, $name, 0)
                                ?? nqp::bindpos(
                                        nqp::if(nqp::isconcrete($list), $list, ($list := nqp::list())),
                                        nqp::fromstr_I($name, Int), [])
                                !! nqp::bindkey($hash, $name, []);
                        }
                    }
                }
            }

            # Walk the capture stack and populate the Match.
            my Mu $cs := nqp::getattr(self, Match, '$!cstack');
            if nqp::isnull($cs) || nqp::not_i(nqp::istrue($cs)) {}

            elsif nqp::not_i(nqp::istrue($caplist)) {}

            elsif nqp::iseq_i($namecount, 1) && nqp::isgt_i(nqp::chars($onlyname), 0) && nqp::eqat($onlyname, '$!', 0) {
                # If there's only one destination, avoid repeated hash lookups
                my int $cselems = nqp::elems($cs);
                my int $csi = -1;
                my Mu $dest;

                # numeric: <= ord("9") so positional capture
                $dest := nqp::islt_i(nqp::ord($onlyname),58)
                  ?? nqp::atpos($list, $onlyname)
                  !! nqp::atkey($hash, $onlyname);

                my $subcur;
                my str $name;
                while nqp::islt_i(++$csi,$cselems) {
                    $subcur := nqp::atpos($cs, $csi);
                    $name    = nqp::getattr_s($subcur, $?CLASS, '$!name');
                    nqp::push($dest,$subcur.MATCH())
                      if nqp::not_i(nqp::isnull_s($name));
                }
            }
            else {
                my int $cselems = nqp::elems($cs);
                my int $csi     = -1;
                my $subcur;
                my str $name;
                while nqp::islt_i(++$csi,$cselems) {
                    $subcur := nqp::atpos($cs, $csi);
                    $name    = nqp::getattr_s($subcur, $?CLASS, '$!name');
                    if nqp::not_i(nqp::isnull_s($name)) && nqp::isgt_i(nqp::chars($name), 0) {
                        my Mu $submatch := $subcur.MATCH;
                        if nqp::eqat($name, '$', 0) && (nqp::iseq_s($name, '$!from') || nqp::iseq_s($name, '$!to')) {
                            nqp::bindattr_i(self, Match, $name, $submatch.from);
                        }
                        elsif nqp::islt_i(nqp::index($name, '='), 0) {
                            my Mu $capval     := nqp::atkey($caplist, $name);
                            my int $needs_list = nqp::isconcrete($capval) && $capval >= 2;
                            if nqp::iscclass(nqp::const::CCLASS_NUMERIC, $name, 0) {
                                $list := nqp::list() unless nqp::isconcrete($list);
                                $needs_list
                                    ?? nqp::atpos($list, nqp::fromstr_I($name, Int)).append($submatch)
                                    !! nqp::bindpos($list, nqp::fromstr_I($name, Int), $submatch);
                            }
                            else {
                                $needs_list
                                    ?? nqp::atkey($hash, $name).append($submatch)
                                    !! nqp::bindkey($hash, $name, $submatch);
                            }
                        }
                        else {
                            my $names := nqp::split('=', $name);
                            my $iter  := nqp::iterator($names);
                            my Mu $capval;
                            my int $needs_list;
                            while $iter {
                                $name    = nqp::shift($iter);
                                $capval := nqp::atkey($caplist, $name);
                                $needs_list = nqp::isconcrete($capval) && $capval >= 2;
                                if nqp::iscclass(nqp::const::CCLASS_NUMERIC, $name, 0) {
                                    $list := nqp::list() unless nqp::isconcrete($list);
                                    $needs_list
                                        ?? nqp::atpos($list, nqp::fromstr_I($name, Int)).append($submatch)
                                        !! nqp::bindpos($list, nqp::fromstr_I($name, Int), $submatch);
                                }
                                else {
                                    $needs_list
                                        ?? nqp::atkey($hash, $name).append($submatch)
                                        !! nqp::bindkey($hash, $name, $submatch);
                                }
                            }
                        }
                    }
                }
            }
        }
        nqp::bindattr(self, Capture, '@!list', nqp::isconcrete($list) ?? $list !! $EMPTY_LIST);
        nqp::bindattr(self, Capture, '%!hash', $hash);
        nqp::bindattr(self, Match, '$!match', $DID_MATCH);

        # Once we've produced the captures, and if we know we're finished and
        # will never be backtracked into, we can release cstack and regexsub.
        unless nqp::defined(nqp::getattr(self, Match, '$!bstack')) {
            nqp::bindattr(self, Match, '$!cstack', nqp::null());
            nqp::bindattr(self, Match, '$!regexsub', nqp::null());
        }

        self;
    }

    method CURSOR_NEXT() {   # from !cursor_next in nqp
        nqp::if(
          nqp::defined($!restart),
          $!restart(self),
          nqp::stmts(
            (my $cur := self."!cursor_start_cur"()),
            $cur."!cursor_fail"(),
            $cur
          )
        )
    }

    method CURSOR_OVERLAP() {  # adapted from !cursor_more in nqp
        nqp::stmts(
          (my $new := nqp::create(self)),
          nqp::bindattr(  $new,$?CLASS,'$!shared',$!shared),
          nqp::bindattr(  $new,$?CLASS,'$!braid',$!braid),
          nqp::bindattr_i($new,$?CLASS,'$!from',-1),
          nqp::bindattr_i($new,$?CLASS,'$!pos',nqp::add_i($!from,1)),
          nqp::bindattr_i($new,$?CLASS,'$!to',-1),
          $!regexsub($new)
        )
    }

    method CURSOR_MORE() {  # adapted from !cursor_more in nqp
        nqp::stmts(
          (my $new := nqp::create(self)),
          nqp::bindattr(  $new,$?CLASS,'$!shared',$!shared),
          nqp::bindattr(  $new,$?CLASS,'$!braid',$!braid),
          nqp::bindattr_i($new,$?CLASS,'$!from',-1),
          nqp::bindattr_i($new,$?CLASS,'$!pos',
            nqp::if(
              nqp::isge_i($!from,$!pos),
              nqp::add_i($!from,1),
              $!pos
            )
          ),
          nqp::bindattr_i($new,$?CLASS,'$!to',-1),
          $!regexsub($new)
        )
    }

    # INTERPOLATE will iterate over the string $tgt beginning at position 0.
    # If it can't match against pattern var (or any element of var if it is an array)
    # it will increment $pos and try again. Therefore it is important to only match
    # against the current position.
    # $i is case insensitive flag
    # $m is ignore accent marks flag
    # $s is for sequential matching instead of junctive
    # $a is true if we are in an assertion

    # INTERPOLATE's parameters are non-optional since the ops for optional params
    # aren't currently JITted on MoarVM
    proto method INTERPOLATE(|) { * }

    multi method INTERPOLATE(Callable:D \var, $, $, $, $, $) {
        # Call it if it is a routine. This will capture if requested.
        (var)(self)
    }

    multi method INTERPOLATE(Iterable:D \var, int \im, int \monkey, int \s, int \a, \context) {
        my $maxmatch;
        my \cur    := self.'!cursor_start_cur'();
        my str $tgt = cur.target;
        my int $eos = nqp::chars($tgt);

        my int $maxlen = -1;
        my int $pos    = nqp::getattr_i(cur, $?CLASS, '$!from');
        my int $start  = 1;
        my int $nomod  = im == 0;

        my Mu $order := nqp::list();

        # Looks something we need to loop over
        if !nqp::iscont(var) {
            my \varlist  := var.list;
            my int $elems = varlist.elems; # reifies
            my \list     := nqp::getattr(varlist,List,'$!reified');

            # Order matters for sequential matching, so no NFA involved.
            if s {
                $order := list;
            }

            # prepare to run the NFA if var is array-ish.
            else {
                my Mu \nfa  := QRegex::NFA.new;
                my Mu \alts := nqp::setelems(nqp::list,$elems);
                my int $fate = 0;
                my int $j    = -1;

                while nqp::islt_i(++$j,$elems) {
                    my Mu $topic := nqp::atpos(list,$j);
                    nqp::bindpos(alts,$j,$topic);

                    # We are in a regex assertion, the strings we get will
                    # be treated as regex rules.
                    if a {
                        return cur.'!cursor_start_cur'()
                          if nqp::istype($topic,Associative);
                        my $rx := MAKE_REGEX($topic,im == 1 || im == 3,im == 2 || im == 3,monkey,context);
                        nfa.mergesubstates($start,0,nqp::decont($fate),
                          nqp::findmethod($rx,'NFA')($rx),
                          Mu);
                    }

                    # A Regex already.
                    elsif nqp::istype($topic,Regex) {
                        nfa.mergesubstates($start,0,nqp::decont($fate),
                          nqp::findmethod($topic,'NFA')($topic),
                          Mu);
                    }

                    # The pattern is a string.
                    else {
                        my Mu \lit  := QAST::Regex.new(
                          :rxtype<literal>, $topic,
                          :subtype( $nomod
                            ?? ''
                            !! im == 2
                              ?? im == 1
                                ?? 'ignorecase+ignoremark'
                                !! 'ignoremark'
                              !! 'ignorecase')
                        );
                        my Mu \nfa2 := QRegex::NFA.new;
                        my Mu \node := nqp::findmethod(nfa2,'addnode')(nfa2,lit);
                        nfa.mergesubstates($start,0,nqp::decont($fate),
                          nqp::findmethod(node,'save')(node,:non_empty(1)),
                          Mu);
                    }
                    ++$fate;
                }

                # Now run the NFA
                my Mu \fates := nqp::findmethod(nfa,'run')(nfa,$tgt,$pos);
                my int $count = nqp::elems(fates);
                nqp::setelems($order,$count);
                $j = -1;
                nqp::bindpos($order,$j,
                  nqp::atpos(alts,nqp::atpos_i(fates,$j)))
                  while nqp::islt_i(++$j,$count);
            }
        }

        # Use the var as it is if it's not array-ish.
        else {
            nqp::push($order, var);
        }

        my str $topic_str;
        my int $omax = nqp::elems($order);
        my int $o    = -1;
        while nqp::islt_i(++$o,$omax) {
            my Mu $topic := nqp::atpos($order,$o);
            my $match;
            my int $len;

            # We are in a regex assertion, the strings we get will be
            # treated as regex rules.
            if a {
                return cur.'!cursor_start_cur'()
                  if nqp::istype($topic,Associative);

                my $rx := MAKE_REGEX($topic,im == 1 || im == 3,im == 2 || im == 3,monkey,context);
                $match := self.$rx;
                $len    = $match.pos - $match.from;
            }

            # A Regex already.
            elsif nqp::istype($topic,Regex) {
                $match := self.$topic;
                $len    = $match.pos - $match.from;
            }

            # The pattern is a string. $len and and $topic_str are used
            # later on if this condition does not hold.
            elsif nqp::iseq_i(($len = nqp::chars($topic_str = $topic.Str)),0) {
                $match = 1;
            }

            # no modifier, match literally
            elsif $nomod {
                $match = nqp::eqat($tgt, $topic_str, $pos);
            }


            # ignoremark+ignorecase
            elsif im == 3 {
                $match = nqp::eqaticim($tgt, $topic_str, $pos);
            }

            # ignoremark
            elsif im == 2 {
                $match = nqp::eqatim($tgt, $topic_str, $pos);
            }

            # ignorecase
            elsif im == 1 {
                $match = nqp::eqatic($tgt, $topic_str, $pos);
            }











































            if $match
              && nqp::isgt_i($len,$maxlen)
              && nqp::isle_i(nqp::add_i($pos,$len),$eos) {
                $maxlen    = $len;
                $maxmatch := $match;
                last if s; # stop here for sequential alternation
            }
        }

        nqp::istype($maxmatch, Match)
          ?? $maxmatch
          !! nqp::isge_i($maxlen,0)
            ?? cur.'!cursor_pass'(nqp::add_i($pos,$maxlen), '')
            !! cur
    }

    multi method INTERPOLATE(Associative:D \var, int \im, $, $, int \a, \context) {
        my \cur    := self.'!cursor_start_cur'();
        if a {
            return cur.'!cursor_start_cur'()
        }
        my $maxmatch;
        my str $tgt = cur.target;

        my int $maxlen = -1;
        my int $pos    = nqp::getattr_i(cur, $?CLASS, '$!from');

        my str $topic_str;
        my $match;
        my int $len;

        # The pattern is a string. $len and and $topic_str are used
        # later on if this condition does not hold.
        if nqp::iseq_i(($len = nqp::chars($topic_str = var.Str)),0) {
            $match = 1;
        }

        # no modifier, match literally
        elsif im == 0 {
            $match = nqp::eqat($tgt, $topic_str, $pos);
        }


        # ignoremark+ignorecase
        elsif im == 3 {
            $match = nqp::eqaticim($tgt, $topic_str, $pos);
        }

        # ignoremark
        elsif im == 2 {
            $match = nqp::eqatim($tgt, $topic_str, $pos);
        }

        # ignorecase
        elsif im == 1 {
            $match = nqp::eqatic($tgt, $topic_str, $pos);
        }











































        if $match
          && nqp::isgt_i($len,$maxlen)
          && nqp::isle_i(nqp::add_i($pos,$len),nqp::chars($tgt)) {
            $maxlen    = $len;
            $maxmatch := $match;
        }

        nqp::istype($maxmatch, Match)
          ?? $maxmatch
          !! nqp::isge_i($maxlen,0)
            ?? cur.'!cursor_pass'(nqp::add_i($pos,$maxlen), '')
            !! cur
    }

    multi method INTERPOLATE(Regex:D \var, int \im, int \monkey, $, int \a, $) {
        my $maxmatch;
        my \cur    := self.'!cursor_start_cur'();

        my int $maxlen = -1;
        my int $pos    = nqp::getattr_i(cur, $?CLASS, '$!from');
        my Mu $topic := var;
        my $match := self.$topic;

        if $match {
            my int $len = $match.pos - $match.from;

            if nqp::isgt_i($len,$maxlen)
               && nqp::isle_i(nqp::add_i($pos,$len),nqp::chars(cur.target)) {
                $maxlen    = $len;
                $maxmatch := $match;
            }
        }

        nqp::istype($maxmatch, Match)
          ?? $maxmatch
          !! nqp::isge_i($maxlen,0)
            ?? cur.'!cursor_pass'(nqp::add_i($pos,$maxlen), '')
            !! cur
    }

    multi method INTERPOLATE(Mu:D \var, int \im, int \monkey, $, int \a, \context) {
        my $maxmatch;
        my \cur     = self.'!cursor_start_cur'();
        my str $tgt = cur.target;

        my int $maxlen = -1;
        my int $pos    = nqp::getattr_i(cur, $?CLASS, '$!from');

        my str $topic_str;
        my $match;
        my int $len;

        # We are in a regex assertion, the strings we get will be
        # treated as regex rules.
        if a {
            my $rx := MAKE_REGEX(var,im == 1 || im == 3,im == 2 || im == 3,monkey,context);
            $match := self.$rx;
            $len    = $match.pos - $match.from;
        }

        # The pattern is a zero length string. $len and and $topic_str
        # are used later on if this condition does not hold.
        elsif nqp::iseq_i(($len = nqp::chars($topic_str = var.Str)),0) {
            $match = 1;
        }

        # no modifier, match literally
        elsif im == 0 {
            $match = nqp::eqat($tgt, $topic_str, $pos);
        }


        # ignoremark+ignorecase
        elsif im == 3 {
            $match = nqp::eqaticim($tgt, $topic_str, $pos);
        }

        # ignoremark
        elsif im == 2 {
            $match = nqp::eqatim($tgt, $topic_str, $pos);
        }

        # ignorecase
        elsif im == 1 {
            $match = nqp::eqatic($tgt, $topic_str, $pos);
        }











































        if $match
          && nqp::isgt_i($len,$maxlen)
          && nqp::isle_i(nqp::add_i($pos,$len),nqp::chars($tgt)) {
            $maxlen    = $len;
            $maxmatch := $match;
        }

        nqp::istype($maxmatch, Match)
          ?? $maxmatch
          !! nqp::isge_i($maxlen,0)
            ?? cur.'!cursor_pass'(nqp::add_i($pos,$maxlen), '')
            !! cur
    }

    multi method INTERPOLATE(Mu:U \var, $, $, $, $, $) {
        self."!cursor_start_cur"()
    }

    method CALL_SUBRULE($rule, |c) {
        $rule(self, |c)
    }

    method DYNQUANT_LIMITS($mm) {
        # Treat non-Range values as range with that value on both end points
        # Throw for non-Numeric or NaN Ranges, or if minimum limit is +Inf
        # Convert endpoints that are less than 0 to 0, then,
        # throw if Range is empty.
        nqp::if(
          nqp::istype($mm,Range),
          nqp::if(
               nqp::isfalse(nqp::istype((my $min := $mm.min),Numeric))
            || nqp::isfalse(nqp::istype((my $max := $mm.max),Numeric))
            || $min.isNaN || $max.isNaN,
            X::Syntax::Regex::QuantifierValue.new(:non-numeric-range).throw,
            nqp::if(
              $min == Inf,
              X::Syntax::Regex::QuantifierValue.new(:inf).throw,
              nqp::stmts(
                nqp::if(
                  nqp::islt_i(
                    ($min := nqp::add_i($min == -Inf ?? -1 !! $min.Int,
                      $mm.excludes-min)),
                    0),
                  $min := 0),
                nqp::if(
                  $max == Inf,
                  nqp::list_i($min,-1),
                  nqp::stmts(
                    nqp::if(
                      $max == -Inf || nqp::islt_i(
                        ($max := nqp::sub_i($max.Int,$mm.excludes-max)),0),
                      $max := 0),
                    nqp::if(
                      nqp::islt_i($max, $min),
                      X::Syntax::Regex::QuantifierValue.new(:empty-range).throw,
                      nqp::list_i($min,$max))))))),
          nqp::if(
            nqp::istype((my $v := $mm.Int), Failure),
            nqp::stmts(
              ($v.so), # handle Failure
              nqp::if(
                nqp::istype($mm,Numeric) && nqp::isfalse($mm.isNaN),
                nqp::if(
                  $mm == Inf,
                  X::Syntax::Regex::QuantifierValue.new(:inf).throw,
                  nqp::list_i(0,0)), # if we got here, $mm is -Inf, treat as zero
                X::Syntax::Regex::QuantifierValue.new(:non-numeric).throw)),
            nqp::if(
              nqp::islt_i($v,0),
              nqp::list_i(0,0),
              nqp::list_i($v,$v))))
    }

    method OTHERGRAMMAR($grammar, $name, |) {
        my $lang_cursor := $grammar.'!cursor_init'(self.target(), :p(self.pos()));
        $lang_cursor.clone_braid_from(self);
        $lang_cursor."$name"();
    }

    method INDMETHOD($name, |c) {
        self."$name"(|c);
    }

    method INDRULE($rule, |c) {
        $rule(self, |c)
    }

    method RECURSE() {
        nqp::getlexdyn('$?REGEX')(self)
    }

    sub MAKE_REGEX($arg, int $i, int $m, int $monkey, $context) {
        my role CachedCompiledRegex {
            has $.regex;
        }
        if nqp::istype($arg,Regex) {
            $arg
        }
        elsif nqp::istype($arg, CachedCompiledRegex) {
            $arg.regex
        }
        else {
            my $*RESTRICTED = "Prohibited regex interpolation"
             unless $monkey;  # Comes from when regex was originally compiled.

            my $rx := $i
              ?? $m
                ?? EVAL("anon regex \{ :i :m $arg\}", :$context)
                !! EVAL("anon regex \{ :i $arg\}",    :$context)
              !! $m
                ?? EVAL("anon regex \{ :m $arg\}",    :$context)
                !! EVAL("anon regex \{ $arg\}",       :$context);
            $arg does CachedCompiledRegex($rx);
            $rx
        }
    }

    submethod BUILD(
        :$orig = '',
        :$from = 0,
        :to(:$pos),
        :ast(:$made),
        :$shared,
        :$braid,
        :$list,
        :$hash)
    {
        # :build tells !cursor_init that it's too late to do a CREATE
        self.'!cursor_init'($orig, :build, :p($pos), :$shared, :$braid);
        nqp::bindattr_i(self, Match,   '$!from', $from);
        nqp::bindattr(  self, Match,   '$!made', nqp::decont($made)) if $made.defined;
    }

    method clone() {
        my $new := nqp::clone(self);
        $new;
    }

    multi method WHICH (Match:D:) {
        self.Mu::WHICH # skip Capture's as Match is not a value type
    }

    proto method Bool(|) { * }
    multi method Bool(Match:U:) { False }
    multi method Bool(Match:D:) { nqp::p6bool($!pos >= $!from) }

    multi method Numeric(Match:D:) {
        self.Str.Numeric
    }
    multi method ACCEPTS(Match:D: Any $) { self }

    method prematch(Match:D:) {
        nqp::substr(self.target,0,$!from)
    }
    method postmatch(Match:D:) {
        nqp::substr(self.target,self.to)
    }

    method caps(Match:D:) {
        my @caps;
        for self.pairs -> $p {
            if nqp::istype($p.value,Array) {
                @caps.push: $p.key => $_ for $p.value.list
            } elsif $p.value.DEFINITE {
                @caps.push: $p
            }
        }
        @caps.sort: -> $a { $a.value.from +< 32 + $a.value.pos }
    }

    method chunks(Match:D:) {
        my $prev = $!from;
        my $target := self.target;
        gather {
            for self.caps {
                if .value.from > $prev {
                    take '~' => substr($target,$prev, .value.from - $prev)
                }
                take $_;
                $prev = .value.pos;
            }
            take '~' => substr($target,$prev, $!pos - $prev) if $prev < $!pos;
        }
    }

    multi method perl(Match:D:) {
        my %attrs;
        %attrs.ASSIGN-KEY("orig", (self.orig // '' ).perl);
        %attrs.ASSIGN-KEY("from", (self.from // 0  ).perl);
        %attrs.ASSIGN-KEY("pos",  (self.pos  // 0  ).perl);
        %attrs.ASSIGN-KEY("made", (self.made // Any).perl);
        %attrs.ASSIGN-KEY("list", (self.Capture::list // [] ).perl);
        %attrs.ASSIGN-KEY("hash", (self.Capture::hash // {} ).perl);

        'Match.new('
            ~ %attrs.fmt('%s => %s', ', ')
            ~ ')'
    }
    multi method gist (Match:D: $d = 0) {
        return "#<failed match>" unless self;
        my $s = ' ' x ($d + 1);
        my $r = ("=> " if $d) ~ "\x[FF62]{self}\x[FF63]\n";
        for @.caps {
            $r ~= $s ~ (.key // '?') ~ ' ' ~ .value.gist($d + 1)
        }
        $d == 0 ?? $r.chomp !! $r;
    }

}

multi sub infix:<eqv>(Match:D \a, Match:D \b) {
    a =:= b
    ||
    [&&] (
        a.pos  eqv b.pos,
        a.from eqv b.from,
        a.orig eqv b.orig,
        (a.made // Any) eqv (b.made // Any),
        (a.Capture::list // nqp::list ) eqv (b.Capture::list // nqp::list ),
        (a.Capture::hash // nqp::hash ) eqv (b.Capture::hash // nqp::hash )
    );
}


sub make(Mu \made) {
    my $slash := nqp::getlexcaller('$/');
    nqp::bindattr( nqp::decont($slash),        Match,  '$!made', made );
}


#line 1 SETTING::src/core/Cursor.pm
my constant Cursor = Match;

#line 1 SETTING::src/core/Grammar.pm
my class Grammar is Match {

    method parse(\target, :$rule, :$args, Mu :$actions, :$filename) is raw {
        my $*LINEPOSCACHE;
        nqp::stmts(
          (my $grammar := self.new(:orig(target), |%_).set_actions($actions)),
          nqp::decont(nqp::getlexcaller('$/') =
            nqp::if(
              (my $cursor := nqp::if(
                $rule,
                nqp::if(
                  $args,
                  $grammar."$rule"(|$args.Capture),
                  $grammar."$rule"()
                ),
                nqp::if(
                  $args,
                  $grammar.TOP(|$args.Capture),
                  $grammar.TOP()
                ),
              )),
              nqp::stmts(
                (my $match := $cursor.MATCH),
                nqp::while(
                  $match && nqp::isne_i(
                    nqp::getattr_i(($match := $cursor.MATCH),Match,'$!pos'),
                    target.chars
                  ),
                  $match := ($cursor := $cursor.'!cursor_next'()).MATCH
                ),
                $match || Nil
              ),
              Nil
            )
          )
        )
    }

    method subparse(\target, :$rule, :$args, :$actions) is raw {
        nqp::stmts(
          (my $grammar := self.new(:orig(target), |%_).set_actions($actions)),
          nqp::decont(nqp::getlexcaller('$/') =
            nqp::if(
              $rule,
              nqp::if(
                $args,
                $grammar."$rule"(|$args.Capture).MATCH,
                $grammar."$rule"().MATCH,
              ),
              nqp::if(
                $args,
                $grammar.TOP(|$args.Capture).MATCH,
                $grammar.TOP().MATCH
              ),
            )
          )
        )
      }

    method parsefile(Str(Cool) $filename, :$enc) is raw {
        nqp::decont(nqp::getlexcaller('$/') = nqp::if(
          nqp::elems(nqp::getattr(%_,Map,'$!storage')),
          self.parse($filename.IO.slurp(:$enc), :$filename, |%_),
          self.parse($filename.IO.slurp(:$enc), :$filename)
        ))
    }
}

#line 1 SETTING::src/core/Regex.pm
my class Regex { # declared in BOOTSTRAP
    # class Regex is Method
    #     has @!caps;
    #     has Mu $!nfa;
    #     has %!alt_nfas;
    #     has str $!source;

    # cache cursor initialization lookup
    my $cursor-init := Match.^lookup("!cursor_init");

    proto method ACCEPTS(|) { * }
    multi method ACCEPTS(Regex:D: Mu:U \a) {
        False
    }

    # use of Any on topic to force autothreading
    # so that all(@foo) ~~ Type works as expected
    multi method ACCEPTS(Regex:U: Any \topic) {
        nqp::p6bool(nqp::istype(topic, self))
    }

    multi method ACCEPTS(Regex:D \SELF: Any \topic) {
        nqp::decont(
          nqp::getlexrelcaller(nqp::ctxcallerskipthunks(nqp::ctx()),'$/') =
          nqp::stmts(
            (my \cursor := SELF.($cursor-init(Match, topic, :c(0)))),
            nqp::if(
              nqp::isge_i(nqp::getattr_i(cursor,Match,'$!pos'),0),
              cursor.MATCH,
              Nil
            )
          )
        )
    }


    multi method ACCEPTS(Regex:D \SELF: Uni:D \uni) {  # RT #130458
        self.ACCEPTS(uni.Str)
    }


    multi method ACCEPTS(Regex:D \SELF: @a) {
        SELF!ACCEPT-ITERATOR(
          nqp::getlexrelcaller(nqp::ctxcallerskipthunks(nqp::ctx()),'$/'),
          @a.iterator
        )
    }

    multi method ACCEPTS(Regex:D \SELF: %h) {
        SELF!ACCEPT-ITERATOR(
          nqp::getlexrelcaller(nqp::ctxcallerskipthunks(nqp::ctx()),'$/'),
          %h.keys.iterator
        )
    }

    method !ACCEPT-ITERATOR(Regex:D \SELF: \slash, Iterator:D \iter) {
        nqp::decont(slash =
          nqp::stmts(
            nqp::until(
              nqp::eqaddr(                                 # nothing to check?
                (my $pulled := iter.pull-one),IterationEnd)
                || nqp::isge_i(                            # valid match?
                     nqp::getattr_i(
                       (my \cursor := SELF.($cursor-init(Match,$pulled,:0c))),
                       Match,'$!pos'),
                   0),
              nqp::null
            ),
            nqp::if(
              nqp::eqaddr($pulled,IterationEnd),
              Nil,               # no match found
              cursor.MATCH       # found it!
            )
          )
        )
    }

    multi method Bool(Regex:D:) {
        nqp::stmts(
          (my $ctx := nqp::ctx),
          nqp::until(
            nqp::isnull($ctx := nqp::ctxcallerskipthunks($ctx))
              || (my $underscore := nqp::getlexrelcaller($ctx,'$_')).DEFINITE,
            nqp::null
          ),
          nqp::if(
            nqp::isnull($ctx),
            False,
            nqp::stmts(
              (my $slash := nqp::getlexrelcaller($ctx,'$/')),
              ($slash = $underscore.match(self)).Bool
            )
          )
        )
    }

    multi method gist(Regex:D:) {
        nqp::ifnull($!source,'')
    }

    multi method perl(Regex:D:) {
        nqp::ifnull($!source,'')
    }
}

multi sub infix:<~~>(Mu \topic, Regex:D \matcher) {
    $/ := nqp::getlexrelcaller(nqp::ctxcallerskipthunks(nqp::ctx()),'$/');
    matcher.ACCEPTS(topic)
}

#line 1 SETTING::src/core/allomorphs.pm
# the uses of add_I in this class are a trick to make bigints work right
my class IntStr is Int is Str {
    method new(Int $i, Str $s) {
        my \SELF = nqp::add_I($i, 0, self);
        nqp::bindattr_s(SELF, Str, '$!value', $s);
        SELF;
    }
    multi method ACCEPTS(IntStr:D: Any:D \a) {
        nqp::if(
          nqp::istype(a, Numeric),
            self.Int.ACCEPTS(a),
          nqp::if(
            nqp::istype(a, Str),
            self.Str.ACCEPTS(a),
            self.Str.ACCEPTS(a) && self.Int.ACCEPTS(a)))
    }
    multi method Numeric(IntStr:D:) { self.Int }
    method Int(IntStr:D:) { nqp::add_I(self, 0, Int) }
    multi method Str(IntStr:D:) { nqp::getattr_s(self, Str, '$!value') }

    multi method perl(IntStr:D:) { self.^name ~ '.new(' ~ self.Int.perl ~ ', ' ~ self.Str.perl ~ ')' }
}

my class NumStr is Num is Str {
    method new(Num $n, Str $s) {
        my \SELF = nqp::create(self);
        nqp::bindattr_n(SELF, Num, '$!value', $n);
        nqp::bindattr_s(SELF, Str, '$!value', $s);
        SELF;
    }
    multi method ACCEPTS(NumStr:D: Any:D \a) {
        nqp::if(
          nqp::istype(a, Numeric),
          self.Num.ACCEPTS(a),
          nqp::if(
            nqp::istype(a, Str),
            self.Str.ACCEPTS(a),
            self.Str.ACCEPTS(a) && self.Num.ACCEPTS(a)))
    }
    multi method Numeric(NumStr:D:) { self.Num }
    method Num(NumStr:D:) { nqp::getattr_n(self, Num, '$!value') }
    multi method Str(NumStr:D:) { nqp::getattr_s(self, Str, '$!value') }

    multi method perl(NumStr:D:) { self.^name ~ '.new(' ~ self.Num.perl ~ ', ' ~ self.Str.perl ~ ')' }
}

my class RatStr is Rat is Str {
    method new(Rat $r, Str $s) {
        my \SELF = nqp::create(self);
        nqp::bindattr(SELF, Rat, '$!numerator', $r.numerator);
        nqp::bindattr(SELF, Rat, '$!denominator', $r.denominator);
        nqp::bindattr_s(SELF, Str, '$!value', $s);
        SELF;
    }
    multi method ACCEPTS(RatStr:D: Any:D \a) {
        nqp::if(
          nqp::istype(a, Numeric),
          self.Rat.ACCEPTS(a),
          nqp::if(
            nqp::istype(a, Str),
            self.Str.ACCEPTS(a),
            self.Str.ACCEPTS(a) && self.Rat.ACCEPTS(a)))
    }
    method Capture(RatStr:D:) { self.Mu::Capture }
    multi method Numeric(RatStr:D:) { self.Rat }
    method Rat(RatStr:D:) { Rat.new(nqp::getattr(self, Rat, '$!numerator'), nqp::getattr(self, Rat, '$!denominator')) }
    multi method Str(RatStr:D:) { nqp::getattr_s(self, Str, '$!value') }

    multi method perl(RatStr:D:) { self.^name ~ '.new(' ~ self.Rat.perl ~ ', ' ~ self.Str.perl ~ ')' }
}

my class ComplexStr is Complex is Str {
    method new(Complex $c, Str $s) {
        my \SELF = nqp::create(self);
        nqp::bindattr_n(SELF, Complex, '$!re', $c.re);
        nqp::bindattr_n(SELF, Complex, '$!im', $c.im);
        nqp::bindattr_s(SELF, Str, '$!value', $s);
        SELF;
    }
    multi method ACCEPTS(ComplexStr:D: Any:D \a) {
        nqp::if(
          nqp::istype(a, Numeric),
          self.Complex.ACCEPTS(a),
          nqp::if(
            nqp::istype(a, Str),
            self.Str.ACCEPTS(a),
            self.Str.ACCEPTS(a) && self.Complex.ACCEPTS(a)))
    }
    method Capture(ComplexStr:D:) { self.Mu::Capture }
    multi method Numeric(ComplexStr:D:) { self.Complex }
    method Complex(ComplexStr:D:) { Complex.new(nqp::getattr_n(self, Complex, '$!re'), nqp::getattr_n(self, Complex, '$!im')) }
    multi method Str(ComplexStr:D:) { nqp::getattr_s(self, Str, '$!value') }

    multi method perl(ComplexStr:D:) { self.^name ~ '.new(' ~ self.Complex.perl ~ ', ' ~ self.Str.perl ~ ')' }
}

# we define cmp ops for these allomorphic types as numeric first, then Str. If
# you want just one half of the cmp, you'll need to coerce the args
multi sub infix:<cmp>(IntStr:D     $a, IntStr:D     $b) { $a.Int     cmp $b.Int     || $a.Str cmp $b.Str }
multi sub infix:<cmp>(IntStr:D     $a, RatStr:D     $b) { $a.Int     cmp $b.Rat     || $a.Str cmp $b.Str }
multi sub infix:<cmp>(IntStr:D     $a, NumStr:D     $b) { $a.Int     cmp $b.Num     || $a.Str cmp $b.Str }
multi sub infix:<cmp>(IntStr:D     $a, ComplexStr:D $b) { $a.Int     cmp $b.Complex || $a.Str cmp $b.Str }

multi sub infix:<cmp>(RatStr:D     $a, IntStr:D     $b) { $a.Rat     cmp $b.Int     || $a.Str cmp $b.Str }
multi sub infix:<cmp>(RatStr:D     $a, RatStr:D     $b) { $a.Rat     cmp $b.Rat     || $a.Str cmp $b.Str }
multi sub infix:<cmp>(RatStr:D     $a, NumStr:D     $b) { $a.Rat     cmp $b.Num     || $a.Str cmp $b.Str }
multi sub infix:<cmp>(RatStr:D     $a, ComplexStr:D $b) { $a.Rat     cmp $b.Complex || $a.Str cmp $b.Str }

multi sub infix:<cmp>(NumStr:D     $a, IntStr:D     $b) { $a.Num     cmp $b.Int     || $a.Str cmp $b.Str }
multi sub infix:<cmp>(NumStr:D     $a, RatStr:D     $b) { $a.Num     cmp $b.Rat     || $a.Str cmp $b.Str }
multi sub infix:<cmp>(NumStr:D     $a, NumStr:D     $b) { $a.Num     cmp $b.Num     || $a.Str cmp $b.Str }
multi sub infix:<cmp>(NumStr:D     $a, ComplexStr:D $b) { $a.Num     cmp $b.Complex || $a.Str cmp $b.Str }

multi sub infix:<cmp>(ComplexStr:D $a, IntStr:D     $b) { $a.Complex cmp $b.Int     || $a.Str cmp $b.Str }
multi sub infix:<cmp>(ComplexStr:D $a, RatStr:D     $b) { $a.Complex cmp $b.Rat     || $a.Str cmp $b.Str }
multi sub infix:<cmp>(ComplexStr:D $a, NumStr:D     $b) { $a.Complex cmp $b.Num     || $a.Str cmp $b.Str }
multi sub infix:<cmp>(ComplexStr:D $a, ComplexStr:D $b) { $a.Complex cmp $b.Complex || $a.Str cmp $b.Str }


multi sub infix:<eqv>(IntStr:D     $a, IntStr:D     $b) { $a.Int     eqv $b.Int     && $a.Str eqv $b.Str }
multi sub infix:<eqv>(IntStr:D     $a, RatStr:D     $b --> False) {}
multi sub infix:<eqv>(IntStr:D     $a, NumStr:D     $b --> False) {}
multi sub infix:<eqv>(IntStr:D     $a, ComplexStr:D $b --> False) {}

multi sub infix:<eqv>(RatStr:D     $a, IntStr:D     $b --> False) {}
multi sub infix:<eqv>(RatStr:D     $a, RatStr:D     $b) { $a.Rat     eqv $b.Rat     && $a.Str eqv $b.Str }
multi sub infix:<eqv>(RatStr:D     $a, NumStr:D     $b --> False) {}
multi sub infix:<eqv>(RatStr:D     $a, ComplexStr:D $b --> False) {}

multi sub infix:<eqv>(NumStr:D     $a, IntStr:D     $b --> False) {}
multi sub infix:<eqv>(NumStr:D     $a, RatStr:D     $b --> False) {}
multi sub infix:<eqv>(NumStr:D     $a, NumStr:D     $b) { $a.Num     eqv $b.Num     && $a.Str eqv $b.Str }
multi sub infix:<eqv>(NumStr:D     $a, ComplexStr:D $b --> False) {}

multi sub infix:<eqv>(ComplexStr:D $a, IntStr:D     $b --> False) {}
multi sub infix:<eqv>(ComplexStr:D $a, RatStr:D     $b --> False) {}
multi sub infix:<eqv>(ComplexStr:D $a, NumStr:D     $b --> False) {}
multi sub infix:<eqv>(ComplexStr:D $a, ComplexStr:D $b) { $a.Complex eqv $b.Complex && $a.Str eqv $b.Str }

multi sub infix:<===>(IntStr:D $a, IntStr:D $b) {
    $a.Int === $b.Int && $a.Str === $b.Str
}
multi sub infix:<===>(RatStr:D $a, RatStr:D $b) {
    $a.Rat === $b.Rat && $a.Str === $b.Str
}
multi sub infix:<===>(NumStr:D $a, NumStr:D $b) {
    $a.Num === $b.Num && $a.Str === $b.Str
}
multi sub infix:<===>(ComplexStr:D $a, ComplexStr:D $b) {
    $a.Complex === $b.Complex && $a.Str === $b.Str
}

multi sub val(*@maybevals) {
    @maybevals.list.map({ val($_) }).eager;
}

multi sub val(Mu) {
    warn "Value of type Mu uselessly passed to val()";
    Mu
}

# needed to preserve slip-ness
multi sub val(Slip:D $maybevals) {
    val(|$maybevals).Slip
}

multi sub val(Pair:D \ww-thing) is raw {
    # this is a Pair object possible in  constructs; just pass it through. We
    # capture this specially from the below sub to avoid emitting a warning
    # whenever an affected  construct is being processed.

    ww-thing
}

multi sub val(\one-thing) {
    warn "Value of type {one-thing.WHAT.perl} uselessly passed to val()";
    one-thing;
}

multi sub val(Str:D $MAYBEVAL, :$val-or-fail) {
    # TODO:
    # * Additional numeric styles:
    #   + fractions in [] radix notation:  :100[10,'.',53]
    # * Performance tuning
    # * Fix remaining XXXX

    my str $str = nqp::unbox_s($MAYBEVAL);
    my int $eos = nqp::chars($str);
    return IntStr.new(0,"") unless $eos;  # handle ""

    # S02:3276-3277: Ignore leading and trailing whitespace
    my int $pos = nqp::findnotcclass(nqp::const::CCLASS_WHITESPACE,
                                              $str, 0, $eos);
    my int $end = nqp::sub_i($eos, 1);

    $end = nqp::sub_i($end, 1)
        while nqp::isge_i($end, $pos)
           && nqp::iscclass(nqp::const::CCLASS_WHITESPACE, $str, $end);

    # Fail all the way out when parse failures occur. Return the original
    # string, or a failure if we're Str.Numeric
    my &parse_fail := -> \msg {
        $val-or-fail
          ?? fail X::Str::Numeric.new(:source($MAYBEVAL),:reason(msg),:$pos)
          !! return $MAYBEVAL
    }

    # Str.Numeric should handle blank string before val()
    parse_fail "Empty string not properly caught before val()" if nqp::islt_i($end, $pos);

    # Reset end-of-string after trimming
    $eos = nqp::add_i($end, 1);

    # return an appropriate type when we've found a number. Allomorphic unless
    # Str.Numeric is calling
    my &parse_win := -> \newval {
        $val-or-fail
          ?? return newval
          !! nqp::istype(newval, Num)
            ?? return NumStr.new(newval, $MAYBEVAL)
            !! nqp::istype(newval, Rat)
              ?? return RatStr.new(newval, $MAYBEVAL)
              !! nqp::istype(newval, Complex)
                ?? return ComplexStr.new(newval, $MAYBEVAL)
                !! nqp::istype(newval, Int)
                  ?? return IntStr.new(newval, $MAYBEVAL)
                  !! die "Unknown type {newval.^name} found in val() processing"
    }

    my sub parse-simple-number() {
        # Handle NaN here, to make later parsing simpler
        if nqp::eqat($str,'NaN',$pos) {
            $pos = nqp::add_i($pos, 3);
            return nqp::p6box_n(nqp::nan());
        }

        # Handle any leading +/-/ sign
        my int $ch  = nqp::ord($str, $pos);
        my int $neg = nqp::iseq_i($ch, 45) || nqp::iseq_i($ch, 8722); # '-', ''
        if $neg || nqp::iseq_i($ch, 43) {  # '-', '', '+'
            $pos = nqp::add_i($pos, 1);
            $ch  = nqp::islt_i($pos, $eos) && nqp::ord($str, $pos);
        }

        # nqp::radix_I parse results, and helper values
        my Mu  $parse;
        my str $prefix;
        my int $radix;
        my int $p;

        my sub parse-int-frac-exp() {
            # Integer part, if any
            my Int $int := 0;
            if nqp::isne_i($ch, 46) {  # '.'
                parse_fail "Cannot convert radix of $radix (max 36)"
                    if nqp::isgt_i($radix, 36);
                $parse := nqp::radix_I($radix, $str, $pos, $neg, Int);
                $p      = nqp::atpos($parse, 2);
                parse_fail "base-$radix number must begin with valid digits or '.'"
                    if nqp::iseq_i($p, -1);
                $pos    = $p;

                $int   := nqp::atpos($parse, 0);
                nqp::isge_i($pos, $eos)
                  ??  return $int
                  !!  ($ch = nqp::ord($str, $pos));
            }

            # Fraction, if any
            my Int $frac := 0;
            my Int $base := 0;
            if nqp::iseq_i($ch, 46) {  # '.'
                $pos    = nqp::add_i($pos, 1);
                $parse := nqp::radix_I($radix, $str, $pos,
                                       nqp::add_i($neg, 4), Int);
                $p      = nqp::atpos($parse, 2);
                parse_fail 'radix point must be followed by one or more valid digits'
                    if nqp::iseq_i($p, -1);
                $pos    = $p;

                $frac  := nqp::atpos($parse, 0);
                $base  := nqp::atpos($parse, 1);
                $ch     = nqp::islt_i($pos, $eos) && nqp::ord($str, $pos);
            }

            # Exponent, if 'E' or 'e' are present (forces return type Num)
            if nqp::iseq_i($ch, 69) || nqp::iseq_i($ch, 101) {  # 'E', 'e'
                parse_fail "'E' or 'e' style exponent only allowed on decimal (base-10) numbers, not base-$radix"
                    unless nqp::iseq_i($radix, 10);

                $pos = nqp::add_i($pos, 1);
                # handle the sign
                # XXX TODO: teach radix_I to handle '' (U+2212) minus?
                my int $ch  = nqp::islt_i($pos, $eos) && nqp::ord($str, $pos);
                my int $neg-e = nqp::if(
                    nqp::iseq_i($ch, 43), # '+'
                    nqp::stmts(($pos = nqp::add_i($pos, 1)), 0),
                    nqp::if( # '-', ''
                        nqp::iseq_i($ch, 45) || nqp::iseq_i($ch, 8722),
                        nqp::stmts(($pos = nqp::add_i($pos, 1)), 1),
                        0,
                    )
                );

                $parse := nqp::radix_I(10, $str, $pos, $neg-e, Int);
                $p      = nqp::atpos($parse, 2);
                parse_fail "'E' or 'e' must be followed by decimal (base-10) integer"
                    if nqp::iseq_i($p, -1);
                $pos    = $p;

                return nqp::p6box_n(nqp::mul_n(
                    $frac ?? nqp::add_n( $int.Num, nqp::div_n($frac.Num, $base.Num) )
                          !! $int.Num,
                    nqp::pow_n(10e0, nqp::atpos($parse, 0).Num)
                )) # if we have a zero, handle the sign correctly
                || nqp::if(nqp::iseq_i($neg, 1), -0e0, 0e0);
            }

            # Multiplier with exponent, if single '*' is present
            # (but skip if current token is '**', as otherwise we
            # get recursive multiplier parsing stupidity)
            if nqp::iseq_i($ch, 42)
            && nqp::isne_s(substr($str, $pos, 2), '**') {  # '*'
                $pos           = nqp::add_i($pos, 1);
                my $mult_base := parse-simple-number();

                parse_fail "'*' multiplier base must be an integer"
                    unless nqp::istype($mult_base, Int);
                parse_fail "'*' multiplier base must be followed by '**' and exponent"
                    unless nqp::eqat($str,'**',$pos);

                $pos           = nqp::add_i($pos, 2);
                my $mult_exp  := parse-simple-number();

                parse_fail "'**' multiplier exponent must be an integer"
                    unless nqp::istype($mult_exp, Int);

                my $mult := $mult_base ** $mult_exp;
                $int     := $int  * $mult;
                $frac    := $frac * $mult;
            }

            # Return an Int if there was no radix point, otherwise, return a Rat
            nqp::unless($base, $int, Rat.new($int * $base + $frac, $base));
        }

        # Look for radix specifiers
        if nqp::iseq_i($ch, 58) {  # ':'
            # A string of the form :16<FE_ED.F0_0D> or :60[12,34,56]
            $pos    = nqp::add_i($pos, 1);
            $parse := nqp::radix_I(10, $str, $pos, 0, Int);
            $p      = nqp::atpos($parse, 2);
            parse_fail "radix (in decimal) expected after ':'"
                if nqp::iseq_i($p, -1);
            $pos    = $p;

            $radix  = nqp::atpos($parse, 0);
            $ch     = nqp::islt_i($pos, $eos) && nqp::ord($str, $pos);
            if nqp::iseq_i($ch, 60) {  # '<'
                $pos = nqp::add_i($pos, 1);

                my $result := parse-int-frac-exp();

                parse_fail "malformed ':$radix<>' style radix number, expecting '>' after the body"
                    unless nqp::islt_i($pos, $eos)
                        && nqp::iseq_i(nqp::ord($str, $pos), 62);  # '>'

                $pos = nqp::add_i($pos, 1);
                return $result;
            }
            elsif nqp::iseq_i($ch, 171) {  # ''
                $pos = nqp::add_i($pos, 1);

                my $result := parse-int-frac-exp();

                parse_fail "malformed ':$radix' style radix number, expecting '' after the body"
                    unless nqp::islt_i($pos, $eos)
                        && nqp::iseq_i(nqp::ord($str, $pos), 187);  # ''

                $pos = nqp::add_i($pos, 1);
                return $result;
            }
            elsif nqp::iseq_i($ch, 91) {  # '['
                $pos = nqp::add_i($pos, 1);
                my Int $result := 0;
                my Int $digit  := 0;
                while nqp::islt_i($pos, $eos)
                   && nqp::isne_i(nqp::ord($str, $pos), 93) {  # ']'
                    $parse := nqp::radix_I(10, $str, $pos, 0, Int);
                    $p      = nqp::atpos($parse, 2);
                    parse_fail "malformed ':$radix[]' style radix number, expecting comma separated decimal values after opening '['"
                        if nqp::iseq_i($p, -1);
                    $pos    = $p;

                    $digit := nqp::atpos($parse, 0);
                    parse_fail "digit is larger than {$radix - 1} in ':$radix[]' style radix number"
                        if nqp::isge_i($digit, $radix);

                    $result := $result * $radix + $digit;
                    $pos     = nqp::add_i($pos, 1)
                        if nqp::islt_i($pos, $eos)
                        && nqp::iseq_i(nqp::ord($str, $pos), 44);  # ','
                }
                parse_fail "malformed ':$radix[]' style radix number, expecting ']' after the body"
                    unless nqp::islt_i($pos, $eos)
                        && nqp::iseq_i(nqp::ord($str, $pos), 93);  # ']'
                $pos = nqp::add_i($pos, 1);

                # XXXX: Handle fractions!
                # XXXX: Handle exponents!
                return $neg ?? -$result !! $result;
            }
            else {
                parse_fail "malformed ':$radix' style radix number, expecting '<' or '[' after the base";
            }
        }
        elsif nqp::iseq_i($ch, 48)  # '0'
          and $radix = nqp::index('  b     o d     x',
                                  nqp::substr($str, nqp::add_i($pos, 1), 1))
          and nqp::isge_i($radix, 2) {
            # A string starting with 0x, 0d, 0o, or 0b,
            # followed by one optional '_'
            $pos   = nqp::add_i($pos, 2);
            $pos   = nqp::add_i($pos, 1)
                if nqp::islt_i($pos, $eos)
                && nqp::iseq_i(nqp::ord($str, $pos), 95);  # '_'

            parse-int-frac-exp();
        }
        elsif nqp::eqat($str,'Inf',$pos) {
            # 'Inf'
            $pos = nqp::add_i($pos, 3);
            $neg ?? -Inf !! Inf;
        }
        else {
            # Last chance: a simple decimal number
            $radix = 10;
            parse-int-frac-exp();
        }
    }

    my sub parse-real() {
        # Parse a simple number or a Rat numerator
        my $result := parse-simple-number();
        return $result if nqp::iseq_i($pos, $eos);

        # Check for '/' indicating Rat denominator
        if nqp::iseq_i(nqp::ord($str, $pos), 47) {  # '/'
            $pos = nqp::add_i($pos, 1);
            parse_fail "denominator expected after '/'"
                unless nqp::islt_i($pos, $eos);

            my $denom := parse-simple-number();

            $result := nqp::istype($result, Int) && nqp::istype($denom, Int)
                    ?? Rat.new($result, $denom)
                    !! $result / $denom;
        }

        $result;
    }

    # Parse a real number, magnitude of a pure imaginary number,
    # or real part of a complex number
    my $result := parse-real();
    parse_win $result if nqp::iseq_i($pos, $eos);

    # Check for 'i' or '\\i' indicating first parsed number was
    # the magnitude of a pure imaginary number
    if nqp::iseq_i(nqp::ord($str, $pos), 105) {  # 'i'
        parse_fail "Imaginary component of 'NaN' or 'Inf' must be followed by \\i"
            if nqp::isnanorinf($result.Num);
        $pos = nqp::add_i($pos, 1);
        $result := Complex.new(0, $result);
    }
    elsif nqp::eqat($str,'\\i',$pos) {
        $pos = nqp::add_i($pos, 2);
        $result := Complex.new(0, $result);
    }
    # Check for '+' or '-' indicating first parsed number was
    # the real part of a complex number
    elsif nqp::iseq_i(nqp::ord($str, $pos), 45)     # '-'
       || nqp::iseq_i(nqp::ord($str, $pos), 43)     # '+'
       || nqp::iseq_i(nqp::ord($str, $pos), 8722) { # ''
        # Don't move $pos -- we want parse-real() to see the sign
        my $im := parse-real();
        parse_fail "imaginary part of complex number must be followed by 'i' or '\\i'"
            unless nqp::islt_i($pos, $eos);

        if nqp::iseq_i(nqp::ord($str, $pos), 105) {  # 'i'
            parse_fail "Imaginary component of 'NaN' or 'Inf' must be followed by \\i"
                if nqp::isnanorinf($im.Num);
            $pos = nqp::add_i($pos, 1);
        }
        elsif nqp::eqat($str,'\\i',$pos) {
            $pos = nqp::add_i($pos, 2);
        }
        else {
            parse_fail "imaginary part of complex number must be followed by 'i' or '\\i'"
        }

        $result := Complex.new($result, $im);
    }

    # Check for trailing garbage
    parse_fail "trailing characters after number"
        if nqp::islt_i($pos, $eos);

    parse_win $result;
}

#line 1 SETTING::src/core/IO.pm
my role IO {
    # This role is empty and exists so that IO() coercers
    # that coerce to IO::Path type check the result values OK
}

enum SeekType (
  :SeekFromBeginning(0),
  :SeekFromCurrent(1),
  :SeekFromEnd(2),
);
enum ProtocolFamily (
  :PF_LOCAL(0),
  :PF_UNIX(1),
  :PF_INET(2),
  :PF_INET6(3),
  :PF_MAX(4),
);
enum SocketType (
  :SOCK_PACKET(0),
  :SOCK_STREAM(1),
  :SOCK_DGRAM(2),
  :SOCK_RAW(3),
  :SOCK_RDM(4),
  :SOCK_SEQPACKET(5),
  :SOCK_MAX(6),
);
enum ProtocolType (
  :PROTO_TCP(6),
  :PROTO_UDP(17),
);

#line 1 SETTING::src/core/IO/Spec.pm
my class VM { ... }

my class IO::Spec {

    my %module =                # only list the non-Unix ones in lowercase
        'mswin32' => 'Win32',
        'os2' =>     'Win32',
        'dos'     => 'Win32',
        'symbian' => 'Win32',
        'netware' => 'Win32',
        'win32'   => 'Win32',
        'cygwin'  => 'Cygwin',
        'qnx'     => 'QNX',
        'nto'     => 'QNX',
        # <MacOS Mac>  => 'Mac',
        # 'VMS'     => 'VMS'
    ;

    method select(IO::Spec:U: $token?) {
        IO::Spec::{%module{ lc($token // VM.osname) } // 'Unix'};
    }
}

# temporary non-lazy initialization of $*SPEC
PROCESS::<$SPEC> = IO::Spec.select;

#line 1 SETTING::src/core/IO/Spec/Unix.pm
my class IO::Spec::Unix is IO::Spec {

    method canonpath( $patharg, :$parent --> Str:D) {
        nqp::if(
          (my str $path = $patharg.Str),
          nqp::stmts(
            nqp::while(                # // -> /
              nqp::isne_i(nqp::index($path,'//'),-1),
              $path = nqp::join('/',nqp::split('//',$path))
            ),
            nqp::while(                # /./ -> /
              nqp::isne_i(nqp::index($path,'/./'),-1),
              $path = nqp::join('/',nqp::split('/./',$path))
            ),
            nqp::if(                   # /. $ -> /
              nqp::eqat($path,'/.',nqp::sub_i(nqp::chars($path),2)),
              $path = nqp::substr($path,0,nqp::sub_i(nqp::chars($path),1))
            ),
            nqp::if(                   # ^ ./ ->
              nqp::eqat($path,'./',0) && nqp::isgt_i(nqp::chars($path),2),
              $path = nqp::substr($path,2)
            ),
            nqp::if(
              $parent,
              nqp::stmts(
                nqp::while(          # ^ /.. -> /
                  ($path ~~ s:g {  [^ | <?after '/'>] <!before '../'> <-[/]>+ '/..' ['/' | $ ] } = ''),
                  nqp::null
                ),
                nqp::unless(
                  $path,
                  $path = '.'
                )
              )
            ),
            nqp::if(                       # ^ /
              nqp::eqat($path,'/',0),
              nqp::stmts(
                nqp::while(                # ^ /../ -> /
                  nqp::eqat($path,'/../',0),
                  $path = nqp::substr($path,3)
                ),
                nqp::if(                   # ^ /.. $ -> /
                  nqp::iseq_s($path,'/..'),
                  $path = '/'
                )
              )
            ),
            nqp::if(                       # .+/ -> .+
              nqp::isgt_i(nqp::chars($path),1)
                && nqp::eqat($path,'/',nqp::sub_i(nqp::chars($path),1)),
              nqp::substr($path,0,nqp::sub_i(nqp::chars($path),1)),
              $path
            )
          ),
          ''
        )
    }

    method dir-sep  {  '/' } # NOTE: IO::Path.resolve assumes dir sep is 1 char
    method curdir   {  '.' }
    method updir    { '..' }
    method curupdir { none('.','..') }
    method rootdir  { '/' }
    method devnull  { '/dev/null' }

    method basename(\path) {
        my str $str = nqp::unbox_s(path);
        my int $index = nqp::rindex($str,'/');
        nqp::p6bool($index == -1)
          ?? path
          !! substr(path,nqp::box_i($index + 1,Int) );
    }

    method extension(\path) {
        my str $str = nqp::unbox_s(path);
        my int $index = nqp::rindex($str,'.');
        nqp::p6bool($index == -1)
          ?? ''
          !! substr(path,nqp::box_i($index + 1,Int) );
    }

    method tmpdir {
        my $io;
        first( {
            if .defined {
                $io = .IO;
                $io.d && $io.rwx;
            }
          },
          %*ENV<TMPDIR>,
          '/tmp',
        ) ?? $io !! IO::Path.new(".");
    }

    method is-absolute( Str() \path ) {
        nqp::p6bool(nqp::iseq_i(nqp::ord(path), 47)) # '/'
    }

    method path {
        (my $p := %*ENV<PATH>) ?? gather {
            my int $els = nqp::elems(my $parts := nqp::split(':', $p));
            my int $i = -1;
            nqp::until(
              nqp::iseq_i($els, $i = nqp::add_i($i, 1)),
              take nqp::atpos($parts, $i) || '.')
        } !! Seq.new: Rakudo::Iterator.Empty
    }

    method splitpath( $path, :$nofile = False ) {
        if $nofile {
            ( '', $path, '' );
        }
        else {
            $path ~~ m/^ ( [ .* \/ [ '.'**1..2 $ ]? ]? ) (<-[\/]>*) /;
            ( '', ~$0, ~$1 );
        }
    }

    method split(IO::Spec::Unix: Cool:D $path) {
        my str $p = $path.Str;
        my int $chars = nqp::chars($p);

        nqp::while(
            nqp::if(
                ($chars = nqp::sub_i(nqp::chars($p), 1)),
                nqp::eqat($p, '/', $chars),
            ),
            $p = nqp::substr($p, 0, $chars),
        );

        my str $dirname;
        my str $basename;
        my int $slash-at = nqp::rindex($p, '/');
        nqp::if(
            $slash-at,
            nqp::if(
                nqp::iseq_i($slash-at, -1),
                nqp::stmts(
                    ($dirname = ''),
                    $basename = $p,
                ),
                nqp::stmts(
                    ($dirname = nqp::substr($p, 0, $slash-at)),
                    $basename = nqp::substr($p, nqp::add_i($slash-at, 1)),
                ),
            ),
            nqp::stmts(
                ($dirname = '/'),
                $basename = nqp::substr($p, 1),
            ),
        );

        nqp::while(
            nqp::if(
                ($chars = nqp::sub_i(nqp::chars($dirname), 1)),
                nqp::eqat($dirname, '/', $chars),
            ),
            $dirname = nqp::substr($dirname, 0, $chars),
        );

        nqp::if(
            $basename,
            nqp::unless($dirname, $dirname = '.'),
            nqp::if(
                nqp::iseq_s($dirname, '/'),
                $basename = '/',
            ),
        );

        # shell dirname '' produces '.', but we don't because it's probably user error
       (:volume(''), :$dirname, :$basename);
    }

    method join ($, \dir, \file) {
        nqp::if(
             (nqp::iseq_s(dir, '/') && nqp::iseq_s(file, '/'))
          || (nqp::iseq_s(dir, '.') && file),
          file,
          nqp::concat(dir,
            nqp::if(
              dir && file
                && nqp::isfalse(
                    nqp::eqat(dir, '/', nqp::sub_i(nqp::chars(dir), 1)))
                && nqp::isne_i(nqp::ord(file), 47), # '/'
              nqp::concat('/', file),
              file)))
    }

    method catpath( $, \dirname, \file ) {
        nqp::concat(dirname,
          nqp::if(
            dirname && file
              && nqp::isfalse(
                  nqp::eqat(dirname, '/',
                    nqp::sub_i(nqp::chars(dirname), 1)))
              && nqp::isne_i(nqp::ord(file), 47), # '/'
            nqp::concat('/', file),
            file))
    }

    method catdir (*@parts) {
        self.canonpath: nqp::concat(
            @parts.join('/'),
            nqp::if(@parts, '/', ''),
        )
    }
    method splitdir(Cool:D $path) {
        nqp::p6bindattrinvres((), List, '$!reified', nqp::split('/', $path.Str))
        || ('',)
    }
    method catfile( |c )     { self.catdir(|c) }

    method abs2rel( $path is copy, $base is copy = $*CWD ) {
        if self.is-absolute($path) || self.is-absolute($base) {
            $path = self.rel2abs( $path );
            $base = self.rel2abs( $base );
        }
        else {
            # save a couple of cwd()s if both paths are relative
            $path = self.catdir( self.rootdir, $path );
            $base = self.catdir( self.rootdir, $base );
        }

        my ($path_volume, $path_directories) = self.splitpath( $path, :nofile );
        my ($base_volume, $base_directories) = self.splitpath( $base, :nofile );

        # Can't relativize across volumes
        return $path unless $path_volume eq $base_volume;

        # For UNC paths, the user might give a volume like //foo/bar that
        # strictly speaking has no directory portion.  Treat it as if it
        # had the root directory for that volume.
        if !$base_directories && self.is-absolute( $base ) {
            $base_directories = self.rootdir;
        }

        # Now, remove all leading components that are the same
        my @pathchunks = self.splitdir( $path_directories );
        my @basechunks = self.splitdir( $base_directories );

        if $base_directories eq self.rootdir {
            @pathchunks.shift;
            return self.canonpath( self.catpath('', self.catdir( @pathchunks ), '') );
        }

        while @pathchunks && @basechunks && @pathchunks[0] eq @basechunks[0] {
            @pathchunks.shift;
            @basechunks.shift;
        }
        return self.curdir unless @pathchunks || @basechunks;

        # $base now contains the directories the resulting relative path
        # must ascend out of before it can descend to $path_directory.
        my $result_dirs = self.catdir( self.updir() xx @basechunks.elems, @pathchunks );
        return self.canonpath( self.catpath('', $result_dirs, '') );
    }

    method rel2abs(Str() \path, $base? is copy) {
        self.canonpath:
          nqp::if(
            nqp::iseq_i(nqp::ord(path), 47), # .starts-with: '/'
            path,
            nqp::concat(
              nqp::if(
                nqp::defined($base),
                nqp::if(
                  nqp::iseq_i(nqp::ord(($base = $base.Str)), 47), # /^ '/'/
                  $base,
                  nqp::if(
                    nqp::iseq_s($base, (my $cwd := $*CWD.Str)),
                    $base, self.rel2abs($base, $cwd))),
                $*CWD.Str),
                nqp::concat('/', path)))
    }
}

#line 1 SETTING::src/core/IO/Spec/Win32.pm
my class IO::Spec::Win32 is IO::Spec::Unix {

    # Some regexes we use for path splitting
    my $slash       = regex {  <[\/ \\]> }
    my $notslash    = regex { <-[\/ \\]> }
    my $driveletter = regex { <[A..Z a..z]> ':' }
    my $UNCpath     = regex { [<$slash> ** 2] <$notslash>+  <$slash>  [<$notslash>+ | $] }
    my $volume_rx   = regex { <$driveletter> | <$UNCpath> }

    method canonpath ($patharg, :$parent) {
        my $path = $patharg.Str;
        $path eq '' ?? '' !! self!canon-cat($path, :$parent);
    }

    method catdir(*@dirs) {
        return "" unless @dirs;
        return self!canon-cat( "\\", @dirs ) if @dirs[0] eq "";
        self!canon-cat(|@dirs);
    }

    # NOTE: IO::Path.resolve assumes dir sep is 1 char
    method dir-sep {  \  }
    method devnull { 'nul' }
    method rootdir {  \  }
    method splitdir(Cool:D $path) {
        nqp::p6bindattrinvres(
          (), List, '$!reified',
          nqp::split('/', nqp::join('/', nqp::split(\, $path.Str))))
        || ('',)
    }

    method basename(\path) {
        my str $str = nqp::unbox_s(path);
        my int $indexf = nqp::rindex($str,'/');
        my int $indexb = nqp::rindex($str,'\\');
        nqp::p6bool($indexf == -1 && $indexb == -1)
          ?? path
          !! $indexf > $indexb
             ?? substr(path,nqp::box_i($indexf + 1,Int) )
             !! substr(path,nqp::box_i($indexb + 1,Int) );
    }

    method tmpdir {
        my $ENV := %*ENV;
        my $io;
        first( {
            if .defined {
                $io = .IO;
                $io.d && $io.rwx;
            }
        },
          $ENV<TMPDIR>,
          $ENV<TEMP>,
          $ENV<TMP>,
          'SYS:/temp',
          'C:\system\temp',
          'C:/temp',
          '/tmp',
          '/',
        ) ?? $io !! IO::Path.new(".");
    }

    method path {
        gather {
          take '.';
          my $p := %*ENV;
          nqp::if(
            ($p := nqp::if(nqp::defined($_ := $p<PATH>), $_, $p<Path>)),
            nqp::stmts(
              (my int $els = nqp::elems(my $parts := nqp::split(';', $p))),
              (my int $i = -1),
              nqp::until(
                nqp::iseq_i($els, $i = nqp::add_i($i, 1)),
                ($_ := nqp::atpos($parts, $i))
                  # unsure why old code removed all `"`, but keeping code same
                  # https://irclog.perlgeek.de/perl6-dev/2017-05-15#i_14585448
                  && take nqp::join('', nqp::split(", $_)))))
        }
   }

    method is-absolute ($path) {
        nqp::p6bool(
          nqp::iseq_i(($_ := nqp::ord($path)), 92) # /^ \ /
          || nqp::iseq_i($_, 47)                   # /^ / /
          || (nqp::eqat($path, ':', 1) # /^ <[A..Z a..z]> ':' [ \ | / ] /
              && ( (nqp::isge_i($_, 65) && nqp::isle_i($_, 90)) # drive letter
                || (nqp::isge_i($_, 97) && nqp::isle_i($_, 122)))
              && ( nqp::iseq_i(($_ := nqp::ordat($path, 2)), 92) # slash
                || nqp::iseq_i($_, 47))))
    }

    method split(IO::Spec::Win32: Cool:D $path is copy) {
        $path ~~ s[ <$slash>+ $] = ''                       #=
            unless $path ~~ /^ <$driveletter>? <$slash>+ $/;

        $path ~~
            m/^ ( <$volume_rx> ? )
            ( [ .* <$slash> ]? )
            (.*)
             /;

        my str $volume   = $0.Str;
        my str $dirname  = $1.Str;
        my str $basename = $2.Str;

        nqp::stmts(
          nqp::while( # s/ <?after .> <$slash>+ $//
            nqp::isgt_i(($_ := nqp::sub_i(nqp::chars($dirname), 1)), 0)
            && (nqp::eqat($dirname, \, $_) || nqp::eqat($dirname, '/', $_)),
            $dirname = nqp::substr($dirname, 0, $_)),
          nqp::if(
            $volume && nqp::isfalse($dirname) && nqp::isfalse($basename),
            nqp::if(
              nqp::eqat($volume, ':', 1) # /^ <[A..Z a..z]> ':'/
                && ( (nqp::isge_i(($_ := nqp::ord($volume)), 65) # drive letter
                    && nqp::isle_i($_, 90))
                  || (nqp::isge_i($_, 97) && nqp::isle_i($_, 122))),
              ($dirname = '.'),
              ($dirname = \))),
          nqp::if(
            (nqp::iseq_s($dirname, \) || nqp::iseq_s($dirname, '/'))
            && nqp::isfalse($basename),
            $basename = \),
          nqp::if(
            $basename && nqp::isfalse($dirname),
            $dirname = '.'));

        (:$volume, :$dirname, :$basename)
    }

    method join (Str \vol, Str $dir is copy, Str $file is copy) {
        nqp::stmts(
          nqp::if(
            $file && nqp::iseq_s($dir, '.'),
            ($dir = ''),
            nqp::if(
                 (nqp::iseq_s($dir,  \) || nqp::iseq_s($dir,  /))
              && (nqp::iseq_s($file, \) || nqp::iseq_s($file, /)),
              nqp::stmts(
                ($file = ''),
                nqp::if(
                  nqp::isgt_i(nqp::chars(vol), 2), # i.e. UNC path
                  $dir = '')))),
          self.catpath: vol, $dir, $file)
    }

    method splitpath(Str() $path, :$nofile = False) {

        if $nofile {
            $path ~~ /^ (<$volume_rx>?) (.*) /;
            (~$0, ~$1, '');
        }
        else {
            $path ~~
                m/^ ( <$volume_rx> ? )
                ( [ .* <$slash> [ '.' ** 1..2 $]? ]? )
                (.*)
                 /;
            (~$0, ~$1, ~$2);
        }
    }

    method catpath(Str $vol is copy, Str \dir, Str \file) {
        nqp::stmts(
          nqp::if(       # Make sure the glue separator is present
            $vol && dir  # unless it's a relative path like A:foo.txt
            && nqp::isfalse(
              nqp::iseq_i(nqp::ord($vol, 1), 58) # /^ <[A..Z a..z]> ':'/
                && (  (nqp::isge_i(nqp::ord($vol), 65) # 'A'
                    && nqp::isle_i(nqp::ord($vol), 90)) # 'Z'
                  ||  (nqp::isge_i(nqp::ord($vol), 97)  # 'a'
                    && nqp::isle_i(nqp::ord($vol), 122)))) # 'z'
            && nqp::isfalse( # /<[/\\]> $/
                nqp::iseq_i(92, nqp::ord( # '\'
                  $vol, nqp::sub_i(nqp::chars($vol), 1)))
                || nqp::iseq_i(47, nqp::ord( # '/'
                  $vol, nqp::sub_i(nqp::chars($vol), 1))))
            && nqp::isfalse( # /^ /<[/\\]>/
                nqp::iseq_i(92, nqp::ord(dir)) # '\'
                || nqp::iseq_i(47, nqp::ord(dir))), # '/'
            $vol = nqp::concat($vol, \)),
            nqp::if(
              dir && file
              && nqp::isfalse( # /<[/\\]> $/
                  nqp::iseq_i(92, nqp::ord( # '\'
                    dir, nqp::sub_i(nqp::chars(dir), 1)))
                  || nqp::iseq_i(47, nqp::ord( # '/'
                    dir, nqp::sub_i(nqp::chars(dir), 1)))),
              nqp::concat($vol, nqp::concat(dir, nqp::concat(\, file))),
              nqp::concat($vol, nqp::concat(dir,                  file))))
    }

    method rel2abs (Str() $path is copy, $base? is copy, :$omit-volume) {
        nqp::if(
          (nqp::eqat($path, ':', 1) # /^ <[A..Z a..z]> ':' [ \ | / ] /
              && ( (nqp::isge_i(($_ := nqp::ord($path)), 65) # drive letter
                  && nqp::isle_i($_, 90))
                || (nqp::isge_i($_, 97) && nqp::isle_i($_, 122)))
              && ( nqp::iseq_i(($_ := nqp::ordat($path, 2)), 92) # slash
                || nqp::iseq_i($_, 47)))
          || 0, #($path ~~ /^ <$UNCpath>/),
          self.canonpath($path),
          nqp::if(
            nqp::iseq_i(($_ := nqp::ord($path)), 92) # /^ \ /
            || nqp::iseq_i($_, 47),                  # /^ / /
            nqp::if(
              $omit-volume,
              self.canonpath($path),
              nqp::stmts(
                (my $vol),
                nqp::if(
                  nqp::defined($base),
                  ($vol := self.splitpath($base).AT-POS(0))),
                nqp::unless(
                  $vol,
                  ($vol := self.splitpath($*CWD)[0])),
                self.canonpath($vol ~ $path))),
            nqp::stmts(
              nqp::unless(
                nqp::defined($base),
                ($base = $*CWD),
                nqp::unless(
                  self.is-absolute($base),
                  ($base = self.rel2abs: $base),
                  ($base = self.canonpath: $base))),
              (my ($path_directories, $path_file)
                = self.splitpath($path)[1, 2]),
              (my ($base_volume, $base_directories)
                = self.splitpath($base, :nofile)),
              self.canonpath(
                self.catpath(
                  $base_volume,
                  self.catdir($base_directories, $path_directories),
                  $path_file)))))
    }


    method !canon-cat ( $first, *@rest, :$parent --> Str:D) {
        $first ~~ /^ ([   <$driveletter> <$slash>?
                        | <$UNCpath>
                        | [<$slash> ** 2] <$notslash>+
                        | <$slash> ]?)
                       (.*)
                   /;
        my str $volume = ~$0;
        my str $path   = ~$1;
        my int $temp;


        $volume = nqp::join(\, nqp::split('/', $volume));
        $temp   = nqp::ord($volume);

        nqp::if(
          nqp::eqat($volume, ':', 1) # this chunk == ~~ /^<[A..Z a..z]>':'/
            && ( (nqp::isge_i($temp, 65) && nqp::isle_i($temp, 90))
              || (nqp::isge_i($temp, 97) && nqp::isle_i($temp, 122))),
          ($volume = nqp::uc($volume)),
          nqp::if(
            ($temp = nqp::chars($volume))
              && nqp::isfalse(nqp::eqat($volume, \, nqp::sub_i($temp, 1))),
            ($volume = nqp::concat($volume, \))));

        $path = join \, $path, @rest.flat;

        # /xx\\\yy\/zz  --> \xx\yy\zz
        $path = nqp::join(\, nqp::split('/', $path));
        nqp::while(
          nqp::isne_i(-1, $temp = nqp::index($path, \\)),
          ($path = nqp::replace($path, $temp, 2, \)));

        # xx/././yy --> xx/yy
        $path ~~ s:g/[ ^ | \]   '.'  \.*  [ \ | $ ]/\\/;

        nqp::if($parent,
          nqp::while(
            ($path ~~ s:g {
                [^ | <?after \>] <!before ..\> <-[\\]>+ \.. [ \ | $ ]
              } = ''),
            nqp::null));

        nqp::while( # \xx --> xx  NOTE: this is *not* root
          nqp::iseq_i(0, nqp::index($path, \)),
          ($path = nqp::substr($path, 1)));

        nqp::while( # xx\ --> xx
          nqp::eqat($path, \, ($temp = nqp::sub_i(nqp::chars($path), 1))),
          ($path = nqp::substr($path, 0, $temp)));

        nqp::if( # <vol>\.. --> <vol>\
          nqp::eqat($volume, \, nqp::sub_i(nqp::chars($volume), 1)),
          $path ~~ s/ ^  '..'  \..*  [ \ | $ ] //);

        nqp::if(
          $path,
          nqp::concat($volume, $path),
          nqp::stmts( # \\HOST\SHARE\ --> \\HOST\SHARE
            nqp::iseq_i(0, nqp::index($volume, \\))
                && nqp::iseq_i(nqp::rindex($volume, \),
                  ($temp = nqp::sub_i(nqp::chars($volume), 1)))
                && ($volume = nqp::substr($volume, 0, $temp)),
            $volume || '.'))
    }
}

#line 1 SETTING::src/core/IO/Spec/Cygwin.pm
my class IO::Spec::Cygwin is IO::Spec::Unix {

    method canonpath ($patharg, :$parent) {
        my $path = $patharg.Str;
        $path.=subst(:g, '\\', '/');

        # Handle network path names beginning with double slash
        my $node = '';
        if $path ~~ s/^ ('//' <-[/]>+) [ '/' | $ ] /\// { #/
            $node = ~$0;
        }
        $node ~ IO::Spec::Unix.canonpath($path, :$parent);
    }

    method catdir ( *@paths ) {
        my $result = IO::Spec::Unix.catdir(@paths);

        # Don't create something that looks like a //network/path
        $result.subst(/ <[\\\/]> ** 2..*/, '/');
    }

    method is-absolute ($path) {
        nqp::p6bool(
          nqp::iseq_i(($_ := nqp::ord($path)), 92) # /^ \ /
          || nqp::iseq_i($_, 47)                   # /^ / /
          || (nqp::eqat($path, ':', 1) # /^ <[A..Z a..z]> ':' [ \ | / ] /
              && ( (nqp::isge_i($_, 65) && nqp::isle_i($_, 90)) # drive letter
                || (nqp::isge_i($_, 97) && nqp::isle_i($_, 122)))
              && ( nqp::iseq_i(($_ := nqp::ordat($path, 2)), 92) # slash
                || nqp::iseq_i($_, 47))))
    }

    method tmpdir {
        my %ENV := %*ENV;
        my $io;
        first( {
            if .defined {
                $io = .IO;
                $io.d && $io.rwx;
            }
          },
          %ENV<TMPDIR>,
          "/tmp",
          %ENV<TMP>,
          %ENV<TEMP>,
          'C:/temp',
        ) ?? $io !! IO::Path.new(".");
    }

    # Paths might have a volume, so we use Win32 splitpath and catpath instead
    method abs2rel(|c) {
        IO::Spec::Win32.abs2rel(|c).subst(:global, '\\', '/');
    }
    method rel2abs(|c) {
        IO::Spec::Win32.rel2abs(|c, :omit-volume).subst(:global, '\\', '/');
    }
    method splitpath(|c) {
        IO::Spec::Win32.splitpath(|c)>>.subst(:global, '\\', '/');
    }
    method catpath(|c) {
        IO::Spec::Win32.catpath(|c).subst(:global, '\\', '/');
    }
    method split(IO::Spec::Cygwin: Cool:D $path) {
        IO::Spec::Win32.split($path).map(
          { .key => .value.subst(:global, '\\', '/') }
        ).List;
    }
    method join(|c) {
        IO::Spec::Win32.join(|c).subst(:global, '\\', '/');
    }
}

#line 1 SETTING::src/core/IO/Spec/QNX.pm
my class IO::Spec::QNX is IO::Spec::Unix {

    method canonpath ($patharg, :$parent) {
        my $path = $patharg.Str;
        # Handle POSIX-style node names beginning with double slash (qnx, nto)
        # (POSIX says: "a pathname that begins with two successive slashes
        # may be interpreted in an implementation-defined manner, although
        # more than two leading slashes shall be treated as a single slash.")
        my $node = '';
        if $path ~~ s {^ ( '//' <-[ / ]>+ ) '/'? $} = ''
        or $path ~~ s {^ ( '//' <-[ / ]>+ ) '/' }   = '/'
            { $node = ~ $0; }

        $path = IO::Spec::Unix.canonpath($path, :$parent);

        $node ~ $path;
    }
}

#line 1 SETTING::src/core/IO/Notification.pm
# stub what we need now
my class Supplier { ... }

my enum FileChangeEvent (:FileChanged(1), :FileRenamed(2));

my class IO::Notification {
    my class FileWatchCancellation is repr('AsyncTask') { }

    class Change {
        has $.path;
        has $.event;
        multi method gist(Change:D:) {
            "$.path: $.event";
        }
        method IO { $!path.IO }
    }

    method watch-path(Str() $path, :$scheduler = $*SCHEDULER) {
        my $is-dir = $path.IO.d;
        my $s = Supplier.new;
        nqp::watchfile(
            $scheduler.queue(:hint-affinity),
            -> \path, \rename, \err {
                if err {
                    $s.quit(err);
                }
                else {
                    my $event = rename ?? FileRenamed !! FileChanged;
                    my $full-path = $is-dir ?? $*SPEC.catdir($path, path) !! $path;
                    $s.emit(Change.new(:path($full-path), :$event));
                }
            },
            $path, FileWatchCancellation);
        $s.Supply
    }
}

#line 1 SETTING::src/core/IO/Special.pm
my class Instant { ... }

class IO::Special does IO {
    has Str $.what;

    method new(\what) {
        nqp::p6bindattrinvres(nqp::create(self),self,'$!what',what)
    }
    multi method WHICH(IO::Special:D:) {        "IO::Special$!what"        }
    multi method Str  (IO::Special:D:) {                    $!what         }
    multi method perl (IO::Special:D:) { "{self.^name}.new({$!what.perl})" }

    method IO(IO::Special:D:) { self }

    method e(IO::Special:D: --> True) { }
    method d(IO::Special:D: --> False) { }
    method f(IO::Special:D: --> False) { }
    method s(IO::Special:D:--> 0) { }
    method l(IO::Special:D: --> False) { }
    method r(IO::Special:D:) { $!what eq '<STDIN>' }
    method w(IO::Special:D:) { $!what eq '<STDOUT>' or $!what eq '<STDERR>' }
    method x(IO::Special:D: --> False) { }
    method modified(IO::Special:D: --> Instant) { Instant }
    method accessed(IO::Special:D: --> Instant) { Instant }
    method changed( IO::Special:D: --> Instant) { Instant }
    method mode(IO::Special:D: --> Nil) { }
}

#line 1 SETTING::src/core/IO/Handle.pm
my class IO::Path { ... }
my class Proc { ... }

my class IO::Handle {
    has $.path;
    has $!PIO;
    has $.chomp is rw = Bool::True;
    has $.nl-in = ["\x0A", "\r\n"];
    has Str:D $.nl-out is rw = "\n";
    has Str $.encoding;
    has Encoding::Decoder $!decoder;
    has Encoding::Encoder $!encoder;
    has int $!out-buffer;

    submethod TWEAK (:$encoding, :$bin, IO() :$!path = Nil) {
        nqp::if(
          $bin,
          nqp::isconcrete($encoding) && X::IO::BinaryAndEncoding.new.throw,
          $!encoding = $encoding || 'utf8')
    }


    # Make sure we close any open files on exit
    my $opened := nqp::list;
    my $opened-locker = Lock.new;
    method !remember-to-close(--> Nil) {
        $opened-locker.protect: {
            nqp::stmts(
              nqp::if(
                nqp::isge_i(
                  (my int $fileno = nqp::filenofh($!PIO)),
                  (my int $elems = nqp::elems($opened))
                ),
                nqp::setelems($opened,nqp::add_i($elems,1024))
              ),
              nqp::bindpos($opened,$fileno,$!PIO)
            )
        }
    }
    method !forget-about-closing(int $fileno --> Nil) {
        $opened-locker.protect: {
            nqp::bindpos($opened,$fileno,nqp::null)
        }
    }
    method !close-all-open-handles() {
        my int $i = 2;
        my int $elems = nqp::elems($opened);
        nqp::while(
          nqp::islt_i(($i = nqp::add_i($i,1)),$elems),
          nqp::unless(
            nqp::isnull(my $PIO := nqp::atpos($opened,$i)),
            nqp::closefh($PIO)
          )
        )
    }


    method open(IO::Handle:D:
      :$r, :$w, :$x, :$a, :$update,
      :$rw, :$rx, :$ra,
      :$mode is copy,
      :$create is copy,
      :$append is copy,
      :$truncate is copy,
      :$exclusive is copy,
      :$bin,
      :$enc is copy,
      :$chomp = $!chomp,
      :$nl-in is copy = $!nl-in,
      Str:D :$nl-out is copy = $!nl-out,
      :$buffer,
      :$out-buffer is copy,
    ) {
        nqp::if(
            $buffer.DEFINITE,
            nqp::stmts(
              ($out-buffer = $buffer),
              DEPRECATED ':out-buffer argument to control handle buffering',
                '2017.09.455.g.2.fba.0.ba.0.d', '2018.01'));

        nqp::if(
          $bin,
          nqp::stmts(
            nqp::isconcrete($enc) && X::IO::BinaryAndEncoding.new.throw,
            $!encoding = Nil),
          nqp::unless(
            nqp::isconcrete($enc),
            $enc = $!encoding));

        $mode = nqp::if(
          $mode,
          nqp::if(nqp::istype($mode, Str), $mode, $mode.Str),
          nqp::if(
            nqp::unless(nqp::if($r, $w), $rw), # $r && $w || $rw
            nqp::stmts(($create = True), 'rw'),
            nqp::if(
              nqp::unless(nqp::if($r, $x), $rx),
              nqp::stmts(($create = $exclusive = True), 'rw'),
              nqp::if(
                nqp::unless(nqp::if($r, $a), $ra),
                nqp::stmts(($create = $append = True), 'rw'),
                nqp::if(
                  $r, 'ro',
                  nqp::if(
                    $w,
                    nqp::stmts(($create = $truncate = True), 'wo'),
                    nqp::if(
                      $x,
                      nqp::stmts(($create = $exclusive = True), 'wo'),
                      nqp::if(
                        $a,
                        nqp::stmts(($create = $append = True), 'wo'),
                        nqp::if(
                          $update, 'rw',
                          'ro'
                        ),
                      ),
                    ),
                  ),
                ),
              ),
            ),
          ),
        );

        nqp::if(
          nqp::iseq_s($!path.Str, '-'),
          nqp::if(
            nqp::iseq_s($mode, 'ro'),
            nqp::if(
              $*IN.opened,
              nqp::stmts(
                $*IN.encoding($enc),
                return $*IN),
              nqp::stmts(
                nqp::if(
                  nqp::iseq_s($*IN.path.Str, '-'),
                  $*IN = IO::Handle.new: :path(IO::Special.new: '<STDIN>')),
                return $*IN.open: :$enc,
                  :bin(nqp::isfalse(nqp::isconcrete($enc))))),
            nqp::if(
              nqp::iseq_s($mode, 'wo'),
              nqp::if(
                $*OUT.opened,
                nqp::stmts(
                  $*OUT.encoding($enc),
                  return $*OUT),
                nqp::stmts(
                  nqp::if(
                    nqp::iseq_s($*OUT.path.Str, '-'),
                    $*OUT = IO::Handle.new: :path(IO::Special.new: '<STDOUT>')),
                  return $*OUT.open: :w, :$enc,
                    :bin(nqp::isfalse(nqp::isconcrete($enc))))),
              die("Cannot open standard stream in mode '$mode'"))));

        if nqp::istype($!path, IO::Special) {
            my $what := $!path.what;
            if $what eq '<STDIN>' {
                $!PIO := nqp::getstdin();
            }
            elsif $what eq '<STDOUT>' {
                $!PIO := nqp::getstdout();
            }
            elsif $what eq '<STDERR>' {
                $!PIO := nqp::getstderr();
            }
            else {
                die "Don't know how to open '$_' especially";
            }
            $!chomp = $chomp;
            $!nl-out = $nl-out;
            if nqp::isconcrete($enc) {
                my $encoding = Encoding::Registry.find($enc);
                $!decoder := $encoding.decoder(:translate-nl);
                $!decoder.set-line-separators(($!nl-in = $nl-in).list);
                $!encoder := $encoding.encoder(:translate-nl);
                $!encoding = $encoding.name;
            }
            self!set-out-buffer-size($out-buffer);
            return self;
        }

        fail X::IO::Directory.new(:$!path, :trying<open>) if $!path.d;

        {
            CATCH { .fail }
            $!PIO := nqp::open(
                $!path.absolute,
                nqp::concat(
                    nqp::if(
                        nqp::iseq_s($mode, 'ro'), 'r',
                        nqp::if(
                            nqp::iseq_s($mode, 'wo'), '-',
                            nqp::if(
                                nqp::iseq_s($mode, 'rw'), '+',
                                die("Unknown mode '$mode'")
                            ),
                        ),
                    ),
                    nqp::concat(
                        nqp::if($create, 'c', ''),
                        nqp::concat(
                            nqp::if($append, 'a', ''),
                            nqp::concat(
                                nqp::if($truncate,  't', ''),
                                nqp::if($exclusive, 'x', ''),
                            ),
                        ),
                    )
                ),
            );

            self!remember-to-close;

        }

        $!chomp = $chomp;
        $!nl-out = $nl-out;
        if nqp::isconcrete($enc) {
            my $encoding = Encoding::Registry.find($enc);
            $!decoder := $encoding.decoder(:translate-nl);
            $!decoder.set-line-separators(($!nl-in = $nl-in).list);
            $!encoder := $encoding.encoder(:translate-nl);
            $!encoding = $encoding.name;
        }
        self!set-out-buffer-size($out-buffer);
        self;
    }

    method out-buffer is rw {
        Proxy.new: :FETCH{ $!out-buffer }, STORE => -> $, \buffer {
            self!set-out-buffer-size: buffer;
        }
    }

    method !set-out-buffer-size($buffer is copy) {
        $buffer //= !nqp::isttyfh($!PIO);
        $!out-buffer = nqp::istype($buffer, Bool)
            ?? ($buffer ?? 8192 !! 0)
            !! $buffer.Int;
        nqp::setbuffersizefh($!PIO, $!out-buffer);
        $!out-buffer
    }

    method nl-in is rw {
        Proxy.new(
          FETCH => {
              $!nl-in
          },
          STORE => -> $, $nl-in {
            $!nl-in = $nl-in;
            $!decoder && $!decoder.set-line-separators($nl-in.list);
            $nl-in
          }
        );
    }

    method close(IO::Handle:D: --> True) {
        nqp::if(
          nqp::defined($!PIO),
          nqp::stmts(





            (my int $fileno = nqp::filenofh($!PIO)),
            nqp::closefh($!PIO), # TODO: catch errors
            ($!PIO := nqp::null),
            self!forget-about-closing($fileno)

          )
        )
    }

    method eof(IO::Handle:D:) {
        nqp::p6bool($!decoder
            ?? $!decoder.is-empty && self.eof-internal
            !! self.eof-internal)
    }

    method eof-internal() {
        nqp::eoffh($!PIO)
    }

    method read-internal(Int $bytes) {
        nqp::readfh($!PIO,buf8.new,nqp::unbox_i($bytes))
    }

    method get(IO::Handle:D:) {
        $!decoder or die X::IO::BinaryMode.new(:trying<get>);
        $!decoder.consume-line-chars(:$!chomp) // self!get-line-slow-path()
    }

    method !get-line-slow-path() {
        my $line := Nil;
        loop {
            my $buf := self.read-internal(0x100000);
            if $buf.elems {
                $!decoder.add-bytes($buf);
                $line := $!decoder.consume-line-chars(:$!chomp);
                last if nqp::isconcrete($line);
            }
            else {
                $line := $!decoder.consume-line-chars(:$!chomp, :eof)
                    unless self.eof-internal && $!decoder.is-empty;
                last;
            }
        }
        $line
    }

    method getc(IO::Handle:D:) {
        $!decoder or die X::IO::BinaryMode.new(:trying<getc>);
        $!decoder.consume-exactly-chars(1) || (self!readchars-slow-path(1) || Nil)
    }

    # XXX TODO: Make these routine read handle lazily when we have Cat type
    method comb (IO::Handle:D: :$close, |c) {
        $!decoder or die X::IO::BinaryMode.new(:trying<comb>);
        self.slurp(:$close).comb: |c
    }
    method split(IO::Handle:D: :$close, |c) {
        $!decoder or die X::IO::BinaryMode.new(:trying<split>);
        self.slurp(:$close).split: |c
    }

    proto method words (|) { * }
    multi method words(IO::Handle:D \SELF: $limit, :$close) {
        $!decoder or die X::IO::BinaryMode.new(:trying<words>);
        nqp::istype($limit,Whatever) || $limit == Inf
          ?? self.words(:$close)
          !! $close
            ?? Seq.new(Rakudo::Iterator.FirstNThenSinkAll(
                self.words.iterator, $limit.Int, {SELF.close}))
            !! self.words.head($limit.Int)
    }
    multi method words(IO::Handle:D: :$close) {
        $!decoder or die X::IO::BinaryMode.new(:trying<words>);
        Seq.new(class :: does Iterator {
            has $!handle;
            has $!close;
            has str $!str;
            has int $!pos;
            has int $!searching;

            method !SET-SELF(\handle, $!close) {
                $!handle   := handle;
                $!searching = 1;
                $!str       = ""; # RT #126492
                self!next-chunk;
                self
            }
            method new(\handle, \close) {
                nqp::create(self)!SET-SELF(handle, close);
            }
            method !next-chunk() {
                my int $chars = nqp::chars($!str);
                $!str = $!pos < $chars ?? nqp::substr($!str,$!pos) !! "";
                $chars = nqp::chars($!str);

                while $!searching {
                    $!str = nqp::concat($!str,$!handle.readchars);
                    my int $new = nqp::chars($!str);
                    $!searching = 0 if $new == $chars; # end
                    $!pos = ($chars = $new)
                      ?? nqp::findnotcclass(
                           nqp::const::CCLASS_WHITESPACE, $!str, 0, $chars)
                      !! 0;
                    last if $!pos < $chars;
                }
            }
            method pull-one() {
                my int $chars;
                my int $left;
                my int $nextpos;

                while ($chars = nqp::chars($!str)) && $!searching {
                    while ($left = $chars - $!pos) > 0 {
                        $nextpos = nqp::findcclass(
                          nqp::const::CCLASS_WHITESPACE,$!str,$!pos,$left);
                        last unless $left = $chars - $nextpos; # broken word

                        my str $found =
                          nqp::substr($!str, $!pos, $nextpos - $!pos);
                        $!pos = nqp::findnotcclass(
                          nqp::const::CCLASS_WHITESPACE,$!str,$nextpos,$left);

                        return nqp::p6box_s($found);
                    }
                    self!next-chunk;
                }
                if $!pos < $chars {
                    my str $found = nqp::substr($!str,$!pos);
                    $!pos = $chars;
                    nqp::p6box_s($found)
                }
                else {
                    $!handle.close if $!close;
                    IterationEnd
                }
            }
            method push-all($target --> IterationEnd) {
                my int $chars;
                my int $left;
                my int $nextpos;

                while ($chars = nqp::chars($!str)) && $!searching {
                    while ($left = $chars - $!pos) > 0 {
                        $nextpos = nqp::findcclass(
                          nqp::const::CCLASS_WHITESPACE,$!str,$!pos,$left);
                        last unless $left = $chars - $nextpos; # broken word

                        $target.push(nqp::p6box_s(
                          nqp::substr($!str, $!pos, $nextpos - $!pos)
                        ));

                        $!pos = nqp::findnotcclass(
                          nqp::const::CCLASS_WHITESPACE,$!str,$nextpos,$left);
                    }
                    self!next-chunk;
                }
                $target.push(nqp::p6box_s(nqp::substr($!str,$!pos)))
                  if $!pos < $chars;
                $!handle.close if $close;
            }
        }.new(self, $close));
    }

    my role PIOIterator does Iterator {
        has $!handle;
        has $!chomp;
        has $!decoder;
        method new(\handle) {
            my \res = nqp::create(self);
            nqp::bindattr(res, self.WHAT, '$!handle', handle);
            nqp::bindattr(res, self.WHAT, '$!chomp',
                nqp::getattr(handle, IO::Handle, '$!chomp'));
            nqp::p6bindattrinvres(res, self.WHAT, '$!decoder',
                nqp::getattr(handle, IO::Handle, '$!decoder'))
        }
        method sink-all(--> IterationEnd) {
            nqp::seekfh(nqp::getattr($!handle, IO::Handle, '$!PIO'), 0, 2)  # seek to end
        }
    }

    method !LINES-ITERATOR (IO::Handle:D:) {
        $!decoder or die X::IO::BinaryMode.new(:trying<lines>);
        (nqp::eqaddr(self.WHAT,IO::Handle)
            ?? (class :: does PIOIterator { # exact type, can shortcircuit get
                method pull-one() {
                    # Slow path falls back to .get on the handle, which will
                    # replenish the buffer once we exhaust it.
                    $!decoder.consume-line-chars(:$!chomp) // ($!handle.get // IterationEnd)
                }
                method push-all($target --> IterationEnd) {
                    nqp::while(
                        nqp::isconcrete(my $line :=
                            $!decoder.consume-line-chars(:$!chomp) // $!handle.get),
                        $target.push($line)
                    )
                }
            })
            !! (class :: does Iterator {    # can *NOT* shortcircuit .get
                has $!handle;
                method new(\handle) {
                    nqp::p6bindattrinvres(
                      nqp::create(self),self.WHAT,'$!handle',handle)
                }
                method pull-one() {
                    nqp::if(
                      (my $line := $!handle.get).DEFINITE,
                      $line,
                      IterationEnd
                    )
                }
                method push-all($target --> IterationEnd) {
                    nqp::while(
                      (my $line := $!handle.get).DEFINITE,
                      $target.push($line)
                    )
                }
                method sink-all(--> IterationEnd) {
                    # can't seek pipes, so need the `try`
                    try $!handle.seek(0,SeekFromEnd)  # seek to end
                }
            })
        ).new(self)
    }

    proto method lines (|) { * }
    multi method lines(IO::Handle:D \SELF: $limit, :$close) {
        nqp::istype($limit,Whatever) || $limit == Inf
          ?? self.lines(:$close)
          !! $close
            ?? Seq.new(Rakudo::Iterator.FirstNThenSinkAll(
                self!LINES-ITERATOR, $limit.Int, {SELF.close}))
            !! self.lines.head($limit.Int)
    }
    multi method lines(IO::Handle:D \SELF: :$close!) {
      Seq.new(
        $close # use -1 as N in FirstNThenSinkAllSeq to get all items
          ?? Rakudo::Iterator.FirstNThenSinkAll(
              self!LINES-ITERATOR, -1, {SELF.close})
          !! self!LINES-ITERATOR
      )
    }
    multi method lines(IO::Handle:D:) { Seq.new(self!LINES-ITERATOR) }

    method read(IO::Handle:D: Int(Cool:D) $bytes = $*DEFAULT-READ-ELEMS) {
        # If we have one, read bytes via. the decoder to support mixed-mode I/O.
        $!decoder
            ?? ($!decoder.consume-exactly-bytes($bytes) // self!read-slow-path($bytes))
            !! self.read-internal($bytes)
    }

    method !read-slow-path($bytes) {
        if self.eof-internal && $!decoder.is-empty {
            buf8.new
        }
        else {
            $!decoder.add-bytes(self.read-internal($bytes max 0x100000));
            $!decoder.consume-exactly-bytes($bytes)
                // $!decoder.consume-exactly-bytes($!decoder.bytes-available)
                // buf8.new
        }
    }

    method readchars(Int(Cool:D) $chars = $*DEFAULT-READ-ELEMS) {
        $!decoder or die X::IO::BinaryMode.new(:trying<readchars>);
        $!decoder.consume-exactly-chars($chars) // self!readchars-slow-path($chars)
    }

    method !readchars-slow-path($chars) {
        my $result := '';
        unless self.eof-internal && $!decoder.is-empty {
            loop {
                my $buf := self.read-internal(0x100000);
                if $buf.elems {
                    $!decoder.add-bytes($buf);
                    $result := $!decoder.consume-exactly-chars($chars);
                    last if nqp::isconcrete($result);
                }
                else {
                    $result := $!decoder.consume-exactly-chars($chars, :eof);
                    last;
                }
            }
        }
        $result
    }

    multi method Supply(IO::Handle:D: :$size = $*DEFAULT-READ-ELEMS --> Supply:D) {
        if $!decoder { # handle is in character mode
            supply {
                my int $chars = $size;
                my str $str = self.readchars($chars);
                nqp::while(
                  nqp::chars($str),
                  nqp::stmts(
                    (emit nqp::p6box_s($str)),
                    ($str = self.readchars($chars))
                  )
                );
                done;
            }
        }
        else {
            supply {
                my $buf := self.read($size);
                nqp::while(
                  nqp::elems($buf),
                  nqp::stmts(
                    (emit $buf),
                    ($buf := self.read($size))
                  )
                );
                done;
            }
        }
    }

    proto method seek(|) { * }
    multi method seek(IO::Handle:D: Int:D $offset, SeekType:D $whence = SeekFromBeginning) {
        my int $rewind = 0;
        if $!decoder {
            # consider bytes we pre-read, when seeking from current position:
            $rewind = $!decoder.bytes-available if
                nqp::eqaddr(nqp::decont($whence), SeekFromCurrent);

            # Freshen decoder, so we won't have stuff left over from earlier reads
            # that were in the wrong place.
            $!decoder := Encoding::Registry.find($!encoding).decoder(:translate-nl);
            $!decoder.set-line-separators($!nl-in.list);
        }
        nqp::seekfh($!PIO, $offset - $rewind, +$whence);
    }

    method tell(IO::Handle:D: --> Int:D) {
        nqp::tellfh($!PIO) - ($!decoder ?? $!decoder.bytes-available !! 0)
    }

    method write(IO::Handle:D: Blob:D $buf --> True) {
        self.write-internal($buf)
    }

    method write-internal(IO::Handle:D: Blob:D $buf --> True) {
        nqp::writefh($!PIO, nqp::decont($buf));
    }

    method opened(IO::Handle:D:) {
        nqp::p6bool(nqp::istrue($!PIO));
    }

    method t(IO::Handle:D:) {
        self.opened && nqp::p6bool(nqp::isttyfh($!PIO))
    }

    method lock(IO::Handle:D:
        Bool:D :$non-blocking = False, Bool:D :$shared = False --> True
    ) {

        self!forget-about-closing(nqp::filenofh($!PIO));

        nqp::lockfh($!PIO, 0x10*$non-blocking + $shared);
        CATCH { default {

            self!remember-to-close;

            fail X::IO::Lock.new: :os-error(.Str),
                :lock-type( 'non-' x $non-blocking ~ 'blocking, '
                    ~ ($shared ?? 'shared' !! 'exclusive') );
        }}
    }

    method unlock(IO::Handle:D: --> True) {

        self!remember-to-close;

        nqp::unlockfh($!PIO);
    }

    method printf(IO::Handle:D: |c) {
        self.print(sprintf |c);
    }

    proto method print(|) { * }
    multi method print(IO::Handle:D: Str:D \x --> True) {
        $!decoder or die X::IO::BinaryMode.new(:trying<print>);
        self.write-internal($!encoder.encode-chars(x));
    }
    multi method print(IO::Handle:D: **@list is raw --> True) { # is raw gives List, which is cheaper
        self.print(@list.join);
    }

    proto method put(|) { * }
    multi method put(IO::Handle:D: Str:D \x --> True) {
        $!decoder or die X::IO::BinaryMode.new(:trying<put>);
        self.write-internal($!encoder.encode-chars(
            nqp::concat(nqp::unbox_s(x), nqp::unbox_s($!nl-out))))
    }
    multi method put(IO::Handle:D: **@list is raw --> True) { # is raw gives List, which is cheaper
        self.put(@list.join);
    }

    multi method say(IO::Handle:D: Str:D $x --> True) {
        $!decoder or die X::IO::BinaryMode.new(:trying<say>);
        self.write-internal($!encoder.encode-chars(
            nqp::concat(nqp::unbox_s($x), nqp::unbox_s($!nl-out))));
    }
    multi method say(IO::Handle:D: \x --> True) {
        $!decoder or die X::IO::BinaryMode.new(:trying<say>);
        self.write-internal($!encoder.encode-chars(
            nqp::concat(nqp::unbox_s(x.gist), nqp::unbox_s($!nl-out))))
    }
    multi method say(IO::Handle:D: |) {
        $!decoder or die X::IO::BinaryMode.new(:trying<say>);
        my Mu $args := nqp::p6argvmarray();
        nqp::shift($args);
        my str $conc = '';
        $conc = nqp::concat($conc, nqp::shift($args).gist) while $args;
        self.print(nqp::concat($conc, $!nl-out));
    }

    method print-nl(IO::Handle:D: --> True) {
        $!decoder or die X::IO::BinaryMode.new(:trying<print-nl>);
        self.write-internal($!encoder.encode-chars($!nl-out));
    }

    proto method slurp-rest(|) { * }
    multi method slurp-rest(IO::Handle:D: :$bin! where *.so, :$close --> Buf:D) {
        # NOTE: THIS METHOD WILL BE DEPRECATED IN 6.d in favour of .slurp()
        # Testing of it in roast master has been removed and only kept in 6.c
        # If you're changing this code for whatever reason, test with 6.c-errata
        LEAVE self.close if $close;
        my $res := buf8.new;
        loop {
            my $buf := self.read(0x100000);
            nqp::elems($buf)
              ?? $res.append($buf)
              !! return $res
        }
    }
    multi method slurp-rest(IO::Handle:D: :$enc, :$bin, :$close --> Str:D) {
        # NOTE: THIS METHOD WILL BE DEPRECATED IN 6.d in favour of .slurp()
        # Testing of it in roast master has been removed and only kept in 6.c
        # If you're changing this code for whatever reason, test with 6.c-errata
        $!decoder or die X::IO::BinaryMode.new(:trying<slurp-rest>);
        LEAVE self.close if $close;
        self.encoding($enc) if $enc.defined;
        self!slurp-all-chars()
    }

    method slurp(IO::Handle:D: :$close, :$bin) {
        nqp::stmts(
          (my $res),
          nqp::if(
            $!decoder,
            nqp::if(
              $bin,
              nqp::stmts(
                ($res := buf8.new),
                nqp::if(
                  $!decoder.bytes-available,
                  $res.append($!decoder.consume-exactly-bytes(
                    $!decoder.bytes-available)))),
              ($res := self!slurp-all-chars())),
            ($res := buf8.new)),
          nqp::if(
            nqp::isfalse($!decoder) || $bin,
            nqp::while(
              nqp::elems(my $buf := self.read-internal(0x100000)),
              $res.append($buf))),
          # don't sink result of .close; it might be a failed Proc
          nqp::if($close, my $ = self.close),
          $res)
    }

    method !slurp-all-chars() {
        while nqp::elems(my $buf := self.read-internal(0x100000)) {
            $!decoder.add-bytes($buf);
        }
        $!decoder.consume-all-chars()
    }

    proto method spurt(|) { * }
    multi method spurt(IO::Handle:D: Blob $data, :$close) {
        LEAVE self.close if $close;
        self.write-internal($data);
    }
    multi method spurt(IO::Handle:D: Cool $data, :$close) {
        LEAVE self.close if $close;
        self.print($data);
    }

    method path(IO::Handle:D:)      { $!path.IO }
    method IO(IO::Handle:D:)        { $!path.IO }

    # use $.path, so IO::Pipe picks it up
    multi method Str(IO::Handle:D:) { $.path.Str }

    multi method gist(IO::Handle:D:) {
        "{self.^name}<$!path.gist()>({self.opened ?? 'opened' !! 'closed'})"
    }

    method flush(IO::Handle:D: --> True) {
        CATCH { default { fail X::IO::Flush.new: :os-error(.Str) } }
        nqp::defined($!PIO) or die 'File handle not open, so cannot flush';
        nqp::flushfh($!PIO);
    }

    proto method encoding(|) { * }
    multi method encoding(IO::Handle:D:) { $!encoding // Nil }
    multi method encoding(IO::Handle:D: $new-encoding is copy) {
        with $new-encoding {
            if $_ eq 'bin' {
                $_ = Nil;
            }
            else {
                return $!encoding if $!encoding && $!encoding eq $_;
            }
        }
        with $!decoder {
            # We're switching encoding, or back to binary mode. First grab any
            # bytes the current decoder is holding on to but has not yet done
            # decoding of.
            my $available = $!decoder.bytes-available;
            with $new-encoding {
                my $prev-decoder := $!decoder;
                my $encoding = Encoding::Registry.find($new-encoding);
                $!decoder := $encoding.decoder(:translate-nl);
                $!decoder.set-line-separators($!nl-in.list);
                $!decoder.add-bytes($prev-decoder.consume-exactly-bytes($available))
                    if $available;
                $!encoder := $encoding.encoder(:translate-nl);
                $!encoding = $encoding.name;
            }
            else {
                nqp::seekfh($!PIO, -$available, SeekFromCurrent) if $available;
                $!decoder := Encoding::Decoder;
                $!encoder := Encoding::Encoder;
                $!encoding = Nil;
                Nil
            }
        }
        else {
            # No previous decoder; make a new one if needed, otherwise no change.
            with $new-encoding {
                my $encoding = Encoding::Registry.find($new-encoding);
                $!decoder := $encoding.decoder(:translate-nl);
                $!decoder.set-line-separators($!nl-in.list);
                $!encoder := $encoding.encoder(:translate-nl);
                $!encoding = $encoding.name;
            }
            else {
                Nil
            }
        }
    }

    submethod DESTROY(IO::Handle:D:) {
        # Close handles with any file descriptor larger than 2. Those below
        # are our $*IN, $*OUT, and $*ERR, and we don't want them closed
        # implicitly via DESTROY, since you can't get them back again.
        nqp::if(
          nqp::defined($!PIO)
            && nqp::isgt_i((my int $fileno = nqp::filenofh($!PIO)), 2),
          nqp::stmts(
            nqp::closefh($!PIO),  # don't bother checking for errors




            ($!PIO := nqp::null),
            self!forget-about-closing($fileno)

          )
        )
    }

    method native-descriptor(IO::Handle:D:) {
        nqp::filenofh($!PIO)
    }
}

Rakudo::Internals.REGISTER-DYNAMIC: '$*DEFAULT-READ-ELEMS', {
    PROCESS::<$DEFAULT-READ-ELEMS> := %*ENV<RAKUDO_DEFAULT_READ_ELEMS> // 65536;
}

#line 1 SETTING::src/core/IO/Pipe.pm
my class IO::Pipe is IO::Handle {
    has $.proc;
    has $!on-read;
    has $!on-write;
    has $!on-close;
    has $!on-native-descriptor;
    has $!eof = False;
    has $!closed = False;

    method TWEAK(:$!on-close!, :$enc, :$bin, :$!on-read, :$!on-write,
                 :$!on-native-descriptor --> Nil) {
        if $bin {
            die X::IO::BinaryAndEncoding.new if nqp::isconcrete($enc);
        }
        else {
            my $encoding = Encoding::Registry.find($enc || 'utf-8');
            nqp::bindattr(self, IO::Handle, '$!encoding', $encoding.name);
            my $decoder := $encoding.decoder(:translate-nl);
            $decoder.set-line-separators($.nl-in.list);
            nqp::bindattr(self, IO::Handle, '$!decoder', $decoder);
            nqp::bindattr(self, IO::Handle, '$!encoder', $encoding.encoder(:translate-nl))
        }
    }

    method read-internal($) {
        if $!on-read {
            loop {
                my \result = $!on-read();
                if result.DEFINITE {
                    return result if result.elems;
                }
                else {
                    $!eof = True;
                    return buf8.new
                }
            }
        }
        else {
            die "This pipe was opened for writing, not reading"
        }
    }

    method eof-internal() {
        $!eof
    }

    method write-internal($data) {
        $!on-write
            ?? $!on-write($data)
            !! die "This pipe was opened for reading, not writing"
    }

    method flush(IO::Handle:D: --> True) { #`(No buffering) }

    method close(IO::Pipe:D:) {
        $!closed = True;
        $!on-close()
    }

    method opened(IO::Pipe:D:) {
        not $!closed
    }

    method t(IO::Pipe:D:) {
        False
    }

    method native-descriptor(IO::Pipe:D:) {
        $!on-native-descriptor
            ?? $!on-native-descriptor()
            !! die("This pipe does not have an associated native descriptor")
    }

    method IO   { IO::Path }
    method path { IO::Path }
}

#line 1 SETTING::src/core/IO/Path.pm
my class IO::Path is Cool does IO {
    has IO::Spec $.SPEC;
    has Str      $.CWD;
    has Str      $.path;
    has Bool $!is-absolute;
    has Str  $!abspath;
    has %!parts;

    multi method ACCEPTS(IO::Path:D: Cool:D \other) {
        nqp::p6bool(nqp::iseq_s($.absolute, nqp::unbox_s(other.IO.absolute)));
    }

    submethod BUILD(:$!path!, :$!SPEC!, :$!CWD! --> Nil) {
        nqp::unless(nqp::chars($!path), # could be an IntStr, so check chars
            die "Must specify something as a path: did you mean '.' for the current directory?"
        );
        nqp::if(
               nqp::isne_i(nqp::index($!path, "\0"), -1)
            || nqp::isne_i(nqp::index($!CWD,  "\0"), -1),
            X::IO::Null.new.throw
        );
    }

    method !new-from-absolute-path($path, :$SPEC = $*SPEC, Str() :$CWD = $*CWD) {
        self.bless(:$path, :$SPEC, :$CWD)!set-absolute($path);
    }

    method !set-absolute($path) {
        $!is-absolute = True;
        $!abspath := $path;
        self;
    }

    proto method new(|) {*}
    multi method new(IO::Path: Str $path, :$SPEC = $*SPEC, Str:D :$CWD) {
        self.bless(:$path, :$SPEC, :$CWD);
    }
    multi method new(IO::Path: Str $path, :$SPEC = $*SPEC, :$CWD = $*CWD) {
        self.bless(:$path, :$SPEC, :CWD($CWD.Str));
    }
    multi method new(IO::Path: Cool $path, :$SPEC = $*SPEC, :$CWD = $*CWD) {
        self.bless(:path($path.Str), :$SPEC, :CWD($CWD.Str));
    }
    multi method new(IO::Path:
      :$basename!,
      :$dirname  = '',
      :$volume   = '',
      :$SPEC     = $*SPEC,
      Str() :$CWD = $*CWD,
    ) {
        self.bless(:path($SPEC.join($volume,$dirname,$basename)),:$SPEC,:$CWD);
    }
    multi method new(IO::Path:) {
        die "Must specify something as a path: did you mean '.' for the current directory?";
    }

    method is-absolute() {
        nqp::if(
          nqp::isconcrete($!is-absolute),
          $!is-absolute,
          $!is-absolute = nqp::p6bool($!SPEC.is-absolute: $!path))
    }
    method is-relative() {
        nqp::p6bool(
          nqp::not_i(
            nqp::if(
              nqp::isconcrete($!is-absolute),
              $!is-absolute,
              $!is-absolute = nqp::p6bool($!SPEC.is-absolute: $!path))))
    }

    method parts {
        %!parts || (%!parts := nqp::create(Map).STORE: $!SPEC.split: $!path)
    }
    method volume(IO::Path:D:)   { %.parts<volume>   }
    method dirname(IO::Path:D:)  { %.parts<dirname>  }
    method basename(IO::Path:D:) { %.parts<basename> }


    my sub EXTENSION-MK-EXTENSION (
        str $name, $no-ext, int $part-min, int $part-max = $part-min
    ) is pure {
      my int $offset = nqp::chars($name);
      my int $next-offset;
      my int $parts;
      nqp::while(
        nqp::if(
          nqp::isne_i( -1,
            ($next-offset = nqp::rindex($name, '.', nqp::sub_i($offset, 1)))),
          nqp::if($offset, nqp::islt_i($parts, $part-max))
        ),
        nqp::stmts(
          ($offset = $next-offset),
          ($parts = nqp::add_i($parts, 1))
        ),
      );
      nqp::if(
        nqp::if(nqp::isle_i($part-min, $parts), nqp::isle_i($parts, $part-max)),
        nqp::substr($name, nqp::add_i($offset, 1)),
        $no-ext,
      )
    }
    my sub EXTENSION-SUBST ($ext, $base, $subst, $joiner) is pure {
      nqp::if(
        nqp::defined($ext),
        nqp::unless(
          nqp::concat(
            nqp::if(
              nqp::unless( # if extension is empty, check $base to find out if...
                nqp::chars($ext), #... it's a missing ext. or empty string ext.
                nqp::eqat($base, '.', nqp::sub_i(nqp::chars($base), 1))
              ),
              nqp::substr($base, 0,
                nqp::sub_i(nqp::chars($base), nqp::add_i(nqp::chars($ext), 1))
              ),
              $base,
            ),
            nqp::concat($joiner, $subst)
          ), '.' # use `.` as basename if we ended up with it being empty
        ),
        $base,
      )
    }
    proto method extension(|) {*}
    multi method extension(IO::Path:D:) {
      nqp::if(
        nqp::iseq_i(-1, (my int $offset = nqp::rindex(
          (my str $basename = nqp::unbox_s(self.basename)),'.'))),
        '', nqp::substr($basename, nqp::add_i($offset, 1))
      )
    }
    multi method extension(IO::Path:D: Int :$parts!) {
      EXTENSION-MK-EXTENSION self.basename, '',
        nqp::if(
          nqp::islt_I(nqp::decont($parts), -2**63), -2**63,
          nqp::if( nqp::isgt_I(nqp::decont($parts),  2**63-1), 2**63-1,
            nqp::unbox_i($parts),
          ),
        )
    }
    multi method extension(IO::Path:D: Range :$parts!) {
      my ($min, $max) := Rakudo::Internals.RANGE-AS-ints:
        $parts, "Can only use numeric, non-NaN Ranges as :parts";
      EXTENSION-MK-EXTENSION self.basename, '', $min, $max
    }
    multi method extension(IO::Path:D:
      Str $subst,
      Int :$parts = 1, Str :$joiner = nqp::if(nqp::chars($subst), '.', '')
    ) {
      self.new: :dirname(self.dirname), :volume(self.volume),
       :$!SPEC, :$!CWD, basename => EXTENSION-SUBST
            EXTENSION-MK-EXTENSION(
              (my str $base = nqp::unbox_s(self.basename)),
              Any, nqp::if(
                nqp::islt_I(nqp::decont($parts), -2**63), -2**63,
                nqp::if( nqp::isgt_I(nqp::decont($parts),  2**63-1), 2**63-1,
                  nqp::unbox_i($parts),
                ),
              )
            ), $base, $subst, $joiner;
    }
    multi method extension(
      Str $subst,
      Range :$parts, Str :$joiner = nqp::if(nqp::chars($subst), '.', '')
    ) {
      my ($min, $max) := Rakudo::Internals.RANGE-AS-ints:
        $parts, "Can only use numeric, non-NaN Ranges as :parts";
      self.new: :dirname(self.dirname), :volume(self.volume),
       :$!SPEC, :$!CWD, basename => EXTENSION-SUBST
        EXTENSION-MK-EXTENSION(
            (my str $base = nqp::unbox_s(self.basename)), Any, $min, $max
        ), $base, $subst, $joiner
    }

    method Numeric(IO::Path:D:) { self.basename.Numeric }

    multi method Str (IO::Path:D:) { $!path }
    multi method gist(IO::Path:D:) {
        $!is-absolute
          ?? qq|"$.absolute".IO|
          !! qq|"$.path".IO|
    }
    multi method perl(IO::Path:D:) {
        self.^name ~ ".new({$.path.perl}, {:$!SPEC.perl}, {:$!CWD.perl})"
    }

    method sibling(IO::Path:D: Str() \sibling) {
        $_ := self.parts;
        self.bless: :path($!SPEC.join: .<volume>, .<dirname>, sibling),
            :$!SPEC, :$!CWD;
    }

    method succ(IO::Path:D:) {
        self.bless(
          :path($!SPEC.join($.volume,$.dirname,$.basename.succ)),
          :$!SPEC,
          :$!CWD,
        );
    }
    method pred(IO::Path:D:) {
        self.bless(
          :path($!SPEC.join($.volume,$.dirname,$.basename.pred)),
          :$!SPEC,
          :$!CWD,
        );
    }

    multi method IO { self }
    method open(IO::Path:D: |c) { IO::Handle.new(:path(self)).open(|c) }


    method watch(IO::Path:D:) {
        IO::Notification.watch-path($.absolute);
    }


    proto method absolute(|) { * }
    multi method absolute (IO::Path:D:) {
        $!abspath //= $!SPEC.rel2abs($!path,$!CWD)
    }
    multi method absolute (IO::Path:D: $CWD) {
        self.is-absolute
          ?? self.absolute
          !! $!SPEC.rel2abs($!path, $CWD);
    }

    method relative (IO::Path:D: $CWD = $*CWD) {
        $!SPEC.abs2rel($.absolute, $CWD);
    }

    method cleanup (IO::Path:D:) {
        self.bless(:path($!SPEC.canonpath($!path)), :$!SPEC, :$!CWD);
    }
    method resolve (IO::Path:D: :$completely) {
        # XXXX: Not portable yet; assumes POSIX semantics
        my int $max-depth = 256;
        my str $sep       = $!SPEC.dir-sep;
        my str $cur       = $!SPEC.curdir;
        my str $up        = $!SPEC.updir;
        my str $empty     = '';
        my str $resolved  = $empty;
        my Mu  $res-list := nqp::list_s();







        # In this bit, we work with bytes, converting $sep (and assuming it's
        # 1-char long) in the path to nul bytes and then splitting the path
        # on nul bytes. This way, even if we get some weird paths like
        # "/\x[308]", we still split on the /, leaving the lone combiner as
        # part of the path part.
        nqp::stmts(
          (my $p := nqp::encode(
            nqp::unbox_s(self.absolute), 'utf8-c8', buf8.new)),
          (my int $ord-sep = nqp::ord($sep)),
          (my int $els = nqp::elems($p)),
          (my int $i = -1),
          nqp::while(
            nqp::isne_i($els, $i = nqp::add_i($i, 1)),
            nqp::if(
              nqp::iseq_i(nqp::atpos_i($p, $i), $ord-sep),
              nqp::atposref_i($p, $i) = 0)),
          my $parts := nqp::split("\0", nqp::decode($p, 'utf8-c8')));


        while $parts {
            fail "Resolved path too deep!"
                if $max-depth < nqp::elems($res-list) + nqp::elems($parts);

            # Grab next unprocessed part, check for '', '.', '..'
            my str $part = nqp::shift($parts);

            next if nqp::iseq_s($part, $empty) || nqp::iseq_s($part, $cur);
            if nqp::iseq_s($part, $up) {
                next unless $res-list;
                nqp::pop_s($res-list);
                $resolved = $res-list ?? $sep ~ nqp::join($sep, $res-list)
                                      !! $empty;
                next;
            }

            # Normal part, set as next path to test
            my str $next = nqp::concat($resolved, nqp::concat($sep, $part));

            # Path part doesn't exist...
            if !nqp::stat($next, nqp::const::STAT_EXISTS) {
                # fail() if we were asked for complete resolution and we still
                # have further parts to resolve. If it's the last part,
                # don't fail; it can be a yet-to-be-created file or dir
                $completely
                  && nqp::elems($parts)
                  && X::IO::Resolve.new(:path(self)).fail;

                # ...or handle rest in non-resolving mode if not
                $resolved = $next;
                while $parts {
                    $part = nqp::shift($parts);
                    next if nqp::iseq_s($part, $empty) || nqp::iseq_s($part, $cur);
                    $resolved = nqp::concat($resolved, nqp::concat($sep, $part));
                }
            }
            # Symlink; read it and act on absolute or relative link
            elsif nqp::fileislink($next) {
                my str $link        = nqp::readlink($next);
                my Mu  $link-parts := nqp::split($sep, $link);
                next unless $link-parts;

                # Symlink to absolute path
                if nqp::iseq_s($link-parts[0], $empty) {
                    $resolved  = nqp::shift($link-parts);
                    $res-list := nqp::list_s();
                }

                nqp::unshift($parts, nqp::pop($link-parts))
                    while $link-parts;
            }
            # Just a plain old path part, so append it and go on
            else {
                $resolved = $next;
                nqp::push_s($res-list, $part);
            }
        }
        $resolved = $sep unless nqp::chars($resolved);
        IO::Path!new-from-absolute-path($resolved,:$!SPEC,:CWD($sep));
    }
    proto method parent(|) { * }
    multi method parent(IO::Path:D: UInt:D $depth) {
        my $io = self;
        $io .= parent xx $depth;
        $io;
    }
    multi method parent(IO::Path:D:) {    # XXX needs work
        my $curdir := $!SPEC.curdir;
        my $updir  := $!SPEC.updir;

        if self.is-absolute {
            return self.bless(
              :path($!SPEC.join($.volume, $.dirname, '')),
              :$!SPEC,
              :$!CWD,
            );
        }
        elsif $.dirname eq $curdir and $.basename eq $curdir {
            return self.bless(
              :path($!SPEC.join($.volume,$curdir,$updir)),
              :$!SPEC,
              :$!CWD,
            );
        }
        elsif $.dirname eq $curdir && $.basename eq $updir
           or !grep({$_ ne $updir}, $!SPEC.splitdir($.dirname)) {
            return self.bless(    # If all updirs, then add one more
              :path($!SPEC.join($.volume,$!SPEC.catdir($.dirname,$updir),$.basename)),
              :$!SPEC,
              :$!CWD,
            );
        }
        else {
            return self.bless(
              :path($!SPEC.join($.volume, $.dirname, '')),
              :$!SPEC,
              :$!CWD,
            );
        }
    }

    method child (IO::Path:D: Str() \child) {
        self.bless: :path($!SPEC.join: '', $!path, child), :$!SPEC, :$!CWD
    }

    # XXX TODO: swap .child to .child-secure sometime close to 6.d
    # Discussion: https://irclog.perlgeek.de/perl6-dev/2017-04-17#i_14439386
    #
    # method child-secure (IO::Path:D: \child) {
    #     # The goal of this method is to guarantee the resultant child path is
    #     # inside the invocant. We resolve the path completely, so for that to
    #     # happen, the kid cannot be inside some currently non-existent dirs, so
    #     # this method will fail with X::IO::Resolve in those cases. To find out
    #     # if the kid is in fact a kid, we fully-resolve the kid and the
    #     # invocant. Then, we append a dir separator to invocant's .absolute and
    #     # check if the kid's .absolute starts with that string.
    #     nqp::if(
    #       nqp::istype((my $kid := self.child(child).resolve: :completely),
    #         Failure),
    #       $kid, # we failed to resolve the kid, return the Failure
    #       nqp::if(
    #         nqp::istype((my $res-self := self.resolve: :completely), Failure),
    #         $res-self, # failed to resolve invocant, return the Failure
    #         nqp::if(
    #           nqp::iseq_s(
    #             ($_ := nqp::concat($res-self.absolute, $!SPEC.dir-sep)),
    #             nqp::substr($kid.absolute, 0, nqp::chars($_))),
    #           $kid, # kid appears to be kid-proper; return it. Otherwise fail
    #           fail X::IO::NotAChild.new:
    #             :path($res-self.absolute), :child($kid.absolute))))
    # }

    method add (IO::Path:D: Str() \what) {
        self.bless: :path($!SPEC.join: '', $!path, what), :$!SPEC, :$!CWD;
    }

    proto method chdir(|) { * }
    multi method chdir(IO::Path:D: Str() $path, :$test!) {
        DEPRECATED(
            :what<:$test argument>,
            'individual named parameters (e.g. :r, :w, :x)',
            "v2017.03.101.ga.5800.a.1", "v6.d", :up(*),
        );
        self.chdir: $path, |$test.words.map(* => True).Hash;
    }
    multi method chdir(IO::Path:D: IO $path, |c) {
        self.chdir: $path.absolute, |c
    }
    multi method chdir(
        IO::Path:D: Str() $path is copy, :$d = True, :$r, :$w, :$x,
    ) {
        unless $!SPEC.is-absolute($path) {
            my ($volume,$dirs) = $!SPEC.splitpath(self.absolute, :nofile);
            my @dirs = $!SPEC.splitdir($dirs);
            @dirs.shift; # the first is always empty for absolute dirs
            for $!SPEC.splitdir($path) -> $dir {
                if $dir eq '..' {
                    @dirs.pop if @dirs;
                }
                elsif $dir ne '.' {
                    @dirs.push: $dir;
                }
            }
            @dirs.push('') if !@dirs;  # need at least the rootdir
            $path = join($!SPEC.dir-sep, $volume, @dirs);
        }
        my $dir = IO::Path!new-from-absolute-path($path,:$!SPEC,:CWD(self));

        nqp::stmts(
            nqp::unless(
                nqp::unless(nqp::isfalse($d), $dir.d),
                fail X::IO::Chdir.new: :$path, :os-error(
                    nqp::if($dir.e, 'is not a directory', 'does not exist')
                )
            ),
            nqp::unless(
                nqp::unless(nqp::isfalse($r), $dir.r),
                fail X::IO::Chdir.new: :$path, :os-error("did not pass :r test")
            ),
            nqp::unless(
                nqp::unless(nqp::isfalse($w), $dir.w),
                fail X::IO::Chdir.new: :$path, :os-error("did not pass :w test")
            ),
            nqp::unless(
                nqp::unless(nqp::isfalse($x), $dir.x),
                fail X::IO::Chdir.new: :$path, :os-error("did not pass :x test")
            ),
            $dir
        )
    }

    method rename(IO::Path:D: IO() $to, :$createonly --> True) {
        $createonly and $to.e and fail X::IO::Rename.new:
            :from($.absolute),
            :to($to.absolute),
            :os-error(':createonly specified and destination exists');

        nqp::rename($.absolute, nqp::unbox_s($to.absolute));
        CATCH { default {
            fail X::IO::Rename.new:
                :from($!abspath), :to($to.absolute), :os-error(.Str);
        }}
    }

    method copy(IO::Path:D: IO() $to, :$createonly --> True) {
        $createonly and $to.e and fail X::IO::Copy.new:
            :from($.absolute),
            :to($to.absolute),
            :os-error(':createonly specified and destination exists');

        # XXX TODO: maybe move the sameness check to the nqp OP/VM
        nqp::if(
            nqp::iseq_s(
                (my $from-abs :=   $.absolute),
                (my $to-abs   := $to.absolute)),
            X::IO::Copy.new(:from($from-abs), :to($to-abs),
                :os-error('source and target are the same')).fail,
            nqp::copy($from-abs, $to-abs));

        CATCH { default {
            fail X::IO::Copy.new:
                :from($!abspath), :to($to.absolute), :os-error(.Str)
        }}
    }

    method move(IO::Path:D: |c --> True) {
        self.copy(|c) orelse fail X::IO::Move.new: :from(.exception.from),
            :to(.exception.to), :os-error(.exception.os-error);
        self.unlink   orelse fail X::IO::Move.new: :from(.exception.from),
            :to(.exception.to), :os-error(.exception.os-error);
    }

    method chmod(IO::Path:D: Int() $mode --> True) {
        nqp::chmod($.absolute, nqp::unbox_i($mode));
        CATCH { default {
            fail X::IO::Chmod.new(
              :path($!abspath), :$mode, :os-error(.Str) );
        }}
    }
    method unlink(IO::Path:D: --> True) {
        nqp::unlink($.absolute);
        CATCH { default {
            fail X::IO::Unlink.new( :path($!abspath), os-error => .Str );
        }}
    }

    method symlink(IO::Path:D: IO() $name --> True) {
        nqp::symlink($.absolute, nqp::unbox_s($name.absolute));
        CATCH { default {
            fail X::IO::Symlink.new:
                :target($!abspath), :name($name.absolute), :os-error(.Str);
        }}
    }

    method link(IO::Path:D: IO() $name --> True) {
        nqp::link($.absolute, $name.absolute);
        CATCH { default {
            fail X::IO::Link.new:
                :target($!abspath), :name($name.absolute), :os-error(.Str);
        }}
    }

    method mkdir(IO::Path:D: Int() $mode = 0o777) {
        nqp::mkdir($.absolute, $mode);
        CATCH { default {
            fail X::IO::Mkdir.new(:path($!abspath), :$mode, os-error => .Str);
        }}
        self
    }

    method rmdir(IO::Path:D: --> True) {
        nqp::rmdir($.absolute);
        CATCH { default {
            fail X::IO::Rmdir.new(:path($!abspath), os-error => .Str);
        }}
    }

    proto method dir(|) {*} # make it possible to augment with multies from modulespace
    multi method dir(IO::Path:D:
        Mu :$test = $*SPEC.curupdir,
        :$CWD = $*CWD,
    ) {

        CATCH { default {
            fail X::IO::Dir.new(
              :path($.absolute), :os-error(.Str) );
        } }

        my str $dir-sep  = $!SPEC.dir-sep;
        my int $absolute = $.is-absolute;

        my str $abspath;
        $absolute && nqp::unless( # calculate $abspath only when we'll need it
            nqp::eqat(($abspath = $.absolute), $dir-sep,
                nqp::sub_i(nqp::chars($abspath), 1)),
            ($abspath = nqp::concat($abspath, $dir-sep)));

        my str $path = nqp::iseq_s($!path, '.') || nqp::iseq_s($!path, $dir-sep)
          ?? ''
          !! nqp::eqat($!path, $dir-sep, nqp::sub_i(nqp::chars($!path), 1))
            ?? $!path
            !! nqp::concat($!path, $dir-sep);

        my Mu $dirh := nqp::opendir(nqp::unbox_s($.absolute));
        gather {
           # set $*CWD inside gather for $test.ACCEPTS to use correct
           # $*CWD the user gave us, instead of whatever $*CWD is
           # when the gather is actually evaluated. We use a temp var
           # so that .IO coercer doesn't use the nulled `$*CWD` for
           # $!CWD attribute and we don't use `temp` for this, because
           # it's about 2x slower than using a temp var.
           my $cwd = $CWD.IO;
          { my $*CWD = $cwd;










            nqp::until(
              nqp::isnull_s(my str $str-elem = nqp::nextfiledir($dirh))
                || nqp::iseq_i(nqp::chars($str-elem),0),
              nqp::if(
                $test.ACCEPTS($str-elem),
                nqp::if(
                  $absolute,
                  (take IO::Path!new-from-absolute-path(
                    nqp::concat($abspath,$str-elem),:$!SPEC,:$CWD)),
                  (take IO::Path.new(
                    nqp::concat($path,$str-elem),:$!SPEC,:$CWD)),)));
            nqp::closedir($dirh);
          }
        }
    }

    proto method slurp() { * }
    multi method slurp(IO::Path:D: :$enc, :$bin) {
        # We use an IO::Handle in binary mode, and then decode the string
        # all in one go, which avoids the overhead of setting up streaming
        # decoding.
        nqp::if(
            nqp::istype((my $handle := IO::Handle.new(:path(self)).open(:bin)), Failure),
            $handle,
            nqp::stmts(
                (my $blob := $handle.slurp(:close)),
                nqp::if($bin, $blob, nqp::join("\n",
                  nqp::split("\r\n", $blob.decode: $enc || 'utf-8')))
            ))
    }

    method spurt(IO::Path:D: $data, :$enc, :$append, :$createonly) {
        my $fh := self.open:
            :$enc,     :bin(nqp::istype($data, Blob)),
            :mode<wo>, :create, :exclusive($createonly),
            :$append,  :truncate(
                nqp::if(nqp::isfalse($append), nqp::isfalse($createonly))
            );
        nqp::if( nqp::istype($fh, Failure), $fh, $fh.spurt($data, :close) )
    }

    # XXX TODO: when we get definedness-based defaults in core, use them in
    # IO::Handle.open and get rid of duplication of default values here
    method lines(IO::Path:D:
        :$chomp = True, :$enc = 'utf8', :$nl-in = ["\x0A", "\r\n"], |c
    ) {
        self.open(:$chomp, :$enc, :$nl-in).lines: |c, :close
    }
    method comb(IO::Path:D:
        :$chomp = True, :$enc = 'utf8', :$nl-in = ["\x0A", "\r\n"], |c
    ) {
        self.open(:$chomp, :$enc, :$nl-in).comb:  |c, :close
    }
    method split(IO::Path:D:
        :$chomp = True, :$enc = 'utf8', :$nl-in = ["\x0A", "\r\n"], |c
    ) {
        self.open(:$chomp, :$enc, :$nl-in).split: |c, :close
    }
    method words(IO::Path:D:
        :$chomp = True, :$enc = 'utf8', :$nl-in = ["\x0A", "\r\n"], |c
    ) {
        self.open(:$chomp, :$enc, :$nl-in).words: |c, :close
    }

    method e(IO::Path:D: --> Bool:D) {
        ?Rakudo::Internals.FILETEST-E($.absolute) # must be $.absolute
    }
    method d(IO::Path:D: --> Bool:D) {
        $.e
          ?? ?Rakudo::Internals.FILETEST-D($!abspath)
          !! Failure.new(X::IO::DoesNotExist.new(:path($!abspath),:trying<d>))
    }

    method f(IO::Path:D: --> Bool:D) {
        $.e
          ?? ?Rakudo::Internals.FILETEST-F($!abspath)
          !! Failure.new(X::IO::DoesNotExist.new(:path($!abspath),:trying<f>))
    }

    method s(IO::Path:D: --> Int:D) {
        $.e
          ?? Rakudo::Internals.FILETEST-S($!abspath)
          !! Failure.new(X::IO::DoesNotExist.new(:path($!abspath),:trying<s>))
    }

    method l(IO::Path:D: --> Bool:D) {
        ?Rakudo::Internals.FILETEST-LE($.absolute)
          ?? ?Rakudo::Internals.FILETEST-L($!abspath)
          !! Failure.new(X::IO::DoesNotExist.new(:path($!abspath),:trying<l>))
    }

    method r(IO::Path:D: --> Bool:D) {
        $.e
          ?? ?Rakudo::Internals.FILETEST-R($!abspath)
          !! Failure.new(X::IO::DoesNotExist.new(:path($!abspath),:trying<r>))
    }

    method w(IO::Path:D: --> Bool:D) {
        $.e
          ?? ?Rakudo::Internals.FILETEST-W($!abspath)
          !! Failure.new(X::IO::DoesNotExist.new(:path($!abspath),:trying<w>))
    }

    method rw(IO::Path:D: --> Bool:D) {
        $.e
          ?? ?Rakudo::Internals.FILETEST-RW($!abspath)
          !! Failure.new(X::IO::DoesNotExist.new(:path($!abspath),:trying<rw>))
    }

    method x(IO::Path:D: --> Bool:D) {
        $.e
          ?? ?Rakudo::Internals.FILETEST-X($!abspath)
          !! Failure.new(X::IO::DoesNotExist.new(:path($!abspath),:trying<x>))
    }

    method rwx(IO::Path:D: --> Bool:D) {
        $.e
          ?? ?Rakudo::Internals.FILETEST-RWX($!abspath)
          !! Failure.new(X::IO::DoesNotExist.new(:path($!abspath),:trying<rwx>))
    }

    method z(IO::Path:D: --> Bool:D) {
        $.e
          ?? ?Rakudo::Internals.FILETEST-Z($!abspath)
          !! Failure.new(X::IO::DoesNotExist.new(:path($!abspath),:trying<z>))
    }

    method modified(IO::Path:D: --> Instant:D) {
        $.e
          ?? Instant.from-posix(Rakudo::Internals.FILETEST-MODIFIED($!abspath))
          !! Failure.new(X::IO::DoesNotExist.new(:path($!abspath),:trying<modified>))
    }

    method accessed(IO::Path:D: --> Instant:D) {
        $.e
          ?? Instant.from-posix(Rakudo::Internals.FILETEST-ACCESSED($!abspath))
          !! Failure.new(X::IO::DoesNotExist.new(:path($!abspath),:trying<accessed>))
    }

    method changed(IO::Path:D: --> Instant:D) {
        $.e
          ?? Instant.from-posix(Rakudo::Internals.FILETEST-CHANGED($!abspath))
          !! Failure.new(X::IO::DoesNotExist.new(:path($!abspath),:trying<changed>))
    }

    method mode(IO::Path:D: --> IntStr:D) {
        $.e
          ?? nqp::stmts(
              (my int $mode = nqp::stat($!abspath, nqp::const::STAT_PLATFORM_MODE) +& 0o7777),
              IntStr.new($mode, sprintf('%04o', $mode))
            )
          !! Failure.new(X::IO::DoesNotExist.new(:path($!abspath),:trying<mode>))
    }
}

my class IO::Path::Cygwin is IO::Path {
    method new(|c) { self.IO::Path::new(|c, :SPEC(IO::Spec::Cygwin) ) }
    multi method perl(::?CLASS:D:) {
        self.^name ~ ".new({$.path.perl}, {:$.CWD.perl})"
    }
}
my class IO::Path::QNX is IO::Path {
    method new(|c) { self.IO::Path::new(|c, :SPEC(IO::Spec::QNX) ) }
    multi method perl(::?CLASS:D:) {
        self.^name ~ ".new({$.path.perl}, {:$.CWD.perl})"
    }
}
my class IO::Path::Unix is IO::Path {
    method new(|c) { self.IO::Path::new(|c, :SPEC(IO::Spec::Unix) ) }
    multi method perl(::?CLASS:D:) {
        self.^name ~ ".new({$.path.perl}, {:$.CWD.perl})"
    }
}
my class IO::Path::Win32 is IO::Path {
    method new(|c) { self.IO::Path::new(|c, :SPEC(IO::Spec::Win32) ) }
    multi method perl(::?CLASS:D:) {
        self.^name ~ ".new({$.path.perl}, {:$.CWD.perl})"
    }
}

#line 1 SETTING::src/core/io_operators.pm
my class IO::ArgFiles { ... }

proto sub print(|) { * }
multi sub print(Str:D \x) {
    $*OUT.print(x);
}
multi sub print(\x) {
    $*OUT.print(x.Str);
}
multi sub print(**@args is raw) {
    my str $str;
    $str = nqp::concat($str,nqp::unbox_s(.Str)) for @args;
    $*OUT.print($str);
}

proto sub say(|) { * }
multi sub say() { $*OUT.print-nl }
multi sub say(Str:D \x) {
    my $out := $*OUT;
    $out.print(nqp::concat(nqp::unbox_s(x),$out.nl-out));
}
multi sub say(\x) {
    my $out := $*OUT;
    $out.print(nqp::concat(nqp::unbox_s(x.gist),$out.nl-out));
}
multi sub say(**@args is raw) {
    my str $str;
    my $iter := @args.iterator;
    nqp::until(
      nqp::eqaddr(($_ := $iter.pull-one), IterationEnd),
      $str = nqp::concat($str, nqp::unbox_s(.gist)));
    my $out := $*OUT;
    $out.print(nqp::concat($str,$out.nl-out));
}

proto sub put(|) { * }
multi sub put() { $*OUT.print-nl }
multi sub put(Str:D \x) {
    my $out := $*OUT;
    $out.print(nqp::concat(nqp::unbox_s(x),$out.nl-out));
}
multi sub put(\x) {
    my $out := $*OUT;
    $out.print(nqp::concat(nqp::unbox_s(x.Str),$out.nl-out));
}
multi sub put(**@args is raw) {
    my str $str;
    my $iter := @args.iterator;
    nqp::until(
      nqp::eqaddr(($_ := $iter.pull-one), IterationEnd),
      $str = nqp::concat($str, nqp::unbox_s(.Str)));
    my $out := $*OUT;
    $out.print(nqp::concat($str,$out.nl-out));
}

proto sub note(|) { * }
multi sub note() {
    my $err := $*ERR;
    $err.print(nqp::concat("Noted",$err.nl-out));
}
multi sub note(Str:D \x) {
    my $err := $*ERR;
    $err.print(nqp::concat(nqp::unbox_s(x),$err.nl-out));
}
multi sub note(**@args is raw) {
    my $err := $*ERR;
    my str $str;
    $str = nqp::concat($str,nqp::unbox_s(.gist)) for @args;
    $err.print(nqp::concat($str,$err.nl-out));
}

sub gist(|) {
    my \args := nqp::p6argvmarray();
    nqp::elems(args) == 1
        ?? nqp::atpos(args, 0).gist
        !! nqp::p6bindattrinvres(nqp::create(List), List, '$!reified', args).gist
}

multi sub prompt() {
    $*IN.get
}
multi sub prompt($msg) {
    my $out := $*OUT;
    $out.print($msg);
    $out.flush();
    $*IN.get;
}

proto sub dir(|) { * }
multi sub dir(*%_) { $*SPEC.curdir.IO.dir(:!absolute, |%_) }
multi sub dir(IO::Path:D $path, |c) { $path.dir(|c) }
multi sub dir(IO()       $path, |c) { $path.dir(|c) }

proto sub open(|) { * }
multi sub open(IO() $path, |c) { IO::Handle.new(:$path).open(|c) }

proto sub lines(|) { * }
multi sub lines($what = $*ARGFILES, |c) { $what.lines(|c) }

proto sub words(|) { * }
multi sub words($what = $*ARGFILES, |c) { $what.words(|c) }

proto sub get  (|) { * }
multi sub get  (IO::Handle:D $fh = $*ARGFILES) { $fh.get  }

proto sub getc (|) { * }
multi sub getc (IO::Handle:D $fh = $*ARGFILES) { $fh.getc }

proto sub close(|) { * }
multi sub close(IO::Handle:D $fh) { $fh.close }

proto sub slurp(|) { * }
multi sub slurp(IO::Handle:D $fh = $*ARGFILES, |c) { $fh.slurp(|c) }
multi sub slurp(IO() $path, |c) { $path.slurp(|c) }

proto sub spurt(|) { * }
multi sub spurt(IO::Handle:D $fh,   |c) { $fh  .spurt(|c) }
multi sub spurt(IO()       $path, |c) { $path.spurt(|c) }

{
    sub chdir(IO() $path) {
        CATCH {
            default {
                return Failure.new: X::IO::Chdir.new: :$path, :os-error(.Str);
            }
        }
        nqp::chdir(nqp::unbox_s($path.absolute));
        $*CWD = IO::Path.new(nqp::cwd());
    }
    PROCESS::<&chdir> := &chdir;
}

sub chdir(|c) {
    nqp::if(nqp::istype(($_ := $*CWD.chdir(|c)), Failure), $_, $*CWD = $_)
}

proto sub indir(|) {*}
multi sub indir(IO() $path, &what, :$test!) {
    DEPRECATED(
        :what<:$test argument>,
        'individual named parameters (e.g. :r, :w, :x)',
        "v2017.03.101.ga.5800.a.1", "v6.d", :up(*),
    );
    indir $path, &what, |$test.words.map(* => True).Hash;
}
multi sub indir(IO() $path, &what, :$d = True, :$r, :$w, :$x) {
    {   # NOTE: we need this extra block so that the IO() coercer doesn't
        # use our (empty at the time) $*CWD when making the IO::Path object
        nqp::stmts(
          $d && nqp::isfalse($path.d) && X::IO::Chdir.new(
            :$path, :os-error(
              $path.e ?? 'is not a directory' !! 'does not exist')).fail,
          $r && nqp::isfalse($path.r) && X::IO::Chdir.new(
            :$path, :os-error("did not pass :r test")).fail,
          $w && nqp::isfalse($path.w) && X::IO::Chdir.new(
            :$path, :os-error("did not pass :w test")).fail,
          $x && nqp::isfalse($path.x) && X::IO::Chdir.new(
            :$path, :os-error("did not pass :x test")).fail,
          # $*CWD gets stringified with .Str in IO::Path.new, so we need to
          # ensure it's set to an absolute path
          my $*CWD = $path.WHAT.new: $path.absolute,
            :SPEC($path.SPEC), :CWD($path.SPEC.rootdir))
        && what
    }
}

# Set up the standard STDIN/STDOUT/STDERR by first setting up the skeletons
# of the IO::Handle objects that can be setup at compile time.  Then, when
# running the mainline of the setting at startup, plug in the low level
# handles and set up the encoder and decoders.  This shaves off about 1.5%
# of bare startup.
{
    my constant NL-IN    = ["\x0A", "\r\n"];
    my constant NL-OUT   = "\n";
    my constant ENCODING = "utf8";

    my sub setup-handle(str $what) {
        my $handle := nqp::p6bindattrinvres(
          nqp::create(IO::Handle),IO::Handle,'$!path',nqp::p6bindattrinvres(
            nqp::create(IO::Special),IO::Special,'$!what',$what
          )
        );
        nqp::getattr($handle,IO::Handle,'$!chomp')    = True;
        nqp::getattr($handle,IO::Handle,'$!nl-in')    = NL-IN;
        nqp::getattr($handle,IO::Handle,'$!nl-out')   = NL-OUT;
        nqp::getattr($handle,IO::Handle,'$!encoding') = ENCODING;
        $handle
    }

    # Set up the skeletons at compile time
    my constant STDIN  = setup-handle('<STDIN>');
    my constant STDOUT = setup-handle('<STDOUT>');
    my constant STDERR = setup-handle('<STDERR>');

    my sub activate-handle(Mu \HANDLE, Mu \PIO) {
        nqp::setbuffersizefh(PIO,8192) unless nqp::isttyfh(PIO);

        my $encoding = Encoding::Registry.find(ENCODING);
        nqp::bindattr(
          HANDLE,IO::Handle,'$!decoder',$encoding.decoder(:translate-nl)
        ).set-line-separators(NL-IN);
        nqp::bindattr(
          HANDLE,IO::Handle,'$!encoder',$encoding.encoder(:translate-nl)
        );
        nqp::p6bindattrinvres(HANDLE,IO::Handle,'$!PIO',PIO)
    }

    # Activate the skeletons at runtime
    PROCESS::<$IN>  = activate-handle(STDIN,  nqp::getstdin);
    PROCESS::<$OUT> = activate-handle(STDOUT, nqp::getstdout);
    PROCESS::<$ERR> = activate-handle(STDERR, nqp::getstderr);
}

sub chmod($mode, *@filenames) {
    my @ok;
    for @filenames -> $file { @ok.push($file) if $file.IO.chmod($mode) }
    @ok;
}
sub unlink(*@filenames) {
    my @ok;
    for @filenames -> $file { @ok.push($file) if $file.IO.unlink }
    @ok;
}
sub rmdir(*@filenames) {
    my @ok;
    for @filenames -> $file { @ok.push($file) if $file.IO.rmdir }
    @ok;
}
sub mkdir(IO() $path, Int() $mode = 0o777) { $path.mkdir($mode) }

sub rename(IO() $from, IO() $to, :$createonly) {
    $from.rename($to, :$createonly)
}
sub copy(IO() $from, IO() $to, :$createonly) { $from.copy($to, :$createonly) }
sub move(IO() $from, IO() $to, :$createonly) { $from.move($to, :$createonly) }

sub symlink(IO() $target, IO() $name) { $target.symlink($name) }
sub    link(IO() $target, IO() $name) { $target   .link($name) }

#line 1 SETTING::src/core/IO/CatHandle.pm
my class IO::CatHandle is IO::Handle {
    has $!handles;
    has $!active-handle is default(Nil);

    has $.chomp is rw;
    has $.nl-in;
    has Str $.encoding;
    has &.on-switch is rw;

    multi method perl(::?CLASS:D:) {
        my @handles =
            ($!active-handle if $!active-handle),
            |nqp::p6bindattrinvres((), List, '$!reified', $!handles);

        my $parts = join ', ',
            (@handles.List.perl if @handles),
            (':!chomp' if not $!chomp),
            (":nl-in({$!nl-in.list.perl})" if $!nl-in !eqv ["\x0A", "\r\n"]),
            (nqp::isconcrete($!encoding)
                ?? ":encoding({$!encoding.perl})"
                !! ':bin'),
            (':&.on-switch({;})' if &!on-switch); # can't .perl Callables :(

        "{self.^name}.new($parts)"
    }

    method !SET-SELF (
        @handles, &!on-switch, $!chomp, $!nl-in, $encoding, $bin
    ) {
        nqp::if(
          $bin,
          nqp::isconcrete($encoding) && X::IO::BinaryAndEncoding.new.throw,
          $!encoding = $encoding || 'utf8');

        @handles.elems; # reify
        $!handles := nqp::getattr(@handles || [], List, '$!reified');
        self.next-handle;
        self
    }
    method new (
        *@handles, :&on-switch,
        :$chomp = True, :$nl-in = ["\x0A", "\r\n"], Str :$encoding, Bool :$bin
    ) {
        self.bless!SET-SELF:
            @handles, &on-switch, $chomp, $nl-in, $encoding, $bin
    }
    method next-handle {
      # Set $!active-handle to the next handle in line, opening it if necessary
      nqp::stmts(
        (my $old-handle is default(Nil) = $!active-handle),
        nqp::if(
          nqp::defined($!active-handle),
          (my $ = $!active-handle.close)), # don't sink the result, since it might
          # .. be an IO::Pipe that returns a Proc that might throw
        nqp::if(
          nqp::elems($!handles),
          nqp::if(
            nqp::istype(($_ := nqp::shift($!handles)), IO::Handle),
            nqp::if(
              .opened,
              nqp::stmts(
                (.encoding: $!encoding), # *Jedi wave*
                (.nl-in = $!nl-in),      # These aren't the attribute assignment
                (.chomp = $!chomp),      # inconsistencies you're looking for!
                $!active-handle = $_),
              nqp::if(
                nqp::istype(
                  ($_ = .open: :r, :$!chomp, :$!nl-in, :enc($!encoding),
                    :bin(nqp::p6bool(nqp::isfalse($!encoding)))),
                  Failure),
                .throw,
                ($!active-handle = $_))),
            nqp::if(
              nqp::istype(
                ($_ := .IO.open: :r, :$!chomp, :$!nl-in, :enc($!encoding),
                  :bin(nqp::p6bool(nqp::isfalse($!encoding)))),
                Failure),
              .throw,
              ($!active-handle = $_))),
          ($!active-handle = Nil)),
        nqp::if(
          &!on-switch,
          nqp::stmts(
            (my $c := &!on-switch.count),
            nqp::if(
              $c,
              nqp::if(
                nqp::istype($c, Num) || nqp::iseq_i($c, 2), # inf or 2
                &!on-switch($!active-handle, $old-handle),
                nqp::if(
                  nqp::iseq_i($c, 1),
                  &!on-switch($!active-handle),
                  die ':&on-switch must have .count 0, 1, 2, or Inf')),
              &!on-switch()))),
        $!active-handle)
    }

    method chomp (::?CLASS:D:) is rw {
        Proxy.new:
          :FETCH{ $!chomp },
          :STORE( -> $, $chomp {
              $!active-handle && $!active-handle.chomp = $chomp;
              $!chomp = $chomp
          })
    }

    # XXX TODO: Make these routine read handle lazily when we have Cat type
    method comb (::?CLASS:D: |c) { self.slurp.comb:  |c }
    method split(::?CLASS:D: |c) { self.slurp.split: |c }

    method !WORDS {
      nqp::if(
        nqp::defined($!active-handle),
        (flat $!active-handle.words, gather {
          nqp::while(
            nqp::defined(self.next-handle),
            take $!active-handle.words)}),
        Seq.new: Rakudo::Iterator.Empty)
    }
    multi method words(::?CLASS:D \SELF: $limit, :$close) {
        nqp::istype($limit,Whatever) || $limit == Inf
          ?? self.words(:$close)
          !! $close
            ?? Seq.new(Rakudo::Iterator.FirstNThenSinkAll(
                self!WORDS.iterator, $limit.Int, {SELF.close}))
            !! self.words.head($limit.Int)
    }
    multi method words(::?CLASS:D \SELF: :$close!) {
      $close # use -1 as N in FirstNThenSinkAllSeq to get all items
        ?? Seq.new(Rakudo::Iterator.FirstNThenSinkAll(
            self!WORDS.iterator, -1, {SELF.close}))
        !! self!WORDS
    }
    multi method words(::?CLASS:D:) { self!WORDS }

    method !LINES {
      nqp::if(
        nqp::defined($!active-handle),
        (flat $!active-handle.lines, gather {
          nqp::while(
            nqp::defined(self.next-handle),
            take $!active-handle.lines)}),
        Seq.new: Rakudo::Iterator.Empty)
    }
    multi method lines(::?CLASS:D \SELF: $limit, :$close) {
        nqp::istype($limit,Whatever) || $limit == Inf
          ?? self.lines(:$close)
          !! $close
            ?? Seq.new(Rakudo::Iterator.FirstNThenSinkAll(
                self!LINES.iterator, $limit.Int, {SELF.close}))
            !! self.lines.head($limit.Int)
    }
    multi method lines(::?CLASS:D \SELF: :$close!) {
      $close # use -1 as N in FirstNThenSinkAllSeq to get all items
        ?? Seq.new(Rakudo::Iterator.FirstNThenSinkAll(
            self!LINES.iterator, -1, {SELF.close}))
        !! self!LINES
    }
    multi method lines(::?CLASS:D:) { self!LINES }

    multi method Supply (::?CLASS:D: :$size = $*DEFAULT-READ-ELEMS --> Supply:D) {
        nqp::if(
          nqp::isconcrete($!encoding),
          (supply nqp::stmts(
            (my str $str = self.readchars: $size),
            nqp::while(
              nqp::chars($str),
              nqp::stmts(
                (emit nqp::p6box_s($str)),
                ($str = self.readchars: $size))),
            done)),
          (supply nqp::stmts(
            (my $buf := self.read: $size),
            nqp::while(
              nqp::elems($buf),
              nqp::stmts(
                (emit $buf),
                ($buf := self.read: $size))),
            done)))
    }

    # Get a single result, going to the next handle on EOF
    method get (::?CLASS:D:) {
        nqp::if(
          nqp::defined($!active-handle),
          nqp::stmts(
            nqp::while(
              nqp::eqaddr(Nil, my $res := $!active-handle.get)
              && nqp::defined(self.next-handle),
              nqp::null),
            $res),
          Nil)
    }
    method getc (::?CLASS:D:) {
        nqp::if(
          nqp::defined($!active-handle),
          nqp::stmts(
            nqp::while(
              nqp::eqaddr(Nil, my $res := $!active-handle.getc)
              && nqp::defined(self.next-handle),
              nqp::null),
            $res),
          Nil)
    }
    method read (::?CLASS:D: Int(Cool:D) $bytes = $*DEFAULT-READ-ELEMS) {
        nqp::if(
          nqp::defined($!active-handle),
          nqp::stmts(
            (my $ret := buf8.new: $!active-handle.read: $bytes),
            nqp::while(
              nqp::islt_i(nqp::elems($ret), $bytes)
              && nqp::defined(self.next-handle),
              $ret.append: $!active-handle.read:
                nqp::sub_i($bytes, nqp::elems($ret))),
            $ret
          ),
          buf8.new)
    }
    method readchars (::?CLASS:D: Int(Cool:D) $chars = $*DEFAULT-READ-ELEMS) {
        nqp::if(
          nqp::defined($!active-handle),
          nqp::stmts(
            (my $ret := $!active-handle.readchars: $chars),
            nqp::while(
              nqp::islt_i(nqp::chars($ret), $chars)
              && nqp::defined(self.next-handle),
              $ret := nqp::concat($ret, $!active-handle.readchars:
                nqp::sub_i($chars, nqp::chars($ret)))),
            $ret
          ),
          '')
    }

    method slurp (::?CLASS:D:) {
        # we don't take a :close arg, because we close exhausted handles
        # and .slurp isn't lazy, so all handles will get exhausted
        nqp::if(
          nqp::defined($!active-handle),
          ([~] gather nqp::stmts( # the [~] takes care of both Str and Blobs
            (take $!active-handle.slurp),
            nqp::while(
              nqp::defined(self.next-handle),
              take $!active-handle.slurp))),
          Nil)
    }
    method slurp-rest (|) {
        # We inherit deprecated .slurp-rest from IO::Handle. Pull the
        # plug on it in this class, since no one is using this yet.
        # The old IO::ArgFiles used .slurp
        die X::Obsolete.new: :old<slurp-rest>, :replacement<slurp>,
            :when('with IO::CatHandle')
    }
    method DESTROY { self.close }

    method close (::?CLASS:D: --> True) {
        # Note: our IO::Handles might be IO::Pipes, whose .close
        # method returns the Proc object, which will explode when sunk if the
        # process exited unsuccessfully. So here, we ensure we never sink it.
        nqp::stmts(
          nqp::if(
            nqp::defined($!active-handle),
            my $ = $!active-handle.close),
          (my int $i = -1),
          (my int $els = nqp::elems($!handles)),
          nqp::while(
            nqp::isgt_i($els, $i = nqp::add_i($i, 1)),
            nqp::if(
              nqp::istype(($_ := nqp::atpos($!handles, $i)), IO::Handle),
              my $ = .close)),
          ($!handles := nqp::list),
          ($!active-handle = Nil))
    }

    proto method encoding(|) { * }
    multi method encoding(::?CLASS:D:) { $!encoding || Nil }
    multi method encoding(::?CLASS:D: $enc is copy) {
        $!encoding = nqp::if(
          nqp::defined($!active-handle),
          $!active-handle.encoding($enc),
          nqp::if(
            nqp::isfalse($enc.defined) || nqp::iseq_s($enc.Str, 'bin'),
            Nil,
            Encoding::Registry.find($enc.Str).name))
    }

    method eof (::?CLASS:D: --> Bool:D) {
        nqp::p6bool(
          nqp::stmts(
            nqp::while(
              $!active-handle
              && $!active-handle.eof
              && self.next-handle,
              nqp::null),
            nqp::isfalse($!active-handle)
            || False))
    }
    multi method gist (::?CLASS:D:) {
        "{self.^name}({self.opened ?? "opened on {$.path.gist}" !! 'closed'})"
    }
    multi method Str (::?CLASS:D:) {
        nqp::if($!active-handle, $.path.Str, '<closed IO::CatHandle>')
    }
    method IO (::?CLASS:D:) {
        nqp::if($!active-handle, $!active-handle.IO, Nil)
    }
    method path (::?CLASS:D:) {
        nqp::if($!active-handle, $!active-handle.path, Nil)
    }
    method opened(::?CLASS:D: --> Bool:D) { nqp::p6bool($!active-handle) }
    method lock(::?CLASS:D: |c) {
        nqp::if($!active-handle, $!active-handle.lock(|c), Nil)
    }
    method nl-in (::?CLASS:D:) is rw {
        Proxy.new:
          :FETCH{ $!nl-in },
          :STORE( -> $, $nl-in {
              $!active-handle && $!active-handle.nl-in = $nl-in;
              $!nl-in = $nl-in
          })
    }
    method seek(::?CLASS:D: |c) {
        nqp::if($!active-handle, $!active-handle.seek(|c), Nil)
    }
    method tell(::?CLASS:D: --> Int:D) {
        nqp::if($!active-handle, $!active-handle.tell, Nil)
    }
    method t (::?CLASS:D: --> Bool:D) {
        nqp::if($!active-handle, $!active-handle.t, False)
    }
    method unlock(::?CLASS:D:) {
        nqp::if($!active-handle, $!active-handle.unlock, Nil)
    }
    method native-descriptor (::?CLASS:D: --> Int:D) {
        nqp::if($!active-handle, $!active-handle.native-descriptor, Nil)
    }
    method open (::?CLASS:D: --> ::?CLASS:D) {
        # The idea behind cat handle's open is to fake .open in code that
        # doesn't know it's dealing with a cat handle, so we accept any args
        # IO::Handle.open accepts and then just return self. Since that .open
        # takes only named args methods have `*%_` in sigs, we don't put any
        # args in our sig. If that ever changes, then ensure cat handle's .open
        # can be called with any of the IO::Handle.open's args
        self
    }

    #                           __________________________________________
    #                          / I don't know what the write methods      \
    #                         | should do in a CatHandle, so I'll mark    |
    #                         | these as NYI, for now.... Has anyone      |
    #                         \ seen my cocoon? I always lose that thing! /
    #                         |  -----------------------------------------
    #                         | /
    #                         |/
    #                       ()
    proto method flush      (|) { * }
    multi method flush      (|) { die X::NYI.new: :feature<flush>      }
    proto method out-buffer (|) { * }
    multi method out-buffer (|) { die X::NYI.new: :feature<out-buffer> }
    proto method print      (|) { * }
    multi method print      (|) { die X::NYI.new: :feature<print>      }
    proto method printf     (|) { * }
    multi method printf     (|) { die X::NYI.new: :feature<printf>     }
    proto method print-nl   (|) { * }
    multi method print-nl   (|) { die X::NYI.new: :feature<print-nl>   }
    proto method put        (|) { * }
    multi method put        (|) { die X::NYI.new: :feature<put>        }
    proto method say        (|) { * }
    multi method say        (|) { die X::NYI.new: :feature<say>        }
    proto method write      (|) { * }
    multi method write      (|) { die X::NYI.new: :feature<write>      }
    #                       /|\

    # Don't die on this one, as doing so breaks .Capture
    # proto method nl-out  (|) { * }
    # multi method nl-out  (|) {
    #     die X::NYI.new: :feature<nl-out>
    # }
}

#line 1 SETTING::src/core/IO/ArgFiles.pm
my class IO::ArgFiles is IO::CatHandle {

    # This class exists for backwards compatibility reasons.
    # There used to be no IO::CatHandle and IO::ArgFiles did the $*ARGFILES.
    # Now all the functionality has been subsumed by IO::CatHandle and
    # we keep $*ARGFILES as IO::ArgFiles that is just an empty subclass
    # of IO::CatHandle type

}

#line 1 SETTING::src/core/AST.pm
# XXX: Would like to have this class as Perl6::AST, but ran up against
#      problems with the serialization context calling it that.
my class AST {
    has $!past;
    has $!quasi_context;
    has $!Str;

    submethod BUILD(:$past --> Nil) { $!past := $past }

    method incarnate($quasi_context, @unquote_asts) {
        my $incarnation = self.clone();
        nqp::bindattr(nqp::decont($incarnation), AST, '$!past', $incarnation.evaluate_unquotes(@unquote_asts));
        nqp::bindattr(nqp::decont($incarnation), AST, '$!quasi_context', $quasi_context);
        $incarnation;
    }

    method evaluate_unquotes(@unquote_asts) {
        my $pasts := nqp::list();
        for @unquote_asts {
            # TODO: find and report macro name
            X::TypeCheck::Splice.new(
                got      => $_,
                expected => AST,
                action   => 'unquote evaluation',
            ).throw unless nqp::istype($_,AST);
            nqp::push($pasts, nqp::getattr(nqp::decont($_), AST, '$!past'))
        }
        $!past.evaluate_unquotes($pasts);
    }

    method is_quasi_ast {
        so $!quasi_context;
    }

    method Str {
        $!Str;
    }
}

#line 1 SETTING::src/core/CallFrame.pm
my class CallFrame {
    has $.annotations;
    has $.my;

    method SET-SELF(\level, Mu \ctx is raw, Mu \bt is raw) {
        nqp::stmts(
          (my int $i = nqp::add_i(level,1)),
          ($!annotations := nqp::atkey(
            nqp::atpos(nqp::getattr(bt,List,'$!reified'),$i),
            'annotations'
          )),
          (my $ctx := ctx),
          nqp::while(
            nqp::isgt_i(($i = nqp::sub_i($i,1)),0),
            nqp::ifnull(
                ($ctx := nqp::ctxcaller($ctx)),
                fail "No callframe at level {level}"
            )
          ),
          ($!my :=
            nqp::p6bindattrinvres(nqp::create(Stash),Map,'$!storage',$ctx)),
          self
        )
    }

    only method new(CallFrame: Int $level = 0) {  # MUST BE AN only
        nqp::create(CallFrame).SET-SELF(          # wrt to backtrace levels
          $level,
          nqp::ctxcaller(nqp::ctx),
          nqp::backtrace(nqp::handle(nqp::die(''),'CATCH',nqp::exception))
        )
    }

    method line() { nqp::atkey($!annotations,'line') }
    method file() { nqp::atkey($!annotations,'file') }
    method code() {
        my \vm-code = nqp::ctxcode(nqp::getattr($!my,Map,'$!storage'));
        nqp::isnull(vm-code) ?? Nil !! nqp::getcodeobj(vm-code)
    }
    method callframe(Int $?) {
        X::NYI.new(feature => 'Callframe.callframe').throw;
    }

    multi method gist(CallFrame:D:) {
        nqp::atkey($!annotations,'file')
          ~ ' at line '
          ~ nqp::atkey($!annotations,'line')
    }

    method annotations() {
        nqp::p6bindattrinvres(nqp::create(Map),Map,'$!storage',$!annotations)
    }
}

only sub callframe(Int $level = 0) {  # MUST BE an only wrt to backtrace levels
    nqp::create(CallFrame).SET-SELF(
      $level,
      nqp::ctxcaller(nqp::ctx),
      nqp::backtrace(nqp::handle(nqp::die(''),'CATCH',nqp::exception))
    )
}

#line 1 SETTING::src/core/Main.pm
# TODO:
# * Command-line parsing
#   * Allow both = and space before argument of double-dash args
#   * Comma-separated list values
#   * Allow exact Perl 6 forms, quoted away from shell
# * Fix remaining XXXX

my sub MAIN_HELPER($retval = 0) {
    # Do we have a MAIN at all?
    my $m = callframe(1).my<&MAIN>;
    return $retval unless $m;

    my %SUB-MAIN-OPTS  := %*SUB-MAIN-OPTS // {};
    my $no-named-after := nqp::isfalse(%SUB-MAIN-OPTS<named-anywhere>);

    sub thevalue(\a) {
        ((my $type := ::(a)) andthen Metamodel::EnumHOW.ACCEPTS($type.HOW))
          ?? $type
          !! val(a)
    }

    # Convert raw command line args into positional and named args for MAIN
    my sub process-cmd-args(@args is copy) {
        my $positional := nqp::create(IterationBuffer);
        my %named;

        while ?@args {
            my str $passed-value = @args.shift;

            # rest considered to be non-parsed
            if nqp::iseq_s($passed-value,'--') {
                nqp::push($positional, thevalue($_)) for @args;
                last;
            }

            # no longer accepting nameds
            elsif $no-named-after && nqp::isgt_i(nqp::elems($positional),0) {
                nqp::push($positional, thevalue($passed-value));
            }

            # named
            elsif $passed-value
              ~~ /^ [ '--' | '-' | ':' ] ('/'?) (<-[0..9\.]> .*) $/ {  # 'hlfix
                my str $arg = $1.Str;
                my $split  := nqp::split("=",$arg);

                # explicit value
                if nqp::isgt_i(nqp::elems($split),1) {
                    my str $name = nqp::shift($split);
                    %named.push: $name => $0.chars
                      ?? thevalue(nqp::join("=",$split)) but False
                      !! thevalue(nqp::join("=",$split));
                }

                # implicit value
                else {
                    %named.push: $arg => !($0.chars);
                }
            }

            # positional
            else {
                nqp::push($positional, thevalue($passed-value));
            }
        }

        nqp::p6bindattrinvres(
          nqp::create(List),List,'$!reified',$positional
        ),%named;
    }

    # Generate $?USAGE string (default usage info for MAIN)
    my sub gen-usage() {
        my @help-msgs;
        my Pair @arg-help;

        my sub strip_path_prefix($name) {
            my $SPEC := $*SPEC;
            my ($vol, $dir, $base) = $SPEC.splitpath($name);
            $dir = $SPEC.canonpath($dir);
            for $SPEC.path() -> $elem {
                if $SPEC.catpath($vol, $elem, $base).IO.x {
                    return $base if $SPEC.canonpath($elem) eq $dir;
                    # Shadowed command found in earlier PATH element
                    return $name;
                }
            }
            # Not in PATH
            $name;
        }

        my $prog-name = %*ENV<PERL6_PROGRAM_NAME>:exists
          ?? %*ENV<PERL6_PROGRAM_NAME>
          !! $*PROGRAM-NAME;
        $prog-name = $prog-name eq '-e'
          ?? "-e '...'"
          !! strip_path_prefix($prog-name);
        for $m.candidates -> $sub {
            next if $sub.?is-hidden-from-USAGE;

            my @required-named;
            my @optional-named;
            my @positional;
            my $docs;

            for $sub.signature.params -> $param {
                my $argument;
                if $param.named {
                    if $param.slurpy {
                        if $param.name { # ignore anon *%
                            $argument  = "--<$param.usage-name()>=...";
                            @optional-named.push("[$argument]");
                        }
                    }
                    else {
                        my @names  = $param.named_names.reverse;
                        $argument  = @names.map({($^n.chars == 1 ?? '-' !! '--') ~ $^n}).join('|');
                        if $param.type !=== Bool {
                            $argument ~= "=<{$param.type.^name}>";
                            if Metamodel::EnumHOW.ACCEPTS($param.type.HOW) {
                                my $options = $param.type.^enum_values.keys.sort.Str;
                                $argument ~= $options.chars > 50
                                  ?? ' (' ~ substr($options,0,50) ~ '...'
                                  !! " ($options)"
                            }
                        }
                        if $param.optional {
                            @optional-named.push("[$argument]");
                        }
                        else {
                            @required-named.push($argument);
                        }
                    }
                }
                else {
                    my $constraints  = $param.constraint_list.map(*.gist).join(' ');
                    my $simple-const = $constraints && $constraints !~~ /^_block/;
                    $argument = $param.name   ?? "<$param.usage-name()>" !!
                                $simple-const ??       $constraints                !!
                                                 '<' ~ $param.type.^name     ~ '>' ;

                    $argument  = "[$argument ...]"          if $param.slurpy;
                    $argument  = "[$argument]"              if $param.optional;
                    $argument .= trans(["'"] => [q|'"'"'|]) if $argument.contains("'");
                    $argument  = "'$argument'"              if $argument.contains(' ' | '"');
                    @positional.push($argument);
                }
                @arg-help.push($argument => $param.WHY.contents) if $param.WHY and (@arg-help.grep:{ .key eq $argument}) == Empty;  # Use first defined
            }
            if $sub.WHY {
                $docs = '-- ' ~ $sub.WHY.contents
            }
            my $msg = join(' ', $prog-name, @required-named, @optional-named, @positional, $docs // '');
            @help-msgs.push($msg);
        }

        if @arg-help {
            @help-msgs.push('');
            my $offset = max(@arg-help.map: { .key.chars }) + 4;
            @help-msgs.append(@arg-help.map: { '  ' ~ .key ~ ' ' x ($offset - .key.chars) ~ .value });
        }

        my $usage = "Usage:\n" ~ @help-msgs.map('  ' ~ *).join("\n");
        $usage;
    }

    sub has-unexpected-named-arguments($signature, %named-arguments) {
        my @named-params = $signature.params.grep: *.named;
        return False if @named-params.grep: *.slurpy;

        my %accepts-argument = @named-params.map({ .named_names.Slip }) Z=> 1 xx *;
        for %named-arguments.keys -> $name {
            return True if !%accepts-argument{$name}
        }

        False;
    }

    # Process command line arguments
    my ($p, $n) := process-cmd-args(@*ARGS);

    # Generate default $?USAGE message
    my $usage;
    my $*USAGE := Proxy.new(
        FETCH => -> | { $usage || ($usage = gen-usage()) },
        STORE => -> | {
            die 'Cannot assign to $*USAGE. Please use `sub USAGE {}` to '
                ~ 'output custom usage message'
        }
    );

    # Get a list of candidates that match according to the dispatcher
    my @matching_candidates = $m.cando(Capture.new(list => $p, hash => $n));
    # Sort out all that would fail due to binding
    @matching_candidates .=grep: {!has-unexpected-named-arguments($_.signature, $n)};
    # If there are still some candidates left, try to dispatch to MAIN
    if +@matching_candidates {
        $m(|@($p), |%($n));
        return;
    }

    # We could not find the correct MAIN to dispatch to!
    # Let's try to run a user defined USAGE sub
    my $h = callframe(1).my<&USAGE>;
    if $h {
        $h();
        return;
    }

    # We could not find a user defined USAGE sub!
    # Let's display the default USAGE message
    if $n<help> {
        $*OUT.say($*USAGE);
        exit 0;
    }
    else {
        $*ERR.say($*USAGE);
        exit 2;
    }
}

#line 1 SETTING::src/core/Instant.pm
my class Date { ... }
my class DateTime { ... }
my class Duration {... }

my class Instant is Cool does Real {
    has Rat $.tai;
      # A linear count of seconds since 1970-01-01T00:00:00Z, plus
      # Rakudo::Internals.initial-offset. Thus, $.tai matches TAI from 1970
      # to the present.

    method SET-SELF($!tai) { self } # cannot be private because of operators

    method new(*@) { X::Cannot::New.new(class => self).throw }

    proto method from-posix(|) { * }
    multi method from-posix($posix) {
        nqp::create(Instant).SET-SELF(
          Rakudo::Internals.tai-from-posix($posix,0).Rat
        )
    }
    multi method from-posix($posix, Bool $prefer-leap-second) {
    # $posix is in general not expected to be an integer.
    # If $prefer-leap-second is true, 915148800 is interpreted to
    # mean 1998-12-31T23:59:60Z rather than 1999-01-01T00:00:00Z.
        nqp::create(Instant).SET-SELF(
          Rakudo::Internals.tai-from-posix($posix,$prefer-leap-second).Rat
        )
    }

    method to-posix() {
    # The inverse of .from-posix, except that the second return
    # value is true if *and only if* this Instant is in a leap
    # second.
        Rakudo::Internals.posix-from-tai($!tai)
    }

    multi method Str(Instant:D:) {
        'Instant:' ~ $!tai
    }
    multi method perl(Instant:D:) {
        "Instant.from-posix{self.to-posix.perl}";
    }
    method Bridge(Instant:D:) { $!tai.Bridge }
    method Num   (Instant:D:) { $!tai.Num    }
    method Rat   (Instant:D:) { $!tai        }
    method Int   (Instant:D:) { $!tai.Int    }
    method narrow(Instant:D:) { $!tai.narrow }

    method Date(Instant:D:)     { Date.new(self)     }
    method DateTime(Instant:D:) { DateTime.new(self) }
    method Instant() { self }

#    TODO: should be the new .gist, probably
#    method Str() {
#        'Instant:' ~ default-formatter
#            ::DateTime.new(self), :subseconds
#    }
}

multi sub infix:cmp(Instant:D $a, Instant:D $b) {
    $a.tai <=> $b.tai }

multi sub infix:<=>(Instant:D $a, Instant:D $b) {
    $a.tai <=> $b.tai
}

multi sub infix:==(Instant:D $a, Instant:D $b) {
    $a.tai == $b.tai
}

multi sub infix:!=(Instant:D $a, Instant:D $b) {
    $a.tai != $b.tai
}
multi sub infix:(Instant:D $a, Instant:D $b) {
    $a.tai  $b.tai
}

multi sub infix:<(Instant:D $a, Instant:D $b) {
    $a.tai < $b.tai
}

multi sub infix:>(Instant:D $a, Instant:D $b) {
    $a.tai > $b.tai
}

multi sub infix:<=(Instant:D $a, Instant:D $b) {
    $a.tai <= $b.tai
}
multi sub infix:(Instant:D $a, Instant:D $b) {
    $a.tai  $b.tai
}

multi sub infix:>=(Instant:D $a, Instant:D $b) {
    $a.tai >= $b.tai
}
multi sub infix:(Instant:D $a, Instant:D $b) {
    $a.tai  $b.tai
}

multi sub infix:<+>(Instant:D $a, Real:D $b) {
    nqp::create(Instant).SET-SELF($a.tai + $b.Rat)
}
multi sub infix:<+>(Real:D $a, Instant:D $b) {
    nqp::create(Instant).SET-SELF($a.Rat + $b.tai)
}
multi sub infix:<+>(Instant:D $a, Duration:D $b) {
    nqp::create(Instant).SET-SELF($a.tai + $b.tai)
}
multi sub infix:<+>(Duration:D $a, Instant:D $b) {
    nqp::create(Instant).SET-SELF($a.tai + $b.tai)
}

multi sub infix:<->(Instant:D $a, Instant:D $b) {
    Duration.new: $a.tai - $b.tai;
}
multi sub infix:<->(Instant:D $a, Real:D $b) {
    nqp::create(Instant).SET-SELF($a.tai - $b.Rat)
}

sub term:<time>() { nqp::p6box_i(nqp::time_i()) }
sub term:<now>() {
    # FIXME: During a leap second, the returned value is one
    # second greater than it should be.
    nqp::create(Instant).SET-SELF(
      Rakudo::Internals.tai-from-posix(nqp::time_n,0).Rat
    )
}

Rakudo::Internals.REGISTER-DYNAMIC: '$*INIT-INSTANT', {
    PROCESS::<$INIT-INSTANT> := nqp::create(Instant).SET-SELF(
      Rakudo::Internals.tai-from-posix(Rakudo::Internals.INITTIME,0).Rat
    )
}
Rakudo::Internals.REGISTER-DYNAMIC: '$*INITTIME', {
    my ($file, $line) = .file, .line with callframe 3;
    DEPRECATED('$*INIT-INSTANT', '2017.09.84.gb.02.da.4.d.1.a', '2018.08',
        :what<$*INITTIME>, :$file, :$line);
    $*INIT-INSTANT
}

#line 1 SETTING::src/core/Duration.pm
my class Duration is Cool does Real {
    has Rat $.tai is default(0.0);
      # A linear count of seconds.

    method new($tai) {
        nqp::p6bindattrinvres(nqp::create(Duration),Duration,'$!tai',$tai.Rat.self) # .self blows up Failures
    }

    method Bridge(Duration:D:) { $!tai.Num    }
    method Num   (Duration:D:) { $!tai.Num    }
    method Rat   (Duration:D:) { $!tai        }
    method narrow(Duration:D:) { $!tai.narrow }

    multi method Str(Duration:D:) { ~$.tai }

    multi method perl(Duration:D:) { "Duration.new({$.tai.perl})" }
}

multi sub prefix:<->(Duration:D $a) {
    Duration.new: -$a.tai;
}

multi sub infix:<+>(Duration:D $a, Real $b) {
    Duration.new: $a.tai + $b;
}
multi sub infix:<+>(Real $a, Duration:D $b) {
    Duration.new: $a + $b.tai;
}
multi sub infix:<+>(Duration:D $a, Duration:D $b) {
    Duration.new: $a.tai + $b.tai;
}

multi sub infix:<->(Duration:D $a, Real $b) {
    Duration.new: $a.tai - $b;
}
multi sub infix:<->(Duration:D $a, Duration:D $b) {
    Duration.new: $a.tai - $b.tai;
}

multi sub infix:<%>(Duration:D $a, Real $b) {
    Duration.new: $a.tai % $b
}

#line 1 SETTING::src/core/Dateish.pm
my role Dateish {
    has Int $.year;
    has Int $.month;     # should be int
    has Int $.day;       # should be int
    has Int $.daycount;
    has     &.formatter;

    method IO(Dateish:D:) { IO::Path.new(~self) }  # because Dateish is not Cool

    # this sub is also used by DAYS-IN-MONTH, which is used by other types
    sub IS-LEAP-YEAR($y) { $y %% 4 and not $y %% 100 or $y %% 400 }
    method is-leap-year(Dateish:D:) { IS-LEAP-YEAR($!year) }

    my $days-in-month := nqp::list_i(
      0, 31, 0, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
    );
    # This method is used by Date and DateTime:
    method DAYS-IN-MONTH(\year, \month) {
        nqp::atpos_i($days-in-month,month) ||
          ( month == 2 ?? 28 + IS-LEAP-YEAR(year) !! Nil );
    }
    method days-in-month(Dateish:D:) { self.DAYS-IN-MONTH($!year,$!month) }

    method !year-Str() {
        sprintf 0 <= $!year <= 9999 ?? '%04d' !! '%+05d', $!year;
    }

    multi method new(Dateish:) {
        Failure.new(
            "Cannot call {self.^name}.new with "
                ~ (%_ ?? "these named parameters: {%_.keys}" !! "no parameters")
        )
    }

    multi method Str(Dateish:D:) {
        &!formatter ?? &!formatter(self) !! self!formatter
    }
    multi method gist(Dateish:D:) { self.Str }

    method daycount() {
        $!daycount //= do {
            # taken from <http://www.merlyn.demon.co.uk/daycount.htm>
            my int $m = $!month < 3 ?? $!month + 12 !! $!month;
            my int $y = $!year - ($!month < 3);
            -678973 + $!day + (153 * $m - 2) div 5
              + 365 * $y + $y div 4
              - $y div 100  + $y div 400;
        }
    }

    method !ymd-from-daycount($daycount,\year,\month,\day --> Nil) {
        # taken from <http://www.merlyn.demon.co.uk/daycount.htm>
        my Int $dc = $daycount.Int + 678881;
        my Int $ti = (4 * ($dc + 36525)) div 146097 - 1;
        my Int $year = 100 * $ti;
        my int $day = $dc - (36524 * $ti + ($ti div 4));
        my int $t = (4 * ($day + 366)) div 1461 - 1;
        year = $year + $t;
        $day  = $day - (365 * $t + ($t div 4));
        my int $month = (5 * $day + 2) div 153;
        day = $day - ((2 + $month * 153) div 5 - 1);
        if ($month > 9) {
            month = $month - 9;
            year  = year + 1;
        }
        else {
            month = $month + 3;
        }
    }

    method day-of-month() { $!day }
    method day-of-week(Dateish:D:) { (self.daycount + 2) % 7 + 1 }

    method week() { # algorithm from Claus Tndering
        my int $a = $!year - ($!month <= 2).floor.Int;
        my int $b = $a div 4 - $a div 100 + $a div 400;
        my int $c = ($a - 1) div 4 - ($a - 1) div 100 + ($a - 1) div 400;
        my int $s = $b - $c;
        my int $e = $!month <= 2 ?? 0 !! $s + 1;
        my int $f = $!day
          + ($!month <= 2
              ?? 31*($!month - 1) - 1
              !! (153*($!month - 3) + 2) div 5 + 58 + $s);

        my int $g = ($a + $b) % 7;
        my int $d = ($f + $g - $e) % 7;
        my int $n = $f + 3 - $d;

           $n < 0        ?? ($!year - 1, 53 - ($g - $s) div 5)
        !! $n > 364 + $s ?? ($!year + 1, 1                   )
        !!                  ($!year,     $n div 7 + 1        );
    }
    method week-year()   { self.week.AT-POS(0) }
    method week-number() { self.week.AT-POS(1) }

    method weekday-of-month {
        ($!day - 1) div 7 + 1
    }

    my $days-at-start-of-month := nqp::list_i(
      0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334
    );
    method day-of-year() {
        $!day
          + nqp::atpos_i($days-at-start-of-month,$!month)
          + ($!month > 2 && IS-LEAP-YEAR($!year));
    }

    method yyyy-mm-dd() { sprintf '%04d-%02d-%02d',$!year,$!month,$!day }

    method earlier(*%unit) { self.later(:earlier, |%unit) }

    method !truncate-ymd(Cool:D $unit, %parts? is copy) {
        if $unit eq 'week' | 'weeks' {
            my $new-dc = self.daycount - self.day-of-week + 1;
            self!ymd-from-daycount($new-dc,
              %parts<year>,%parts<month>,%parts<day>);
        }
        else { # $unit eq 'month' | 'months' | 'year' | 'years'
            %parts<day>   = 1;
            %parts<month> = 1 if $unit eq 'year' | 'years';
        }
        %parts;
    }
}

# =begin pod
#
# =head1 SEE ALSO
# Perl 6 spec <S32-Temporal|http://design.perl6.org/S32/Temporal.html>.
# The Perl 5 DateTime Project home page L<http://datetime.perl.org>.
# Perl 5 perldoc L<doc:DateTime> and L<doc:Time::Local>.
#
# The best yet seen explanation of calendars, by Claus Tndering
# L<Calendar FAQ|http://www.tondering.dk/claus/calendar.html>.
# Similar algorithms at L<http://www.hermetic.ch/cal_stud/jdn.htm>
# and L<http://www.merlyn.demon.co.uk/daycount.htm>.
#
# <ISO 8601|http://en.wikipedia.org/wiki/ISO_8601>
# <Time zones|http://en.wikipedia.org/wiki/List_of_time_zones>
#
# As per the recommendation, the strftime() method has bee moved into a
# loadable module called DateTime::strftime.
#
# =end pod

#line 1 SETTING::src/core/DateTime.pm
my class DateTime does Dateish {
    has int $.hour;
    has int $.minute;
    has     $.second;
    has int $.timezone;  # UTC
      # Not an optimization but a necessity to ensure that
      # $dt.utc.local.utc is equivalent to $dt.utc. Otherwise,
      # DST-induced ambiguity could ruin our day.

    method !formatter() { # ISO 8601 timestamp
        sprintf '%s-%02d-%02dT%02d:%02d:%s%s',
            self!year-Str, $!month, $!day, $!hour, $!minute,
            $!second.floor == $!second
              ?? $!second.Int.fmt('%02d')
              !! $!second.fmt('%09.6f'),
            $!timezone == 0
              ?? 'Z'
              !! $!timezone > 0
                ?? sprintf('+%02d:%02d',
                     ($!timezone/3600).floor,
                     ($!timezone/60%60).floor)
                !! sprintf('-%02d:%02d',
                  ($!timezone.abs/3600).floor,
                  ($!timezone.abs/60%60).floor)
    }

    my $valid-units := nqp::hash(
      'second',  0,
      'seconds', 0,
      'minute',  0,
      'minutes', 0,
      'hour',    0,
      'hours',   0,
      'day',     0,
      'days',    0,
      'week',    0,
      'weeks',   0,
      'month',   1,
      'months',  1,
      'year',    1,
      'years',   1,
    );
    method !VALID-UNIT($unit) {
        nqp::existskey($valid-units,$unit)
          ?? $unit
          !! X::DateTime::InvalidDeltaUnit.new(:$unit).throw
    }

    method !SET-SELF(
      $!year,$!month,$!day,$hour,$minute,$!second,$timezone,&!formatter
    ) {
        # can't assign native in attributes inside signature yet
        $!hour     = $hour,
        $!minute   = $minute,
        $!timezone = $timezone;
        self
    }
    method !new-from-positional(DateTime:
      Int() $year,
      Int() $month,
      Int() $day,
      Int() $hour,
      Int() $minute,
            $second,
            %extra,
      :$timezone = 0,
      :&formatter,
    ) {
        (1..12).in-range($month,'Month');
        (1 .. self.DAYS-IN-MONTH($year,$month)).in-range($day,'Day');
        (0..23).in-range($hour,'Hour');
        (0..59).in-range($minute,'Minute');
        (^61).in-range($second,'Second');
        my $dt = self === DateTime
          ?? nqp::create(self)!SET-SELF(
               $year,$month,$day,$hour,$minute,$second,$timezone,&formatter)
          !! self.bless(
               :$year,:$month,:$day,
               :$hour,:$minute,:$second,:$timezone,:&formatter,|%extra);

        # check leap second spec
        if $second >= 60 {
            my $utc = $timezone ?? $dt.utc !! $dt;
            X::OutOfRange.new(
              what  => 'Second',
              range => "0..^60",
              got   => $second,
              comment => 'a leap second can occur only at 23:59',
            ).throw unless $utc.hour == 23 && $utc.minute == 59;
            my $date = $utc.yyyy-mm-dd;
            X::OutOfRange.new(
              what  => 'Second',
              range => "0..^60",
              got   => $second,
              comment => "There is no leap second on UTC $date",
            ).throw unless Rakudo::Internals.is-leap-second-date($date);
        }

        $dt
    }

    proto method new(|) {*}
    multi method new(DateTime:
      \y,\mo,\d,\h,\mi,\s,:$timezone = 0,:&formatter,*%_) {
        self!new-from-positional(y,mo,d,h,mi,s,%_,:$timezone,:&formatter)
    }
    multi method new(DateTime:
      :$year!,
      :$month    = 1,
      :$day      = 1,
      :$hour     = 0,
      :$minute   = 0,
      :$second   = 0,
      :$timezone = 0,
      :&formatter,
      *%_
      ) {
        self!new-from-positional(
          $year,$month,$day,$hour,$minute,$second,%_,:$timezone,:&formatter)
    }
    multi method new(DateTime: Date:D :$date!, *%_) {
        self.new(:year($date.year),:month($date.month),:day($date.day),|%_)
    }
    multi method new(DateTime: Instant:D $i, :$timezone = 0, *%_) {
        my ($p, $leap-second) = $i.to-posix;
        my $dt = self.new( floor($p - $leap-second).Int, |%_ );
        $dt.clone(
          :second($dt.second + $p % 1 + $leap-second), |%_
        ).in-timezone($timezone)
    }
    multi method new(DateTime:
      Numeric:D $time is copy, :$timezone = 0, :&formatter, *%_
    ) {
        # Interpret $time as a POSIX time.
        my     $second = $time % 60; $time = $time.Int div 60;
        my int $minute = $time % 60; $time = $time     div 60;
        my int $hour   = $time % 24; $time = $time     div 24;
        # Day month and leap year arithmetic, based on Gregorian day #.
        # 2000-01-01 noon UTC == 2451558.0 Julian == 2451545.0 Gregorian
        $time += 2440588;   # because 2000-01-01 == Unix epoch day 10957
        my Int $a = $time + 32044;     # date algorithm from Claus Tndering
        my Int $b = (4 * $a + 3) div 146097; # 146097 = days in 400 years
        my Int $c = $a - (146097 * $b) div 4;
        my Int $d = (4 * $c + 3) div 1461;       # 1461 = days in 4 years
        my Int $e = $c - ($d * 1461) div 4;
        my Int $m = (5 * $e + 2) div 153; # 153 = days in Mar-Jul Aug-Dec
        my int $day   = $e - (153 * $m + 2) div 5 + 1;
        my int $month = $m + 3 - 12 * ($m div 10);
        my Int $year  = $b * 100 + $d - 4800 + $m div 10;

        my $dt = self === DateTime
          ?? ( %_ ?? die "Unexpected named parameter{"s" if %_ > 1} "
                    ~ %_.keys.map({"`$_`"}).join(", ") ~ " passed. Were you "
                    ~ "trying to use the named parameter form of .new() but "
                    ~ "accidentally passed one named parameter as a positional?"
                  !! nqp::create(self)!SET-SELF(
                    $year,$month,$day,$hour,$minute,$second,0,&formatter)
          ) !! self.bless(
               :$year,:$month,:$day,
               :$hour,:$minute,:$second,:timezone(0),:&formatter,|%_);
        $timezone ?? $dt.in-timezone($timezone) !! $dt
    }
    multi method new(DateTime:
      Str:D $datetime, :$timezone is copy, :&formatter, *%_
    ) {
        X::Temporal::InvalidFormat.new(
          invalid-str => $datetime,
          target      => 'DateTime',
          format      => 'an ISO 8601 timestamp (yyyy-mm-ddThh:mm:ssZ or yyyy-mm-ddThh:mm:ss+01:00)',
        ).throw unless $datetime.chars == $datetime.codes and $datetime ~~ /^
          (<[+-]>? \d**4 \d*)                            # year
          '-'
          (\d\d)                                         # month
          '-'
          (\d\d)                                         # day
          <[Tt]>                                         # time separator
          (\d\d)                                         # hour
          ':'
          (\d\d)                                         # minute
          ':'
          (\d\d[<[\.,]>\d ** 1..6]?)                     # second
          (<[Zz]> || (<[\-\+]>) (\d\d) (':'? (\d\d))? )? # timezone
        $/;

        if $6 {
            X::DateTime::TimezoneClash.new.throw with $timezone;
            if $6.chars != 1 {
                X::OutOfRange.new(
                  what  => "minutes of timezone",
                  got   => +$6[2][0],
                  range => "0..^60",
                ).throw if $6[2] && $6[2][0] > 59;

                $timezone = (($6[1]*60 + ($6[2][0] // 0)) * 60).Int;
                  # RAKUDO: .Int is needed to avoid to avoid the nasty '-0'.
                $timezone = -$timezone if $6[0] eq '-';
            }
        }
        $timezone //= 0;

        self!new-from-positional(
          $0,$1,$2,$3,$4,+(~$5.subst(",",".")),%_,:$timezone,:&formatter)
    }

    method now(:$timezone=$*TZ, :&formatter --> DateTime:D) {
        self.new(nqp::time_n(), :$timezone, :&formatter)
    }

    method clone(*%_) {
        my $h := nqp::getattr(%_,Map,'$!storage');
        self!new-from-positional(
          nqp::existskey($h,'year')   ?? nqp::atkey($h,'year')   !! $!year,
          nqp::existskey($h,'month')  ?? nqp::atkey($h,'month')  !! $!month,
          nqp::existskey($h,'day')    ?? nqp::atkey($h,'day')    !! $!day,
          nqp::existskey($h,'hour')   ?? nqp::atkey($h,'hour')   !! $!hour,
          nqp::existskey($h,'minute') ?? nqp::atkey($h,'minute') !! $!minute,
          nqp::existskey($h,'second') ?? nqp::atkey($h,'second') !! $!second,
          %_,
          timezone => nqp::existskey($h,'timezone')
            ?? nqp::atkey($h,'timezone')  !! $!timezone,
          formatter => nqp::existskey($h,'formatter')
            ?? nqp::atkey($h,'formatter') !! &!formatter,
        )
    }
    method !clone-without-validating(*%_) { # A premature optimization.
        return self.clone(|%_) unless self === DateTime;

        my $h := nqp::getattr(%_,Map,'$!storage');
        nqp::create(self)!SET-SELF(
          nqp::existskey($h,'year')   ?? nqp::atkey($h,'year')   !! $!year,
          nqp::existskey($h,'month')  ?? nqp::atkey($h,'month')  !! $!month,
          nqp::existskey($h,'day')    ?? nqp::atkey($h,'day')    !! $!day,
          nqp::existskey($h,'hour')   ?? nqp::atkey($h,'hour')   !! $!hour,
          nqp::existskey($h,'minute') ?? nqp::atkey($h,'minute') !! $!minute,
          nqp::existskey($h,'second') ?? nqp::atkey($h,'second') !! $!second,
          nqp::existskey($h,'timezone')
            ?? nqp::atkey($h,'timezone') !! $!timezone,
          &!formatter,
        )
    }

    method Instant() {
        Instant.from-posix: self.posix + $!second % 1, $!second >= 60;
    }

    method posix($ignore-timezone?) {
        return self.utc.posix if $!timezone && !$ignore-timezone;

        # algorithm from Claus Tndering
        my int $a = (14 - $!month) div 12;
        my int $y = $!year + 4800 - $a;
        my int $m = $!month + 12 * $a - 3;
        my int $jd = $!day + (153 * $m + 2) div 5 + 365 * $y
            + $y div 4 - $y div 100 + $y div 400 - 32045;
        ($jd - 2440588) * 86400
          + $!hour      * 3600
          + $!minute    * 60
          + self.whole-second
    }

    method offset()            { $!timezone }
    method offset-in-minutes() { $!timezone / 60 }
    method offset-in-hours()   { $!timezone / 3600 }

    method hh-mm-ss()          { sprintf "%02d:%02d:%02d", $!hour,$!minute,$!second }

    method later(:$earlier, *%unit) {
        my @pairs = %unit.pairs;
        die "More than one time unit supplied" if @pairs > 1;
        die "No time unit supplied"        unless @pairs;

        my $unit   = self!VALID-UNIT(@pairs.AT-POS(0).key);
        my $amount = @pairs.AT-POS(0).value.Int;
        $amount = -$amount if $earlier;

        # work on instant (tai)
        if $unit.starts-with('second') {
            self.new(self.Instant + $amount, :$!timezone, :&!formatter)
        }

        # on a leap second and not moving by second
        elsif $!second >= 60 {
            my $dt := self!clone-without-validating(
              :second($!second-1)).later(|($unit => $amount));
            $dt.hour == 23 && $dt.minute == 59 && $dt.second >= 59
              && Rakudo::Internals.is-leap-second-date($dt.yyyy-mm-dd)
              ?? $dt!clone-without-validating(:$!second)
              !! $dt
        }

        # month,year
        elsif nqp::atkey($valid-units,$unit) {
            my $date :=
              Date.new($!year,$!month,$!day).later(|($unit => $amount));
            nqp::create(self)!SET-SELF(
              nqp::getattr($date,Date,'$!year'),
              nqp::getattr($date,Date,'$!month'),
              nqp::getattr($date,Date,'$!day'),
              $!hour, $!minute, $!second, $!timezone, &!formatter
            )
        }
        # minute,hour,day,week
        else {
            my int $minute = $!minute;
            my int $hour   = $!hour;

            $minute += $amount if $unit.starts-with('minute');
            $hour   += floor($minute / 60);
            $minute %= 60;
            $hour   += $amount if $unit.starts-with('hour');

            my $day-delta = floor($hour / 24);
            $hour %= 24;

            $day-delta = $amount     if $unit.starts-with('day');
            $day-delta = 7 * $amount if $unit.starts-with('week');

            my $date := Date.new-from-daycount(self.daycount + $day-delta);
            nqp::create(self)!SET-SELF(
              nqp::getattr($date,Date,'$!year'),
              nqp::getattr($date,Date,'$!month'),
              nqp::getattr($date,Date,'$!day'),
              $hour, $minute, $!second, $!timezone, &!formatter)
        }
    }

    method truncated-to(Cool $unit) {
        my %parts;
        given self!VALID-UNIT($unit) {
            %parts<second> = self.whole-second;
            when 'second' | 'seconds' {}
            %parts<second> = 0;
            when 'minute' | 'minutes' {}
            %parts<minute> = 0;
            when 'hour'   | 'hours'   {}
            %parts<hour> = 0;
            when 'day'    | 'days'    {}
            %parts = self!truncate-ymd($unit, %parts);
        }
        self!clone-without-validating(|%parts);
    }
    method whole-second() { $!second.Int }

    method in-timezone($timezone) {
        return self if $timezone == $!timezone;

        my int $old-offset = self.offset;
        my int $new-offset = $timezone.Int;
        my %parts;
        # Is the logic for handling leap seconds right?
        # I don't know, but it passes the tests!
        my $a = ($!second >= 60 ?? 59 !! $!second)
            + $new-offset - $old-offset;
        %parts<second> = $!second >= 60 ?? $!second !! $a % 60;
        my Int $b = $!minute + floor($a) div 60;
        %parts<minute> = $b % 60;
        my Int $c = $!hour + $b div 60;
        %parts<hour> = $c % 24;

        # Let Dateish handle any further rollover.
        self!ymd-from-daycount(self.daycount + $c div 24,
          %parts<year>,%parts<month>,%parts<day>) if $c div 24;
        self!clone-without-validating: :$timezone, |%parts;
    }

    method utc()   { self.in-timezone(0) }
    method local() { self.in-timezone($*TZ) }

    proto method Date() { * }
    multi method Date(DateTime:D:) { Date.new($!year,$!month,$!day) }
    multi method Date(DateTime:U:) { Date }
    method DateTime() { self }

    multi method perl(DateTime:D:) {
        self.^name
          ~ ".new($!year,$!month,$!day,$!hour,$!minute,$!second"
          ~ (',' ~ :$!timezone.perl if $!timezone)
          ~ ')'
    }
}

Rakudo::Internals.REGISTER-DYNAMIC: '$*TZ', {
    PROCESS::<$TZ> = Rakudo::Internals.get-local-timezone-offset
}

multi sub infix:<(DateTime:D \a, DateTime:D \b) {
    a.Instant < b.Instant
}
multi sub infix:>(DateTime:D \a, DateTime:D \b) {
    a.Instant > b.Instant
}
multi sub infix:<=(DateTime:D \a, DateTime:D \b) {
    a.Instant <= b.Instant
}
multi sub infix:(DateTime:D \a, DateTime:D \b) {
    a.Instant  b.Instant
}
multi sub infix:>=(DateTime:D \a, DateTime:D \b) {
    a.Instant >= b.Instant
}
multi sub infix:(DateTime:D \a, DateTime:D \b) {
    a.Instant  b.Instant
}
multi sub infix:==(DateTime:D \a, DateTime:D \b) {
    a.Instant == b.Instant
}
multi sub infix:!=(DateTime:D \a, DateTime:D \b) {
    a.Instant != b.Instant
}
multi sub infix:(DateTime:D \a, DateTime:D \b) {
    a.Instant  b.Instant
}
multi sub infix:<=>(DateTime:D \a, DateTime:D \b) {
    a.Instant <=> b.Instant
}
multi sub infix:cmp(DateTime:D \a, DateTime:D \b) {
    a.Instant cmp b.Instant
}
multi sub infix:<->(DateTime:D \a, DateTime:D \b) {
    a.Instant - b.Instant
}
multi sub infix:<->(DateTime:D \a, Duration:D \b) {
    a.new(a.Instant - b).in-timezone(a.timezone)
}
multi sub infix:<+>(DateTime:D \a, Duration:D \b) {
    a.new(a.Instant + b).in-timezone(a.timezone)
}
multi sub infix:<+>(Duration:D \a, DateTime:D \b) {
    b.new(b.Instant + a).in-timezone(b.timezone)
}

#line 1 SETTING::src/core/Date.pm
my class Date does Dateish {

    method !formatter() { sprintf '%s-%02d-%02d',self!year-Str,$!month,$!day }

    my $valid-units := nqp::hash(
      'day',    1,
      'days',   1,
      'week',   7,
      'weeks',  7,
      'month',  0,
      'months', 0,
      'year',   0,
      'years',  0,
    );
    method !VALID-UNIT($unit) {
        nqp::existskey($valid-units,$unit)
          ?? $unit
          !! X::DateTime::InvalidDeltaUnit.new(:$unit).throw
    }

    method !SET-SELF($!year,$!month,$!day,&!formatter,$!daycount = Int) { self }

    proto method new(|) {*}
    multi method new(Date: Int() $year, Int() $month, Int() $day, :&formatter, *%_) {
        (1..12).in-range($month,'Month');
        (1 .. self.DAYS-IN-MONTH($year,$month)).in-range($day,'Day');
        self === Date
          ?? nqp::create(self)!SET-SELF($year,$month,$day,&formatter)
          !! self.bless(:$year,:$month,:$day,:&formatter,|%_)
    }
    multi method new(Date: Int() :$year!, Int() :$month = 1, Int() :$day = 1, :&formatter, *%_) {
        (1..12).in-range($month,'Month');
        (1 .. self.DAYS-IN-MONTH($year,$month)).in-range($day,'Day');
        self === Date
          ?? nqp::create(self)!SET-SELF($year,$month,$day,&formatter)
          !! self.bless(:$year,:$month,:$day,:&formatter,|%_)
    }
    multi method new(Date: Str $date, :&formatter, *%_) {
        X::Temporal::InvalidFormat.new(
          invalid-str => $date,
          target      => 'Date',
          format      => 'yyyy-mm-dd',
        ).throw unless $date.codes == $date.chars and $date ~~ /^
          (<[+-]>? \d**4 \d*)                            # year
          '-'
          (\d\d)                                         # month
          '-'
          (\d\d)                                         # day
        $/;
        self.new($0,$1,$2,:&formatter,|%_)
    }
    multi method new(Date: Dateish $d, :&formatter, *%_) {
        self === Date
          ?? nqp::create(self)!SET-SELF($d.year,$d.month,$d.day,&formatter)
          !! self.bless(
               :year($d.year),
               :month($d.month),
               :day($d.day),
               :&formatter,
               |%_
             )
    }
    multi method new(Date: Instant $i, :&formatter, *%_) {
        self.new(DateTime.new($i),:&formatter,|%_)
    }
    method new-from-daycount($daycount,:&formatter) {
        self!ymd-from-daycount($daycount, my $year, my $month, my $day);
        self === Date
          ?? nqp::create(self)!SET-SELF($year,$month,$day,&formatter,$daycount)
          !! self.bless(:$year,:$month,:$day,:&formatter,:$daycount)
    }

    method today(:&formatter) { self.new(DateTime.now, :&formatter) }

    multi method WHICH(Date:D:) {
        nqp::box_s(
          nqp::concat(
            nqp::if(
              nqp::eqaddr(self.WHAT,Date),
              'Date|',
              nqp::concat(nqp::unbox_s(self.^name), '|')
            ),
            nqp::unbox_i(self.daycount)
          ),
          ObjAt
        )
    }

    method truncated-to(Cool $unit) {
        self!clone-without-validating(
          |self!truncate-ymd(self!VALID-UNIT($unit)));
    }

    method later(:$earlier, *%unit) {
        my @pairs = %unit.pairs;
        die "More than one time unit supplied" if @pairs > 1;
        die "No time unit supplied"        unless @pairs;

        my $unit   = self!VALID-UNIT(@pairs.AT-POS(0).key);
        my $amount = @pairs.AT-POS(0).value.Int;
        $amount = -$amount if $earlier;

        if nqp::atkey($valid-units,$unit) -> $multiplier {
            self.new-from-daycount(self.daycount + $multiplier * $amount )
        }
        elsif $unit.starts-with('month') {
            my int $month = $!month;
            my int $year  = $!year;
            $month += $amount;
            $year += floor(($month - 1) / 12);
            $month = ($month - 1) % 12 + 1;
            # If we overflow on days in the month, rather than throw an
            # exception, we just clip to the last of the month
            self.new($year,$month,$!day > 28
              ?? $!day min self.DAYS-IN-MONTH($year,$month)
              !! $!day);
        }
        else { # year
            my int $year = $!year + $amount;
            self.new($year,$!month,$!day > 28
              ?? $!day min self.DAYS-IN-MONTH($year,$!month)
              !! $!day);
        }
    }

    method clone(*%_) {
        my $h := nqp::getattr(%_,Map,'$!storage');
        self.new(
          nqp::existskey($h,'year')  ?? nqp::atkey($h,'year')  !! $!year,
          nqp::existskey($h,'month') ?? nqp::atkey($h,'month') !! $!month,
          nqp::existskey($h,'day')   ?? nqp::atkey($h,'day')   !! $!day,
          formatter => nqp::existskey($h,'formatter')
            ?? nqp::atkey($h,'formatter') !! &!formatter,
        )
    }
    method !clone-without-validating(*%_) { # A premature optimization.
        my $h := nqp::getattr(%_,Map,'$!storage');
        nqp::create(self)!SET-SELF(
          nqp::existskey($h,'year')  ?? nqp::atkey($h,'year')  !! $!year,
          nqp::existskey($h,'month') ?? nqp::atkey($h,'month') !! $!month,
          nqp::existskey($h,'day')   ?? nqp::atkey($h,'day')   !! $!day,
          &!formatter,
        )
    }

    method succ(Date:D:) {
        self.new-from-daycount(self.daycount + 1);
    }
    method pred(Date:D:) {
        self.new-from-daycount(self.daycount - 1);
    }

    multi method perl(Date:D:) {
        self.^name ~ ".new($!year,$!month,$!day)"
    }
    multi method ACCEPTS(Date:D: DateTime:D $dt) {
        $dt.day == $!day && $dt.month == $!month && $dt.year == $!year
    }

    proto method DateTime()  { * }
    multi method DateTime(Date:D:) { DateTime.new(:$!year, :$!month, :$!day) }
    multi method DateTime(Date:U:) { DateTime }
    method Date() { self }
}

multi sub infix:<+>(Date:D $d, Int:D $x) {
    Date.new-from-daycount($d.daycount + $x)
}
multi sub infix:<+>(Int:D $x, Date:D $d) {
    Date.new-from-daycount($d.daycount + $x)
}
multi sub infix:<->(Date:D $d, Int:D $x) {
    Date.new-from-daycount($d.daycount - $x)
}
multi sub infix:<->(Date:D $a, Date:D $b) {
    $a.daycount - $b.daycount;
}
multi sub infix:<cmp>(Date:D $a, Date:D $b) {
    $a.daycount cmp $b.daycount
}
multi sub infix:<=>(Date:D $a, Date:D $b) {
    $a.daycount <=> $b.daycount
}
multi sub infix:<==>(Date:D $a, Date:D $b) {
    $a.daycount == $b.daycount
}
multi sub infix:<=(Date:D $a, Date:D $b) {
    $a.daycount <= $b.daycount
}
multi sub infix:(Date:D $a, Date:D $b) {
    $a.daycount  $b.daycount
}
multi sub infix:<(Date:D $a, Date:D $b) {
    $a.daycount < $b.daycount
}
multi sub infix:>=(Date:D $a, Date:D $b) {
    $a.daycount >= $b.daycount
}
multi sub infix:(Date:D $a, Date:D $b) {
    $a.daycount  $b.daycount
}
multi sub infix:>(Date:D $a, Date:D $b) {
    $a.daycount > $b.daycount
}

sub sleep($seconds = Inf --> Nil) {
    # 1e9 seconds is a large enough value that still makes VMs sleep
    # larger values cause nqp::sleep() to exit immediatelly (esp. on 32-bit)
    if $seconds == Inf || nqp::istype($seconds,Whatever) {
        nqp::sleep(1e9) while True;
    }
    elsif $seconds > 1e9 {
        nqp::sleep($_) for gather {
            1e9.take xx ($seconds / 1e9);
            take $seconds - 1e9 * ($seconds / 1e9).Int;
        }
    }
    elsif $seconds > 0 {
        nqp::sleep($seconds.Num);
    }
}

sub sleep-timer(Real() $seconds = Inf --> Duration:D) {
    if $seconds <= 0 {
        Duration.new(0);
    }
    else {
        my $time1 = now;
        nqp::sleep($seconds.Num);
        Duration.new( ( $seconds - (now - $time1) ) max 0 );
    }
}

sub sleep-until(Instant() $until --> Bool:D) {
    my $seconds = $until - now;
    return False if $seconds < 0;

    Nil while $seconds = sleep-timer($seconds);
    True;
}

#line 1 SETTING::src/core/EXPORTHOW.pm
# Bind the HOWs into the EXPORTHOW package under the package declarator
# names.
my module EXPORTHOW {
    nqp::bindkey($?PACKAGE.WHO, 'package', Perl6::Metamodel::PackageHOW);
    nqp::bindkey($?PACKAGE.WHO, 'module', Perl6::Metamodel::ModuleHOW);
    nqp::bindkey($?PACKAGE.WHO, 'generic', Perl6::Metamodel::GenericHOW);
    nqp::bindkey($?PACKAGE.WHO, 'class', Perl6::Metamodel::ClassHOW);
    nqp::bindkey($?PACKAGE.WHO, 'class-attr', Attribute);
    nqp::bindkey($?PACKAGE.WHO, 'role', Perl6::Metamodel::ParametricRoleHOW);
    nqp::bindkey($?PACKAGE.WHO, 'role-attr', Attribute);
    nqp::bindkey($?PACKAGE.WHO, 'role-group', Perl6::Metamodel::ParametricRoleGroupHOW);
    nqp::bindkey($?PACKAGE.WHO, 'grammar', Perl6::Metamodel::GrammarHOW);
    nqp::bindkey($?PACKAGE.WHO, 'grammar-attr', Attribute);
    nqp::bindkey($?PACKAGE.WHO, 'native', Perl6::Metamodel::NativeHOW);
    nqp::bindkey($?PACKAGE.WHO, 'subset', Perl6::Metamodel::SubsetHOW);
    nqp::bindkey($?PACKAGE.WHO, 'enum', Perl6::Metamodel::EnumHOW);
    nqp::bindkey($?PACKAGE.WHO, 'coercion', Perl6::Metamodel::CoercionHOW);
    nqp::bindkey($?PACKAGE.WHO, 'definite', Perl6::Metamodel::DefiniteHOW);
}

#line 1 SETTING::src/core/Pod.pm
my class Pod::Block {
    has %.config;
    has @.contents;

    submethod BUILD(:%!config, :@!contents --> Nil) {}

    sub pod-gist(Pod::Block $pod, $level = 0) {
        my $leading = ' ' x $level;
        my %confs;
        my @chunks;
        for <config name level caption type> {
            my $thing = $pod.?"$_"();
            if $thing {
                %confs{$_} = nqp::istype($thing,Iterable)
                  ?? $thing.perl
                  !! $thing.Str;
            }
        }
        @chunks = $leading, $pod.^name, (%confs.perl if %confs), "\n";
        for $pod.contents.flat -> $c {
            if nqp::istype($c,Pod::Block) {
                @chunks.push: pod-gist($c, $level + 2);
            }
            elsif nqp::istype($c,Positional) {
                @chunks.append: $c>>.Str.perl.indent($level + 2), "\n";
            }
            else {
                @chunks.append: $c.Str.indent($level + 2), "\n";
            }
        }
        @chunks.join;
    }

    multi method gist(Pod::Block:D:) {
        pod-gist(self)
    }
}

my class Pod::Block::Para is Pod::Block {
}

my class Pod::Block::Named is Pod::Block {
    has $.name;
}

my class Pod::Block::Comment is Pod::Block { }

my class Pod::Block::Code is Pod::Block {
    has @.allowed;
}

my class Pod::Block::Declarator is Pod::Block {
    has $.WHEREFORE;
    has @!leading;
    has @!trailing;

    submethod BUILD(:@!leading, :@!trailing --> Nil) {}

    method set_docee($d) {
        $!WHEREFORE = $d
    }
    method Str {
        @.contents.join('')
    }
    multi method gist(Pod::Block::Declarator:D:) {
        @.contents.join('')
    }

    method contents {
        if @!leading && @!trailing {
            [ $.leading ~ "\n" ~ $.trailing ]
        } elsif @!leading {
            [ $.leading ]
        } elsif @!trailing {
            [ $.trailing ]
        } else {
            []
        }
    }

    method leading  { @!leading  ?? @!leading.join(' ')  !! Nil }
    method trailing { @!trailing ?? @!trailing.join(' ') !! Nil }

    method _add_leading($addition) {
        @!leading.push: ~$addition;
    }

    method _add_trailing($addition) {
        @!trailing.push: ~$addition;
    }
}

my class Pod::Block::Table is Pod::Block {
    has $.caption;
    has @.headers; # optional, may be empty
}

my class Pod::FormattingCode is Pod::Block {
    has $.type;
    has @.meta;
}

my class Pod::Heading is Pod::Block {
    has $.level;
}

my class Pod::Item is Pod::Block {
    has $.level;
}

class Pod::Config {
    has $.type;
    has %.config;
}

# for passing raw instructions to specific backends
class Pod::Raw {
    has $.target;
    has @.contents;
}

#line 1 SETTING::src/core/QuantHash.pm
my role QuantHash does Associative {
    method Int     ( --> Int:D)     { self.total.Int }
    method Num     ( --> Num:D)     { self.total.Num }
    method Numeric ( --> Numeric:D) { self.total.Numeric }
    method Real    ( --> Real:D)    { self.total.Real }

    method Capture() { self.Hash.Capture }

    multi method list(QuantHash:U:) { self.Any::list }
    multi method list(QuantHash:D:) { self.pairs.cache }

    method fmt(QuantHash: Cool $format = "%s\t\%s", $sep = "\n") {
        nqp::iseq_i(nqp::sprintfdirectives( nqp::unbox_s($format.Stringy)),1)
          ?? self.keys.fmt($format, $sep)
          !! self.pairs.fmt($format, $sep)
    }

    multi method AT-KEY(QuantHash:U \SELF: $key) is raw {
        nqp::istype(self, Set) || nqp::istype(self, Bag) || nqp::istype(self, Mix)
          ?? die "Cannot auto-vivify an immutable {SELF.^name}"
          !! (SELF = self.new).AT-KEY($key)
    }

    multi method pairs(QuantHash:D:) { Seq.new(self.iterator) }
}

#line 1 SETTING::src/core/Setty.pm
my role Setty does QuantHash {
    has Rakudo::Internals::IterationSet $!elems; # key.WHICH => key

    # helper sub to create Set from iterator, check for laziness
    sub create-from-iterator(\type, \iterator --> Setty:D) {
        nqp::if(
          iterator.is-lazy,
          Failure.new(X::Cannot::Lazy.new(:action<coerce>,:what(type.^name))),
          nqp::create(type).SET-SELF(
            Rakudo::QuantHash.ADD-ITERATOR-TO-SET(
              nqp::create(Rakudo::Internals::IterationSet), iterator
            )
          )
        )
    }

    multi method new(Setty: --> Setty:D) { nqp::create(self) }
    multi method new(Setty: \value --> Setty:D) {
        nqp::if(
          nqp::istype(value,Iterable) && nqp::not_i(nqp::iscont(value)),
          create-from-iterator(self, value.iterator),
          nqp::stmts(
            nqp::bindkey(
              (my $elems := nqp::create(Rakudo::Internals::IterationSet)),
              value.WHICH,
              nqp::decont(value)
            ),
            nqp::create(self).SET-SELF($elems)
          )
        )
    }
    multi method new(Setty: **@args --> Setty:D) {
        create-from-iterator(self, @args.iterator)
    }

    method new-from-pairs(*@pairs --> Setty:D) {
        nqp::if(
          (my $iterator := @pairs.iterator).is-lazy,
          Failure.new(X::Cannot::Lazy.new(:action<coerce>,:what(self.^name))),
          nqp::create(self).SET-SELF(
            Rakudo::QuantHash.ADD-PAIRS-TO-SET(
              nqp::create(Rakudo::Internals::IterationSet), $iterator
            )
          )
        )
    }

    method default(--> False) { }

    multi method keys(Setty:D:) {
        Seq.new(Rakudo::Iterator.Mappy-values($!elems))
    }

    method elems(Setty:D: --> Int:D) {
        nqp::istrue($!elems) && nqp::elems($!elems)
    }
    method total(Setty:D: --> Int:D) {
        nqp::istrue($!elems) && nqp::elems($!elems)
    }
    multi method antipairs(Setty:D:) {
        Seq.new(class :: does Rakudo::Iterator::Mappy {
            method pull-one() {
              nqp::if(
                $!iter,
                Pair.new(True,nqp::iterval(nqp::shift($!iter))),
                IterationEnd
              )
            }
        }.new($!elems))
    }
    multi method minpairs(Setty:D:) { self.pairs }
    multi method maxpairs(Setty:D:) { self.pairs }
    multi method Bool(Setty:D: --> Bool:D) {
        nqp::p6bool($!elems && nqp::elems($!elems))
    }

    method HASHIFY(\type) {
        nqp::stmts(
          (my $hash := Hash.^parameterize(type,Any).new),
          (my $descriptor := nqp::getattr($hash,Hash,'$!descriptor')),
          nqp::if(
            $!elems && nqp::elems($!elems),
            nqp::stmts(
              (my $storage := nqp::clone($!elems)),
              (my $iter := nqp::iterator($storage)),
              nqp::while(
                $iter,
                nqp::bindkey(
                  $storage,
                  nqp::iterkey_s(nqp::shift($iter)),
                  Pair.new(
                    nqp::iterval($iter),
                    (nqp::p6scalarfromdesc($descriptor) = True)
                  )
                )
              ),
              nqp::bindattr($hash,Map,'$!storage',$storage)
            )
          ),
          $hash
        )
    }
    multi method hash(Setty:D: --> Hash:D) { self.HASHIFY(Any) }
    multi method Hash(Setty:D: --> Hash:D) { self.HASHIFY(Bool) }

    multi method ACCEPTS(Setty:U: \other) { other.^does(self) }
    multi method ACCEPTS(Setty:D: Setty:D \other) {
        nqp::p6bool(
          nqp::unless(
            nqp::eqaddr(self,other),
            nqp::if(                                # not same object
              $!elems,
              nqp::if(                              # something on left
                (my $oraw := other.RAW-HASH),
                nqp::if(                            # something on both sides
                  nqp::iseq_i(nqp::elems($!elems),nqp::elems($oraw)),
                  nqp::stmts(                       # same size
                    (my $iter := nqp::iterator($!elems)),
                    nqp::while(
                      $iter,
                      nqp::unless(
                        nqp::existskey($oraw,nqp::iterkey_s(nqp::shift($iter))),
                        return False                # missing key, we're done
                      )
                    ),
                    True                            # all keys identical
                  )
                )
              ),
              # true -> both empty
              nqp::isfalse(
                ($oraw := other.RAW-HASH) && nqp::elems($oraw)
              )
            )
          )
        )
    }
    multi method ACCEPTS(Setty:D: \other) { self.ACCEPTS(other.Set) }

    multi method Str(Setty:D $ : --> Str:D) {
        nqp::join(" ",Rakudo::QuantHash.RAW-VALUES-MAP(self, *.Str))
    }
    multi method gist(Setty:D $ : --> Str:D) {
        nqp::concat(
          nqp::concat(
            nqp::if(
              nqp::istype(self,Set),
              'set(',
              nqp::concat(self.^name,'(')
            ),
            nqp::join(" ",
              Rakudo::Sorting.MERGESORT-str(
                Rakudo::QuantHash.RAW-VALUES-MAP(self, *.gist)
              )
            )
          ),
          ')'
        )
    }
    multi method perl(Setty:D $ : --> Str:D) {
        nqp::concat(
          nqp::concat(
            nqp::if(
              nqp::istype(self,Set),
              'set(',
              nqp::concat(self.^name,'(')
            ),
            nqp::join(",",Rakudo::QuantHash.RAW-VALUES-MAP(self, *.perl))
          ),
          ')'
        )
    }

    proto method grab(|) { * }
    proto method grabpairs(|) { * }

    proto method pick(|) { * }
    multi method pick(Setty:D:) { self.roll }
    multi method pick(Setty:D: Callable:D $calculate) {
        self.pick( $calculate(self.elems) )
    }
    multi method pick(Setty:D: Whatever $) {
        self.pick(Inf)
    }
    multi method pick(Setty:D: $count) {
        Seq.new(class :: does Rakudo::QuantHash::Pairs {
            method pull-one() is raw {
                nqp::if(
                  nqp::elems($!picked),
                  nqp::atkey($!elems,nqp::pop_s($!picked)),
                  IterationEnd
                )
            }
        }.new($!elems, $count))
    }

    proto method pickpairs(|) { * }
    multi method pickpairs(Setty:D:) { Pair.new(self.roll,True) }
    multi method pickpairs(Setty:D: Callable:D $calculate) {
        self.pickpairs( $calculate(self.elems) )
    }
    multi method pickpairs(Setty:D: Whatever $) {
        self.pickpairs(Inf)
    }
    multi method pickpairs(Setty:D: $count) {
        Seq.new(class :: does Rakudo::QuantHash::Pairs {
            method pull-one() is raw {
                nqp::if(
                  nqp::elems($!picked),
                  Pair.new(nqp::atkey($!elems,nqp::pop_s($!picked)),True),
                  IterationEnd
                )
            }
        }.new($!elems, $count))
    }

    proto method roll(|) { * }
    multi method roll(Setty:D:) {
        nqp::if(
          $!elems,
          nqp::iterval(Rakudo::QuantHash.ROLL($!elems)),
          Nil
        )
    }
    multi method roll(Setty:D: Callable:D $calculate) {
        self.roll($calculate(self.elems))
    }
    multi method roll(Setty:D: Whatever) {
        self.roll(Inf)
    }
    multi method roll(Setty:D: $count) {
        Seq.new(nqp::if(
          (my $todo = Rakudo::QuantHash.TODO($count))
            && $!elems
            && (my int $elems = nqp::elems($!elems)),
          nqp::stmts(
            (my $keys := Rakudo::QuantHash.RAW-KEYS(self)),
            nqp::if(
              $todo == Inf,
              Rakudo::Iterator.Callable(
                { nqp::atkey($!elems,nqp::atpos_s($keys,nqp::rand_n($elems))) },
                True
              ),
              Rakudo::Iterator.Callable( {
                  nqp::if(
                    $todo,
                    nqp::stmts(
                      --$todo,
                      nqp::atkey(
                        $!elems,
                        nqp::atpos_s($keys,nqp::rand_n($elems))
                      )
                    ),
                    IterationEnd
                  )
              } )
            )
          ),
          Rakudo::Iterator.Empty
        ))
    }

    multi method EXISTS-KEY(Setty:D: \k --> Bool:D) {
        nqp::p6bool($!elems && nqp::existskey($!elems,k.WHICH))
    }

    multi method Bag(Setty:D:) {
        nqp::if(
          $!elems && nqp::elems($!elems),
          nqp::create(Bag).SET-SELF(Rakudo::QuantHash.SET-BAGGIFY($!elems)),
          bag()
        )
    }
    multi method BagHash(Setty:D:) {
        nqp::if(
          $!elems && nqp::elems($!elems),
          nqp::create(BagHash).SET-SELF(Rakudo::QuantHash.SET-BAGGIFY($!elems)),
          nqp::create(BagHash)
        )
    }
    multi method Mix(Setty:D:) {
        nqp::if(
          $!elems && nqp::elems($!elems),
          nqp::create(Mix).SET-SELF(Rakudo::QuantHash.SET-BAGGIFY($!elems)),
          mix()
        )
    }
    multi method MixHash(Setty:D:) {
        nqp::if(
          $!elems && nqp::elems($!elems),
          nqp::create(MixHash).SET-SELF(Rakudo::QuantHash.SET-BAGGIFY($!elems)),
          nqp::create(MixHash)
        )
    }

    method RAW-HASH() is raw { $!elems }

    # TODO: WHICH will require the capability for >1 pointer in ObjAt
}

multi sub infix:<eqv>(Setty:D \a, Setty:D \b --> Bool:D) {
    nqp::p6bool(
      nqp::eqaddr(a,b) || (nqp::eqaddr(a.WHAT,b.WHAT) && a.ACCEPTS(b))
    )
}

#line 1 SETTING::src/core/Set.pm
my class Set does Setty {
    has $!WHICH;

    method SET-SELF(\elems) {
        nqp::if(
          nqp::elems(elems),
          nqp::stmts(
            nqp::bindattr(self,::?CLASS,'$!elems',elems),
            self
          ),
          set()
        )
    }
    multi method new(Set:_:) {
        nqp::if(
          nqp::eqaddr(self.WHAT,Set),
          set(),
          nqp::create(self)
        )
    }

    multi method WHICH (Set:D:) {
        nqp::if(
          nqp::attrinited(self,Set,'$!WHICH'),
          $!WHICH,
          $!WHICH := nqp::if(
            nqp::istype(self.WHAT,Set),
            'Set|',
            nqp::concat(self.^name,'|')
          ) ~ nqp::sha1(
                nqp::join("\0",Rakudo::Sorting.MERGESORT-str(
                  Rakudo::QuantHash.RAW-KEYS(self)
                ))
            )
        )
    }

    method iterator(Set:D:) {
        class :: does Rakudo::Iterator::Mappy {
            method pull-one() {
              nqp::if(
                $!iter,
                Pair.new(nqp::iterval(nqp::shift($!iter)),True),
                IterationEnd
              )
            }
        }.new($!elems)
    }

    multi method kv(Set:D:) {
        Seq.new(class :: does Rakudo::QuantHash::Quanty-kv {
            method pull-one() is raw {
                nqp::if(
                  $!on,
                  nqp::stmts(
                    ($!on = 0),
                    True,
                  ),
                  nqp::if(
                    $!iter,
                    nqp::stmts(
                      ($!on = 1),
                      nqp::iterval(nqp::shift($!iter))
                    ),
                    IterationEnd
                  )
                )
            }
            method push-all($target --> IterationEnd) {
                nqp::while(
                  $!iter,
                  nqp::stmts(  # doesn't sink
                    $target.push(nqp::iterval(nqp::shift($!iter))),
                    $target.push(True)
                  )
                )
            }
        }.new(self))
    }
    multi method values(Set:D:) { True xx self.total }

    multi method grab(Set:D: $count?) {
        X::Immutable.new( method => 'grab', typename => self.^name ).throw;
    }
    multi method grabpairs(Set:D $count?) {
        X::Immutable.new( method => 'grabpairs', typename => self.^name ).throw;
    }

#--- coercion methods
    multi method Set(Set:D:) { self }
    multi method SetHash(Set:D:) {
        nqp::if(
          $!elems && nqp::elems($!elems),
          nqp::p6bindattrinvres(
            nqp::create(SetHash),SetHash,'$!elems',nqp::clone($!elems)
          ),
          nqp::create(SetHash)
        )
    }
    method clone() {
        nqp::if(
          $!elems && nqp::elems($!elems),
          nqp::clone(self),
          set()
        )
    }

#--- interface methods
    multi method AT-KEY(Set:D: \k --> Bool:D) {
        nqp::p6bool($!elems && nqp::existskey($!elems,k.WHICH))
    }
    multi method ASSIGN-KEY(Set:D: \k,\v) {
        X::Assignment::RO.new(value => self).throw;
    }
    multi method DELETE-KEY(Set:D: \k) {
        X::Immutable.new(method => 'DELETE-KEY', typename => self.^name).throw;
    }
}

#line 1 SETTING::src/core/SetHash.pm
my class SetHash does Setty {

    method SET-SELF(\elems) {
        nqp::stmts(
          nqp::if(
            nqp::elems(elems),
            nqp::bindattr(self,::?CLASS,'$!elems',elems)
          ),
          self
        )
    }

#--- selector methods

    multi method grab(SetHash:D:) {
        nqp::if(
          $!elems,
          nqp::stmts(
            (my $object := nqp::iterval(
              my $iter := Rakudo::QuantHash.ROLL($!elems)
            )),
            nqp::deletekey($!elems,nqp::iterkey_s($iter)),
            $object
          ),
          Nil
        )
    }
    multi method grab(SetHash:D: Callable:D $calculate) {
        self.grab($calculate(self.elems))
    }
    multi method grab(SetHash:D: Whatever) {
        self.grab(Inf)
    }
    multi method grab(SetHash:D: $count) {
        Seq.new(class :: does Rakudo::QuantHash::Pairs {
            method pull-one() is raw {
                nqp::if(
                  nqp::elems($!picked),
                  nqp::stmts(
                    (my $object := nqp::atkey(
                      $!elems,
                      (my $key := nqp::pop_s($!picked))
                    )),
                    nqp::deletekey($!elems,$key),
                    $object
                  ),
                  IterationEnd
                )
            }
        }.new($!elems, $count))
    }

    multi method grabpairs(SetHash:D:) {
        Pair.new(self.grab,True)
    }
    multi method grabpairs(SetHash:D: Callable:D $calculate) {
        self.grabpairs($calculate(self.elems))
    }
    multi method grabpairs(SetHash:D: Whatever) {
        self.grabpairs(Inf)
    }
    multi method grabpairs(SetHash:D: $count) {
        Seq.new(class :: does Rakudo::QuantHash::Pairs {
            method pull-one() is raw {
                nqp::if(
                  nqp::elems($!picked),
                  nqp::stmts(
                    (my $object := nqp::atkey(
                      $!elems,
                      (my $key := nqp::pop_s($!picked))
                    )),
                    nqp::deletekey($!elems,$key),
                    Pair.new($object,True)
                  ),
                  IterationEnd
                )
            }
        }.new($!elems, $count))
    }

#--- iterator methods

    sub proxy(Mu \iter,Mu \elems) is raw {
        # We are only sure that the key exists when the Proxy
        # is made, but we cannot be sure of its existence when
        # either the FETCH or STORE block is executed.  So we
        # still need to check for existence, and handle the case
        # where we need to (re-create) the key and value.  The
        # logic is therefore basically the same as in AT-KEY,
        # except for tests for allocated storage and .WHICH
        # processing.
        nqp::stmts(
          # save object for potential recreation
          (my $object := nqp::iterval(iter)),

          Proxy.new(
            FETCH => {
                nqp::p6bool(nqp::existskey(elems,nqp::iterkey_s(iter)))
            },
            STORE => -> $, $value {
                nqp::stmts(
                  nqp::if(
                    $value,
                    nqp::bindkey(elems,nqp::iterkey_s(iter),$object),
                    nqp::deletekey(elems,nqp::iterkey_s(iter))
                  ),
                  $value.Bool
                )
            }
          )
        )
    }

    method iterator(SetHash:D:) {
        class :: does Rakudo::Iterator::Mappy {
            method pull-one() {
              nqp::if(
                $!iter,
                Pair.new(
                  nqp::iterval(nqp::shift($!iter)),
                  proxy($!iter,$!hash)
                ),
                IterationEnd
              )
            }
        }.new($!elems)
    }

    multi method kv(SetHash:D:) {
        Seq.new(class :: does Rakudo::QuantHash::Quanty-kv {
            method pull-one() is raw {
                nqp::if(
                  $!on,
                  nqp::stmts(
                    ($!on = 0),
                    proxy($!iter,$!elems)
                  ),
                  nqp::if(
                    $!iter,
                    nqp::stmts(
                      ($!on = 1),
                      nqp::iterval(nqp::shift($!iter))
                    ),
                    IterationEnd
                  )
                )
            }
            method push-all($target --> IterationEnd) {
                nqp::while(
                  $!iter,
                  nqp::stmts(  # doesn't sink
                    $target.push(nqp::iterval(nqp::shift($!iter))),
                    $target.push(True)
                  )
                )
            }
        }.new(self))
    }
    multi method values(SetHash:D:) {
        Seq.new(class :: does Rakudo::Iterator::Mappy {
            method pull-one() {
              nqp::if(
                $!iter,
                proxy(nqp::shift($!iter),$!hash),
                IterationEnd
              )
            }
        }.new($!elems))
    }

#--- coercion methods
    multi method Set(SetHash:D: :$view) {
        nqp::if(
          $!elems && nqp::elems($!elems),
          nqp::create(Set).SET-SELF(nqp::if($view,$!elems,nqp::clone($!elems))),
          nqp::create(Set)
        )
    }
    multi method SetHash(SetHash:D:) { self }
    method clone() {
        nqp::if(
          $!elems && nqp::elems($!elems),
          nqp::create(self).SET-SELF(nqp::clone($!elems)),
          nqp::create(self)
        )
    }

#--- interface methods
    multi method AT-KEY(SetHash:D: \k --> Bool:D) is raw {
        Proxy.new(
          FETCH => {
              nqp::p6bool($!elems && nqp::existskey($!elems,k.WHICH))
          },
          STORE => -> $, $value {
              nqp::stmts(
                nqp::if(
                  $value,
                  nqp::stmts(
                    nqp::unless(
                      $!elems,
# XXX for some reason, $!elems := nqp::create(...) doesn't work
# Type check failed in binding; expected NQPMu but got Rakudo::Internals::IterationSet
                      nqp::bindattr(self,::?CLASS,'$!elems',
                        nqp::create(Rakudo::Internals::IterationSet))
                    ),
                    nqp::bindkey($!elems,k.WHICH,nqp::decont(k))
                  ),
                  $!elems && nqp::deletekey($!elems,k.WHICH)
                ),
                $value.Bool
              )
          }
        )
    }

    multi method DELETE-KEY(SetHash:D: \k --> Bool:D) {
        nqp::p6bool(
          nqp::if(
            $!elems && nqp::existskey($!elems,(my $which := k.WHICH)),
            nqp::stmts(
              nqp::deletekey($!elems,$which),
              1
            )
          )
        )
    }
}

#line 1 SETTING::src/core/Baggy.pm
my role Baggy does QuantHash {

# A Bag/BagHash/Mix/MixHash consists of a single hash with Pairs.
# The keys of the hash, are the .WHICH strings of the original object key.
# The values are Pairs containing the original object key and value.

    has Rakudo::Internals::IterationSet $!elems; # key.WHICH => (key,value)

# The Baggy role takes care of all mutable and immutable aspects that are
# shared between Bag,BagHash,Mix,MixHash.  Any specific behaviour for
# mutable and immutable aspects of Mix/MixHash need to live in Mixy.
# Immutables aspects of Bag/Mix, need to live to Bag/Mix respectively.

#--- interface methods
    method SET-SELF(Baggy:D: \elems) {
        nqp::stmts(
          nqp::if(
            nqp::elems(elems),
            nqp::bindattr(self,::?CLASS,'$!elems',elems)
          ),
          self
        )
    }
    multi method ACCEPTS(Baggy:U: \other --> Bool:D) {
        other.^does(self)
    }
    multi method ACCEPTS(Baggy:D: Baggy:D \other --> Bool:D) {
        nqp::p6bool(
          nqp::unless(
            nqp::eqaddr(self,other),
            nqp::if(                         # not same object
              (my $araw := $!elems),
              nqp::if(                       # something on left
                (my $braw := other.RAW-HASH),
                nqp::if(                     # something on both sides
                  nqp::iseq_i(nqp::elems($araw),nqp::elems($braw)),
                  nqp::stmts(                # same size
                    (my $iter := nqp::iterator($araw)),
                    nqp::while(
                      $iter,
                      nqp::unless(
                        nqp::getattr(
                          nqp::ifnull(
                            nqp::atkey($braw,nqp::iterkey_s(nqp::shift($iter))),
                            BEGIN nqp::p6bindattrinvres(  # virtual Pair with 0
                              nqp::create(Pair),Pair,'$!value',0)
                          ),Pair,'$!value')
                          == nqp::getattr(nqp::iterval($iter),Pair,'$!value'),
                        return False         # missing/different: we're done
                      )
                    ),
                    True                     # all keys identical/same value
                  )
                )
              ),
              # true -> both empty
              nqp::isfalse(
                ($braw := other.RAW-HASH) && nqp::elems($braw)
              )
            )
          )
        )
    }
    multi method ACCEPTS(Baggy:D: Mu \other --> Bool:D) {
        self.ACCEPTS(other.Bag)
    }

    multi method AT-KEY(Baggy:D: \k) {  # exception: ro version for Bag/Mix
        nqp::if(
          $!elems,
          nqp::getattr(
            nqp::ifnull(
              nqp::atkey($!elems,k.WHICH),
              BEGIN nqp::p6bindattrinvres(nqp::create(Pair),Pair,'$!value',0)
            ),
            Pair,
            '$!value'
          ),
          0
        )
    }
    multi method DELETE-KEY(Baggy:D: \k) {
        nqp::if(
          $!elems && nqp::existskey($!elems,(my $which := k.WHICH)),
          nqp::stmts(
            (my $value :=
              nqp::getattr(nqp::atkey($!elems,$which),Pair,'$!value')),
            nqp::deletekey($!elems,$which),
            $value
          ),
          0
        )
    }
    multi method EXISTS-KEY(Baggy:D: \k) {
        nqp::p6bool(
          $!elems && nqp::existskey($!elems,k.WHICH)
        )
    }

#--- object creation methods

    # helper sub to create Bag from iterator, check for laziness
    sub create-from-iterator(\type, \iterator --> Baggy:D) {
        nqp::if(
          iterator.is-lazy,
          Failure.new(X::Cannot::Lazy.new(:action<coerce>,:what(type.^name))),
          nqp::create(type).SET-SELF(
            Rakudo::QuantHash.ADD-ITERATOR-TO-BAG(
              nqp::create(Rakudo::Internals::IterationSet), iterator
            )
          )
        )
    }

    multi method new(Baggy:_: --> Baggy:D) { nqp::create(self) }
    multi method new(Baggy:_: \value --> Baggy:D) {
        nqp::if(
          nqp::istype(value,Iterable) && nqp::not_i(nqp::iscont(value)),
          create-from-iterator(self, value.iterator),
          nqp::stmts(
            nqp::bindkey(
              (my $elems := nqp::create(Rakudo::Internals::IterationSet)),
              value.WHICH,
              Pair.new(value,1)
            ),
            nqp::create(self).SET-SELF($elems)
          )
        )
    }
    multi method new(Baggy:_: **@args) {
        create-from-iterator(self, @args.iterator)
    }

    method new-from-pairs(Baggy:_: *@pairs --> Baggy:D) {
        nqp::if(
          (my $iterator := @pairs.iterator).is-lazy,
          Failure.new(X::Cannot::Lazy.new(:action<coerce>,:what(self.^name))),
          nqp::create(self).SET-SELF(
            Rakudo::QuantHash.ADD-PAIRS-TO-BAG(
              nqp::create(Rakudo::Internals::IterationSet),$iterator
            )
          )
        )
    }

#--- iterator methods
    multi method iterator(Baggy:D:) {
        Rakudo::Iterator.Mappy-values($!elems)
    }
    multi method keys(Baggy:D:) {
        Seq.new(class :: does Rakudo::Iterator::Mappy {
            method pull-one() {
                $!iter
                  ?? nqp::getattr(nqp::iterval(nqp::shift($!iter)),Pair,'$!key')
                  !! IterationEnd
            }
            method push-all($target --> IterationEnd) {
                nqp::while(  # doesn't sink
                  $!iter,
                  $target.push(
                    nqp::getattr(nqp::iterval(nqp::shift($!iter)),Pair,'$!key')
                  )
                )
            }
        }.new($!elems))
    }
    multi method kv(Baggy:D:) {
        Seq.new(Rakudo::Iterator.Mappy-kv-from-pairs($!elems))
    }
    multi method values(Baggy:D:) {
        Seq.new(class :: does Rakudo::Iterator::Mappy {
            method pull-one() is raw {
                nqp::if(
                  $!iter,
                  nqp::getattr(nqp::iterval(nqp::shift($!iter)),Pair,'$!value'),
                  IterationEnd
                )
            }
            method push-all($target --> IterationEnd) {
                nqp::while(  # doesn't sink
                  $!iter,
                  $target.push(
                    nqp::getattr(
                      nqp::iterval(nqp::shift($!iter)),
                      Pair,
                      '$!value'
                    )
                  )
                )
            }
        }.new($!elems))
    }
    multi method antipairs(Baggy:D:) {
        Seq.new(class :: does Rakudo::Iterator::Mappy {
            method pull-one() {
                nqp::if(
                  $!iter,
                  nqp::iterval(nqp::shift($!iter)).antipair,
                  IterationEnd
                )
            }
            method push-all($target --> IterationEnd) {
                nqp::while(
                  $!iter,
                  $target.push(nqp::iterval(nqp::shift($!iter)).antipair),
                )
            }
        }.new($!elems))
    }
    proto method kxxv(|) { * }
    multi method kxxv(Baggy:D:) {
        Seq.new(class :: does Rakudo::Iterator::Mappy {
            has Mu $!key;
            has int $!times;

            method pull-one() is raw {
                nqp::if(
                  $!times,
                  nqp::stmts(
                    ($!times = nqp::sub_i($!times,1)),
                    $!key
                  ),
                  nqp::if(
                    $!iter,
                    nqp::stmts(
                      ($!key := nqp::getattr(
                        (my $pair := nqp::iterval(nqp::shift($!iter))),
                        Pair,
                        '$!key'
                      )),
                      ($!times =
                        nqp::sub_i(nqp::getattr($pair,Pair,'$!value'),1)),
                      $!key
                    ),
                    IterationEnd
                  )
                )
            }
            method skip-one() { # the default skip-one, too difficult to handle
                nqp::not_i(nqp::eqaddr(self.pull-one,IterationEnd))
            }
            method push-all($target --> IterationEnd) {
                nqp::while(
                  $!iter,
                  nqp::stmts(
                    ($!key := nqp::getattr(
                      (my $pair := nqp::iterval(nqp::shift($!iter))),
                      Pair,
                      '$!key'
                    )),
                    ($!times =
                      nqp::add_i(nqp::getattr($pair,Pair,'$!value'),1)),
                    nqp::while(  # doesn't sink
                      ($!times = nqp::sub_i($!times,1)),
                      $target.push($!key)
                    )
                  )
                )
            }
        }.new($!elems))
    }
    multi method invert(Baggy:D:) {
        Seq.new(Rakudo::Iterator.Invert(Rakudo::Iterator.Mappy-values($!elems)))
    }

#--- introspection methods
    multi method elems(Baggy:D: --> Int:D) {
        nqp::istrue($!elems) && nqp::elems($!elems)
    }
    multi method Bool(Baggy:D: --> Bool:D) {
        nqp::p6bool($!elems && nqp::elems($!elems))
    }

    method HASHIFY(\type) {
        nqp::stmts(
          (my $hash := Hash.^parameterize(type,Any).new),
          (my $descriptor := nqp::getattr($hash,Hash,'$!descriptor')),
          nqp::if(
            $!elems && nqp::elems($!elems),
            nqp::stmts(
              (my $storage := nqp::clone($!elems)),
              (my $iter := nqp::iterator($storage)),
              nqp::while(
                $iter,
                nqp::bindkey(
                  $storage,
                  nqp::iterkey_s(nqp::shift($iter)),
                  nqp::p6bindattrinvres(
                    nqp::clone(nqp::iterval($iter)),
                    Pair,
                    '$!value',
                    (nqp::p6scalarfromdesc($descriptor) =
                      nqp::getattr(nqp::iterval($iter),Pair,'$!value'))
                  )
                )
              ),
              nqp::bindattr($hash,Map,'$!storage',$storage)
            )
          ),
          $hash
        )
    }
    multi method hash(Baggy:D: --> Hash:D) { self.HASHIFY(Any) }
    multi method Hash(Baggy:D: --> Hash:D) { self.HASHIFY(UInt) }

    method default(Baggy:D: --> 0) { }

    multi method Str(Baggy:D: --> Str:D) {
        nqp::join(' ',Rakudo::QuantHash.RAW-VALUES-MAP(self, {
            nqp::if(
              (my $value := nqp::getattr($_,Pair,'$!value')) == 1,
              nqp::getattr($_,Pair,'$!key').gist,
              "{nqp::getattr($_,Pair,'$!key').gist}($value)"
            )
        }))
    }
    multi method gist(Baggy:D: --> Str:D) {
        nqp::concat(
          nqp::concat(
            nqp::concat(self.^name,'('),
            nqp::join(', ',
              Rakudo::Sorting.MERGESORT-str(
                Rakudo::QuantHash.RAW-VALUES-MAP(self, {
                    nqp::if(
                      (my $value := nqp::getattr($_,Pair,'$!value')) == 1,
                      nqp::getattr($_,Pair,'$!key').gist,
                      "{nqp::getattr($_,Pair,'$!key').gist}($value)"
                    )
                })
              )
            )
          ),
          ')',
        )
    }
    multi method perl(Baggy:D: --> Str:D) {
        nqp::if(
          $!elems && nqp::elems($!elems),
          nqp::concat(
            nqp::concat(
              '(',
              nqp::join(',',
                Rakudo::QuantHash.RAW-VALUES-MAP(self, {
                    nqp::if(
                      (my $value := nqp::getattr($_,Pair,'$!value')) == 1,
                      nqp::getattr($_,Pair,'$!key').perl,
                      "{nqp::getattr($_,Pair,'$!key').perl}=>$value"
                    )
                })
              )
            ),
            nqp::concat(').',self.^name)
          ),
          nqp::if(
            nqp::istype(self,Bag),
            'bag()',
            nqp::if(
              nqp::istype(self,Mix),
              'mix()',
              nqp::concat('().',self.^name)
            )
          )
        )
    }

#--- selection methods
    proto method grabpairs (|) { * }
    multi method grabpairs(Baggy:D:) {
        nqp::if(
          $!elems && nqp::elems($!elems),
          nqp::stmts(
            (my $iter := Rakudo::QuantHash.ROLL($!elems)),
            (my $pair := nqp::iterval($iter)),
            nqp::deletekey($!elems,nqp::iterkey_s($iter)),
            $pair
          ),
          Nil
        )
    }
    multi method grabpairs(Baggy:D: Callable:D $calculate) {
        self.grabpairs( $calculate(self.elems) )
    }
    multi method grabpairs(Baggy:D: Whatever $) {
        self.grabpairs(Inf)
    }
    multi method grabpairs(Baggy:D: $count) {
        Seq.new(class :: does Rakudo::QuantHash::Pairs {
            method pull-one() is raw {
                nqp::if(
                  nqp::elems($!picked),
                  nqp::stmts(
                    (my $pair := nqp::atkey(
                      $!elems,
                      (my $key := nqp::pop_s($!picked))
                    )),
                    nqp::deletekey($!elems,$key),
                    $pair
                  ),
                  IterationEnd
                )
            }
        }.new($!elems, $count))
    }

    proto method pickpairs(|) { * }
    multi method pickpairs(Baggy:D:) {
        nqp::if(
          $!elems && nqp::elems($!elems),
          nqp::iterval(Rakudo::QuantHash.ROLL($!elems)),
          Nil
        )
    }
    multi method pickpairs(Baggy:D: Callable:D $calculate) {
        self.pickpairs( $calculate(self.total) )
    }
    multi method pickpairs(Baggy:D: Whatever $) {
        self.pickpairs(Inf)
    }
    multi method pickpairs(Baggy:D: $count) {
        Seq.new(class :: does Rakudo::QuantHash::Pairs {
            method pull-one() is raw {
                nqp::if(
                  nqp::elems($!picked),
                  nqp::atkey($!elems,nqp::pop_s($!picked)),
                  IterationEnd
                )
            }
        }.new($!elems, $count))
    }

    proto method grab(|) { * }
    multi method grab(Baggy:D: |c) {
        X::Immutable.new( method => 'grab', typename => self.^name ).throw;
    }

    proto method pick(|) { * }
    multi method pick(Baggy:D:) { self.roll }
    multi method pick(Baggy:D: Callable:D $calculate) {
        self.pick( $calculate(self.total) )
    }
    multi method pick(Baggy:D: Whatever) { self.pick(Inf) }
    multi method pick(Baggy:D: $count) {
        Seq.new(nqp::if(
          (my $todo = nqp::if(
            $count == Inf,
            (my $total := self.total),
            $count.Int                          # also handles NaN
          )) < 1,
          Rakudo::Iterator.Empty,               # nothing to do
          class :: does Iterator {
              has $!raw;      # the IterationSet of the Baggy
              has $!weights;  # clone of raw, but with just the weights
              has $!todo;     # number of draws to do
              has $!total;    # total number of draws possible

              # Return the .WHICH key of a randomly picked object.  Updates
              # the weight of the picked object and the total number of draws
              # still possible.
              method BAG-PICK() {
                  nqp::stmts(
                    (my Int $rand := $!total.rand.Int),
                    (my Int $seen := 0),
                    (my $iter := nqp::iterator($!weights)),
                    nqp::while(
                      $iter && nqp::isle_I(
                        ($seen := nqp::add_I(
                          $seen,
                          nqp::iterval(nqp::shift($iter)),
                          Int
                        )),
                        $rand
                      ),
                      nqp::null
                    ),
                    nqp::bindkey(                # $iter now contains picked one
                      $!weights,
                      nqp::iterkey_s($iter),
                      nqp::sub_I(nqp::iterval($iter),1,Int)
                    ),
                    ($!total := nqp::sub_I($!total,1,Int)),
                    nqp::iterkey_s($iter)
                  )
              }

              method SET-SELF(\raw, \todo, \total) {
                  nqp::stmts(
                    ($!weights := nqp::clone($!raw := raw)),
                    (my $iter := nqp::iterator($!weights)),
                    nqp::while(
                      $iter,
                      nqp::bindkey(
                        $!weights,
                        nqp::iterkey_s(nqp::shift($iter)),
                        nqp::getattr(nqp::iterval($iter),Pair,'$!value')
                      )
                    ),
                    ($!todo := nqp::if(todo > total,total,todo)),
                    ($!total := total),
                    self
                  )
              }
              method new(\raw, \todo, \total) {
                  nqp::create(self).SET-SELF(raw, todo, total)
              }

              method pull-one() is raw {
                  nqp::if(
                    $!todo,
                    nqp::stmts(
                      ($!todo := nqp::sub_I($!todo,1,Int)),
                      nqp::getattr(nqp::atkey($!raw,self.BAG-PICK),Pair,'$!key')
                    ),
                    IterationEnd
                  )
              }
              method skip-one() {
                  nqp::if(
                    $!todo,
                    nqp::stmts(
                      ($!todo := nqp::sub_I($!todo,1,Int)),
                      self.BAG-PICK
                    )
                  )
              }
              method push-all($target --> IterationEnd) {
                  nqp::stmts(
                    (my $todo = $!todo),
                    nqp::while(
                      $todo,
                      nqp::stmts(
                        --$todo,
                        $target.push(nqp::getattr(
                          nqp::atkey($!raw,self.BAG-PICK),
                          Pair,
                          '$!key'
                        ))
                      )
                    ),
                    ($!todo := nqp::decont($todo))
                  )
              }
              method count-only() { $!todo - 1 }
              method bool-only(--> True) { }
              method sink-all() { $!todo := 0 }

          }.new($!elems, $todo, nqp::ifnull($total,self.total))
        ))
    }

    proto method roll(|) { * }
    multi method roll(Baggy:D:) {
        nqp::if(
          $!elems && (my $total := self.total),
          nqp::getattr(
            nqp::iterval(Rakudo::QuantHash.BAG-ROLL($!elems,$total)),
            Pair,
            '$!key'
          ),
          Nil
        )
    }
    multi method roll(Baggy:D: Whatever) {
        Seq.new(nqp::if(
          $!elems && (my $total := self.total),
          Rakudo::Iterator.Callable( {
              nqp::getattr(
                nqp::iterval(Rakudo::QuantHash.BAG-ROLL($!elems, $total)),
                Pair,
                '$!key'
              )
          }, True ),
          Rakudo::Iterator.Empty
        ))
    }
    multi method roll(Baggy:D: Callable:D $calculate) {
      nqp::if(
        (my $total := self.total),
        self.roll($calculate($total)),
        Seq.new(Rakudo::Iterator.Empty)
      )
    }
    multi method roll(Baggy:D: $count) {
        nqp::if(
          $count == Inf,
          self.roll(*),                         # let Whatever handle it
          Seq.new(nqp::if(                      # something else as count
            (my $todo = $count.Int) < 1, # also handles NaN
            Rakudo::Iterator.Empty,             # nothing to do
            nqp::if(
              $!elems && (my $total := self.total) && ++$todo,
              Rakudo::Iterator.Callable( {      # need to do a number of times
                  nqp::if(
                    --$todo,
                    nqp::getattr(
                      nqp::iterval(Rakudo::QuantHash.BAG-ROLL($!elems, $total)),
                      Pair,
                      '$!key'
                    ),
                    IterationEnd
                  )
              }),
              Rakudo::Iterator.Empty            # nothing to roll for
            )
          ))
        )
    }

#--- classification method
    proto method classify-list(|) { * }
    multi method classify-list( &test, \list) {
        fail X::Cannot::Lazy.new(:action<classify>) if list.is-lazy;
        my \iter = (nqp::istype(list, Iterable) ?? list !! list.list).iterator;

        while (my $value := iter.pull-one) !=:= IterationEnd {
            my $tested := test($value);
            if nqp::istype($tested, Iterable) { # multi-level classify
                X::Invalid::ComputedValue.new(
                    :name<mapper>,
                    :method<classify-list>,
                    :value<an Iterable item>,
                    :reason(self.^name ~ ' cannot be nested and so does not '
                        ~ 'support multi-level classification'),
                ).throw;
            }
            else {
                self{$tested}++;
            }
        }
        self;
    }
    multi method classify-list( %test, |c ) {
        self.classify-list( { %test{$^a} }, |c );
    }
    multi method classify-list( @test, |c ) {
        self.classify-list( { @test[$^a] }, |c );
    }
    multi method classify-list(&test, **@list, |c) {
        self.classify-list(&test, @list, |c);
    }

    proto method categorize-list(|) { * }
    multi method categorize-list( &test, \list ) {
        fail X::Cannot::Lazy.new(:action<categorize>) if list.is-lazy;
        my \iter = (nqp::istype(list, Iterable) ?? list !! list.list).iterator;
        my $value := iter.pull-one;
        unless $value =:= IterationEnd {
            my $tested := test($value);

            # multi-level categorize
            if nqp::istype($tested[0],Iterable) {
                X::Invalid::ComputedValue.new(
                    :name<mapper>,
                    :method<categorize-list>,
                    :value<a nested Iterable item>,
                    :reason(self.^name ~ ' cannot be nested and so does not '
                        ~ 'support multi-level categorization'),
                ).throw;
            }
            # simple categorize
            else {
                loop {
                    self{$_}++ for @$tested;
                    last if ($value := iter.pull-one) =:= IterationEnd;
                    nqp::istype(($tested := test($value))[0], Iterable)
                        and X::Invalid::ComputedValue.new(
                            :name<mapper>,
                            :method<categorize-list>,
                            :value('an item with different number of elements '
                                ~ 'in it than previous items'),
                            :reason('all values need to have the same number '
                                ~ 'of elements. Mixed-level classification is '
                                ~ 'not supported.'),
                        ).throw;
                };
            }
       }
       self;
    }
    multi method categorize-list( %test, |c ) {
        self.categorize-list( { %test{$^a} }, |c );
    }
    multi method categorize-list( @test, |c ) {
        self.categorize-list( { @test[$^a] }, |c );
    }
    multi method categorize-list( &test, **@list, |c ) {
        self.categorize-list( &test, @list, |c );
    }

#--- coercion methods
   sub SETIFY(\raw, \type) {
        nqp::if(
          raw && nqp::elems(raw),
          nqp::stmts(
            (my $elems := nqp::clone(raw)),
            (my $iter := nqp::iterator($elems)),
            nqp::while(
              $iter,
              nqp::bindkey(
                $elems,
                nqp::iterkey_s(nqp::shift($iter)),
                nqp::getattr(nqp::iterval($iter),Pair,'$!key'),
              )
            ),
            nqp::create(type).SET-SELF($elems)
          ),
          nqp::if(
            nqp::eqaddr(type,Set),
            set(),
            nqp::create(type)
          )
        )
    }
    multi method Set(Baggy:D:)     { SETIFY($!elems,Set)     }
    multi method SetHash(Baggy:D:) { SETIFY($!elems,SetHash) }

    sub MIXIFY(\raw, \type) {
        nqp::if(
          raw && nqp::elems(raw),
          nqp::create(type).SET-SELF(Rakudo::QuantHash.BAGGY-CLONE(raw)),
          nqp::if(
            nqp::istype(type,Mix),
            mix(),
            nqp::create(MixHash)
          )
        )
    }

    multi method Mix(Baggy:D:)     { MIXIFY($!elems, Mix)     }
    multi method MixHash(Baggy:D:) { MIXIFY($!elems, MixHash) }

    method RAW-HASH() is raw { $!elems }
}

multi sub infix:<eqv>(Baggy:D \a, Baggy:D \b --> Bool:D) {
    nqp::p6bool(
      nqp::eqaddr(a,b) || (nqp::eqaddr(a.WHAT,b.WHAT) && a.ACCEPTS(b))
    )
}
#line 1 SETTING::src/core/Bag.pm
my class Bag does Baggy {
    has Int $!total;
    has $!WHICH;

#--- introspection methods
    multi method WHICH(Bag:D:)   {
        nqp::if(
          nqp::attrinited(self,Bag,'$!WHICH'),
          $!WHICH,
          $!WHICH := ObjAt.new('Bag!' ~ nqp::sha1(
            nqp::join('\0',Rakudo::Sorting.MERGESORT-str(
              Rakudo::QuantHash.BAGGY-RAW-KEY-VALUES(self)
            ))
          ))
        )
    }
    method total(Bag:D: --> Int:D) {
        nqp::if(
          nqp::attrinited(self,Bag,'$!total'),
          $!total,
          $!total := Rakudo::QuantHash.BAG-TOTAL($!elems)
        )
    }

#--- object creation methods
    multi method new(Bag:_:) {
        nqp::if(
          nqp::eqaddr(self.WHAT,Bag),
          bag(),
          nqp::create(self)
        )
    }

#--- interface methods
    method SET-SELF(Bag:D: \elems) {
        nqp::if(
          nqp::elems(elems),
          nqp::stmts(
            nqp::bindattr(self,::?CLASS,'$!elems',elems),
            self
          ),
          bag()
        )
    }

    multi method DELETE-KEY(Bag:D: \k) {
        X::Immutable.new(method => 'DELETE-KEY', typename => self.^name).throw;
    }

#--- selection methods
    multi method grabpairs(Bag:D: $count?) {
        X::Immutable.new( method => 'grabpairs', typename => self.^name ).throw;
    }

#--- coercion methods
    multi method Bag(Bag:D:) { self }
    multi method BagHash(Bag:D) {
        nqp::if(
          $!elems && nqp::elems($!elems),
          nqp::create(BagHash).SET-SELF(Rakudo::QuantHash.BAGGY-CLONE($!elems)),
          nqp::create(BagHash)
        )
    }
    multi method Mix(Bag:D:) {
        nqp::if(
          $!elems && nqp::elems($!elems),
          nqp::create(Mix).SET-SELF($!elems),
          mix()
        )
    }
    multi method MixHash(Bag:D) {
        nqp::if(
          $!elems && nqp::elems($!elems),
          nqp::create(MixHash).SET-SELF(Rakudo::QuantHash.BAGGY-CLONE($!elems)),
          nqp::create(MixHash)
        )
    }
    method clone() {
        nqp::if(
          $!elems && nqp::elems($!elems),
          nqp::clone(self),
          bag()
        )
    }

#--- illegal methods
    proto method classify-list(|) {
        X::Immutable.new(:method<classify-list>, :typename(self.^name)).throw;
    }
    proto method categorize-list(|) {
        X::Immutable.new(:method<categorize-list>, :typename(self.^name)).throw;
    }
}

#line 1 SETTING::src/core/BagHash.pm
my class BagHash does Baggy {

#--- interface methods
    multi method AT-KEY(BagHash:D: \k) is raw {
        Proxy.new(
          FETCH => {
              nqp::if(
                $!elems && nqp::existskey($!elems,(my $which := k.WHICH)),
                nqp::getattr(nqp::atkey($!elems,$which),Pair,'$!value'),
                0
              )
          },
          STORE => -> $, Int() $value {
              nqp::if(
                nqp::istype($value,Failure),    # RT 128927
                $value.throw,
                nqp::if(
                  $!elems,
                  nqp::if(                      # allocated hash
                    nqp::existskey($!elems,(my $which := k.WHICH)),
                    nqp::if(                    # existing element
                      nqp::isgt_i($value,0),
                      nqp::bindattr(
                        nqp::atkey($!elems,$which),
                        Pair,
                        '$!value',
                        nqp::decont($value)
                      ),
                      nqp::stmts(
                        nqp::deletekey($!elems,$which),
                        0
                      )
                    ),
                    nqp::if(
                      nqp::isgt_i($value,0),    # new
                      nqp::bindkey(
                        $!elems,
                        $which,
                        Pair.new(k,nqp::decont($value))
                      )
                    )
                  ),
                  nqp::if(                      # no hash allocated yet
                    nqp::isgt_i($value,0),
                    nqp::bindkey(
                      nqp::bindattr(self,::?CLASS,'$!elems',
                        nqp::create(Rakudo::Internals::IterationSet)),
                      k.WHICH,
                      Pair.new(k,nqp::decont($value))
                    )
                  )
                )
              )
          }
        )
    }

#--- object creation methods
    multi method new(BagHash:_:) { nqp::create(self) }

#--- introspection methods
    method total() { Rakudo::QuantHash.BAG-TOTAL($!elems) }

#--- coercion methods
    multi method Bag(BagHash:D: :$view) {
        nqp::if(
          $!elems && nqp::elems($!elems),
          nqp::create(Bag).SET-SELF(                  # not empty
            nqp::if(
              $view,
              $!elems,                                # BagHash won't change
              Rakudo::QuantHash.BAGGY-CLONE($!elems)  # need deep copy
            )
          ),
          bag()                                       # empty, bag() will do
        )
    }
    multi method BagHash(BagHash:D:) { self }
    multi method Mix(BagHash:D:) {
        nqp::if(
          $!elems && nqp::elems($!elems),
          nqp::create(Mix).SET-SELF(Rakudo::QuantHash.BAGGY-CLONE($!elems)),
          mix()
        )
    }
    multi method MixHash(BagHash:D:) {
        nqp::if(
          $!elems && nqp::elems($!elems),
          nqp::create(MixHash).SET-SELF(Rakudo::QuantHash.BAGGY-CLONE($!elems)),
          nqp::create(MixHash)
        )
    }
    method clone() {
        nqp::if(
          $!elems && nqp::elems($!elems),
          nqp::create(BagHash).SET-SELF(Rakudo::QuantHash.BAGGY-CLONE($!elems)),
          nqp::create(BagHash)
        )
    }

#--- iterator methods

    sub proxy(Mu \iter,Mu \storage) is raw {
        # We are only sure that the key exists when the Proxy
        # is made, but we cannot be sure of its existence when
        # either the FETCH or STORE block is executed.  So we
        # still need to check for existence, and handle the case
        # where we need to (re-create) the key and value.  The
        # logic is therefore basically the same as in AT-KEY,
        # except for tests for allocated storage and .WHICH
        # processing.
        nqp::stmts(
          (my $which  := nqp::iterkey_s(iter)),
          # save object for potential recreation
          (my $object := nqp::getattr(nqp::iterval(iter),Pair,'$!key')),

          Proxy.new(
            FETCH => {
                nqp::if(
                  nqp::existskey(storage,$which),
                  nqp::getattr(nqp::atkey(storage,$which),Pair,'$!value'),
                  0
                )
            },
            STORE => -> $, Int() $value {
                nqp::if(
                  nqp::istype($value,Failure),  # RT 128927
                  $value.throw,
                  nqp::if(
                    nqp::existskey(storage,$which),
                    nqp::if(                    # existing element
                      nqp::isgt_i($value,0),
                      nqp::bindattr(            # value ok
                        nqp::atkey(storage,$which),
                        Pair,
                        '$!value',
                        nqp::decont($value)
                      ),
                      nqp::stmts(               # goodbye!
                        nqp::deletekey(storage,$which),
                        0
                      )
                    ),
                    nqp::if(                    # where did it go?
                      nqp::isgt_i($value,0),
                      nqp::bindkey(
                        storage,
                        $which,
                        Pair.new($object,nqp::decont($value))
                      )
                    )
                  )
                )
            }
          )
        )
    }

    multi method iterator(BagHash:D:) {    # also .pairs
        class :: does Rakudo::Iterator::Mappy {
            method pull-one() is raw {
                nqp::if(
                  $!iter,
                  nqp::p6bindattrinvres(
                    nqp::clone(nqp::iterval(nqp::shift($!iter))),
                    Pair,
                    '$!value',
                    proxy($!iter,$!hash)
                  ),
                  IterationEnd
                )
            }
            method push-all($target --> IterationEnd) {
                nqp::while(  # doesn't sink
                  $!iter,
                  $target.push(nqp::iterval(nqp::shift($!iter)))
                )
            }
        }.new($!elems)
    }

    multi method values(BagHash:D:) {
        Seq.new(class :: does Rakudo::Iterator::Mappy {
            method pull-one() is raw {
                nqp::if(
                  $!iter,
                  proxy(nqp::shift($!iter),$!hash),
                  IterationEnd
                )
            }

            # same as Baggy.values
            method push-all($target --> IterationEnd) {
                nqp::while(  # doesn't sink
                  $!iter,
                  $target.push(nqp::getattr(
                    nqp::iterval(nqp::shift($!iter)),Pair,'$!value'))
                )
            }
        }.new($!elems))
    }

    multi method kv(BagHash:D:) {
        Seq.new(class :: does Rakudo::Iterator::Mappy-kv-from-pairs {
            method pull-one() is raw {
                nqp::if(
                  $!on,
                  nqp::stmts(
                    ($!on = 0),
                    proxy($!iter,$!hash)
                  ),
                  nqp::if(
                    $!iter,
                    nqp::stmts(
                      ($!on = 1),
                      nqp::getattr(
                        nqp::iterval(nqp::shift($!iter)),Pair,'$!key')
                    ),
                    IterationEnd
                  )
                )
            }
        }.new($!elems))
    }

#---- selection methods
    multi method grab(BagHash:D:) {
        nqp::if(
          $!elems && nqp::elems($!elems),
          Rakudo::QuantHash.BAG-GRAB($!elems,self.total),
          Nil
        )
    }
    multi method grab(BagHash:D: Callable:D $calculate) {
        self.grab( $calculate(self.total) )
    }
    multi method grab(BagHash:D: Whatever) { self.grab(Inf) }
    multi method grab(BagHash:D: $count) {
        Seq.new(nqp::if(
          (my $todo = Rakudo::QuantHash.TODO($count))
            && $!elems
            && nqp::elems($!elems),
          nqp::stmts(
            (my Int $total = self.total),
            nqp::if($todo > $total,$todo = $total),
            Rakudo::Iterator.Callable( {
                nqp::if(
                  $todo,
                  nqp::stmts(
                    --$todo,
                    Rakudo::QuantHash.BAG-GRAB($!elems,$total--)
                  ),
                  IterationEnd
                )
            } )
          ),
          Rakudo::Iterator.Empty
        ))
    }
}

#line 1 SETTING::src/core/Mixy.pm
my role Mixy does Baggy  {

    multi method hash(Mixy:D: --> Hash:D) { self.HASHIFY(Any) }
    multi method Hash(Mixy:D: --> Hash:D) { self.HASHIFY(Real) }

    multi method kxxv(Mixy:D:) {
        Failure.new(".kxxv is not supported on a {self.^name}")
    }

    multi method grab(Mixy:D: $count?) {
        Failure.new(".grab is not supported on a {self.^name}")
    }

    multi method pick(Mixy:D: $count?) {
        Failure.new(".pick is not supported on a {self.^name}")
    }

    multi method roll(Mixy:D:) {
        nqp::if(
          (my $raw := self.RAW-HASH) && (my $total := self!total-positive),
          nqp::getattr(
            nqp::iterval(Rakudo::QuantHash.MIX-ROLL($raw, $total)),
            Pair,
            '$!key'
          ),
          Nil
        )
    }
    multi method roll(Mixy:D: Whatever) {
        Seq.new(nqp::if(
          (my $raw := self.RAW-HASH) && (my $total := self!total-positive),
          Rakudo::Iterator.Callable( {
              nqp::getattr(
                nqp::iterval(Rakudo::QuantHash.MIX-ROLL($raw, $total)),
                Pair,
                '$!key'
              )
          }, True ),
          Rakudo::Iterator.Empty
        ))
    }
    multi method roll(Mixy:D: Callable:D $calculate) {
      nqp::if(
        (my $total := self!total-positive),
        self.roll($calculate($total)),
        Seq.new(Rakudo::Iterator.Empty)
      )
    }
    multi method roll(Mixy:D: $count) {
        nqp::if(
          $count == Inf,
          self.roll(*),                         # let Whatever handle it
          Seq.new(nqp::if(                      # something else as count
            (my $todo = $count.Int) < 1, # also handles NaN
            Rakudo::Iterator.Empty,             # nothing to do
            nqp::if(
              (my $raw := self.RAW-HASH)
                && (my $total := self!total-positive)
                && ++$todo,
              Rakudo::Iterator.Callable( {      # need to do a number of times
                  nqp::if(
                    --$todo,
                    nqp::getattr(
                      nqp::iterval(Rakudo::QuantHash.MIX-ROLL($raw, $total)),
                      Pair,
                      '$!key'
                    ),
                    IterationEnd
                  )
              }),
              Rakudo::Iterator.Empty            # nothing to roll for
            )
          ))
        )
    }

#--- object creation methods
    method new-from-pairs(Mixy:_: *@pairs --> Mixy:D) {
        nqp::if(
          (my $iterator := @pairs.iterator).is-lazy,
          Failure.new(X::Cannot::Lazy.new(:action<coerce>,:what(self.^name))),
          nqp::create(self).SET-SELF(
            Rakudo::QuantHash.ADD-PAIRS-TO-MIX(
              nqp::create(Rakudo::Internals::IterationSet),$iterator
            )
          )
        )
    }

#--- coercion methods
   sub SETIFY(\mixy, \type) {
        nqp::if(
          (my $raw := mixy.RAW-HASH) && nqp::elems($raw),
          nqp::stmts(
            (my $elems := nqp::clone($raw)),
            (my $iter := nqp::iterator($elems)),
            nqp::while(
              $iter,
              nqp::if(
                nqp::getattr(
                  nqp::iterval(nqp::shift($iter)),
                  Pair,
                  '$!value'
                ) < 0,
                nqp::deletekey($elems,nqp::iterkey_s($iter)),
                nqp::bindkey(
                  $elems,
                  nqp::iterkey_s($iter),
                  nqp::getattr(nqp::iterval($iter),Pair,'$!key')
                )
              )
            ),
            nqp::create(type).SET-SELF($elems)
          ),
          nqp::if(
            nqp::eqaddr(type,Set),
            set(),
            nqp::create(type)
          )
        )
    }
    multi method Set(Mixy:D:)     { SETIFY(self,Set)     }
    multi method SetHash(Mixy:D:) { SETIFY(self,SetHash) }

    sub BAGGIFY(\mixy, \type) {
        nqp::if(
          (my $raw := mixy.RAW-HASH) && nqp::elems($raw),
          nqp::stmts(                               # something to coerce
            (my $elems := nqp::clone($raw)),
            (my $iter := nqp::iterator($elems)),
            nqp::while(
              $iter,
              nqp::if(
                (my $value := nqp::getattr(
                  nqp::iterval(nqp::shift($iter)),
                  Pair,
                  '$!value'
                ).Int) > 0,                         # .Int also deconts
                nqp::bindkey(                       # ok to keep value.Int
                  $elems,
                  nqp::iterkey_s($iter),
                  nqp::p6bindattrinvres(
                    nqp::iterval($iter),Pair,'$!value',$value)
                ),
                nqp::deletekey($elems,nqp::iterkey_s($iter))
              )
            ),
            nqp::create(type).SET-SELF($elems),
          ),
          nqp::if(                                  # nothing to coerce
            nqp::istype(type,Bag),
            bag(),
            nqp::create(BagHash)
          )
        )
    }

    multi method Bag(Baggy:D:)     { BAGGIFY(self, Bag)     }
    multi method BagHash(Baggy:D:) { BAGGIFY(self, BagHash) }
}

#line 1 SETTING::src/core/Mix.pm
my class Mix does Mixy {
    has $!WHICH;
    has Real $!total;
    has Real $!total-positive;

#--- interface methods
    method SET-SELF(Mix:D: \elems) {
        nqp::if(
          nqp::elems(elems),
          nqp::stmts(
            nqp::bindattr(self,::?CLASS,'$!elems',elems),
            self
          ),
          mix()
        )
    }

    multi method DELETE-KEY(Mix:D: \k) {
        X::Immutable.new(method => 'DELETE-KEY', typename => self.^name).throw;
    }

#--- introspection methods
    multi method WHICH(Mix:D:)    {
        nqp::if(
          nqp::attrinited(self,Mix,'$!WHICH'),
          $!WHICH,
          $!WHICH := ObjAt.new('Mix|' ~ nqp::sha1(
            nqp::join('\0',Rakudo::Sorting.MERGESORT-str(
              Rakudo::QuantHash.BAGGY-RAW-KEY-VALUES(self)
            ))
          ))
        )
    }
    method total(Mix:D: --> Real:D) {
        nqp::if(
          nqp::attrinited(self,Mix,'$!total'),
          $!total,
          $!total := Rakudo::QuantHash.MIX-TOTAL($!elems)
        )
    }
    method !total-positive(Mix:D: --> Real:D) {
        nqp::if(
          nqp::attrinited(self,Mix,'$!total-positive'),
          $!total-positive,
          $!total-positive := Rakudo::QuantHash.MIX-TOTAL-POSITIVE($!elems)
        )
    }

#--- object creation methods
    multi method new(Mix:_:) {
        nqp::if(
          nqp::eqaddr(self.WHAT,Mix),
          mix(),
          nqp::create(self)
        )
    }

#--- selection methods
    multi method grab($count? --> Real:D) {
        X::Immutable.new( method => 'grab', typename => self.^name ).throw;
    }
    multi method grabpairs($count? --> Real:D) {
        X::Immutable.new( method => 'grabpairs', typename => self.^name ).throw;
    }

#--- coercion methods
    multi method Mix(Mix:D:) { self }
    multi method MixHash(Mix:D) {
        nqp::if(
          $!elems && nqp::elems($!elems),
          nqp::create(MixHash).SET-SELF(Rakudo::QuantHash.BAGGY-CLONE($!elems)),
          nqp::create(MixHash)
        )
    }
    method clone() {
        nqp::if(
          $!elems && nqp::elems($!elems),
          nqp::clone(self),
          mix()
        )
    }

#--- illegal methods
    proto method classify-list(|) {
        X::Immutable.new(:method<classify-list>, :typename(self.^name)).throw;
    }
    proto method categorize-list(|) {
        X::Immutable.new(:method<categorize-list>, :typename(self.^name)).throw;
    }
}

#line 1 SETTING::src/core/MixHash.pm
my class MixHash does Mixy {

#--- interface methods
    method total() { Rakudo::QuantHash.MIX-TOTAL($!elems) }
    method !total-positive() { Rakudo::QuantHash.MIX-TOTAL-POSITIVE($!elems) }

    multi method AT-KEY(MixHash:D: \k) is raw {
        Proxy.new(
          FETCH => {
              nqp::if(
                $!elems && nqp::existskey($!elems,(my $which := k.WHICH)),
                nqp::getattr(nqp::atkey($!elems,$which),Pair,'$!value'),
                0
              )
          },
          STORE => -> $, Real() $value {
              nqp::if(
                nqp::istype($value,Failure),   # RT 128927
                $value.throw,
                nqp::if(
                  $!elems,
                  nqp::if(                      # allocated hash
                    nqp::existskey($!elems,(my $which := k.WHICH)),
                    nqp::if(                    # existing element
                      $value == 0,
                      nqp::stmts(
                        nqp::deletekey($!elems,$which),
                        0
                      ),
                      nqp::bindattr(
                        nqp::atkey($!elems,$which),
                        Pair,
                        '$!value',
                        nqp::decont($value)
                      ),
                    ),
                    nqp::unless(
                      $value == 0,
                      nqp::bindkey($!elems,$which,Pair.new(k,nqp::decont($value)))
                    )
                  ),
                  nqp::unless(                  # no hash allocated yet
                    $value == 0,
                    nqp::bindkey(
                      nqp::bindattr(self,::?CLASS,'$!elems',
                        nqp::create(Rakudo::Internals::IterationSet)),
                      k.WHICH,
                      Pair.new(k,nqp::decont($value))
                    )
                  )
                )
              )
          }
        )
    }

#--- object creation methods
    multi method new(MixHash:_:) { nqp::create(self) }

#--- coercion methods
    multi method Mix(MixHash:D: :$view) {
        nqp::if(
          $!elems && nqp::elems($!elems),
          nqp::p6bindattrinvres(
            nqp::create(Mix),Mix,'$!elems',
            nqp::if($view,$!elems,$!elems.clone)
          ),
          mix()
        )
    }
    multi method MixHash(MixHash:D:) { self }
    method clone() {
        nqp::if(
          $!elems && nqp::elems($!elems),
          nqp::create(MixHash).SET-SELF(Rakudo::QuantHash.BAGGY-CLONE($!elems)),
          nqp::create(MixHash)
        )
    }

#--- iterator methods
    sub proxy(Mu \iter,Mu \storage) is raw {
        # We are only sure that the key exists when the Proxy
        # is made, but we cannot be sure of its existence when
        # either the FETCH or STORE block is executed.  So we
        # still need to check for existence, and handle the case
        # where we need to (re-create) the key and value.  The
        # logic is therefore basically the same as in AT-KEY,
        # except for tests for allocated storage and .WHICH
        # processing.
        nqp::stmts(
          (my $which := nqp::iterkey_s(iter)),
          # save for possible object recreation
          (my $object := nqp::getattr(nqp::iterval(iter),Pair,'$!key')),

          Proxy.new(
            FETCH => {
                nqp::if(
                  nqp::existskey(storage,$which),
                  nqp::getattr(nqp::atkey(storage,$which),Pair,'$!value'),
                  0
                )
            },
            STORE => -> $, Real() $value {
                nqp::if(
                  nqp::istype($value,Failure),  # RT 128927
                  $value.throw,
                  nqp::if(
                    nqp::existskey(storage,$which),
                    nqp::if(                    # existing element
                      $value == 0,
                      nqp::stmts(               # goodbye!
                        nqp::deletekey(storage,$which),
                        0
                      ),
                      nqp::bindattr(            # value ok
                        nqp::atkey(storage,$which),
                        Pair,
                        '$!value',
                        nqp::decont($value)
                      )
                    ),
                    nqp::unless(                # where did it go?
                      $value == 0,
                      nqp::bindkey(
                        storage,
                        $which,
                        Pair.new($object,nqp::decont($value))
                      )
                    )
                  )
                )
            }
          )
        )
    }

    multi method iterator(MixHash:D:) {    # also .pairs
        class :: does Rakudo::Iterator::Mappy {
            method pull-one() is raw {
                nqp::if(
                  $!iter,
                  nqp::p6bindattrinvres(
                    nqp::clone(nqp::iterval(nqp::shift($!iter))),
                    Pair,
                    '$!value',
                    proxy($!iter,$!hash)
                  ),
                  IterationEnd
                )
            }
            method push-all($target --> IterationEnd) {
                nqp::while(  # doesn't sink
                  $!iter,
                  $target.push(nqp::iterval(nqp::shift($!iter)))
                )
            }
        }.new($!elems)
    }

    multi method values(MixHash:D:) {
        Seq.new(class :: does Rakudo::Iterator::Mappy {
            method pull-one() is raw {
                nqp::if(
                  $!iter,
                  proxy(nqp::shift($!iter),$!hash),
                  IterationEnd
                )
            }

            # same as Baggy.values
            method push-all($target --> IterationEnd) {
                nqp::while(  # doesn't sink
                  $!iter,
                  $target.push(nqp::getattr(
                    nqp::iterval(nqp::shift($!iter)),Pair,'$!value'))
                )
            }
        }.new($!elems))
    }

    multi method kv(MixHash:D:) {
        Seq.new(class :: does Rakudo::Iterator::Mappy-kv-from-pairs {
            method pull-one() is raw {
                nqp::if(
                  $!on,
                  nqp::stmts(
                    ($!on = 0),
                    proxy($!iter,$!hash)
                  ),
                  nqp::if(
                    $!iter,
                    nqp::stmts(
                      ($!on = 1),
                      nqp::getattr(
                        nqp::iterval(nqp::shift($!iter)),Pair,'$!key')
                    ),
                    IterationEnd
                  )
                )
            }
        }.new($!elems))
    }
}

#line 1 SETTING::src/core/set_operators.pm
proto sub set(|) { * }
multi sub set() { BEGIN nqp::create(Set) }
multi sub set(*@a --> Set:D) { Set.new(@a) }

proto sub bag(|) { * }
multi sub bag() { BEGIN nqp::create(Bag) }
multi sub bag(*@a --> Bag:D) { Bag.new(@a) }

proto sub mix(|) { * }
multi sub mix() { BEGIN nqp::create(Mix) }
multi sub mix(*@a --> Mix:D) { Mix.new(@a) }

#line 1 SETTING::src/core/set_elem.pm
# This file implements the following set operators:
#   (elem)  is an element of (ASCII)
#          is an element of
#          is NOT an element of
#   (cont)  contains (ASCII)
#          contains
#          does NOT contain

proto sub infix:<(elem)>($, $ --> Bool:D) is pure {*}
multi sub infix:<(elem)>(Str:D $a, Map:D $b --> Bool:D) {
    nqp::p6bool(
      (my $storage := nqp::getattr(nqp::decont($b),Map,'$!storage'))
        && nqp::elems($storage)
        && nqp::if(
             nqp::eqaddr($b.keyof,Str(Any)),
             nqp::atkey($storage,$a),                     # normal hash
             nqp::getattr(                                # object hash
               nqp::ifnull(
                 nqp::atkey($storage,$a.WHICH),
                 BEGIN   # provide virtual value False    # did not exist
                   nqp::p6bindattrinvres(nqp::create(Pair),Pair,'$!value',False)
               ),
               Pair,
              '$!value'
             )
           )
    )
}
multi sub infix:<(elem)>(Any $a, Map:D $b --> Bool:D) {
    nqp::p6bool(
      (my $storage := nqp::getattr(nqp::decont($b),Map,'$!storage'))
        && nqp::elems($storage)                         # haz a haystack
        && nqp::not_i(nqp::eqaddr($b.keyof,Str(Any)))   # is object hash
        && nqp::getattr(
             nqp::ifnull(
               nqp::atkey($storage,$a.WHICH),           # exists
               BEGIN   # provide virtual value False    # did not exist
                 nqp::p6bindattrinvres(nqp::create(Pair),Pair,'$!value',False)
             ),
             Pair,
             '$!value'
           )
    )
}
multi sub infix:<(elem)>(Any $a, Iterable:D $b --> Bool:D) {
    nqp::if(
      (my $iterator := $b.iterator).is-lazy,
      Failure.new(X::Cannot::Lazy.new(:action<(elem)>)),
      nqp::stmts(
        (my str $needle = $a.WHICH),
        nqp::until(
          nqp::eqaddr((my $pulled := $iterator.pull-one),IterationEnd),
          nqp::if(
            nqp::iseq_s($needle,$pulled.WHICH),
            return True
          )
        ),
        False
      )
    )
}
multi sub infix:<(elem)>(Any $a, QuantHash:D $b --> Bool:D) {
    nqp::p6bool(
      (my $elems := $b.RAW-HASH) && nqp::existskey($elems,$a.WHICH)
    )
}

multi sub infix:<(elem)>(Any $, Failure:D $b) { $b.throw }
multi sub infix:<(elem)>(Failure:D $a, Any $) { $a.throw }
multi sub infix:<(elem)>(Any $a, Any $b) { infix:<(elem)>($a,$b.Set) }

# U+2208 ELEMENT OF
my constant &infix:<> := &infix:<(elem)>;

# U+2209 NOT AN ELEMENT OF
only sub infix:<>($a, $b --> Bool:D) is pure {
    not $a (elem) $b;
}

only sub infix:<(cont)>($a, $b --> Bool:D) is pure { $b (elem) $a }

# U+220B CONTAINS AS MEMBER
only sub infix:<>($a, $b --> Bool:D) is pure {
    $b (elem) $a;
}
# U+220C DOES NOT CONTAIN AS MEMBER
only sub infix:<>($a, $b --> Bool:D) is pure {
    not $b (elem) $a;
}

#line 1 SETTING::src/core/set_union.pm
# This file implements the following set operators:
#   (|)     union (ASCII)
#          union

proto sub infix:<(|)>(|) is pure { * }
multi sub infix:<(|)>()               { set()  }
multi sub infix:<(|)>(QuantHash:D $a) { $a     } # Set/Bag/Mix
multi sub infix:<(|)>(SetHash:D $a)   { $a.Set }
multi sub infix:<(|)>(BagHash:D $a)   { $a.Bag }
multi sub infix:<(|)>(MixHash:D $a)   { $a.Mix }
multi sub infix:<(|)>(Any $a)         { $a.Set } # also for Iterable/Map

multi sub infix:<(|)>(Setty:D $a, Setty:D $b) {
    nqp::if(
      (my $araw := $a.RAW-HASH) && nqp::elems($araw),
      nqp::if(                                    # first has elems
        (my $braw := $b.RAW-HASH) && nqp::elems($braw),
        nqp::stmts(                               # second has elems
          (my $elems := nqp::clone($araw)),
          (my $iter := nqp::iterator($braw)),
          nqp::while(                             # loop over keys of second
            $iter,
            nqp::bindkey(                         # bind into clone of first
              $elems,
              nqp::iterkey_s(nqp::shift($iter)),
              nqp::iterval($iter)
            )
          ),
          nqp::create(Set).SET-SELF($elems)       # make it a Set
        ),
        $a.Set                                    # no second, so first
      ),
      nqp::if(                                    # no first
        ($braw := $b.RAW-HASH) && nqp::elems($braw),
        $b.Set,                                   # but second
        set()                                     # both empty
      )
    )
}
multi sub infix:<(|)>(Setty:D $a, Mixy:D  $b) { $a.Mix (|) $b }
multi sub infix:<(|)>(Setty:D $a, Baggy:D $b) { $a.Bag (|) $b }

multi sub infix:<(|)>(Mixy:D $a, Mixy:D $b) {
    nqp::if(
      (my $araw := $a.RAW-HASH) && nqp::elems($araw),
      nqp::if(                                    # first has elems
        (my $braw := $b.RAW-HASH) && nqp::elems($braw),
        nqp::stmts(                               # second has elems
          (my $elems := nqp::clone($araw)),
          (my $iter := nqp::iterator($braw)),
          nqp::while(                             # loop over keys of second
            $iter,
            nqp::if(
              nqp::existskey(
                $araw,
                (my $key := nqp::iterkey_s(nqp::shift($iter)))
              ),
              nqp::if(   # must use HLL < because values can be bignums
                nqp::getattr(
                  nqp::decont(nqp::atkey($araw,$key)),Pair,'$!value')
                < nqp::getattr(
                    nqp::decont(nqp::atkey($braw,$key)),Pair,'$!value'),
                nqp::bindkey($elems,$key,nqp::atkey($braw,$key))
              ),
              nqp::bindkey($elems,$key,nqp::atkey($braw,$key))
            )
          ),
          nqp::create(Mix).SET-SELF($elems)       # make it a Mix
        ),
        $a.Mix                                    # no second, so first
      ),
      nqp::if(                                    # no first
        ($braw := $b.RAW-HASH) && nqp::elems($braw),
        $b.Mix,                                   # but second
        mix()                                     # both empty
      )
    )
}

multi sub infix:<(|)>(Mixy:D $a, Baggy:D $b) { $a (|) $b.Mix }
multi sub infix:<(|)>(Mixy:D $a, Setty:D $b) { $a (|) $b.Mix }

multi sub infix:<(|)>(Baggy:D $a, Mixy:D $b) { $a.Mix (|) $b }
multi sub infix:<(|)>(Baggy:D $a, Baggy:D $b) {
    nqp::if(
      (my $araw := $a.RAW-HASH) && nqp::elems($araw),
      nqp::if(                                    # first has elems
        (my $braw := $b.RAW-HASH) && nqp::elems($braw),
        nqp::stmts(                               # second has elems
          (my $elems := nqp::clone($araw)),
          (my $iter := nqp::iterator($braw)),
          nqp::while(                             # loop over keys of second
            $iter,
            nqp::if(
              nqp::existskey(
                $araw,
                (my $key := nqp::iterkey_s(nqp::shift($iter)))
              ),
              nqp::if(
                nqp::islt_i(
                  nqp::getattr(
                    nqp::decont(nqp::atkey($araw,$key)),Pair,'$!value'),
                  nqp::getattr(
                    nqp::decont(nqp::atkey($braw,$key)),Pair,'$!value')
                ),
                nqp::bindkey($elems,$key,nqp::atkey($braw,$key))
              ),
              nqp::bindkey($elems,$key,nqp::atkey($braw,$key))
            )
          ),
          nqp::create(Bag).SET-SELF($elems)       # make it a Bag
        ),
        $a.Bag                                    # no second, so first
      ),
      nqp::if(                                    # no first
        ($braw := $b.RAW-HASH) && nqp::elems($braw),
        $b.Bag,                                   # but second
        bag()                                     # both empty
      )
    )
}
multi sub infix:<(|)>(Baggy:D $a, Setty:D $b) { $a (|) $b.Bag }

multi sub infix:<(|)>(Map:D $a, Map:D $b) {
    nqp::create(Set).SET-SELF(
      Rakudo::QuantHash.ADD-MAP-TO-SET(
        Rakudo::QuantHash.COERCE-MAP-TO-SET($a),
        $b
      )
    )
}

multi sub infix:<(|)>(Iterable:D $a, Iterable:D $b) {
    nqp::if(
      (my $aiterator := $a.flat.iterator).is-lazy
        || (my $biterator := $b.flat.iterator).is-lazy,
      Failure.new(X::Cannot::Lazy.new(:action<union>,:what<set>)),
      nqp::create(Set).SET-SELF(
        Rakudo::QuantHash.ADD-PAIRS-TO-SET(
          Rakudo::QuantHash.ADD-PAIRS-TO-SET(
            nqp::create(Rakudo::Internals::IterationSet),
            $aiterator
          ),
          $biterator
        )
      )
    )
}

multi sub infix:<(|)>(Failure:D $a, Any $b) { $a.throw }
multi sub infix:<(|)>(Any $a, Failure:D $b) { $b.throw }
multi sub infix:<(|)>(Any $a, Any $b) {
    nqp::if(
      nqp::istype($a,Mixy) || nqp::istype($b,Mixy),
      infix:<(|)>($a.Mix, $b.Mix),
      nqp::if(
        nqp::istype($a,Baggy) || nqp::istype($b,Baggy),
        infix:<(|)>($a.Bag, $b.Bag),
        infix:<(|)>($a.Set, $b.Set)
      )
    )
}

multi sub infix:<(|)>(**@p) {
    my $result = @p.shift;
    $result = $result (|) @p.shift while @p;
    $result
}

# U+222A UNION
my constant &infix:<> := &infix:<(|)>;

#line 1 SETTING::src/core/set_intersection.pm
# This file implements the following set operators:
#   (&)     intersection (ASCII)
#          intersection

proto sub infix:<(&)>(|) is pure { * }
multi sub infix:<(&)>()               { set()  }
multi sub infix:<(&)>(QuantHash:D $a) { $a     } # Set/Bag/Mix
multi sub infix:<(&)>(SetHash:D $a)   { $a.Set }
multi sub infix:<(&)>(BagHash:D $a)   { $a.Bag }
multi sub infix:<(&)>(MixHash:D $a)   { $a.Mix }
multi sub infix:<(&)>(Any $a)         { $a.Set } # also for Iterable/Map

multi sub infix:<(&)>(Setty:D $a, Setty:D $b) {
    nqp::if(
      (my $araw := $a.RAW-HASH) && nqp::elems($araw)
        && (my $braw := $b.RAW-HASH) && nqp::elems($braw),
      nqp::stmts(                              # both have elems
        nqp::if(
          nqp::islt_i(nqp::elems($araw),nqp::elems($braw)),
          nqp::stmts(                          # $a smallest, iterate over it
            (my $iter := nqp::iterator($araw)),
            (my $base := $braw)
          ),
          nqp::stmts(                          # $b smallest, iterate over that
            ($iter := nqp::iterator($braw)),
            ($base := $araw)
          )
        ),
        (my $elems := nqp::create(Rakudo::Internals::IterationSet)),
        nqp::while(
          $iter,
          nqp::if(                             # bind if in both
            nqp::existskey($base,nqp::iterkey_s(nqp::shift($iter))),
            nqp::bindkey($elems,nqp::iterkey_s($iter),nqp::iterval($iter))
          )
        ),
        nqp::create(Set).SET-SELF($elems)
      ),
      set()                                    # one/neither has elems
    )
}
multi sub infix:<(&)>(Setty:D $a, Baggy:D $b) {
    Rakudo::QuantHash.INTERSECT-BAGGIES($a.Bag, $b, bag())
}
multi sub infix:<(&)>(Baggy:D $a, Setty:D $b) {
    Rakudo::QuantHash.INTERSECT-BAGGIES($a, $b.Bag, bag())
}
multi sub infix:<(&)>(Setty:D $a, Mixy:D $b) {
    Rakudo::QuantHash.INTERSECT-BAGGIES($a.Mix, $b, mix())
}
multi sub infix:<(&)>(Mixy:D $a, Setty:D $b) {
    Rakudo::QuantHash.INTERSECT-BAGGIES($a, $b.Mix, mix())
}
multi sub infix:<(&)>(Baggy:D $a, Baggy:D $b) {
    Rakudo::QuantHash.INTERSECT-BAGGIES($a, $b, bag())
}
multi sub infix:<(&)>(Mixy:D $a, Baggy:D $b) {
    Rakudo::QuantHash.INTERSECT-BAGGIES($a, $b, mix())
}
multi sub infix:<(&)>(Baggy:D $a, Mixy:D $b) {
    Rakudo::QuantHash.INTERSECT-BAGGIES($a, $b, mix())
}
multi sub infix:<(&)>(Mixy:D $a, Mixy:D $b) {
    Rakudo::QuantHash.INTERSECT-BAGGIES($a, $b, mix())
}
multi sub infix:<(&)>(Baggy:D $a, Any:D $b) {
    nqp::if(
      nqp::istype((my $bbag := $b.Bag),Bag),
      Rakudo::QuantHash.INTERSECT-BAGGIES($a, $bbag, bag()),
      $bbag.throw
    )
}
multi sub infix:<(&)>(Any:D $a, Baggy:D $b) {
    infix:<(&)>($b, $a)
}
multi sub infix:<(&)>(Mixy:D $a, Any:D $b) {
    nqp::if(
      nqp::istype((my $bmix := $b.Mix),Mix),
      Rakudo::QuantHash.INTERSECT-BAGGIES($a, $bmix, mix()),
      $bmix.throw
    )
}
multi sub infix:<(&)>(Any:D $a, Mixy:D $b) {
    infix:<(&)>($b, $a)
}

multi sub infix:<(&)>(Map:D $a, Map:D $b) {
    nqp::if(
      nqp::eqaddr($a.keyof,Str(Any)) && nqp::eqaddr($b.keyof,Str(Any)),
      nqp::if(                               # both ordinary Str hashes
        (my $araw := nqp::getattr(nqp::decont($a),Map,'$!storage'))
          && nqp::elems($araw)
          && (my $braw := nqp::getattr(nqp::decont($b),Map,'$!storage'))
          && nqp::elems($braw),
        nqp::stmts(                          # both are initialized
          nqp::if(
            nqp::islt_i(nqp::elems($araw),nqp::elems($braw)),
            nqp::stmts(                      # $a smallest, iterate over it
              (my $iter := nqp::iterator($araw)),
              (my $base := $braw)
            ),
            nqp::stmts(                      # $b smallest, iterate over that
              ($iter := nqp::iterator($braw)),
              ($base := $araw)
            )
          ),
          (my $elems := nqp::create(Rakudo::Internals::IterationSet)),
          nqp::while(
            $iter,
            nqp::if(                         # create if in both
              nqp::existskey(
                $base,
                nqp::iterkey_s(nqp::shift($iter))
              ),
              nqp::bindkey(
                $elems,nqp::iterkey_s($iter).WHICH,nqp::iterkey_s($iter))
            )
          ),
          nqp::create(Set).SET-SELF($elems)
        ),
        set()                                # one/neither has elems
      ),
      infix:<(&)>($a.Set, $b.Set)            # object hash(es), coerce!
    )
}

multi sub infix:<(&)>(Any $, Failure:D $b) { $b.throw }
multi sub infix:<(&)>(Failure:D $a, Any $) { $a.throw }
multi sub infix:<(&)>(Any $a, Any $b) { infix:<(&)>($a.Set,$b.Set) }

multi sub infix:<(&)>(**@p) {
    my $result = @p.shift;
    $result = $result (&) @p.shift while @p;
    $result
}

# U+2229 INTERSECTION
my constant &infix:<> := &infix:<(&)>;

#line 1 SETTING::src/core/set_difference.pm
# This file implements the following set operators:
#   (-)     set difference (ASCII)
#          set difference

proto sub infix:<(-)>(|) is pure { * }
multi sub infix:<(-)>()               { set()  }
multi sub infix:<(-)>(QuantHash:D $a) { $a     } # Set/Bag/Mix
multi sub infix:<(-)>(SetHash:D $a)   { $a.Set }
multi sub infix:<(-)>(BagHash:D $a)   { $a.Bag }
multi sub infix:<(-)>(MixHash:D $a)   { $a.Mix }
multi sub infix:<(-)>(Any $a)         { $a.Set } # also for Iterable/Map

multi sub infix:<(-)>(Setty:D $a, Setty:D $b) {
    nqp::if(
      (my $araw := $a.RAW-HASH) && nqp::elems($araw),
      nqp::if(                                 # elems in $a
        (my $braw := $b.RAW-HASH) && nqp::elems($braw),
        nqp::create(Set).SET-SELF(             # both have elems
          Rakudo::QuantHash.SUB-SET-FROM-SET($araw, $braw)
        ),
        $a.Set,                                # no elems in $b
      ),
      set()                                    # no elems in $a
    )
}
multi sub infix:<(-)>(Setty:D $a, Map:D $b) {
    nqp::if(
      (my $araw := $a.RAW-HASH) && nqp::elems($araw),
      nqp::create(Set).SET-SELF(                          # elems in $a
        nqp::if(
          (my $braw := nqp::getattr(nqp::decont($b),Map,'$!storage'))
            && nqp::elems($braw),
          Rakudo::QuantHash.SUB-MAP-FROM-SET($araw, $b),  # both have elems
          nqp::clone($araw)                               # no elems in $b
        )
      ),
      set()                                               # no elems in $a
    )
}
multi sub infix:<(-)>(Setty:D $a, Iterable:D $b) {
    nqp::if(
      (my $iterator := $b.iterator).is-lazy,
      Failure.new(X::Cannot::Lazy.new(:action('difference'),:what<set>)),
      nqp::if(
        (my $raw := $a.RAW-HASH) && nqp::elems($raw),
        nqp::create(Set).SET-SELF(
          Rakudo::QuantHash.SUB-PAIRS-FROM-SET($raw, $iterator)
        ),
        set()
      )
    )
}
multi sub infix:<(-)>(Mixy:D $a, Mixy:D $b) {    # needed as tie-breaker
    Rakudo::QuantHash.DIFFERENCE-MIXY-QUANTHASH($a, $b)
}
multi sub infix:<(-)>(Mixy:D $a, QuantHash:D $b) {
    Rakudo::QuantHash.DIFFERENCE-MIXY-QUANTHASH($a, $b)
}
multi sub infix:<(-)>(QuantHash:D $a, Mixy:D $b) {
    Rakudo::QuantHash.DIFFERENCE-MIXY-QUANTHASH($a.Mix, $b)
}
multi sub infix:<(-)>(Mixy:D $a, Map:D $b) {
    Rakudo::QuantHash.DIFFERENCE-MIXY-QUANTHASH($a, $b.Set)
}
multi sub infix:<(-)>(Mixy:D $a, Any:D $b) {     # also Iterable
    Rakudo::QuantHash.DIFFERENCE-MIXY-QUANTHASH($a, $b.Set)
}
multi sub infix:<(-)>(Any:D $a, Mixy:D $b) {
    Rakudo::QuantHash.DIFFERENCE-MIXY-QUANTHASH($a.Mix, $b)
}
multi sub infix:<(-)>(Baggy:D $a, Mixy:D $b) {   # needed as tie-breaker
    Rakudo::QuantHash.DIFFERENCE-MIXY-QUANTHASH($a.Mix, $b)
}
multi sub infix:<(-)>(Baggy:D $a, Baggy:D $b) {  # needed as tie-breaker
    Rakudo::QuantHash.DIFFERENCE-BAGGY-QUANTHASH($a, $b)
}
multi sub infix:<(-)>(Baggy:D $a, QuantHash:D $b) {
    Rakudo::QuantHash.DIFFERENCE-BAGGY-QUANTHASH($a, $b)
}
multi sub infix:<(-)>(QuantHash:D $a, Baggy:D $b) {
    Rakudo::QuantHash.DIFFERENCE-BAGGY-QUANTHASH($a.Bag, $b)
}
multi sub infix:<(-)>(Baggy:D $a, Map:D $b) {
    Rakudo::QuantHash.DIFFERENCE-BAGGY-QUANTHASH($a, $b.Set)
}
multi sub infix:<(-)>(Baggy:D $a, Any:D $b) {    # also Iterable
    Rakudo::QuantHash.DIFFERENCE-BAGGY-QUANTHASH($a, $b.Set)
}
multi sub infix:<(-)>(Any $a, Baggy:D $b) {
    Rakudo::QuantHash.DIFFERENCE-BAGGY-QUANTHASH($a.Bag, $b)
}
multi sub infix:<(-)>(Any $a, Map:D $b)      { infix:<(-)>($a.Set, $b) }
multi sub infix:<(-)>(Any $a, Iterable:D $b) { infix:<(-)>($a.Set, $b) }

multi sub infix:<(-)>(Any $, Failure:D $b) { $b.throw }
multi sub infix:<(-)>(Failure:D $a, Any $) { $a.throw }
multi sub infix:<(-)>(Any $a, Any $b) { infix:<(-)>($a.Set,$b.Set) }

multi sub infix:<(-)>(**@p) {

    sub subtract(Mu \elems, Mu \iter, \clone, \value --> Nil) {
        nqp::stmts(
          (my $pair := nqp::ifnull(
            nqp::atkey(elems, nqp::iterkey_s(iter)),
            nqp::bindkey(
              elems,
              nqp::iterkey_s(iter),
              nqp::if(
                clone,
                nqp::p6bindattrinvres(
                  nqp::clone(nqp::iterval(iter)),
                  Pair,
                  '$!value',
                  0
                ),
                Pair.new(nqp::iterval(iter),0)
              )
            )
          )),
          nqp::bindattr($pair,Pair,'$!value',
            nqp::getattr($pair,Pair,'$!value') - value
          )
        )
    }

    nqp::if(
      (my $params := @p.iterator).is-lazy,
      Failure.new(X::Cannot::Lazy.new(:action('difference'))),  # bye bye

      nqp::stmts(                                # fixed list of things to diff
        (my $type := nqp::if(
          nqp::istype((my $p := $params.pull-one),Mixy),
          Mix,
          nqp::if(nqp::istype($p,Baggy),Bag,Set)
        )),
        (my $elems := nqp::if(
          nqp::istype($p,Baggy),
          nqp::if(                               # already have a Baggy, clone
            (my $raw := $p.RAW-HASH),
            Rakudo::QuantHash.BAGGY-CLONE($raw),
            nqp::create(Rakudo::Internals::IterationSet)
          ),
          nqp::unless(                           # something else, Mix it!
            $p.Mix.RAW-HASH,
            nqp::create(Rakudo::Internals::IterationSet)
          )
        )),

        nqp::until(
          nqp::eqaddr(($p := $params.pull-one),IterationEnd),

          nqp::if(                               # not done parsing
            nqp::istype($p,Baggy),

            nqp::stmts(                          # Mixy/Baggy semantics apply
              nqp::unless(                       # upgrade type if needed
                nqp::istype($type,Mix),
                ($type := nqp::if(nqp::istype($p,Mixy),Mix,Bag))
              ),
              nqp::if(
                ($raw := $p.RAW-HASH) && (my $iter := nqp::iterator($raw)),
                nqp::while(                      # something to process
                  $iter,
                  subtract(
                    $elems,
                    nqp::shift($iter),
                    1,
                    nqp::getattr(nqp::iterval($iter),Pair,'$!value')
                  )
                )
              )
            ),

            nqp::stmts(                          # not a Baggy/Mixy, assume Set
              ($raw := nqp::if(nqp::istype($p,Setty),$p,$p.Set).RAW-HASH)
                && ($iter := nqp::iterator($raw)),
              nqp::while(                        # something to process
                $iter,
                subtract($elems, nqp::shift($iter), 0, 1)
              )
            )
          )
        ),

        ($iter := nqp::iterator($elems)),        # start post-processing
        nqp::if(
          nqp::istype($type,Set),
          nqp::while(                            # need to create a Set
            $iter,
            nqp::if(
              nqp::getattr(nqp::iterval(nqp::shift($iter)),Pair,'$!value') > 0,
              nqp::bindkey(
                $elems,
                nqp::iterkey_s($iter),
                nqp::getattr(nqp::iterval($iter),Pair,'$!key')
              ),
              nqp::deletekey($elems,nqp::iterkey_s($iter))
            )
          ),
          nqp::if(
            nqp::istype($type,Mix),
            nqp::while(                          # convert to Mix semantics
              $iter,
              nqp::unless(
                nqp::getattr(nqp::iterval(nqp::shift($iter)),Pair,'$!value'),
                nqp::deletekey($elems,nqp::iterkey_s($iter))  # not valid in Mix
              )
            ),
            nqp::while(                          # convert to Bag semantics
              $iter,
              nqp::unless(
                nqp::getattr(nqp::iterval(nqp::shift($iter)),Pair,'$!value') >0,
                nqp::deletekey($elems,nqp::iterkey_s($iter))  # not valid in Bag
              )
            )
          )
        ),
        nqp::create($type).SET-SELF($elems)
      )
    )
}

# U+2216 SET MINUS
my constant &infix:<> := &infix:<(-)>;

#line 1 SETTING::src/core/set_symmetric_difference.pm
# This test file tests the following set operators:
#   (^)     set symmetric difference (Texas)
#          set symmetric difference

proto sub infix:<(^)>(|) is pure { * }
multi sub infix:<(^)>()               { set()  }
multi sub infix:<(^)>(QuantHash:D $a) { $a     } # Set/Bag/Mix
multi sub infix:<(^)>(SetHash:D $a)   { $a.Set }
multi sub infix:<(^)>(BagHash:D $a)   { $a.Bag }
multi sub infix:<(^)>(MixHash:D $a)   { $a.Mix }
multi sub infix:<(^)>(Any $a)         { $a.Set } # also for Iterable/Map

multi sub infix:<(^)>(Setty:D $a, Setty:D $b) {
    nqp::if(
      (my $araw := $a.RAW-HASH) && nqp::elems($araw),
      nqp::if(
        (my $braw := $b.RAW-HASH) && nqp::elems($braw),
        nqp::stmts(                            # both are initialized
          nqp::if(
            nqp::islt_i(nqp::elems($araw),nqp::elems($braw)),
            nqp::stmts(                        # $a smallest, iterate over it
              (my $iter  := nqp::iterator($araw)),
              (my $elems := nqp::clone($braw))
            ),
            nqp::stmts(                        # $b smallest, iterate over that
              ($iter  := nqp::iterator($braw)),
              ($elems := nqp::clone($araw))
            )
          ),
          nqp::while(
            $iter,
            nqp::if(                           # remove if in both
              nqp::existskey($elems,nqp::iterkey_s(nqp::shift($iter))),
              nqp::deletekey($elems,nqp::iterkey_s($iter)),
              nqp::bindkey($elems,nqp::iterkey_s($iter),nqp::iterval($iter))
            )
          ),
          nqp::create(Set).SET-SELF($elems)
        ),
        nqp::if(nqp::istype($a,Set),$a,$a.Set) # $b empty, so $a
      ),
      nqp::if(nqp::istype($b,Set),$b,$b.Set)   # $a empty, so $b
    )
}
multi sub infix:<(^)>(Setty:D $a, Mixy:D  $b) { $a.Mix (^) $b }
multi sub infix:<(^)>(Setty:D $a, Baggy:D $b) { $a.Bag (^) $b }

multi sub infix:<(^)>(Mixy:D $a, Mixy:D $b) {
    nqp::if(
      (my $araw := $a.RAW-HASH) && nqp::elems($araw),
      nqp::if(
        (my $braw := $b.RAW-HASH) && nqp::elems($braw),
        nqp::stmts(                            # both are initialized
          nqp::if(
            nqp::islt_i(nqp::elems($araw),nqp::elems($braw)),
            nqp::stmts(                        # $a smallest, iterate over it
              (my $iter  := nqp::iterator(my $base := $araw)),
              (my $elems := nqp::clone($braw))
            ),
            nqp::stmts(                        # $b smallest, iterate over that
              ($iter  := nqp::iterator($base := $braw)),
              ($elems := nqp::clone($araw))
            )
          ),
          nqp::while(
            $iter,
            nqp::if(
              nqp::existskey($elems,nqp::iterkey_s(nqp::shift($iter))),
              nqp::if(
                (my $diff := nqp::getattr(nqp::iterval($iter),Pair,'$!value')
                  - nqp::getattr(
                      nqp::atkey($elems,nqp::iterkey_s($iter)),
                      Pair,
                      '$!value'
                    )
                ),
                nqp::bindkey(
                  $elems,
                  nqp::iterkey_s($iter),
                  nqp::p6bindattrinvres(
                    nqp::clone(nqp::iterval($iter)),Pair,'$!value',abs($diff)
                  )
                ),
                nqp::deletekey($elems,nqp::iterkey_s($iter))
              ),
              nqp::bindkey(
                $elems,
                nqp::iterkey_s($iter),
                nqp::clone(nqp::iterval($iter))
              )
            )
          ),
          nqp::create(Mix).SET-SELF($elems)
        ),
        nqp::create(Mix).SET-SELF(             # $b empty, so $a
          Rakudo::QuantHash.MIX-CLONE-ALL-POSITIVE($araw)
        )
      ),
      nqp::if(
        ($braw := $b.RAW-HASH) && nqp::elems($braw),
        nqp::create(Mix).SET-SELF(             # $a empty, so $b
          Rakudo::QuantHash.MIX-CLONE-ALL-POSITIVE($braw)
        ),
        mix()
      )
    )
}
multi sub infix:<(^)>(Mixy:D $a, Baggy:D $b) { $a (^) $b.Mix }
multi sub infix:<(^)>(Mixy:D $a, Setty:D $b) { $a (^) $b.Mix }

multi sub infix:<(^)>(Baggy:D $a, Mixy:D $b) { $a.Mix (^) $b }
multi sub infix:<(^)>(Baggy:D $a, Baggy:D $b) {
    nqp::if(
      (my $araw := $a.RAW-HASH) && nqp::elems($araw),
      nqp::if(
        (my $braw := $b.RAW-HASH) && nqp::elems($braw),
        nqp::stmts(                            # both are initialized
          nqp::if(
            nqp::islt_i(nqp::elems($araw),nqp::elems($braw)),
            nqp::stmts(                        # $a smallest, iterate over it
              (my $iter  := nqp::iterator(my $base := $araw)),
              (my $elems := nqp::clone($braw))
            ),
            nqp::stmts(                        # $b smallest, iterate over that
              ($iter  := nqp::iterator($base := $braw)),
              ($elems := nqp::clone($araw))
            )
          ),
          nqp::while(
            $iter,
            nqp::if(                           # remove if in both
              nqp::existskey($elems,nqp::iterkey_s(nqp::shift($iter))),
              nqp::if(
                (my int $diff = nqp::sub_i(
                  nqp::getattr(nqp::iterval($iter),Pair,'$!value'),
                  nqp::getattr(
                    nqp::atkey($elems,nqp::iterkey_s($iter)),
                    Pair,
                    '$!value'
                  )
                )),
                nqp::bindkey(
                  $elems,
                  nqp::iterkey_s($iter),
                  nqp::p6bindattrinvres(
                    nqp::clone(nqp::iterval($iter)),
                    Pair,
                    '$!value',
                    nqp::abs_i($diff)
                  )
                ),
                nqp::deletekey($elems,nqp::iterkey_s($iter))
              ),
              nqp::bindkey($elems,nqp::iterkey_s($iter),nqp::iterval($iter))
            )
          ),
          nqp::create(Bag).SET-SELF($elems)
        ),
        nqp::if(nqp::istype($a,Bag),$a,$a.Bag) # $b empty, so $a
      ),
      nqp::if(nqp::istype($b,Bag),$b,$b.Bag)   # $a empty, so $b
    )
}
multi sub infix:<(^)>(Baggy:D $a, Setty:D $b) { $a (^) $b.Bag }

multi sub infix:<(^)>(Map:D $a, Map:D $b) {
    nqp::if(
      nqp::elems((my $elems := Rakudo::QuantHash.COERCE-MAP-TO-SET($a))),
      nqp::if(                                    # $a has elems
        (my $raw := nqp::getattr(nqp::decont($b),Map,'$!storage'))
          && (my $iter := nqp::iterator($raw)),
        nqp::stmts(
          nqp::if(                                # both have elems
            nqp::eqaddr($b.keyof,Str(Any)),
            nqp::while(                           # ordinary hash
              $iter,
              nqp::if(
                nqp::iterval(nqp::shift($iter)),
                nqp::if(                          # should be checked
                  nqp::existskey(
                    $elems,
                    (my $which := nqp::iterkey_s($iter).WHICH)
                  ),
                  nqp::deletekey($elems,$which),  # remove existing
                  nqp::bindkey($elems,$which,nqp::iterkey_s($iter)) # add new
                )
              )
            ),
            nqp::while(                           # object hash
              $iter,
              nqp::if(
                nqp::getattr(nqp::iterval(nqp::shift($iter)),Pair,'$!value'),
                nqp::if(                          # should be checked
                  nqp::existskey($elems,nqp::iterkey_s($iter)),
                  nqp::deletekey($elems,nqp::iterkey_s($iter)),# remove existing
                  nqp::bindkey(                   # add new
                    $elems,
                    nqp::iterkey_s($iter),
                    nqp::getattr(nqp::iterval($iter),Pair,'$!key')
                  )
                )
              )
            )
          ),
          nqp::create(Set).SET-SELF($elems)       # done
        ),
        nqp::create(Set).SET-SELF($elems)         # nothing right, so make left
      ),
      $b.Set                                      # nothing left, coerce right
    )
}

multi sub infix:<(^)>(Failure:D $a, Any $b) { $a.throw }
multi sub infix:<(^)>(Any $a, Failure:D $b) { $b.throw }
multi sub infix:<(^)>(Any $a, Any $b) {
    nqp::if(
      nqp::istype($a,Mixy) || nqp::istype($b,Mixy),
      infix:<(^)>($a.Mix, $b.Mix),
      nqp::if(
        nqp::istype($a,Baggy) || nqp::istype($b,Baggy),
        infix:<(^)>($a.Bag, $b.Bag),
        infix:<(^)>($a.Set, $b.Set)
      )
    )
}

multi sub infix:<(^)>(**@p) is pure {

    # positions / size in minmax info
    my constant COUNT   = 0;
    my constant LOWEST  = 1;
    my constant HIGHEST = 2;
    my constant SIZE    = 3;

    # basic minmax for new keys
    my $init-minmax := nqp::setelems(nqp::create(IterationBuffer),SIZE);
    nqp::bindpos($init-minmax,COUNT,1);

    # handle key that has been seen before for given value
    sub handle-existing(Mu \elems, Mu \iter, \value --> Nil) {
        nqp::stmts(
          (my $minmax := nqp::getattr(
            nqp::atkey(elems,nqp::iterkey_s(iter)),Pair,'$!value')
          ),
          nqp::bindpos($minmax,COUNT,nqp::add_i(nqp::atpos($minmax,COUNT),1)),
          nqp::if(
            value > nqp::atpos($minmax,HIGHEST),
            nqp::stmts(
              nqp::bindpos($minmax,LOWEST,nqp::atpos($minmax,HIGHEST)),
              nqp::bindpos($minmax,HIGHEST,value)
            ),
            nqp::if(
              nqp::not_i(nqp::defined(nqp::atpos($minmax,LOWEST)))
                || value > nqp::atpos($minmax,LOWEST),
              nqp::bindpos($minmax,LOWEST,value)
            )
          )
        )
    }

    # handle key that has not yet been seen
    sub handle-new(Mu \elems, Mu \iter, \pair, \value) {
        nqp::stmts(
          (my $minmax := nqp::clone($init-minmax)),
          nqp::bindpos($minmax,HIGHEST,value),
          nqp::bindkey(
            elems,
            nqp::iterkey_s(iter),
            nqp::p6bindattrinvres(pair,Pair,'$!value',$minmax)
          )
        )
    }

    nqp::if(
      (my $params := @p.iterator).is-lazy,
      Failure.new(X::Cannot::Lazy.new(:action('symmetric diff'))),  # bye bye

      nqp::stmts(                                # fixed list of things to diff
        (my $elems := nqp::create(Rakudo::Internals::IterationSet)),
        (my $type  := Set),
        (my int $pseen = 0),

        nqp::until(
          nqp::eqaddr((my $p := $params.pull-one),IterationEnd),

          nqp::stmts(                            # not done parsing
            ($pseen = nqp::add_i($pseen,1)),
            nqp::if(
              nqp::istype($p,Baggy),

              nqp::stmts(                        # Mixy/Baggy semantics apply
                nqp::unless(
                  nqp::istype($type,Mix),
                  ($type := nqp::if(nqp::istype($p,Mixy),Mix,Bag))
                ),
                nqp::if(
                  (my $raw := $p.RAW-HASH) && (my $iter := nqp::iterator($raw)),
                  nqp::stmts(                    # something to process
                    nqp::while(
                      $iter,
                      nqp::if(
                        nqp::existskey(
                          $elems,
                          nqp::iterkey_s(nqp::shift($iter))
                        ),
                        handle-existing(         # seen this element before
                          $elems,
                          $iter,
                          nqp::getattr(nqp::iterval($iter),Pair,'$!value')
                        ),
                        handle-new(              # new element
                          $elems,
                          $iter,
                          nqp::clone(nqp::iterval($iter)),
                          nqp::getattr(nqp::iterval($iter),Pair,'$!value')
                        )
                      )
                    )
                  )
                )
              ),

              nqp::stmts(                        # not a Baggy/Mixy, assume Set
                ($raw := nqp::if(nqp::istype($p,Setty),$p,$p.Set).RAW-HASH)
                  && ($iter := nqp::iterator($raw)),
                nqp::while(                      # something to process
                  $iter,
                  nqp::if(
                    nqp::existskey($elems,nqp::iterkey_s(nqp::shift($iter))),
                    handle-existing(             # seen this element before
                      $elems,
                      $iter,
                      nqp::istrue(nqp::iterval($iter))
                    ),
                    handle-new(                  # new element
                      $elems,
                      $iter,
                      nqp::p6bindattrinvres(
                        nqp::create(Pair),Pair,'$!key',nqp::iterval($iter)),
                      nqp::istrue(nqp::iterval($iter))
                    )
                  )
                )
              )
            )
          )
        ),

        ($iter := nqp::iterator($elems)),        # start post-processing
        nqp::if(
          nqp::istype($type,Set),
          nqp::while(                            # need to create a Set
            $iter,
            nqp::if(
              nqp::ifnull(
                nqp::atpos(
                  nqp::getattr(nqp::iterval(nqp::shift($iter)),Pair,'$!value'),
                  LOWEST
                ),
                0
              ) == 1,
              nqp::deletekey($elems,nqp::iterkey_s($iter)),    # seen > 1
              nqp::bindkey(                                    # only once
                $elems,                                        # convert to
                nqp::iterkey_s($iter),                         # Setty format
                nqp::getattr(nqp::iterval($iter),Pair,'$!key')
              )
            )
          ),
          nqp::if(
            nqp::istype($type,Mix),
            nqp::while(                          # convert to Mixy semantics
              $iter,
              nqp::stmts(
                (my $minmax :=
                  nqp::getattr(nqp::iterval(nqp::shift($iter)),Pair,'$!value')),
                nqp::if(
                  nqp::islt_i(nqp::atpos($minmax,COUNT),$pseen),
                  handle-existing($elems,$iter,0)  # absentee == value 0 seen
                ),
                nqp::if(
                  nqp::ifnull(nqp::atpos($minmax,LOWEST),0)
                   == nqp::atpos($minmax,HIGHEST),
                  nqp::deletekey($elems,nqp::iterkey_s($iter)),  # top 2 same
                  nqp::bindattr(                                 # there's a
                    nqp::iterval($iter),                         # difference
                    Pair,                                        # so convert
                    '$!value',
                    nqp::atpos($minmax,HIGHEST)
                      - nqp::ifnull(nqp::atpos($minmax,LOWEST),0)
                  )
                )
              )
            ),
            nqp::while(                          # convert to Baggy semantics
              $iter,
              nqp::if(
                nqp::ifnull(
                  nqp::atpos(
                    ($minmax := nqp::getattr(
                      nqp::iterval(nqp::shift($iter)),Pair,'$!value')),
                    LOWEST
                  ),
                  0
                ) == nqp::atpos($minmax,HIGHEST),
                nqp::deletekey($elems,nqp::iterkey_s($iter)),    # top 2 same
                nqp::bindattr(                                   # there's a
                  nqp::iterval($iter),                           # difference
                  Pair,                                          # so convert
                  '$!value',
                  nqp::atpos($minmax,HIGHEST)
                    - nqp::ifnull(nqp::atpos($minmax,LOWEST),0)
                )
              )
            )
          )
        ),
        nqp::create($type).SET-SELF($elems)
      )
    )
}

# U+2296 CIRCLED MINUS
my constant &infix:<> := &infix:<(^)>;

#line 1 SETTING::src/core/set_subset.pm
# This file implements the following set operators:
#   (<=)  is a subset of (ASCII)
#        is a subset of
#        is NOT a subset of
#   (>=)  is a superset of (ASCII)
#        is a superset of
#        is NOT a superset of

proto sub infix:<<(<=)>>($, $ --> Bool:D) is pure {*}
multi sub infix:<<(<=)>>(Setty:D $a, Setty:D $b --> Bool:D) {
    nqp::stmts(
      nqp::unless(
        nqp::eqaddr(nqp::decont($a),nqp::decont($b)),
        nqp::if(
          (my $araw := $a.RAW-HASH)
            && nqp::elems($araw),
          nqp::if(                # number of elems in B *always* >= A
            (my $braw := $b.RAW-HASH)
              && nqp::isle_i(nqp::elems($araw),nqp::elems($braw))
              && (my $iter := nqp::iterator($araw)),
            nqp::while(           # number of elems in B >= A
              $iter,
              nqp::unless(
                nqp::existskey($braw,nqp::iterkey_s(nqp::shift($iter))),
                return False      # elem in A doesn't exist in B
              )
            ),
            return False          # number of elems in B smaller than A
          )
        )
      ),
      True
    )
}
multi sub infix:<<(<=)>>(Setty:D $a, Mixy:D  $b --> Bool:D) { $a.Mix (<=) $b }
multi sub infix:<<(<=)>>(Setty:D $a, Baggy:D $b --> Bool:D) { $a.Bag (<=) $b }
multi sub infix:<<(<=)>>(Setty:D $a, Any     $b --> Bool:D) { $a (<=) $b.Set }

multi sub infix:<<(<=)>>(Mixy:D $a, Mixy:D  $b --> Bool:D) {
    Rakudo::QuantHash.MIX-IS-SUBSET($a,$b)
}
multi sub infix:<<(<=)>>(Mixy:D $a, Baggy:D $b --> Bool:D) {
    Rakudo::QuantHash.MIX-IS-SUBSET($a,$b)
}
multi sub infix:<<(<=)>>(Mixy:D $a, Setty:D $b --> Bool:D) { $a (<=) $b.Mix }
multi sub infix:<<(<=)>>(Mixy:D $a, Any     $b --> Bool:D) { $a (<=) $b.Mix }

multi sub infix:<<(<=)>>(Baggy:D $a, Mixy:D $b --> Bool:D) {
    Rakudo::QuantHash.MIX-IS-SUBSET($a,$b)
}
multi sub infix:<<(<=)>>(Baggy:D $a, Baggy:D $b --> Bool:D) {
    nqp::stmts(
      nqp::unless(
        nqp::eqaddr(nqp::decont($a),nqp::decont($b)),
        nqp::if(
          (my $araw := $a.RAW-HASH)
            && nqp::elems($araw),
          nqp::if(                # number of elems in B *always* >= A
            (my $braw := $b.RAW-HASH)
              && nqp::isle_i(nqp::elems($araw),nqp::elems($braw))
              && (my $iter := nqp::iterator($araw)),
            nqp::while(           # number of elems in B >= A
              $iter,
              nqp::unless(
                nqp::getattr(nqp::iterval(nqp::shift($iter)),Pair,'$!value')
                  <=              # value in A should be less or equal than B
                nqp::getattr(
                  nqp::ifnull(
                    nqp::atkey($braw,nqp::iterkey_s($iter)),
                    BEGIN       # provide virtual value 0
                      nqp::p6bindattrinvres(nqp::create(Pair),Pair,'$!value',0)
                  ),
                  Pair,
                  '$!value'
                ),
                return False
              )
            ),
            return False          # number of elems in B smaller than A
          )
        )
      ),
      True
    )
}
multi sub infix:<<(<=)>>(Baggy:D $a, Setty:D $b --> Bool:D) { $a (<=) $b.Bag }
multi sub infix:<<(<=)>>(Baggy:D $a, Any     $b --> Bool:D) { $a (<=) $b.Bag }

multi sub infix:<<(<=)>>(Map:D $a, Map:D $b --> Bool:D) {
    nqp::if(
      nqp::eqaddr(nqp::decont($a),nqp::decont($b)),
      True,                       # B is alias of A
      nqp::if(                    # A and B are different
        (my $araw := nqp::getattr(nqp::decont($a),Map,'$!storage'))
          && nqp::elems($araw),
        nqp::if(                  # something in A
          nqp::eqaddr($a.keyof,Str(Any)) && nqp::eqaddr($b.keyof,Str(Any)),
          nqp::if(                # both are normal Maps
            (my $iter := nqp::iterator($araw))
              && (my $braw := nqp::getattr(nqp::decont($b),Map,'$!storage'))
              && nqp::elems($braw),
            nqp::stmts(           # something to check for in B
              nqp::while(
                $iter,
                nqp::if(
                  nqp::iterval(nqp::shift($iter)),
                  nqp::unless(    # valid in A
                    nqp::atkey($braw,nqp::iterkey_s($iter)),
                    return False  # valid elem in A isn't valid elem in B
                  )
                )
              ),
              True                # all valids in A occur as valids in B
            ),
            nqp::stmts(           # nothing to check for in B
              nqp::while(
                $iter,
                nqp::if(
                  nqp::iterval(nqp::shift($iter)),
                  return False    # valid in elem in A (and none in B)
                )
              ),
              True                # no valid elems in A
            )
          ),
          $a.Set (<=) $b.Set      # either is objectHash, so coerce
        ),
        True                      # nothing in A
      )
    )
}

multi sub infix:<<(<=)>>(Any $a, Mixy:D  $b --> Bool:D) { $a.Mix (<=) $b     }
multi sub infix:<<(<=)>>(Any $a, Baggy:D $b --> Bool:D) { $a.Bag (<=) $b     }
multi sub infix:<<(<=)>>(Any $a, Setty:D $b --> Bool:D) { $a.Set (<=) $b     }

multi sub infix:<<(<=)>>(Failure:D $a, Any $b) { $a.throw }
multi sub infix:<<(<=)>>(Any $a, Failure:D $b) { $b.throw }
multi sub infix:<<(<=)>>(Any $a, Any $b --> Bool:D) {
    infix:<<(<=)>>($a.Set, $b.Set)
}

# U+2286 SUBSET OF OR EQUAL TO
my constant &infix:<> := &infix:<<(<=)>>;

# U+2288 NEITHER A SUBSET OF NOR EQUAL TO
only sub infix:<>($a, $b --> Bool:D) is pure {
    not $a (<=) $b;
}

only sub infix:<<(>=)>>(Any $a, Any $b --> Bool:D) {
    $b (<=) $a
}
# U+2287 SUPERSET OF OR EQUAL TO
only sub infix:<>($a, $b --> Bool:D) is pure {
    $b (<=) $a
}
# U+2289 NEITHER A SUPERSET OF NOR EQUAL TO
only sub infix:<>($a, $b --> Bool:D) is pure {
    not $b (<=) $a
}

#line 1 SETTING::src/core/set_proper_subset.pm
# This file implements the following set operators:
#   (<)   is a proper subset of (ASCII)
#        is a proper subset of
#        is NOT a proper subset of
#   (>)   is a proper superset of (ASCII)
#        is a proper superset of
#        is NOT a proper superset of

proto sub infix:<<(<)>>($, $ --> Bool:D) is pure {*}
multi sub infix:<<(<)>>(Setty:D $a, Setty:D $b --> Bool:D) {
    nqp::if(
      nqp::eqaddr(nqp::decont($a),nqp::decont($b)),
      False,                    # X is never a true subset of itself
      nqp::if(
        (my $braw := $b.RAW-HASH) && nqp::elems($braw),
        nqp::if(
          (my $araw := $a.RAW-HASH) && nqp::elems($araw),
          nqp::if(
            nqp::islt_i(nqp::elems($araw),nqp::elems($braw))
              && (my $iter := nqp::iterator($araw)),
            nqp::stmts(         # A has fewer elems than B
              nqp::while(
                $iter,
                nqp::unless(
                  nqp::existskey($braw,nqp::iterkey_s(nqp::shift($iter))),
                  return False  # elem in A doesn't exist in B
                )
              ),
              True              # all elems in A exist in B
            ),
            False               # number of elems in B smaller or equal to A
          ),
          True                  # no elems in A, and elems in B
        ),
        False                   # can never have fewer elems in A than in B
      )
    )
}
multi sub infix:<<(<)>>(Setty:D $a, Mixy:D  $b --> Bool:D) { $a.Mix (<) $b }
multi sub infix:<<(<)>>(Setty:D $a, Baggy:D $b --> Bool:D) { $a.Bag (<) $b }
multi sub infix:<<(<)>>(Setty:D $a, Any     $b --> Bool:D) { $a (<) $b.Set }

multi sub infix:<<(<)>>(Mixy:D $a, Mixy:D  $b --> Bool:D) {
    Rakudo::QuantHash.MIX-IS-PROPER-SUBSET($a,$b)
}
multi sub infix:<<(<)>>(Mixy:D $a, Baggy:D $b --> Bool:D) {
    Rakudo::QuantHash.MIX-IS-PROPER-SUBSET($a,$b)
}
multi sub infix:<<(<)>>(Mixy:D $a, Any     $b --> Bool:D) { $a (<) $b.Mix }

multi sub infix:<<(<)>>(Baggy:D $a, Mixy:D $b --> Bool:D) {
    Rakudo::QuantHash.MIX-IS-PROPER-SUBSET($a,$b)
}
multi sub infix:<<(<)>>(Baggy:D $a, Baggy:D $b --> Bool:D) {
    nqp::if(
      nqp::eqaddr(nqp::decont($a),nqp::decont($b)),
      False,                    # never proper subset of self

      nqp::if(                  # different objects
        (my $araw := $a.RAW-HASH) && (my $iter := nqp::iterator($araw)),
        nqp::if(                # elements on left
          (my $braw := $b.RAW-HASH) && nqp::elems($braw),
          nqp::if(              # elements on both sides
            nqp::isle_i(nqp::elems($araw),nqp::elems($braw)),
            nqp::stmts(         # equal number of elements on either side
              (my int $less = 0),
              nqp::while(
                $iter,
                nqp::if(
                  (my $left := nqp::getattr(
                    nqp::iterval(nqp::shift($iter)),
                    Pair,
                    '$!value'
                  ))
                   >
                  (my $right := nqp::getattr(
                    nqp::ifnull(
                      nqp::atkey($braw,nqp::iterkey_s($iter)),
                      BEGIN nqp::p6bindattrinvres(     # virtual 0
                        nqp::create(Pair),Pair,'$!value',0)
                    ),
                    Pair,
                    '$!value'
                  )),
                  (return False), # too many on left, we're done
                  nqp::unless($less,$less = $left < $right)
                )
              ),
              nqp::p6bool(      # ok so far, must have lower total or fewer keys
                $less || nqp::islt_i(nqp::elems($araw),nqp::elems($braw))
              )
            ),
            False               # more keys on left
          ),
          False                 # keys on left, no keys on right
        ),
        nqp::p6bool(            # no keys on left
          ($braw := $b.RAW-HASH) && nqp::elems($braw)
        )
      )
    )
}
multi sub infix:<<(<)>>(Baggy:D $a, Any $b --> Bool:D) { $a (<) $b.Bag }

multi sub infix:<<(<)>>(Any $a, Mixy:D  $b --> Bool:D) { $a.Mix (<) $b     }
multi sub infix:<<(<)>>(Any $a, Baggy:D $b --> Bool:D) { $a.Bag (<) $b     }

multi sub infix:<<(<)>>(Failure:D $a, Any $b) { $a.throw }
multi sub infix:<<(<)>>(Any $a, Failure:D $b) { $b.throw }
multi sub infix:<<(<)>>(Any $a, Any $b --> Bool:D) {
    infix:<<(<)>>($a.Set, $b.Set)
}

# U+2282 SUBSET OF
my constant &infix:<> := &infix:<<(<)>>;

# U+2284 NOT A SUBSET OF
only sub infix:<>($a, $b --> Bool:D) is pure {
    not $a (<) $b;
}

only sub infix:<<(>)>>(Any $a, Any $b --> Bool:D) {
    $b (<) $a
}
# U+2283 SUPERSET OF
only sub infix:<>($a, $b --> Bool:D) is pure {
    $b (<) $a
}
# U+2285 NOT A SUPERSET OF
only sub infix:<>($a, $b --> Bool:D) is pure {
    not $b (<) $a
}

#line 1 SETTING::src/core/set_multiply.pm
# This file implements the following set operators:
#   (.)  set multiplication (ASCII)
#       set multiplication

proto sub infix:<(.)>(|) is pure { * }
multi sub infix:<(.)>()               { bag()  }
multi sub infix:<(.)>(Bag:D $a)       { $a     }
multi sub infix:<(.)>(Mix:D $a)       { $a     }
multi sub infix:<(.)>(MixHash:D $a)   { $a.Mix }
multi sub infix:<(.)>(Any $a)         { $a.Bag }

multi sub infix:<(.)>(Setty:D $a, Setty:D $b) {
    nqp::if(
      (my $elems := $a.Bag.RAW-HASH) && nqp::elems($elems),
      nqp::create(Bag).SET-SELF(
        Rakudo::QuantHash.MULTIPLY-SET-TO-BAG($elems,$b.RAW-HASH),
      ),
      bag()
    )
}

multi sub infix:<(.)>(Mixy:D $a, Mixy:D $b) {
    nqp::if(
      (my $elems := Rakudo::QuantHash.BAGGY-CLONE-RAW($a.RAW-HASH))
        && nqp::elems($elems),
      nqp::stmts(
        Rakudo::QuantHash.MULTIPLY-MIX-TO-MIX($elems,$b.RAW-HASH),
        nqp::create(Mix).SET-SELF($elems)
      ),
      mix()
    )
}

multi sub infix:<(.)>(Mixy:D $a, Baggy:D $b) { infix:<(.)>($a, $b.Mix) }
multi sub infix:<(.)>(Mixy:D $a, Any $b)     { infix:<(.)>($a, $b.Mix) }
multi sub infix:<(.)>(Baggy:D $a, Mixy:D $b) { infix:<(.)>($a.Mix, $b) }
multi sub infix:<(.)>(Any $a, Mixy:D $b)     { infix:<(.)>($a.Mix, $b) }
multi sub infix:<(.)>(Baggy:D $a, Baggy:D $b) {
    nqp::if(
      (my $elems := Rakudo::QuantHash.BAGGY-CLONE-RAW($a.RAW-HASH))
        && nqp::elems($elems),
      nqp::create(Bag).SET-SELF(
        Rakudo::QuantHash.MULTIPLY-BAG-TO-BAG($elems,$b.RAW-HASH),
      ),
      bag()
    )
}

multi sub infix:<(.)>(Any $, Failure:D $b) { $b.throw }
multi sub infix:<(.)>(Failure:D $a, Any $) { $a.throw }
multi sub infix:<(.)>(Any $a, Any $b) { infix:<(.)>($a.Bag,$b.Bag) }

multi sub infix:<(.)>(**@p) {
    my $result = @p.shift;
    $result = $result (.) @p.shift while @p;
    $result
}

# U+228D MULTISET MULTIPLICATION
my constant &infix:<> := &infix:<(.)>;

#line 1 SETTING::src/core/set_addition.pm
# This file implements the following set operators:
#   (+)     baggy addition (ASCII)
#          baggy addition

proto sub infix:<(+)>(|) is pure { * }
multi sub infix:<(+)>()               { bag()  }
multi sub infix:<(+)>(Bag:D $a)       { $a     }
multi sub infix:<(+)>(Mix:D $a)       { $a     }
multi sub infix:<(+)>(MixHash:D $a)   { $a.Mix }
multi sub infix:<(+)>(Any $a)         { $a.Bag }

multi sub infix:<(+)>(Setty:D $a, QuantHash:D $b) {
    nqp::if(
      (my $araw := $a.RAW-HASH) && nqp::elems($araw),
      nqp::if(                                         # elems on left
        (my $braw := $b.RAW-HASH) && nqp::elems($braw),
        nqp::stmts(                                    # elems on both sides
          (my $elems := Rakudo::QuantHash.SET-BAGGIFY($araw)),
          nqp::create(nqp::if(nqp::istype($b,Mixy),Mix,Bag)).SET-SELF(
            nqp::if(
              nqp::istype($b,Mixy),
              Rakudo::QuantHash.ADD-MIX-TO-MIX($elems, $braw),
              nqp::if(
                nqp::istype($b,Baggy),
                Rakudo::QuantHash.ADD-BAG-TO-BAG($elems, $braw),
                Rakudo::QuantHash.ADD-SET-TO-BAG($elems, $braw)
              )
            )
          )
        ),
        nqp::if(nqp::istype($b,Mixy),$a.Mix,$a.Bag)    # no elems on right
      ),
      nqp::if(nqp::istype($b,Mixy),$b.Mix,$b.Bag)      # no elems left/either
    )
}
multi sub infix:<(+)>(Setty:D $a, Map:D $b) {
    nqp::if(
      (my $araw := $a.RAW-HASH) && nqp::elems($araw),
      nqp::if(                                         # elems on left
        (my $braw := nqp::getattr(nqp::decont($b),Map,'$!storage'))
          && nqp::elems($braw),
        nqp::create(Bag).SET-SELF(                     # elems on both sides
          Rakudo::QuantHash.ADD-MAP-TO-BAG(
            Rakudo::QuantHash.SET-BAGGIFY($araw), $b
          )
        ),
        $a.Bag                                         # no elems on right
      ),
      $b.Bag                                           # no elems left/either
    )
}
multi sub infix:<(+)>(Mixy:D $a, QuantHash:D $b) {
    nqp::if(
      (my $araw := $a.RAW-HASH) && nqp::elems($araw),
      nqp::if(                                         # elems on left
        (my $braw := $b.RAW-HASH) && nqp::elems($braw),
        nqp::stmts(                                    # elems on both sides
          (my $elems := Rakudo::QuantHash.BAGGY-CLONE($araw)),
          nqp::create(Mix).SET-SELF(
            nqp::if(
              nqp::istype($b,Baggy),
              Rakudo::QuantHash.ADD-MIX-TO-MIX($elems, $braw),
              Rakudo::QuantHash.ADD-SET-TO-MIX($elems, $braw)
            )
          )
        ),
        $a.Mix                                         # no elems on right
      ),
      $b.Mix                                           # no elems left/either
    )
}

multi sub infix:<(+)>(Baggy:D $a, QuantHash:D $b) {
    nqp::if(
      (my $araw := $a.RAW-HASH) && nqp::elems($araw),
      nqp::if(                                         # elems on left
        (my $braw := $b.RAW-HASH) && nqp::elems($braw),
        nqp::stmts(                                    # elems on both sides
          (my $elems := Rakudo::QuantHash.BAGGY-CLONE($araw)),
          nqp::create(nqp::if(nqp::istype($b,Mixy),Mix,Bag)).SET-SELF(
            nqp::if(
              nqp::istype($b,Mixy),
              Rakudo::QuantHash.ADD-MIX-TO-MIX($elems, $braw),
              nqp::if(
                nqp::istype($b,Baggy),
                Rakudo::QuantHash.ADD-BAG-TO-BAG($elems, $braw),
                Rakudo::QuantHash.ADD-SET-TO-BAG($elems, $braw)
              )
            )
          )
        ),
        nqp::if(nqp::istype($b,Mixy),$a.Mix,$a.Bag)    # no elems on right
      ),
      nqp::if(nqp::istype($b,Mixy),$b.Mix,$b.Bag)      # no elems left/either
    )
}

multi sub infix:<(+)>(Map:D $a, Map:D $b) {
    nqp::if(
      (my $araw := nqp::getattr(nqp::decont($b),Map,'$!storage'))
        && nqp::elems($araw),
      nqp::if(                                         # elems on left
        (my $braw := nqp::getattr(nqp::decont($b),Map,'$!storage'))
          && nqp::elems($braw),
        nqp::create(Bag).SET-SELF(                     # elems on both sides
          Rakudo::QuantHash.ADD-MAP-TO-BAG(
            Rakudo::QuantHash.COERCE-MAP-TO-BAG($a), $b
          )
        ),
        $a.Bag                                         # no elems on right
      ),
      $b.Bag                                           # no elems left/either
    )
}

multi sub infix:<(+)>(Iterable:D $a, Iterable:D $b) {
    nqp::create(Bag).SET-SELF(
      Rakudo::QuantHash.ADD-PAIRS-TO-BAG(
        Rakudo::QuantHash.ADD-PAIRS-TO-BAG(
          nqp::create(Rakudo::Internals::IterationSet),
          $a.iterator
        ),
        $b.iterator
      )
    )
}

multi sub infix:<(+)>(Any $, Failure:D $b) { $b.throw }
multi sub infix:<(+)>(Failure:D $a, Any $) { $a.throw }
multi sub infix:<(+)>(Any $a, Any $b) {
    nqp::if(
      nqp::istype($a,Mixy) || nqp::istype($b,Mixy),
      infix:<(+)>($a.Mix, $b.Mix),
      infix:<(+)>($a.Bag, $b.Bag)
    )
}

multi sub infix:<(+)>(**@p) {
    my $result = @p.shift;
    $result = $result (+) @p.shift while @p;
    $result
}

# U+228E MULTISET UNION
my constant &infix:<> := &infix:<(+)>;

#line 1 SETTING::src/core/set_precedes.pm
# This file implements the following set operators:
#   (<+)    precedes (ASCII)
#          precedes
#   (>+)    succeeds (ASCII)
#          succeeds

proto sub infix:<<(<+)>>($, $ --> Bool:D) is pure {
    DEPRECATED(
      "set operator {$*INSTEAD // "(<=)"}",
      "",
      "6.d",
      :what("Set operator {$*WHAT // "(<+)"}"),
      :up( 1 + ?$*WHAT )
    );
    {*}
}
multi sub infix:<<(<+)>>(Setty:D \a, QuantHash:D \b --> Bool:D) {
    nqp::if(
      (my $a := a.RAW-HASH),
      nqp::if(
        (my $b := b.RAW-HASH) && nqp::isge_i(nqp::elems($b),nqp::elems($a)),
        nqp::stmts(
          (my $iter := nqp::iterator($a)),
          nqp::while(
            $iter && nqp::existskey($b,nqp::iterkey_s(nqp::shift($iter))),
            nqp::null
          ),
          nqp::p6bool(nqp::isfalse($iter))
        ),
        False
      ),
      True
    )
}
multi sub infix:<<(<+)>>(Mixy:D \a, Baggy:D \b --> Bool:D) {
    nqp::if(
      (my $a := a.RAW-HASH),
      nqp::if(
        (my $b := b.RAW-HASH) && nqp::isge_i(nqp::elems($b),nqp::elems($a)),
        nqp::stmts(
          (my $iter := nqp::iterator($a)),
          nqp::while(
            $iter,
            nqp::if(
              nqp::not_i(nqp::existskey(
                $b,
                (my $key := nqp::iterkey_s(nqp::shift($iter)))
              )) ||
              nqp::getattr(nqp::decont(nqp::atkey($a,$key)),Pair,'$!value')
                > nqp::getattr(nqp::decont(nqp::atkey($b,$key)),Pair,'$!value'),
              (return False)
            )
          ),
          True
        ),
        False
      ),
      True
    )
}
multi sub infix:<<(<+)>>(Baggy:D \a, Baggy:D \b --> Bool:D) {
    nqp::if(
      (my $a := a.RAW-HASH),
      nqp::if(
        (my $b := b.RAW-HASH) && nqp::isge_i(nqp::elems($b),nqp::elems($a)),
        nqp::stmts(
          (my $iter := nqp::iterator($a)),
          nqp::while(
            $iter,
            nqp::if(
              nqp::not_i(nqp::existskey(
                $b,
                (my $key := nqp::iterkey_s(nqp::shift($iter)))
              )) ||
              nqp::isgt_i(
                nqp::getattr(nqp::decont(nqp::atkey($a,$key)),Pair,'$!value'),
                nqp::getattr(nqp::decont(nqp::atkey($b,$key)),Pair,'$!value')
              ),
              (return False)
            )
          ),
          True
        ),
        False
      ),
      True
    )
}
multi sub infix:<<(<+)>>(QuantHash:U $a, QuantHash:U $b --> True ) {}
multi sub infix:<<(<+)>>(QuantHash:U $a, QuantHash:D $b --> True ) {}
multi sub infix:<<(<+)>>(QuantHash:D $a, QuantHash:U $b --> Bool:D ) {
    not $a.elems
}
multi sub infix:<<(<+)>>(QuantHash:D $a, QuantHash:D $b --> Bool:D ) {
    return False if $a.AT-KEY($_) > $b.AT-KEY($_) for $a.keys;
    True
}

multi sub infix:<<(<+)>>(Any $, Failure:D $b) { $b.throw }
multi sub infix:<<(<+)>>(Failure:D $a, Any $) { $a.throw }
multi sub infix:<<(<+)>>(Any $a, Any $b --> Bool:D) {
    nqp::if(
      nqp::istype($a,Mixy) || nqp::istype($b,Mixy),
      infix:<<(<+)>>($a.Mix, $b.Mix),
      infix:<<(<+)>>($a.Bag, $b.Bag)
    )
}

# U+227C PRECEDES OR EQUAL TO
only sub infix:<>($a, $b --> Bool:D) is pure {
    my $*WHAT    = "";
    my $*INSTEAD = "";
    infix:<<(<+)>>($a, $b)
}

# $a (>+) $b === $a R(<+) $b
only sub infix:<<(>+)>>($a, $b --> Bool:D) is pure {
    my $*WHAT    = "(>+)";
    my $*INSTEAD = "(>=)";
    infix:<<(<+)>>($b, $a)
}
# U+227D SUCCEEDS OR EQUAL TO
only sub infix:<>($a, $b --> Bool:D) is pure {
    my $*WHAT    = "";
    my $*INSTEAD = "";
    infix:<<(<+)>>($b, $a)
}

#line 1 SETTING::src/core/ObjAt.pm
my class ObjAt { # declared in BOOTSTRAP
    # class ObjAt is Any
    #     has str $!value;
    method new(str $s) {
        nqp::box_s($s, self.WHAT)
    }

    multi method WHICH(ObjAt:D:) {
        nqp::box_s(
          nqp::concat(
            nqp::if(
              nqp::eqaddr(self.WHAT,ObjAt),
              'ObjAt|',
              nqp::concat(nqp::unbox_s(self.^name), '|')
            ),
            $!value
          ),
          ObjAt
        )
    }
    multi method Str(ObjAt:D:) {
        nqp::p6box_s(nqp::unbox_s(self));
    }
    multi method gist(ObjAt:D:) {
        nqp::p6box_s(nqp::unbox_s(self));
    }
    multi method perl(ObjAt:D:) {
        self.^name ~ ".new(" ~ nqp::p6box_s(nqp::unbox_s(self)).perl ~ ")"
    }
}

#line 1 SETTING::src/core/Version.pm
class Version {
    has $!parts;
    has int $!plus;
    has str $!string;

    method !SET-SELF(\parts,\plus,\string) {
        $!parts := nqp::getattr(parts,List,'$!reified');
        $!plus   = plus;
        $!string = string;
        self
    }

    multi method new(Version:) {
        # "v" highlander
        INIT nqp::create(Version)!SET-SELF(nqp::list,0,"")      # should be once
    }
    multi method new(Version: Whatever) {
        # "v*" highlander
        INIT nqp::create(Version)!SET-SELF(nqp::list(*),-1,"*") # should be once
    }
    multi method new(Version: @parts, Str:D $string, Int() $plus = 0) {
        nqp::create(self)!SET-SELF(@parts.eager,$plus,$string)
    }
    multi method new(Version: Str() $s) {

        # highlanderize most common
        if $s eq '6' {
            INIT nqp::create(Version)!SET-SELF(nqp::list(6),0,"6") # should be once
        }
        elsif $s eq '6.c' {
            INIT nqp::create(Version)!SET-SELF(nqp::list(6,"c"),0,"6.c") # should be once
        }

        # something sensible given
        elsif $s.comb(/:r '*' || \d+ || <.alpha>+/).eager -> @s {
            my $strings  := nqp::getattr(@s,List,'$!reified');
            my int $elems = nqp::elems($strings);
            my $parts    := nqp::setelems(nqp::list,$elems);

            my int $i = -1;
            while nqp::islt_i(++$i,$elems) {
                my str $s = nqp::atpos($strings,$i);
                nqp::bindpos($parts,$i, nqp::iseq_s($s,"*")
                  ?? *
                  !! (my $numeric = $s.Numeric).defined
                    ?? nqp::decont($numeric)
                    !! nqp::unbox_s($s)
                );
            }

            my str $string = nqp::join(".", $strings);
            my int $plus   = $s.ends-with("+");
            nqp::create(self)!SET-SELF($parts,$plus,$plus
              ?? nqp::concat($string,"+")
              !! $string
            )
        }

        # "v+" highlander
        elsif $s.ends-with("+") {
            INIT nqp::create(Version)!SET-SELF(nqp::list,1,"") # should be once
        }
        # get "v" highlander
        else {
            self.new
        }
    }

    multi method Str(Version:D:)  { $!string }
    multi method gist(Version:D:) { nqp::concat("v",$!string) }
    multi method perl(Version:D:) {
        if nqp::chars($!string) {
            my int $first = nqp::ord($!string);
            nqp::isge_i($first,48) && nqp::isle_i($first,57) # "0" <= x <= "9"
              ?? nqp::concat("v",$!string)
              !! self.^name ~ ".new('$!string')"
        }
        else {
            self.^name ~ ".new"
        }
    }
    multi method ACCEPTS(Version:D: Version:D $other) {
        my $oparts       := nqp::getattr(nqp::decont($other),Version,'$!parts');
        my int $oelems    = nqp::isnull($oparts) ?? 0 !! nqp::elems($oparts);
        my int $elems     = nqp::elems($!parts);
        my int $max-elems = nqp::if(nqp::isge_i($oelems,$elems), $oelems, $elems);

        my int $i = -1;
        while nqp::islt_i(++$i,$max-elems) {
            my $v := nqp::if(nqp::isge_i($i,$elems), Whatever, nqp::atpos($!parts,$i));

            # if whatever here, no more check this iteration
            unless nqp::istype($v,Whatever) {
                my $o := nqp::if(nqp::isge_i($i,$oelems), 0, nqp::atpos($oparts,$i));

                # if whatever there, no more to check this iteration
                unless nqp::istype($o,Whatever) {
                    return nqp::p6bool($!plus) if $o after  $v;
                    return False               if $o before $v;
                }
            }
        }
        True;
    }

    method Capture() { die X::Cannot::Capture.new: :what(self) }

    multi method WHICH(Version:D:) {
        nqp::box_s(
          nqp::concat(
            nqp::if(
              nqp::eqaddr(self.WHAT,Version),
              'Version|',
              nqp::concat(nqp::unbox_s(self.^name), '|')
            ),
            $!string
          ),
          ObjAt
        )
    }

    method parts() { nqp::hllize($!parts) }
    method plus()  { nqp::p6bool($!plus) }
}


multi sub infix:<eqv>(Version:D \a, Version:D \b) {
    nqp::p6bool(
      nqp::eqaddr(a,b)
        || (nqp::eqaddr(a.WHAT,b.WHAT)
             && nqp::iseq_s(
               nqp::getattr_s(a,Version,'$!string'),
               nqp::getattr_s(b,Version,'$!string')
             ))
    )
}

multi sub infix:<cmp>(Version:D \a, Version:D \b) {
    nqp::if(
      nqp::eqaddr(nqp::decont(a),nqp::decont(b)), # we're us
      Same,
      nqp::stmts(
        (my \ia := nqp::iterator(nqp::getattr(nqp::decont(a),Version,'$!parts'))),
        (my \ib := nqp::iterator(nqp::getattr(nqp::decont(b),Version,'$!parts'))),
        (my ($ret, $a-part, $b-part)),
        nqp::while(
          ia, # check from left
          nqp::stmts(
            ($a-part := nqp::shift(ia)),
            ($b-part := ib ?? nqp::shift(ib) !! 0),
            nqp::if(
              ($ret := nqp::if(
                nqp::istype($a-part,Str) && nqp::istype($b-part,Int),
                Less,
                nqp::if(
                  nqp::istype($a-part,Int) && nqp::istype($b-part,Str),
                  More,
                  ($a-part cmp $b-part)))),
              return $ret))),
        nqp::while(
          ib, # check from right
          nqp::stmts(
            ($a-part := 0),
            ($b-part := nqp::shift(ib)),
            nqp::if(
              ($ret := nqp::if(
                nqp::istype($a-part,Str) && nqp::istype($b-part,Int),
                Less,
                nqp::if(
                  nqp::istype($a-part,Int) && nqp::istype($b-part,Str),
                  More,
                  ($a-part cmp $b-part)))),
              return $ret))),
        (     nqp::getattr_i(nqp::decont(a),Version,'$!plus')
          cmp nqp::getattr_i(nqp::decont(b),Version,'$!plus'))))
}

multi sub infix:<=>(Version:D \a, Version:D \b) { a cmp b }
multi sub infix:<  (Version:D \a, Version:D \b) { a cmp b == Less }
multi sub infix:<= (Version:D \a, Version:D \b) { a cmp b != More }
multi sub infix:  (Version:D \a, Version:D \b) { a cmp b != More }
multi sub infix:== (Version:D \a, Version:D \b) { a cmp b == Same }
multi sub infix:!= (Version:D \a, Version:D \b) { a cmp b != Same }
multi sub infix:  (Version:D \a, Version:D \b) { a cmp b   Same }
multi sub infix:>= (Version:D \a, Version:D \b) { a cmp b != Less }
multi sub infix:  (Version:D \a, Version:D \b) { a cmp b != Less }
multi sub infix:>  (Version:D \a, Version:D \b) { a cmp b == More }

#line 1 SETTING::src/core/ForeignCode.pm
# Takes a foreign code object and tries to make it feel somewhat like a Perl
# 6 one. Note that it doesn't have signature information we can know about.

my class ForeignCode does Callable { # declared in BOOTSTRAP
    # class ForeignCode
    #     has Code $!do;                # Code object we delegate to

    method arity() { self.signature.arity }

    method count() { self.signature.count }

    method signature(ForeignCode:D:) { (sub (|) { }).signature }

    method name() { (nqp::can($!do, 'name') ?? $!do.name !! nqp::getcodename($!do)) || '<anon>' }

    multi method gist(ForeignCode:D:) { self.name }

    multi method Str(ForeignCode:D:) { self.name }
}

my class Rakudo::Internals::EvalIdSource {
    my Int $count = 0;
    my Lock $lock = Lock.new;
    method next-id() {
        $lock.protect: { $count++ }
    }
}
proto sub EVAL($code is copy where Blob|Cool, Str() :$lang = 'perl6', PseudoStash :$context, *%n) {
    # First look in compiler registry.
    my $compiler := nqp::getcomp($lang);
    if nqp::isnull($compiler) {
        # Try a multi-dispatch to another EVAL candidate. If that fails to
        # dispatch, map it to a typed exception.
        CATCH {
            when X::Multi::NoMatch {
                X::Eval::NoSuchLang.new(:$lang).throw
            }
        }
        return {*};
    }
    $code = nqp::istype($code,Blob) ?? $code.decode(
        $compiler.cli-options<encoding> // 'utf8'
    ) !! $code.Str;

    $context := CALLER:: unless nqp::defined($context);
    my $eval_ctx := nqp::getattr(nqp::decont($context), PseudoStash, '$!ctx');
    my $?FILES   := 'EVAL_' ~ Rakudo::Internals::EvalIdSource.next-id;
    my \mast_frames := nqp::hash();
    my $*CTXSAVE; # make sure we don't use the EVAL's MAIN context for the currently compiling compilation unit
    my $compiled;
    my $LANG := $context<%?LANG>;
    if !$LANG {
        $LANG := CALLERS::<%?LANG>;
    }
    if $LANG {
        # XXX
        my $grammar := $LANG<MAIN>;
        my $actions := $LANG<MAIN-actions>;
        $compiled := $compiler.compile(
            $code,
            :outer_ctx($eval_ctx),
            :global(GLOBAL),
            :mast_frames(mast_frames),
            :grammar($grammar),
            :actions($actions),
        );
    }
    else {
        $compiled := $compiler.compile(
            $code,
            :outer_ctx($eval_ctx),
            :global(GLOBAL),
            :mast_frames(mast_frames),
        );
    }
    if $*W and $*W.is_precompilation_mode() { # we are still compiling
        $*W.add_additional_frames(mast_frames);
    }
    nqp::forceouterctx(nqp::getattr($compiled, ForeignCode, '$!do'), $eval_ctx);
    $compiled();
}

multi sub EVAL($code, Str :$lang where { ($lang // '') eq 'Perl5' }, PseudoStash :$context) {
    my $eval_ctx := nqp::getattr(nqp::decont($context // CALLER::), PseudoStash, '$!ctx');
    my $?FILES   := 'EVAL_' ~ (state $no)++;
    state $p5;
    unless $p5 {
        {
            my $compunit := $*REPO.need(CompUnit::DependencySpecification.new(:short-name<Inline::Perl5>));
            GLOBAL.WHO.merge-symbols($compunit.handle.globalish-package);
            CATCH {
                #X::Eval::NoSuchLang.new(:$lang).throw;
                note $_;
            }
        }
        $p5 = ::("Inline::Perl5").default_perl5;
    }
    $p5.run: nqp::istype($code,Blob)
        ?? Blob.new($code).decode('utf8-c8')
        !! $code.Str;
}

proto sub EVALFILE($, *%) {*}
multi sub EVALFILE($filename, :$lang = 'perl6') {
    EVAL slurp(:bin, $filename), :$lang, :context(CALLER::);
}

#line 1 SETTING::src/core/operators.pm
## miscellaneous operators can go here.
##   generic numeric operators are in Numeric.pm
##   generic string operators are in Stringy.pm
##   Int/Rat/Num operators are in {Int|Rat|Num}.pm

sub infix:<=>(Mu \a, Mu \b) is raw {
    nqp::p6store(a, b)
}

my class X::Does::TypeObject is Exception {
    has Mu $.type;
    method message() { "Cannot use 'does' operator with a type object." }
}

proto sub infix:<does>(|) { * }
multi sub infix:<does>(Mu:D \obj, Mu:U \rolish) is raw {
    # XXX Mutability check.
    my $role := rolish.HOW.archetypes.composable() ?? rolish !!
                rolish.HOW.archetypes.composalizable() ?? rolish.HOW.composalize(rolish) !!
                X::Mixin::NotComposable.new(:target(obj), :rolish(rolish)).throw;
    obj.^mixin($role).BUILD_LEAST_DERIVED({});
}
multi sub infix:<does>(Mu:D \obj, Mu:U \rolish, :$value! is raw) is raw {
    # XXX Mutability check.
    my $role := rolish.HOW.archetypes.composable() ?? rolish !!
                rolish.HOW.archetypes.composalizable() ?? rolish.HOW.composalize(rolish) !!
                X::Mixin::NotComposable.new(:target(obj), :rolish(rolish)).throw;
    my \mixedin = obj.^mixin($role, :need-mixin-attribute);
    mixedin.BUILD_LEAST_DERIVED({ substr(mixedin.^mixin_attribute.Str,2) => $value });
}
multi sub infix:<does>(Mu:U \obj, Mu:U \role) is raw {
    X::Does::TypeObject.new(type => obj).throw
}
multi sub infix:<does>(Mu:D \obj, **@roles) is raw {
    # XXX Mutability check.
    my \real-roles = eager @roles.map: -> \rolish {
        rolish.HOW.archetypes.composable() ?? rolish !!
            rolish.HOW.archetypes.composalizable() ?? rolish.HOW.composalize(rolish) !!
            X::Mixin::NotComposable.new(:target(obj), :rolish(rolish)).throw
    }
    obj.^mixin(|real-roles).BUILD_LEAST_DERIVED({});
}
multi sub infix:<does>(Mu:U \obj, **@roles) is raw {
    X::Does::TypeObject.new(type => obj).throw
}

# we need this candidate tighter than infix:<cmp>(Real:D, Real:D)
# but can't yet use `is default` at the place where that candidate
# is defined because it uses `infix:<does>`
multi sub infix:<cmp>(Rational:D \a, Rational:D \b) is default {
    a.isNaN || b.isNaN ?? a.Num cmp b.Num !! a <=> b
}

proto sub infix:<but>(|) is pure { * }
multi sub infix:<but>(Mu:D \obj, Mu:U \rolish) {
    my $role := rolish.HOW.archetypes.composable() ?? rolish !!
                rolish.HOW.archetypes.composalizable() ?? rolish.HOW.composalize(rolish) !!
                X::Mixin::NotComposable.new(:target(obj), :rolish(rolish)).throw;
    obj.clone.^mixin($role).BUILD_LEAST_DERIVED({});
}
multi sub infix:<but>(Mu:D \obj, Mu:U \rolish, :$value! is raw) {
    my $role := rolish.HOW.archetypes.composable() ?? rolish !!
                rolish.HOW.archetypes.composalizable() ?? rolish.HOW.composalize(rolish) !!
                X::Mixin::NotComposable.new(:target(obj), :rolish(rolish)).throw;
    my \mixedin = obj.clone.^mixin($role, :need-mixin-attribute);
    my \attr = mixedin.^mixin_attribute;
    my $mixin-value := $value;
    unless nqp::istype($value, attr.type) {
        if attr.type.HOW.^name eq 'Perl6::Metamodel::EnumHOW' {
            $mixin-value := attr.type.($value);
        }
    }
    mixedin.BUILD_LEAST_DERIVED({ substr(attr.Str,2) => $mixin-value });
}
multi sub infix:<but>(Mu:U \obj, Mu:U \rolish) {
    my $role := rolish.HOW.archetypes.composable() ?? rolish !!
                rolish.HOW.archetypes.composalizable() ?? rolish.HOW.composalize(rolish) !!
                X::Mixin::NotComposable.new(:target(obj), :rolish(rolish)).throw;
    obj.^mixin($role);
}
sub GENERATE-ROLE-FROM-VALUE($val) {
    my $role := Metamodel::ParametricRoleHOW.new_type();
    my $meth := method () { $val };
    $meth.set_name($val.^name);
    $role.^add_method($meth.name, $meth);
    $role.^set_body_block(
      -> |c { nqp::list($role, nqp::hash('$?CLASS', c<$?CLASS>)) });
    $role.^compose;
}
multi sub infix:<but>(Mu \obj, Mu:D $val) is raw {
    obj.clone.^mixin(GENERATE-ROLE-FROM-VALUE($val));
}
multi sub infix:<but>(Mu:D \obj, **@roles) {
    my \real-roles := eager @roles.map: -> \rolish {
        rolish.DEFINITE ?? GENERATE-ROLE-FROM-VALUE(rolish) !!
            rolish.HOW.archetypes.composable() ?? rolish !!
            rolish.HOW.archetypes.composalizable() ?? rolish.HOW.composalize(rolish) !!
            X::Mixin::NotComposable.new(:target(obj), :rolish(rolish)).throw
    }
    obj.clone.^mixin(|real-roles).BUILD_LEAST_DERIVED({});
}
multi sub infix:<but>(Mu:U \obj, **@roles) {
    my \real-roles := eager @roles.map: -> \rolish {
        rolish.DEFINITE ?? GENERATE-ROLE-FROM-VALUE(rolish) !!
            rolish.HOW.archetypes.composable() ?? rolish !!
            rolish.HOW.archetypes.composalizable() ?? rolish.HOW.composalize(rolish) !!
            X::Mixin::NotComposable.new(:target(obj), :rolish(rolish)).throw
    }
    obj.^mixin(|real-roles)
}

sub SEQUENCE(\left, Mu \right, :$exclude_end) {
    my \righti := (nqp::iscont(right) ?? right !! [right]).iterator;
    my $endpoint := righti.pull-one.self; # .self explodes Failures
    $endpoint =:= IterationEnd and X::Cannot::Empty.new(
        :action('get sequence endpoint'),
        :what('list (use * or :!elems instead?)'),
    ).throw;
    my $infinite = nqp::istype($endpoint,Whatever) || $endpoint === Inf;
    $endpoint := False if $infinite;

    my $end_code_arity = 0;
    if nqp::istype($endpoint,Code) && !nqp::istype($endpoint,Regex) {
        $end_code_arity = $endpoint.arity;
        $end_code_arity = $endpoint.count if $end_code_arity == 0;
        $end_code_arity = -Inf if $end_code_arity == Inf;
    }

    my sub succpred($a,$b) {
        my $cmp = $a cmp $b;
        if $a.WHAT === $b.WHAT === $endpoint.WHAT {
            $cmp < 0 && $a ~~ Stringy
                ?? -> $x {
                    my $new = $x.succ;
                    last if $new       after $endpoint
                         or $new.chars >     $endpoint.chars;
                    $new;
                }
                !! $cmp < 0
                    ?? -> $x {
                        my $new = $x.succ;
                        last if $new after $endpoint;
                        $new;
                    }
                    !! $cmp > 0
                        ?? -> $x {
                            my $new = $x.pred;
                            last if $x before $endpoint;
                            $new;
                        }
                        !! { $_ }
        }
        else {
               $cmp < 0 ?? { $^x.succ }
            !! $cmp > 0 ?? { $^x.pred }
            !!             { $^x      }
        }
    }
    my sub unisuccpred($a,$b) {
        my $cmp = $a.ord cmp $b.ord;
           $cmp < 0 ?? { $^x.ord.succ.chr }
        !! $cmp > 0 ?? { $^x.ord.pred.chr }
        !!             { $^x              }
    }

    my \gathered = GATHER({
        my \lefti := left.iterator;
        my $value;
        my $code;
        my $stop;
        my $looped;
        my @tail;
        my @end_tail;
        while !((my \value := lefti.pull-one) =:= IterationEnd) {
            $looped = True;
            if nqp::istype(value,Code) { $code = value; last }
            if $end_code_arity != 0 {
                @end_tail.push(value);
                if +@end_tail >= $end_code_arity {
                    @end_tail.shift xx (@end_tail.elems - $end_code_arity)
                        unless $end_code_arity ~~ -Inf;

                    if $endpoint(|@end_tail) {
                        $stop = 1;
                        @tail.push(value) unless $exclude_end;
                        last;
                    }
                }
            }
            elsif value ~~ $endpoint {
                $stop = 1;
                @tail.push(value) unless $exclude_end;
                last;
            }
            @tail.push(value);
        }
        X::Cannot::Empty.new(
            :action('get sequence start value'), :what('list')
        ).throw unless $looped;

        if $stop {
            take $_ for @tail;
        }
        else {
            my $badseq;
            my $a;
            my $b;
            my $c;
            unless $code.defined {
                take @tail.shift while @tail.elems > 3;
                $a = @tail[0];
                $b = @tail[1];
                $c = @tail[2];
            }
            if $code.defined { }
            elsif @tail.grep(Real).elems != @tail.elems {
                if @tail.elems > 1 {
                    $code = @tail.tail.WHAT === $endpoint.WHAT
                        ?? succpred(@tail.tail, $endpoint)
                        !! succpred(@tail[*-2], @tail.tail);
                }
                elsif nqp::istype($endpoint, Stringy)
                  and nqp::istype($a, Stringy)
                  and nqp::isconcrete($endpoint) {
                    if $a.codes == 1 && $endpoint.codes == 1 {
                        $code = unisuccpred($a, $endpoint);
                    }
                    elsif $a.codes == $endpoint.codes {
                        my @a = $a.comb;
                        my @e = $endpoint.comb;
                        my @ranges;
                        for flat @a Z @e -> $from, $to {
                            @ranges.push: $($from ... $to);
                        }
                        .take for flat [X~] @ranges;
                        $stop = 1;
                    }
                    elsif $a lt $endpoint {
                        $stop = 1 if $a gt $endpoint;
                        $code = -> $x {
                            my $new = $x.succ;
                            last if $new       gt $endpoint
                                 or $new.chars >  $endpoint.chars;
                            $new;
                        }
                    }
                    else {
                        $stop = 1 if $a lt $endpoint;
                        $code = -> $x {
                            my $new = $x.pred;
                            last if $new lt $endpoint;
                            $new;
                        }
                    }
                }
                elsif $infinite or nqp::istype($endpoint, Code) {
                    $code = *.succ;
                }
                else {
                    $code = succpred($a,$endpoint);
                }
            }
            elsif @tail.elems == 3 {
                my $ab = $b - $a;
                if $ab == $c - $b {
                    if $ab != 0
                    || nqp::istype($a,Real)
                    && nqp::istype($b,Real)
                    && nqp::istype($c,Real) {
                        if      nqp::istype($endpoint, Real)
                        and not nqp::istype($endpoint, Bool)
                        and     nqp::isconcrete($endpoint) {
                            if $ab > 0 {
                                $stop = 1 if $a > $endpoint;
                                $code = -> $x {
                                    my $new = $x + $ab;
                                    last if $new > $endpoint;
                                    $new;
                                }
                            }
                            else {
                                $stop = 1 if $a < $endpoint;
                                $code = -> $x {
                                    my $new = $x + $ab;
                                    last if $new < $endpoint;
                                    $new;
                                }
                            }
                        }
                        else {
                            $code = { $^x + $ab }
                        }
                    }
                    else {
                        $code = succpred($b, $c)
                    }
                }
                elsif $a != 0 && $b != 0 && $c != 0 {
                    $ab = $b / $a;
                    if $ab == $c / $b {
                        # XXX TODO: this code likely has a 2 bugs:
                        # 1) It should check Rational, not just Rat
                        # 2) Currently Rats aren't guaranteed to be always
                        #    normalized, so denominator might not be 1, even if
                        #    it could be, if normalized
                        $ab = $ab.Int
                            if nqp::istype($ab, Rat) && $ab.denominator == 1;

                        if      nqp::istype($endpoint, Real)
                        and not nqp::istype($endpoint, Bool)
                        and     nqp::isconcrete($endpoint) {
                            if $ab > 0 {
                                if $ab > 1  {
                                    $stop = 1 if $a > $endpoint;
                                    $code = -> $x {
                                        my $new = $x * $ab;
                                        last if $new > $endpoint;
                                        $new;
                                    }
                                }
                                else {
                                    $stop = 1 if $a < $endpoint;
                                    $code = -> $x {
                                        my $new = $x * $ab;
                                        last if $new < $endpoint;
                                        $new;
                                    }
                                }
                            }
                            else {
                                $code = -> $x {
                                    my $new = $x * $ab;
                                    my $absend = $endpoint.abs;
                                    last if sign(  $x.abs - $absend)
                                        == -sign($new.abs - $absend);
                                    $new;
                                }
                            }
                        }
                        else {
                            $code = { $^x * $ab }
                        }
                    }
                }
                if $code {
                    @tail.pop;
                    @tail.pop;
                }
                else {
                    $badseq = "$a,$b,$c" unless $code;
                }
            }
            elsif @tail.elems == 2 {
                my $ab = $b - $a;
                if $ab != 0 || nqp::istype($a,Real) && nqp::istype($b,Real) {
                    if      nqp::istype($endpoint, Real)
                    and not nqp::istype($endpoint, Bool)
                    and     nqp::isconcrete($endpoint) {
                        if $ab > 0 {
                            $stop = 1 if $a > $endpoint;
                            $code = -> $x {
                                my $new = $x + $ab;
                                last if $new > $endpoint;
                                $new;
                            }
                        }
                        else {
                            $stop = 1 if $a < $endpoint;
                            $code = -> $x {
                                my $new = $x + $ab;
                                last if $new < $endpoint;
                                $new;
                            }
                        }
                    }
                    else {
                        $code = { $^x + $ab }
                    }
                }
                else {
                    $code = succpred($a, $b)
                }
                @tail.pop;
            }
            elsif @tail.elems == 1 {
                if     nqp::istype($endpoint,Code)
                or not nqp::isconcrete($endpoint) {
                    $code = { $^x.succ }
                }
                elsif   nqp::istype($endpoint, Real)
                and not nqp::istype($endpoint, Bool)
                and     nqp::istype($a, Real) {
                    if $a < $endpoint {
                        $code = -> $x {
                            my $new = $x.succ;
                            last if $new > $endpoint;
                            $new;
                        }
                    }
                    else {
                        $code = -> $x {
                            my $new = $x.pred;
                            last if $new < $endpoint;
                            $new;
                        }
                    }
                }
                else {
                    $code = { $^x.succ }
                }
            }
            elsif @tail.elems == 0 {
                $code = {()}
            }

            if $stop { }
            elsif $code.defined {
                .take for @tail;
                my $count = $code.count;

                until $stop {
                    @tail.shift while @tail.elems > $count;
                    my \value = $code(|@tail);

                    if $end_code_arity != 0 {
                        @end_tail.push(value);

                        if @end_tail.elems >= $end_code_arity {
                            @end_tail.shift xx (
                                @end_tail.elems - $end_code_arity
                            ) unless $end_code_arity == -Inf;

                            if $endpoint(|@end_tail) {
                                value.take unless $exclude_end;
                                $stop = 1;
                            }
                        }
                    }
                    elsif value ~~ $endpoint {
                        value.take unless $exclude_end;
                        $stop = 1;
                    }

                    if $stop { }
                    else {
                        @tail.push(value);
                        value.take;
                    }
                }
            }
            elsif $badseq {
                die X::Sequence::Deduction.new(:from($badseq));
            }
            else {
                die X::Sequence::Deduction.new;
            }
        }
    });
    $infinite
        ?? (gathered.Slip, Slip.from-iterator(righti)).lazy
        !! (gathered.Slip, Slip.from-iterator(righti))
}

# XXX Wants to be macros when we have them.
sub WHAT(Mu \x) { x.WHAT }
sub HOW (Mu \x) { x.HOW }
sub VAR (Mu \x) { x.VAR }

proto sub infix:<...>(|) { * }
multi sub infix:<...>(\a, Mu \b) { Seq.new(SEQUENCE(a, b).iterator) }
multi sub infix:<...>(|lol) {
    my @lol := lol.list;
    my @end;
    my @seq;
    my @excl;
    my $ret := ();
    my int $i = 0;
    my int $m = +@lol - 1;
    while $i <= $m {
        @seq[$i] := @lol[$i].iterator;
        if $i {
            @end[$i-1] := @seq[$i].pull-one;
            if @end[$i-1] ~~ Numeric | Stringy {
                @seq[$i] := @lol[$i].iterator;
                @excl[$i-1] = True;
            }
        }
        ++$i;
    }
    $i = 0;
    while $i < $m {
        $ret := ($ret.Slip,
            SEQUENCE(
                (Slip.from-iterator(@seq[$i]),),
                @end[$i],
                :exclude_end(so @excl[$i])
            ).Slip
        );
        ++$i;
    }
    if @seq[$m] =:= Empty {
        Seq.new($ret.iterator);
    }
    else {
        Seq.new(($ret.Slip, Slip.from-iterator(@seq[$m])).iterator);
    }
}

proto sub infix:<...^>(|) { * }
multi sub infix:<...^>(\a, Mu \b) { Seq.new(SEQUENCE(a, b, :exclude_end(1)).iterator) }

proto sub infix:<>(|) { * }
multi sub infix:<>(|c) { infix:<...>(|c) }

proto sub infix:<^>(|) { * }
multi sub infix:<^>(|c) { infix:<...^>(|c) }

multi sub undefine(Mu \x) is raw { x = Nil }
multi sub undefine(Array \x) is raw { x = Empty }
multi sub undefine(Hash \x) is raw { x = Empty }

sub prefix:<temp>(\cont) is raw {
    my $temp_restore := nqp::getlexcaller('!TEMP-RESTORE');
    my int $i = nqp::elems($temp_restore);
    while $i > 0 {
        $i = $i - 2;
        return-rw cont if nqp::atpos($temp_restore, $i) =:= cont;
    }
    if nqp::iscont(cont) {
        nqp::push($temp_restore, cont);
        nqp::push($temp_restore, nqp::decont(cont));
    }
    elsif nqp::istype(cont, Array) {
        nqp::push($temp_restore, cont);
        nqp::push($temp_restore, my @a = cont);
    }
    elsif nqp::istype(cont, Hash) {
        nqp::push($temp_restore, cont);
        nqp::push($temp_restore, my %h = cont);
    }
    elsif nqp::istype(cont, Failure) {
        cont.exception.throw
    }
    else {
        X::Localizer::NoContainer.new(localizer => 'temp').throw;
    }
    cont
}

sub prefix:<let>(\cont) is raw {
    my $let_restore := nqp::getlexcaller('!LET-RESTORE');
    my int $i = nqp::elems($let_restore);
    while $i > 0 {
        $i = $i - 2;
        return-rw cont if nqp::atpos($let_restore, $i) =:= cont;
    }
    if nqp::iscont(cont) {
        nqp::push($let_restore, cont);
        nqp::push($let_restore, nqp::decont(cont));
    }
    elsif nqp::istype(cont, Array) {
        nqp::push($let_restore, cont);
        nqp::push($let_restore, my @a = cont);
    }
    elsif nqp::istype(cont, Hash) {
        nqp::push($let_restore, cont);
        nqp::push($let_restore, my %h = cont);
    }
    elsif nqp::istype(cont, Failure) {
        cont.exception.throw
    }
    else {
        X::Localizer::NoContainer.new(localizer => 'let').throw;
    }
    cont
}

# this implements the ::() indirect lookup
sub INDIRECT_NAME_LOOKUP($root, *@chunks) is raw {
    nqp::if(
      # Note that each part of @chunks itself can contain double colons.
      # That's why joining and re-splitting is necessary
      nqp::elems(my $parts :=
        nqp::split('::',my str $name = @chunks.join('::'))),
      nqp::stmts(
        (my str $first = nqp::shift($parts)),
        nqp::if( # move the sigil to the last part of the name if available
          nqp::elems($parts),
          nqp::stmts(
            (my str $sigil = nqp::substr($first,0,1)),
            nqp::if(
              nqp::iseq_s($sigil,'$')
                || nqp::iseq_s($sigil,'@')
                || nqp::iseq_s($sigil,'%')
                || nqp::iseq_s($sigil,'&'),
              nqp::stmts(
                nqp::push($parts,
                  nqp::concat($sigil,nqp::unbox_s(nqp::pop($parts)))),
                ($first = nqp::substr($first,1))
              )
            ),
            nqp::unless(
              $first,
              nqp::stmts(
                ($first = nqp::shift($parts)),
                ($name  = nqp::join("::",$parts)),
              )
            )
          )
        ),
        (my Mu $thing := nqp::if(
          $root.EXISTS-KEY('%REQUIRE_SYMBOLS')
            && (my $REQUIRE_SYMBOLS := $root.AT-KEY('%REQUIRE_SYMBOLS'))
            && ($REQUIRE_SYMBOLS{$first}:exists),
          $REQUIRE_SYMBOLS{$first},
          nqp::if(
            $root.EXISTS-KEY($first),
            $root.AT-KEY($first),
            nqp::if(
              GLOBAL::.EXISTS-KEY($first),
              GLOBAL::.AT-KEY($first),
              nqp::if(
		nqp::iseq_s($first, 'GLOBAL'),
		GLOBAL,
                X::NoSuchSymbol.new(symbol => $name).fail
              )
            )
          ))),
        nqp::while(
          nqp::elems($parts),
          nqp::if(
            $thing.WHO.EXISTS-KEY(my $part := nqp::shift($parts)),
            ($thing := $thing.WHO.AT-KEY($part)),
            X::NoSuchSymbol.new(symbol => $name).fail
          )
        ),
        $thing
      ),
      X::NoSuchSymbol.new(symbol => $name).fail
    )
}

sub REQUIRE_IMPORT($compunit, $existing-path,$top-existing-pkg,$stubname, *@syms --> Nil) {
    my $handle := $compunit.handle;
    my $DEFAULT := $handle.export-package()<DEFAULT>.WHO;
    my $GLOBALish := $handle.globalish-package;
    my @missing;
    my $block := CALLER::.EXISTS-KEY('%REQUIRE_SYMBOLS')
        ?? CALLER::MY::
        !! CALLER::OUTER::;

    my $targetWHO;
    my $sourceWHO;
    if $existing-path {
        my @existing-path = @$existing-path;
        my $topname := @existing-path.shift;
        $targetWHO := $top-existing-pkg.WHO;
        $sourceWHO := $GLOBALish.AT-KEY($topname).WHO;
        # Yes! the target CAN be the source if it's something like Cool::Utils
        # because Cool is common to both compunits..so no need to do anything
        unless $targetWHO === $sourceWHO {
            # We want to skip over the parts of the Package::That::Already::Existed
            for @existing-path {
                $targetWHO := $targetWHO.AT-KEY($_).WHO;
                $sourceWHO := $sourceWHO.AT-KEY($_).WHO;
            }
            # Now we are just above our target stub. If it exists
            # delete it so it can be replaced by the real one we're importing.
            if $stubname {
                $targetWHO.DELETE-KEY($stubname);
            }
            $targetWHO.merge-symbols($sourceWHO);
        }
    } elsif $stubname {
        $targetWHO := $block.AT-KEY($stubname).WHO;
        $sourceWHO := $GLOBALish.AT-KEY($stubname).WHO;
        $targetWHO.merge-symbols($sourceWHO);
    }
    # Set the runtime values for compile time stub symbols
    for @syms {
        unless $DEFAULT.EXISTS-KEY($_) {
            @missing.push: $_;
            next;
        }
        $block{$_} := $DEFAULT{$_};
    }
    if @missing {
        X::Import::MissingSymbols.new(:from($compunit.short-name), :@missing).throw;
    }
    # Merge GLOBAL from compunit.
    nqp::gethllsym('perl6','ModuleLoader').merge_globals(
        $block<%REQUIRE_SYMBOLS>,
        $GLOBALish,
    );
}

sub infix:<andthen>(+a) {
    # We need to be able to process `Empty` in our args, which we can get
    # when we're chained with, say, `andthen`. Since Empty disappears in normal
    # arg handling, we use nqp::p6argvmarray op to fetch the args, and then
    # emulate the `+@foo` slurpy by inspecting the list the op gave us.
    nqp::if(
      (my int $els = nqp::elems(my $args := nqp::p6argvmarray)),
      nqp::stmts(
        (my $current := nqp::atpos($args, 0)),
        nqp::if( # emulate the +@foo slurpy
          nqp::iseq_i($els, 1) && nqp::istype($current, Iterable),
          nqp::stmts(
            ($args := $current.List),
            ($current := $args[0]),
            $els = $args.elems)),
        (my int $i),
        nqp::until(
          nqp::iseq_i($els, $i = nqp::add_i($i, 1))
          || ( # if $current not defined, set it to Empty and bail from the loop
            nqp::isfalse($current.defined)
            && nqp::stmts(($current := Empty), 1)
          ),
          ($current := nqp::if(
            nqp::istype(($_ := $args[$i]), Callable),
            nqp::if(.count, $_($current), $_()),
            $_)),
          :nohandler), # do not handle control stuff in thunks
        $current), # either the last arg or Empty if any but last were undefined
      True) # We were given no args, return True
}

sub infix:<notandthen>(+a) {
    # We need to be able to process `Empty` in our args, which we can get
    # when we're chained with, say, `andthen`. Since Empty disappears in normal
    # arg handling, we use nqp::p6argvmarray op to fetch the args, and then
    # emulate the `+@foo` slurpy by inspecting the list the op gave us.
    nqp::if(
      (my int $els = nqp::elems(my $args := nqp::p6argvmarray)),
      nqp::stmts(
        (my $current := nqp::atpos($args, 0)),
        nqp::if( # emulate the +@foo slurpy
          nqp::iseq_i($els, 1) && nqp::istype($current, Iterable),
          nqp::stmts(
            ($args := $current.List),
            ($current := $args[0]),
            $els = $args.elems)),
        (my int $i),
        nqp::until(
          nqp::iseq_i($els, $i = nqp::add_i($i, 1))
          || ( # if $current is defined, set it to Empty and bail from the loop
            $current.defined
            && nqp::stmts(($current := Empty), 1)
          ),
          ($current := nqp::if(
            nqp::istype(($_ := $args[$i]), Callable),
            nqp::if(.count, $_($current), $_()),
            $_)),
          :nohandler), # do not handle control stuff in thunks
        $current), # either the last arg or Empty if any but last were undefined
      True) # We were given no args, return True
}

sub infix:<orelse>(+$) {
    # We need to be able to process `Empty` in our args, which we can get
    # when we're chained with, say, `andthen`. Since Empty disappears in normal
    # arg handling, we use nqp::p6argvmarray op to fetch the args, and then
    # emulate the `+@foo` slurpy by inspecting the list the op gave us.
    nqp::if(
      (my int $els = nqp::elems(my $args := nqp::p6argvmarray)),
      nqp::stmts(
        (my $current := nqp::atpos($args, 0)),
        nqp::if( # emulate the +@foo slurpy
          nqp::iseq_i($els, 1) && nqp::istype($current, Iterable),
          nqp::stmts(
            ($args := $current.List),
            ($current := $args[0]),
            $els = $args.elems)),
        (my int $i),
        nqp::until(
          nqp::iseq_i($els, $i = nqp::add_i($i, 1)) || $current.defined,
          ($current := nqp::if(
            nqp::istype(($_ := $args[$i]), Callable),
            nqp::if(.count, $_($current), $_()),
            $_)),
          :nohandler), # do not handle control stuff in thunks
        $current),
      Nil) # We were given no args, return Nil
}

# next three sub would belong to traits.pm if PseudoStash were available
# so early in the setting compunit
multi sub trait_mod:<is>(Routine $r, Str :$equiv!) {
    if (my $i = nqp::index($r.name, ':')) > 0 {
        my \nm ='&' ~ nqp::substr($r.name, 0, $i+1) ~ '<' ~ nqp::escape($equiv) ~ '>';
        trait_mod:<is>($r, equiv => ::(nm));
        return;
    }
    die "Routine given to equiv does not appear to be an operator";;
}

multi sub trait_mod:<is>(Routine $r, Str :$tighter!) {
    if (my $i = nqp::index($r.name, ':')) > 0 {
        my \nm ='&' ~ nqp::substr($r.name, 0, $i+1) ~ '<' ~ nqp::escape($tighter) ~ '>';
        trait_mod:<is>($r, tighter => ::(nm));
        return;
    }
    die "Routine given to tighter does not appear to be an operator";;
}

multi sub trait_mod:<is>(Routine $r, Str :$looser!) {
    if (my $i = nqp::index($r.name, ':')) > 0 {
        my \nm ='&' ~ nqp::substr($r.name, 0, $i+1) ~ '<' ~ nqp::escape($looser) ~ '>';
        trait_mod:<is>($r, looser => ::(nm));
        return;
    }
    die "Routine given to looser does not appear to be an operator";;
}

proto sub infix:<> (&?, &?) {*}
multi sub infix:<> () { *.self }
multi sub infix:<> (&f) { &f }
multi sub infix:<> (&f, &g --> Block:D) {
    my \ret = &f.count > 1
        ?? -> |args { f |g |args }
        !! -> |args { f  g |args }

    my role FakeSignature[$arity, $count, $of] {
        method arity { $arity }
        method count { $count }
        method of    { $of    }
    }
    ret.^mixin(FakeSignature[&g.arity, &g.count, &f.of]);
    ret
}
my &infix:<o> := &infix:<>;

#line 1 SETTING::src/core/metaops.pm

sub METAOP_ASSIGN(\op) {
    -> Mu \a, Mu \b { a = op.( ( a.DEFINITE ?? a !! op.() ), b) }
}

sub METAOP_TEST_ASSIGN:<//>(\lhs, $rhs) is raw { lhs // (lhs = $rhs()) }
sub METAOP_TEST_ASSIGN:<||>(\lhs, $rhs) is raw { lhs || (lhs = $rhs()) }
sub METAOP_TEST_ASSIGN:<&&>(\lhs, $rhs) is raw { lhs && (lhs = $rhs()) }
sub METAOP_TEST_ASSIGN:<or>(\lhs, $rhs) is raw { lhs or (lhs = $rhs()) }
sub METAOP_TEST_ASSIGN:<and>(       \lhs, $rhs) is raw { lhs and        (lhs = $rhs()) }
sub METAOP_TEST_ASSIGN:<andthen>(   \lhs, $rhs) is raw { lhs andthen    (lhs = $rhs()) }
sub METAOP_TEST_ASSIGN:<notandthen>(\lhs, $rhs) is raw { lhs notandthen (lhs = $rhs()) }
sub METAOP_TEST_ASSIGN:<orelse>(    \lhs, $rhs) is raw { lhs orelse     (lhs = $rhs()) }

sub METAOP_NEGATE(\op) {
    -> |c { c.elems > 1 ?? !op.(|c) !! True }
}

sub METAOP_REVERSE(\op) {
    -> |args { op.(|args.reverse) }
}

sub METAOP_CROSS(\op, &reduce) {
    nqp::if(op.prec('thunky').starts-with('.'),
    -> +lol {
        my $rop = lol.elems == 2 ?? op !! &reduce(op);
        my $laze = False;
        my @loi = eager for lol -> \elem {
            if nqp::iscont(elem) {
                $laze = False;
                (elem,).iterator
            }
            else {
                $laze = True if elem.is-lazy;
                elem.iterator
            }
        }
        my Mu $cache := nqp::list();
        my int $i = 0;
        for ^lol.elems {
            $i = $_;
            my Mu $rpa := nqp::list();
            nqp::bindpos($cache, $i, $rpa);
        }
        my int $n = lol.elems - 1;
        my $j = 0;
        my @j;
        my @v;

        $i = 0;
        gather {
            while $i >= 0 {
                my Mu $sublist := nqp::atpos($cache, $i);
                if $j < nqp::elems($sublist) {
                    my Mu $o := nqp::atpos($sublist, $j);
                    @v[$i] := $o;
                    $j = $j + 1;
                    if $i >= $n { take lol.elems == 2 ?? $rop(|@v) !! $rop(@v); }
                    else { $i = $i + 1; @j.push($j); $j = 0; }
                }
                elsif nqp::not_i(nqp::eqaddr((my \value = @loi[$i].pull-one),IterationEnd)) {
                    nqp::bindpos($sublist, $j, value);
                    redo;
                }
                else {
                    $i = $i - 1;
                    if $i { $j = @j.pop if $i > 0 }  # continue previous dimension where we left off
                    else  {
                        $j = 0;
                        my Mu $sublist := nqp::atpos($cache,$i);
                        nqp::pop($sublist);          # don't cache 1st dimension (could be infinite)
                    }
                }
            }
        }.lazy-if($laze);
    },
    -> +lol {
        Seq.new(Rakudo::Iterator.CrossIterablesOp(lol,op))
    }
    )
}

sub METAOP_ZIP(\op, &reduce) {
   nqp::if(op.prec('thunky').starts-with('.'),
   -> +lol {
        my $arity = lol.elems;
        my $rop = $arity == 2 ?? op !! &reduce(op);
        my $laze = True;
        my @loi = eager for lol -> \elem {
            if nqp::iscont(elem) {
                $laze = False;
                Rakudo::Iterator.OneValue(elem)
            }
            else {
                $laze = False unless elem.is-lazy;
                Rakudo::Iterator.Whatever(elem.iterator)
            }
        }
        gather {
            loop {
                my \z = @loi.map: {
                    my \value = .pull-one;
                    last if nqp::eqaddr(value,IterationEnd);
                    value
                };
                my $z = List.from-iterator(z.iterator);
                $z.eager;
                last if $z.elems < $arity;
                take-rw $arity == 2 ?? $rop(|$z) !! $rop(@$z);
            }
        }.lazy-if($laze)
    },
    -> +lol {
        Seq.new(Rakudo::Iterator.ZipIterablesOp(lol,op))
    }
    )
}

proto sub METAOP_REDUCE_LEFT(|) { * }
multi sub METAOP_REDUCE_LEFT(\op, \triangle) {
    if op.count > 2 and op.count < Inf {
        my $count = op.count;
        sub (+values) {
            my \source = values.iterator;

            my \first = source.pull-one;
            return () if nqp::eqaddr(first,IterationEnd);

            my @args.push: first;
            GATHER({
                take first;
                until nqp::eqaddr((my \current = source.pull-one),IterationEnd) {
                    @args.push: current;
                    if @args.elems == $count {
                        my \val = op.(|@args);
                        take val;
                        @args = ();
                        @args.push: val;  # use of push allows op to return a Slip
                    }
                }
            }).lazy-if(source.is-lazy);
        }
    }
    else {
        sub (+values) {
            my \source = values.iterator;

            my \first = source.pull-one;
            return () if nqp::eqaddr(first,IterationEnd);

            my $result := first;
            GATHER({
                take first;
                until nqp::eqaddr((my \value = source.pull-one),IterationEnd) {
                    take ($result := op.($result, value));
                }
            }).lazy-if(source.is-lazy);
        }
    }
}

multi sub METAOP_REDUCE_LEFT(\op) {
    if op.count > 2 and op.count < Inf {
        my $count = op.count;
        sub (+values) {
            my \iter = values.iterator;
            my \first = iter.pull-one;
            return op.() if nqp::eqaddr(first,IterationEnd);

            my @args.push: first;
            my $result := first;
            until nqp::eqaddr((my \value = iter.pull-one),IterationEnd) {
                @args.push: value;
                if @args.elems == $count {
                    my \val = op.(|@args);
                    @args = ();
                    @args.push: val;  # use of push allows op to return a Slip
                    $result := val;
                }
            }
            $result;
        }
    }
    else {
        nqp::eqaddr(op,&infix:<+>)
        ?? &sum
        !! sub (+values) {
            nqp::stmts(
              (my $iter := values.iterator),
              nqp::if(
                nqp::eqaddr((my $result := $iter.pull-one),IterationEnd),
                op.(),                         # identity
                nqp::if(
                  nqp::eqaddr((my $value := $iter.pull-one),IterationEnd),
                  nqp::if(
                    nqp::isle_i(op.arity,1),
                    op.($result),              # can call with 1 param
                    $result                    # what we got
                  ),
                  nqp::stmts(
                    ($result := op.($result,$value)),
                    nqp::until(
                      nqp::eqaddr(($value := $iter.pull-one),IterationEnd),
                      ($result := op.($result,$value))
                    ),
                    $result                    # final result
                  )
                )
              )
            )
        }
    }
}

proto sub METAOP_REDUCE_RIGHT(|) { * }
multi sub METAOP_REDUCE_RIGHT(\op, \triangle) {
    nqp::if(
      op.count < Inf && nqp::isgt_i((my int $count = op.count),2),
      sub (+values) {
          Seq.new(nqp::if(
            nqp::isge_i((my int $i = (my $v :=
                nqp::if(nqp::istype(values,List),values,values.List)
              ).elems),                                       # reifies
              $count
            ),   # reifies
            class :: does Iterator {
                has $!op;
                has $!reified;
                has $!result;
                has int $!count;
                has int $!i;
                method !SET-SELF(\op,\list,\count,\index) {
                    nqp::stmts(
                      ($!op := op),
                      ($!reified := nqp::getattr(list,List,'$!reified')),
                      ($!count = count),
                      ($!i = index),
                      self
                    )
                }
                method new(\op,\list,\count,\index) {
                    nqp::create(self)!SET-SELF(op,list,count,index)
                }
                method pull-one() is raw {
                    nqp::if(
                      nqp::attrinited(self,self.WHAT,'$!result'),
                      nqp::stmts(
                        (my $args := nqp::list($!result)),
                        nqp::until(
                          nqp::iseq_i(nqp::elems($args),$!count)
                            || nqp::islt_i(($!i = nqp::sub_i($!i,1)),0),
                          nqp::unshift($args,nqp::atpos($!reified,$!i))
                        ),
                        nqp::if(
                          nqp::isgt_i(nqp::elems($args),1),
                          ($!result := op.(|nqp::hllize($args))),
                          IterationEnd
                        )
                      ),
                      ($!result := nqp::atpos(
                        $!reified,
                        ($!i = nqp::sub_i($!i,1))
                      ))
                    )
                }
                method bool-only(--> True) { };
                method count-only() { nqp::p6box_i($!i) }
            }.new(op,$v,$count,$i),
            Rakudo::Iterator.OneValue(
              nqp::if(
                $i,
                op.(|nqp::getattr($v,List,'$!reified')),
                op.()
              )
            )
          ))
      },
      sub (+values) {
          Seq.new(nqp::if(
            nqp::isgt_i((my int $i = (my $v :=
                nqp::if(nqp::istype(values,List),values,values.List)
              ).elems),                                       # reifies
              1
            ),
            class :: does Iterator {
                has $!op;
                has $!reified;
                has $!result;
                has int $!i;
                method !SET-SELF(\op,\list,\count) {
                    nqp::stmts(
                      ($!op := op),
                      ($!reified := nqp::getattr(list,List,'$!reified')),
                      ($!i = count),
                      self
                    )
                }
                method new(\op,\li,\co) { nqp::create(self)!SET-SELF(op,li,co) }
                method pull-one() is raw {
                    nqp::if(
                      nqp::attrinited(self,self.WHAT,'$!result'),
                      nqp::if(
                        nqp::isge_i(($!i = nqp::sub_i($!i,1)),0),
                        ($!result := $!op.(nqp::atpos($!reified,$!i),$!result)),
                        IterationEnd
                      ),
                      ($!result := nqp::atpos(
                        $!reified,
                        ($!i = nqp::sub_i($!i,1))
                      ))
                    )
                }
                method bool-only(--> True) { };
                method count-only() { nqp::p6box_i($!i) }
            }.new(op,$v,$i),
            Rakudo::Iterator.OneValue(
              nqp::if(
                $i,
                op.(nqp::atpos(nqp::getattr($v,List,'$!reified'),0)),
                op.()
              )
            )
          ))
      }
    )
}
multi sub METAOP_REDUCE_RIGHT(\op) {
    nqp::if(
      op.count < Inf && nqp::isgt_i((my int $count = op.count),2),
      sub (+values) {
          nqp::if(
            nqp::isge_i((my int $i = (my $v :=
                nqp::if(nqp::istype(values,List),values,values.List)
              ).elems),                                       # reifies
              $count
            ),   # reifies
            nqp::stmts(
              (my $args := nqp::list(
                my $result := nqp::atpos(
                  (my $reified := nqp::getattr($v,List,'$!reified')),
                  ($i = nqp::sub_i($i,1))
                )
              )),
              nqp::until(
                nqp::islt_i(($i = nqp::sub_i($i,1)),0),
                nqp::stmts(
                  nqp::unshift($args,nqp::atpos($reified,$i)),
                  nqp::if(
                    nqp::iseq_i(nqp::elems($args),$count),
                    nqp::stmts(
                      ($result := op.(|nqp::hllize($args))),
                      nqp::bindpos(nqp::setelems($args,1),0,$result)
                    )
                  )
                )
              ),
              nqp::if(
                nqp::isgt_i(nqp::elems($args),1),
                op.(|nqp::hllize($args)),    # something left to process
                $result
              )
            ),
            nqp::if(
              $i,
              op.(|nqp::getattr($v,List,'$!reified')),
              op.()
            )
        )
      },
      sub (+values) {
          nqp::if(
            nqp::isgt_i((my int $i = (my $v :=
                nqp::if(nqp::istype(values,List),values,values.List)
              ).elems),                                       # reifies
              1
            ),
            nqp::stmts(
              (my $result := nqp::atpos(
                nqp::getattr($v,List,'$!reified'),
                ($i = nqp::sub_i($i,1))
              )),
              nqp::while(
                nqp::isge_i(($i = nqp::sub_i($i,1)),0),
                ($result := op.(
                  nqp::atpos(nqp::getattr($v,List,'$!reified'),$i),
                  $result
                ))
              ),
              $result
            ),
            nqp::if(
              $i,
              op.(nqp::atpos(nqp::getattr($v,List,'$!reified'),0)),
              op.()
            )
          )
      }
    )
}

proto sub METAOP_REDUCE_LIST(|) { * }
multi sub METAOP_REDUCE_LIST(\op, \triangle) {
    sub (+values) {
        GATHER({
            my @list;
            for values -> \v {
                @list.push(v);
                take op.(|@list);
            }
        }).lazy-if(values.is-lazy);
    }
}
multi sub METAOP_REDUCE_LIST(\op) {
    sub (+values) { op.(|values) }
}

proto sub METAOP_REDUCE_LISTINFIX(|) { * }
multi sub METAOP_REDUCE_LISTINFIX(\op, \triangle) {
    sub (|values) {
        my \p = values[0];
        return () unless p.elems;

        my int $i;
        GATHER({
            my @list;
            while $i < p.elems {
                @list.push(p[$i++]);
                take op.(|@list.map({nqp::decont($_)}));
            }
        }).lazy-if(p.is-lazy);
    }
}
multi sub METAOP_REDUCE_LISTINFIX(\op) {
    sub (+values) {
        op.(|values.map({nqp::decont($_)}));
    }
}

proto sub METAOP_REDUCE_CHAIN(|) { * }
multi sub METAOP_REDUCE_CHAIN(\op, \triangle) {
    sub (+values) {
        my $state = True;
        my \iter = values.iterator;
        my Mu $current = iter.pull-one;
        gather {
            take $state;
            while $state && nqp::not_i(nqp::eqaddr((my $next := iter.pull-one),IterationEnd)) {
                $state = op.($current, $next);
                take $state;
                $current := $next;
            }
            unless $state {
                take False until nqp::eqaddr(iter.pull-one,IterationEnd);
            }
        }.lazy-if(values.is-lazy);
    }
}
multi sub METAOP_REDUCE_CHAIN(\op) {
    sub (+values) {
        nqp::if(
          nqp::eqaddr(
            (my $current := (my $iter := values.iterator).pull-one),
            IterationEnd
          ),
          True,
          nqp::stmts(
            nqp::while(
              nqp::not_i(nqp::eqaddr((my $next := $iter.pull-one),IterationEnd))
                && op.($current,$next),
              $current := $next
            ),
            nqp::p6bool(nqp::eqaddr($next,IterationEnd))
          )
        )
    }
}

sub METAOP_REDUCE_XOR(\op, $triangle?) {
    X::NYI.new(feature => 'xor reduce').throw;
}

sub METAOP_HYPER(\op, *%opt) {
    -> Mu \a, Mu \b { HYPER(op, a, b, |%opt) }
}

proto sub METAOP_HYPER_POSTFIX(|) {*}
multi sub METAOP_HYPER_POSTFIX(\op) {
    nqp::if(
      nqp::can(op,"nodal"),
      (-> \obj { nodemap(op, obj) }),
      (-> \obj { deepmap(op, obj) })
    )
}

# no indirection for subscripts and such
proto sub METAOP_HYPER_POSTFIX_ARGS(|) {*}
multi sub METAOP_HYPER_POSTFIX_ARGS(\obj,\op) {
    nqp::if(
      nqp::can(op,"nodal"),
      nodemap(op, obj),
      deepmap(op, obj)
    )
}
multi sub METAOP_HYPER_POSTFIX_ARGS(\obj, @args, \op) {
    nqp::if(
      nqp::can(op,"nodal"),
      nodemap( -> \o { op.(o,@args) }, obj ),
      deepmap( -> \o { op.(o,@args) }, obj )
    )
}
multi sub METAOP_HYPER_POSTFIX_ARGS(\obj, \args, \op) {
    nqp::if(
      nqp::can(op,"nodal"),
      nodemap( -> \o { op.(o,|args) }, obj ),
      deepmap( -> \o { op.(o,|args) }, obj )
    )
}

sub METAOP_HYPER_PREFIX(\op) {
    nqp::if(
      nqp::can(op,"nodal"),      # rarely true for prefixes
      (-> \obj { nodemap(op, obj) }),
      (-> \obj { deepmap(op, obj) })
    )
}

sub METAOP_HYPER_CALL(\list, |args) { deepmap(-> $c { $c(|args) }, list) }

proto sub HYPER(|) { * }

multi sub HYPER(&op, \left, \right, :$dwim-left, :$dwim-right) {
    op(left, right);
}

multi sub HYPER(&op, Associative:D \left, Associative:D \right, :$dwim-left, :$dwim-right) {
    my %keyset;
    if !$dwim-left {
        %keyset{$_} = 1 for left.keys;
    }
    else {
        %keyset{$_} = 1 if right.EXISTS-KEY($_) for left.keys;
    }
    if !$dwim-right {
        %keyset{$_} = 1 for right.keys;
    }
    my @keys = %keyset.keys;
    my $type = left.WHAT;
    my \result := $type.new;
    result = quietly @keys Z=> HYPER(&op, left{@keys}, right{@keys}, :$dwim-left, :$dwim-right);
    nqp::iscont(left) ?? result.item !! result;
}

multi sub HYPER(&op, Associative:D \left, \right, :$dwim-left, :$dwim-right) {
    my @keys = left.keys;
    my $type = left.WHAT;
    my \result := $type.new;
    result = @keys Z=> HYPER(&op, left{@keys}, right, :$dwim-left, :$dwim-right);
    nqp::iscont(left) ?? result.item !! result;
}

multi sub HYPER(&op, \left, Associative:D \right, :$dwim-left, :$dwim-right) {
    my @keys = right.keys;
    my $type = right.WHAT;
    my \result := $type.new;
    result = @keys Z=> HYPER(&op, left, right{@keys}, :$dwim-left, :$dwim-right);
    nqp::iscont(right) ?? result.item !! result;
}

multi sub HYPER(&operator, Positional:D \left, \right, :$dwim-left, :$dwim-right) {
    my @result;
    X::HyperOp::Infinite.new(:side<left>, :&operator).throw if left.is-lazy;
    my int $elems = left.elems;
    X::HyperOp::NonDWIM.new(:&operator, :left-elems($elems), :right-elems(1), :recursing(callframe(3).code.name eq 'HYPER')).throw
        unless $elems == 1 or $elems > 1 and $dwim-right or $elems == 0 and $dwim-left || $dwim-right;
    my \lefti := left.iterator;
    my int $i = 0;
    until nqp::eqaddr((my \value := lefti.pull-one),IterationEnd) {
        @result[$i++] := HYPER(&operator, value, right, :$dwim-left, :$dwim-right);
    }
    # Coerce to the original type if it's a subtype of List
    my $type = nqp::istype(left, List) ?? left.WHAT !! List;
    nqp::iscont(left) ?? $type(|@result.eager).item !! $type(|@result.eager)
}

multi sub HYPER(&operator, \left, Positional:D \right, :$dwim-left, :$dwim-right) {
    my @result;
    X::HyperOp::Infinite.new(:side<right>, :&operator).throw if right.is-lazy;
    my int $elems = right.elems;
    X::HyperOp::NonDWIM.new(:&operator, :left-elems(1), :right-elems($elems), :recursing(callframe(3).code.name eq 'HYPER')).throw
        unless $elems == 1 or $elems > 1 and $dwim-left or $elems == 0 and $dwim-left || $dwim-right;
    my \righti := right.iterator;
    my int $i = 0;
    until nqp::eqaddr((my \value := righti.pull-one),IterationEnd) {
        @result[$i++] := HYPER(&operator, left, value, :$dwim-left, :$dwim-right);
    }
    # Coerce to the original type if it's a subtype of List
    my $type = nqp::istype(right, List) ?? right.WHAT !! List;
    nqp::iscont(right) ?? $type(|@result.eager).item !! $type(|@result.eager)
}

multi sub HYPER(&operator, Iterable:D \left, Iterable:D \right, :$dwim-left, :$dwim-right) {
    my \left-iterator = left.iterator;
    my \right-iterator = right.iterator;

    # Check whether any side is lazy. They must not be to proceed.
    if left-iterator.is-lazy {
        X::HyperOp::Infinite.new(:side<both>, :&operator).throw if right-iterator.is-lazy;
        X::HyperOp::Infinite.new(:side<left>, :&operator).throw if not $dwim-left or $dwim-right;
    }
    X::HyperOp::Infinite.new(:side<right>, :&operator).throw if right-iterator.is-lazy and
        (not $dwim-right or $dwim-left);

    my \lefti  := Rakudo::Iterator.DWIM(left-iterator);
    my \righti := Rakudo::Iterator.DWIM(right-iterator);

    my \result := IterationBuffer.new;
    loop {
        my \leftv := lefti.pull-one;
        my \rightv := righti.pull-one;

        X::HyperOp::NonDWIM.new(:&operator, :left-elems(lefti.count-elems), :right-elems(righti.count-elems), :recursing(callframe(3).code.name eq 'HYPER')).throw
            if !$dwim-left and !$dwim-right and (lefti.ended != righti.ended);

        last if ($dwim-left and $dwim-right) ?? (lefti.ended and righti.ended) !!
               (($dwim-left or lefti.ended) and ($dwim-right or righti.ended));
        last if $++ == 0 and ($dwim-left and lefti.ended or $dwim-right and righti.ended);

        nqp::push(result,HYPER(&operator, leftv, rightv, :$dwim-left, :$dwim-right));
    }

    # Coerce to the original type
    my $type = nqp::istype(left, List) ?? left.WHAT !! List; # keep subtypes of List
    my \retval = $type.new;
    nqp::bindattr(retval, List, '$!reified', result);
    nqp::iscont(left) ?? retval.item !! retval;
}

multi sub HYPER(\op, \obj) {
    nqp::if(
      nqp::can(op,"nodal"),
      nodemap(op, obj),
      deepmap(op,obj)
    )
}

proto sub deepmap(|) { * }

multi sub deepmap(\op, \obj) {
    Rakudo::Internals.coremap(op, obj, :deep)
}

multi sub deepmap(\op, Associative \h) {
    my @keys = h.keys;
    hash @keys Z deepmap(op, h{@keys})
}

proto sub nodemap(|) { * }
multi sub nodemap(\op, \obj) {
    my Mu $rpa := nqp::create(IterationBuffer);
    my \objs := obj.list;
    # as a wanted side-effect is-lazy reifies the list
    fail X::Cannot::Lazy.new(:action('deepmap')) if objs.is-lazy;
    my Mu $items := nqp::getattr(objs, List, '$!reified');
    my Mu $o;
    # We process the elements in two passes, end to start, to
    # prevent users from relying on a sequential ordering of hyper.
    # Also, starting at the end pre-allocates $rpa for us.
    my int $i = nqp::elems($items) - 1;
    nqp::while(
        nqp::isge_i($i, 0),
        nqp::stmts(
            ($o := nqp::atpos($items, $i)),
            nqp::bindpos($rpa, $i,
                nqp::if(Mu,             # hack cuz I don't understand nqp
                        $o.new(nodemap(op, $o)).item,
                        op.($o))),
            $i = nqp::sub_i($i, 2)
        )
    );
    $i = nqp::elems($items) - 2;
    nqp::while(
        nqp::isge_i($i, 0),
        nqp::stmts(
            ($o := nqp::atpos($items, $i)),
            nqp::bindpos($rpa, $i,
                nqp::if(Mu,             # hack cuz I don't understand nqp
                        $o.new(nodemap(op, $o)).item,
                        op.($o))),
            $i = nqp::sub_i($i, 2)
        )
    );
    nqp::p6bindattrinvres(nqp::create(List), List, '$!reified', $rpa)
}

multi sub nodemap(\op, Associative \h) {
    my @keys = h.keys;
    hash @keys Z nodemap(op, h{@keys})
}

proto sub duckmap(|) { * }
multi sub duckmap(\op, \obj) {
    Rakudo::Internals.coremap(sub (\arg) { CATCH { return arg ~~ Iterable:D ?? duckmap(op,arg) !! arg }; op.(arg); }, obj);
}

multi sub duckmap(\op, Associative \h) {
    my @keys = h.keys;
    hash @keys Z duckmap(op, h{@keys})
}

#line 1 SETTING::src/core/precedence.pm
# We attach precedence information to all operators here. This is instead of
# putting the traits directly on the op bodies, since some of the things that
# the traits are implemented using aren't defined that early.
BEGIN {
    my Mu $methodcall       := nqp::hash('prec', 'y=');
    my Mu $autoincrement    := nqp::hash('prec', 'x=');
    my Mu $exponentiation   := nqp::hash('prec', 'w=', 'assoc', 'right');
    my Mu $symbolic_unary   := nqp::hash('prec', 'v=');
    my Mu $multiplicative   := nqp::hash('prec', 'u=', 'assoc', 'left');
    my Mu $iffy             := nqp::hash('prec', 'u=', 'assoc', 'left', 'iffy', 1);
    my Mu $additive         := nqp::hash('prec', 't=', 'assoc', 'left');
    my Mu $replication      := nqp::hash('prec', 's=', 'assoc', 'left');
    my Mu $replication_xx   := nqp::hash('prec', 's=', 'assoc', 'left', 'thunky', 't.');
    my Mu $concatenation    := nqp::hash('prec', 'r=', 'assoc', 'list');
    my Mu $junctive_and     := nqp::hash('prec', 'q=', 'assoc', 'list');
    my Mu $junctive_or      := nqp::hash('prec', 'p=', 'assoc', 'list');
    my Mu $structural       := nqp::hash('prec', 'n=', 'assoc', 'non');
    my Mu $chaining         := nqp::hash('prec', 'm=', 'assoc', 'chain', 'iffy', 1, 'pasttype', 'chain');
    my Mu $tight_and        := nqp::hash('prec', 'l=', 'assoc', 'list', 'thunky', '.t');
    my Mu $tight_or         := nqp::hash('prec', 'k=', 'assoc', 'list', 'thunky', '.t');
    my Mu $tight_or_xor     := nqp::hash('prec', 'k=', 'assoc', 'list', 'thunky', '..t');
    my Mu $tight_or_minmax  := nqp::hash('prec', 'k=', 'assoc', 'list');
    my Mu $item_assignment  := nqp::hash('prec', 'i=', 'assoc', 'right');
    my Mu $loose_unary      := nqp::hash('prec', 'h=');
    my Mu $comma            := nqp::hash('prec', 'g=', 'assoc', 'list');
    my Mu $list_infix       := nqp::hash('prec', 'f=', 'assoc', 'list');
    my Mu $list_prefix      := nqp::hash('prec', 'e=');
    my Mu $loose_and        := nqp::hash('prec', 'd=', 'assoc', 'list', 'thunky', '.t');
    my Mu $loose_andthen    := nqp::hash('prec', 'd=', 'assoc', 'list', 'thunky', '.b');
    my Mu $loose_or         := nqp::hash('prec', 'c=', 'assoc', 'list', 'thunky', '.t');
    my Mu $loose_orelse     := nqp::hash('prec', 'c=', 'assoc', 'list', 'thunky', '.b');

    trait_mod:<is>(&postfix:<i>, :prec($methodcall));
    trait_mod:<is>(&postcircumfix:<[ ]>, :prec($methodcall));
    trait_mod:<is>(&postcircumfix:<[ ]>, :nodal);
    trait_mod:<is>(&postcircumfix:<{ }>, :prec($methodcall));
    trait_mod:<is>(&postcircumfix:<{ }>, :nodal);

    trait_mod:<is>(&prefix:<++>,  :prec($autoincrement));
    trait_mod:<is>(&prefix:<-->,  :prec($autoincrement));
    trait_mod:<is>(&postfix:<++>, :prec($autoincrement));
    trait_mod:<is>(&postfix:<-->, :prec($autoincrement));

    trait_mod:<is>(&infix:<**>, :prec($exponentiation));

    trait_mod:<is>(&prefix:<+>,  :prec($symbolic_unary));
    trait_mod:<is>(&prefix:<~>,  :prec($symbolic_unary));
    trait_mod:<is>(&prefix:<->,  :prec($symbolic_unary));
    trait_mod:<is>(&prefix:<?>,  :prec($symbolic_unary));
    trait_mod:<is>(&prefix:<!>,  :prec($symbolic_unary));
    trait_mod:<is>(&prefix:<|>,  :prec($symbolic_unary));
    trait_mod:<is>(&prefix:<+^>, :prec($symbolic_unary));
    trait_mod:<is>(&prefix:<~^>, :prec($symbolic_unary));
    trait_mod:<is>(&prefix:<?^>, :prec($symbolic_unary));
    trait_mod:<is>(&prefix:<^>,  :prec($symbolic_unary));

    trait_mod:<is>(&infix:<*>,   :prec($multiplicative));
    trait_mod:<is>(&infix:</>,   :prec($multiplicative));
    trait_mod:<is>(&infix:<div>, :prec($multiplicative));
    trait_mod:<is>(&infix:<gcd>, :prec($multiplicative));
    trait_mod:<is>(&infix:<lcm>, :prec($multiplicative));
    trait_mod:<is>(&infix:<%>,   :prec($multiplicative));
    trait_mod:<is>(&infix:<mod>, :prec($multiplicative));
    trait_mod:<is>(&infix:<+&>,  :prec($multiplicative));
    trait_mod:<is>(&infix:<~&>,  :prec($multiplicative));
    trait_mod:<is>(&infix:<?&>,  :prec($multiplicative));

    trait_mod:<is>(&infix:<%%>,  :prec($iffy));

    trait_mod:<is>(&infix:<+>,  :prec($additive));
    trait_mod:<is>(&infix:<->,  :prec($additive));
    trait_mod:<is>(&infix:<+|>, :prec($additive));
    trait_mod:<is>(&infix:<+^>, :prec($additive));
    trait_mod:<is>(&infix:<~|>, :prec($additive));
    trait_mod:<is>(&infix:<~^>, :prec($additive));
    trait_mod:<is>(&infix:<?|>, :prec($additive));
    trait_mod:<is>(&infix:<?^>, :prec($additive));

    trait_mod:<is>(&infix:<x>,  :prec($replication));
    trait_mod:<is>(&infix:<xx>, :prec($replication_xx));

    trait_mod:<is>(&infix:<~>, :prec($concatenation));

    trait_mod:<is>(&infix:<&>,   :prec($junctive_and));
    trait_mod:<is>(&infix:<(&)>, :prec($junctive_and));
# U+2229 INTERSECTION
    trait_mod:<is>(&infix:<>,   :prec($junctive_and));
    trait_mod:<is>(&infix:<(.)>, :prec($junctive_and));
# U+228D MULTISET MULTIPLICATION
    trait_mod:<is>(&infix:<>,   :prec($junctive_and));

    trait_mod:<is>(&infix:<|>,   :prec($junctive_or));
    trait_mod:<is>(&infix:<^>,   :prec($junctive_or));
    trait_mod:<is>(&infix:<(+)>, :prec($junctive_or));
# U+228E MULTISET UNION
    trait_mod:<is>(&infix:<>,   :prec($junctive_or));
    trait_mod:<is>(&infix:<(|)>, :prec($junctive_or));
# U+222A UNION
    trait_mod:<is>(&infix:<>,   :prec($junctive_or));
    trait_mod:<is>(&infix:<(-)>, :prec($junctive_or));
# U+2216 SET MINUS
    trait_mod:<is>(&infix:<>,   :prec($junctive_or));
    trait_mod:<is>(&infix:<(^)>, :prec($junctive_or));
# U+2296 CIRCLED MINUS
    trait_mod:<is>(&infix:<>,   :prec($junctive_or));

    trait_mod:<is>(&infix:<==>,     :prec($chaining));
    trait_mod:<is>(&infix:<!=>,     :prec($chaining));
    trait_mod:<is>(&infix:<eq>,     :prec($chaining));
    trait_mod:<is>(&infix:<ne>,     :prec($chaining));
    trait_mod:<is>(&infix:<le>,     :prec($chaining));
    trait_mod:<is>(&infix:<ge>,     :prec($chaining));
    trait_mod:<is>(&infix:<lt>,     :prec($chaining));
    trait_mod:<is>(&infix:<gt>,     :prec($chaining));
    trait_mod:<is>(&infix:<=:=>,    :prec($chaining));
    trait_mod:<is>(&infix:<===>,    :prec($chaining));
    trait_mod:<is>(&infix:<eqv>,    :prec($chaining));
    trait_mod:<is>(&infix:<before>, :prec($chaining));
    trait_mod:<is>(&infix:<after>,  :prec($chaining));
    trait_mod:<is>(&infix:<~~>,     :prec($chaining));
    trait_mod:<is>(&infix:<(elem)>, :prec($chaining));
# U+2208 ELEMENT OF
    trait_mod:<is>(&infix:<>,      :prec($chaining));
# U+2209 NOT AN ELEMENT OF
    trait_mod:<is>(&infix:<>,      :prec($chaining));
    trait_mod:<is>(&infix:<(cont)>, :prec($chaining));
# U+220B CONTAINS AS MEMBER
    trait_mod:<is>(&infix:<>,      :prec($chaining));
# U+220C DOES NOT CONTAIN AS MEMBER
    trait_mod:<is>(&infix:<>,      :prec($chaining));
    trait_mod:<is>(&infix:<<(<)>>,  :prec($chaining));
# U+2282 SUBSET OF
    trait_mod:<is>(&infix:<>,      :prec($chaining));
# U+2284 NOT A SUBSET OF
    trait_mod:<is>(&infix:<>,      :prec($chaining));
    trait_mod:<is>(&infix:<<(>)>>,  :prec($chaining));
# U+2283 SUPERSET OF
    trait_mod:<is>(&infix:<>,      :prec($chaining));
# U+2285 NOT A SUPERSET OF
    trait_mod:<is>(&infix:<>,      :prec($chaining));
    trait_mod:<is>(&infix:<<(<=)>>, :prec($chaining));
# U+2286 SUBSET OF OR EQUAL TO
    trait_mod:<is>(&infix:<>,      :prec($chaining));
# U+2288 NEITHER A SUBSET OF NOR EQUAL TO
    trait_mod:<is>(&infix:<>,      :prec($chaining));
    trait_mod:<is>(&infix:<<(>=)>>, :prec($chaining));
# U+2287 SUPERSET OF OR EQUAL TO
    trait_mod:<is>(&infix:<>,      :prec($chaining));
# U+2289 NEITHER A SUPERSET OF NOR EQUAL TO
    trait_mod:<is>(&infix:<>,      :prec($chaining));
    trait_mod:<is>(&infix:<<(<+)>>, :prec($chaining));
# U+227C PRECEDES OR EQUAL TO
    trait_mod:<is>(&infix:<>,      :prec($chaining));
    trait_mod:<is>(&infix:<<(>+)>>, :prec($chaining));
# U+227D SUCCEEDS OR EQUAL TO
    trait_mod:<is>(&infix:<>,      :prec($chaining));

    trait_mod:<is>(&infix:<..>,     :prec($structural));
    trait_mod:<is>(&infix:<^..>,    :prec($structural));
    trait_mod:<is>(&infix:<..^>,    :prec($structural));
    trait_mod:<is>(&infix:<^..^>,   :prec($structural));
    trait_mod:<is>(&infix:<leg>,    :prec($structural));
    trait_mod:<is>(&infix:<cmp>,    :prec($structural));
    trait_mod:<is>(&infix:<unicmp>, :prec($structural));
    trait_mod:<is>(&infix:<coll>,   :prec($structural));
    trait_mod:<is>(&infix:<but>,    :prec($structural));
    trait_mod:<is>(&infix:<does>,   :prec($structural));

    trait_mod:<is>(&infix:<&&>, :prec($tight_and));

    trait_mod:<is>(&infix:<||>,  :prec($tight_or));
    trait_mod:<is>(&infix:<^^>,  :prec($tight_or_xor));
    trait_mod:<is>(&infix:<//>,  :prec($tight_or));
    trait_mod:<is>(&infix:<min>, :prec($tight_or_minmax));
    trait_mod:<is>(&infix:<max>, :prec($tight_or_minmax));

    #trait_mod:<is>(&infix:<ff>,  :prec($conditional_ff));
    #trait_mod:<is>(&infix:<fff>, :prec($conditional_ff));

    trait_mod:<is>(&infix:<< => >>, :prec($item_assignment));

    trait_mod:<is>(&prefix:<so>,   :prec($loose_unary));
    trait_mod:<is>(&prefix:<not>,  :prec($loose_unary));

    trait_mod:<is>(&infix:<,>, :prec($comma));

    trait_mod:<is>(&infix:<Z>,      :prec($list_infix));
    trait_mod:<is>(&infix:<X>,      :prec($list_infix));
    trait_mod:<is>(&infix:<...>,    :prec($list_infix));
    trait_mod:<is>(&infix:<minmax>, :prec($list_infix));

    trait_mod:<is>(&infix:<=>,   :prec($list_prefix));
    #trait_mod:<is>(&infix:<:=>,  :prec($list_prefix));
    #trait_mod:<is>(&infix:<::=>, :prec($list_prefix));

    trait_mod:<is>(&infix:<and>,     :prec($loose_and));
    trait_mod:<is>(&infix:<andthen>, :prec($loose_andthen));
    trait_mod:<is>(&infix:<notandthen>, :prec($loose_andthen));

    trait_mod:<is>(&infix:<or>,     :prec($loose_orelse));
    trait_mod:<is>(&infix:<xor>,    :prec($loose_orelse));
    trait_mod:<is>(&infix:<orelse>, :prec($loose_orelse));
}

#line 1 SETTING::src/core/Deprecations.pm
my %DEPRECATIONS; # where we keep our deprecation info

class Deprecation {
    has $.file;         # file of the code that is deprecated
    has $.type;         # type of code (sub/method etc.) that is deprecated
    has $.package;      # package of code that is deprecated
    has $.name;         # name of code that is deprecated
    has $.alternative;  # alternative for code that is deprecated
    has %.callsites;    # places where called (file -> line -> count)
    has Version $.from;    # release version from which deprecated
    has Version $.removed; # release version when will be removed

    multi method WHICH (Deprecation:D:) {
        ($!file||"",$!type||"",$!package||"",$!name).join(':');
    }

    proto method report (|) { * }
    multi method report (Deprecation:U:) {
        return Nil unless %DEPRECATIONS;

        my $message = "Saw {+%DEPRECATIONS} occurrence{ 's' if +%DEPRECATIONS != 1 } of deprecated code.\n";
        $message ~= ("=" x 80) ~ "\n";
        for %DEPRECATIONS.sort(*.key)>>.value>>.report -> $r {
            $message ~= $r;
            $message ~= ("-" x 80) ~ "\n";
        }

        %DEPRECATIONS = ();  # reset for new batches if applicable

        $message.chop;
    }
    multi method report (Deprecation:D:) {
        my $type    = $.type ?? "$.type " !! "";
        my $name    = $.name ?? "$.name " !! "";
        my $package = $.package ?? "(from $.package) " !! "";
        my $message = $type ~ $name ~ $package ~ "seen at:\n";
        for %.callsites.kv -> $file, $lines {
            $message ~=
              "  $file, line{ 's' if +$lines > 1 } {$lines.keys.sort.join(',')}\n";
            if $.from or $.removed {
                $message ~= $.from
                  ?? "Deprecated since v$.from, will be removed"
                  !! "Will be removed";
                $message ~= $.removed
                  ?? " with release v$.removed!\n"
                  !! " sometime in the future\n";
            }
        }
        $message ~= "Please use $.alternative instead.\n";
        $message;
    }
}

sub DEPRECATED($alternative,$from?,$removed?,:$up = 1,:$what,:$file,:$line,Bool :$lang-vers) {
    state $ver  = $*PERL.compiler.version;
    my $version = $lang-vers ?? nqp::getcomp('perl6').language_version !! $ver;
    # if $lang-vers was given, treat the provided versions as language
    # versions, rather than compiler versions. Note that we can't
    # `state` the lang version (I think) because different CompUnits
    # might be using different versions.

    my Version $vfrom;
    my Version $vremoved;
    $from && nqp::iseq_i($version cmp ($vfrom = Version.new: $from), -1)
          && return; # not deprecated yet;
    $vremoved = Version.new($removed) if $removed;

    my $bt = Backtrace.new;
    my $deprecated =
      $bt[ my $index = $bt.next-interesting-index(2, :named, :setting) ];

    if $up ~~ Whatever {
        $index = $_ with $bt.next-interesting-index($index, :noproto);
    }
    else {
        $index = $_
          with $bt.next-interesting-index($index, :noproto, :setting)
          for ^$up;
    }
    my $callsite = $bt[$index];

    # get object, existing or new
    my $dep = $what
      ?? Deprecation.new(
        :name($what),
        :$alternative,
        :from($vfrom),
        :removed($vremoved) )
      !! Deprecation.new(
        file    => $deprecated.file,
        type    => $deprecated.subtype.tc,
        package => try { $deprecated.package.^name } // 'unknown',
        name    => $deprecated.subname,
        :$alternative,
        :from($vfrom),
        :removed($vremoved),
    );
    $dep = %DEPRECATIONS{$dep.WHICH} //= $dep;

    state $fatal = %*ENV<RAKUDO_DEPRECATIONS_FATAL>;
    die $dep.report if $fatal;

    # update callsite
    $dep.callsites{$file // $callsite.file.IO}{$line // $callsite.line}++;
}

END {
    unless %*ENV<RAKUDO_NO_DEPRECATIONS> {
        if Deprecation.report -> $message {
            note $message;   # q:to/TEXT/ doesn't work in settings
            note 'Please contact the author to have these occurrences of deprecated code
adapted, so that this message will disappear!';
        }
    }
}

#line 1 SETTING::src/core/Thread.pm
# Thread represents an OS-level thread. While it could be used directly, it
# is not the preferred way to work in Perl 6. It's a building block for the
# interesting things.
my class Thread {
    # The VM-level thread handle.
    has Mu $!vm_thread;

    # Is the thread's lifetime bounded by that of the application, such
    # that when it exits, so does the thread?
    has Bool $.app_lifetime;

    # Thread's (user-defined) name.
    has Str $.name;

    submethod BUILD(
             :&code!,
      Bool() :$!app_lifetime = False,
      Str()  :$!name         = "<anon>"
      --> Nil
    ) {
        $!vm_thread := nqp::newthread(
            anon sub THREAD-ENTRY() {
                my $*THREAD = self;
                CONTROL {
                    default {
                        my Mu $vm-ex := nqp::getattr(nqp::decont($_), Exception, '$!ex');
                        nqp::getcomp('perl6').handle-control($vm-ex);
                    }
                }
                code();
            },
            $!app_lifetime ?? 1 !! 0);
    }

    method start(Thread:U: &code, *%adverbs) {
        Thread.new(:&code, |%adverbs).run()
    }

    method run(Thread:D:) {
        nqp::threadrun($!vm_thread);
        self
    }

    method id(Thread:D:) {
        nqp::p6box_i(nqp::threadid($!vm_thread));
    }

    method finish(Thread:D:) {
        nqp::threadjoin($!vm_thread);
        self
    }

    method join(Thread:D:) {
        self.finish
    }

    multi method Numeric(Thread:D:) {
        self.id
    }

    multi method Str(Thread:D:) {
        "Thread<$.id>($.name)"
    }
    multi method gist(Thread:D:) {
        "Thread #$.id" ~ ($!name ne '<anon>' ?? " ($!name)" !! '')
    }

    method yield(Thread:U: --> Nil) {
        nqp::threadyield();
    }

    method is-initial-thread(--> Bool) {
        nqp::p6bool(
          nqp::iseq_i(
            nqp::threadid(
              nqp::if(nqp::isconcrete(self),$!vm_thread,nqp::currentthread)
            ),
            nqp::threadid(Rakudo::Internals.INITTHREAD)
          )
        )
    }
}

Rakudo::Internals.REGISTER-DYNAMIC: '$*THREAD', {
    my $init_thread := nqp::create(Thread);
    nqp::bindattr($init_thread, Thread, '$!vm_thread',
      Rakudo::Internals.INITTHREAD);
    nqp::bindattr($init_thread, Thread, '$!app_lifetime', False);
    nqp::bindattr($init_thread, Thread, '$!name', 'Initial thread');
    PROCESS::<$THREAD> := $init_thread;
}

#line 1 SETTING::src/core/Lock.pm
# A reentrant lock mechanism with condition variable support.
my class X::Lock::ConditionVariable::New is Exception {
    method message() {
        "Cannot directly create a ConditionVariable; use the 'condition' method on a lock"
    }
}
my class Lock {
    class ConditionVariable is repr('ConditionVariable') {
        method new() {
            X::Lock::ConditionVariable::New.new.throw
        }
        method wait() { nqp::condwait(self) }
        method signal() { nqp::condsignalone(self) }
        method signal_all() { nqp::condsignalall(self) }
    }

    method new() { nqp::create(self) }

    method lock(Lock:D:) { nqp::lock(self) }

    method unlock(Lock:D:) { nqp::unlock(self) }

    method protect(Lock:D: &code) {
        nqp::lock(self);
        LEAVE nqp::unlock(self);
        code()
    }

    method condition(Lock:D:) {
        nqp::getlockcondvar(self, ConditionVariable)
    }
}

#line 1 SETTING::src/core/Lock/Async.pm
# An asynchronous lock provides a non-blocking non-reentrant mechanism for
# mutual exclusion. The lock method returns a Promise, which will already be
# Kept if nothing was holding the lock already, so execution can proceed
# immediately. For performance reasons, in this case it returns a singleton
# Promise instance. Otherwise, a Promise in planned state will be returned,
# and Kept once the lock has been unlocked by its current holder. The lock
# and unlock do not need to take place on the same thread; that's why it's not
# reentrant.

my class X::Lock::Async::NotLocked is Exception {
    method message() {
        "Cannot unlock a Lock::Async that is not currently locked"
    }
}

my class Lock::Async {
    # The Holder class is an immutable object. A type object represents an
    # unheld lock, an instance represents a held lock, and it has a queue of
    # vows to be kept on unlock.
    my class Holder {
        has $!queue;

        method queue-vow(\v) {
            my $new-queue := $!queue.DEFINITE
                ?? nqp::clone($!queue)
                !! nqp::list();
            nqp::push($new-queue, v);
            nqp::p6bindattrinvres(nqp::create(Holder), Holder, '$!queue', $new-queue)
        }

        method waiter-queue-length() {
            nqp::elems($!queue)
        }

        # Assumes it won't be called if there is no queue (SINGLE_HOLDER case
        # in unlock())
        method head-vow() {
            nqp::atpos($!queue, 0)
        }

        # Assumes it won't be called if the queue only had one item in it (to
        # mantain SINGLE_HOLDER fast path usage)
        method without-head-vow() {
            my $new-queue := nqp::clone($!queue);
            nqp::shift($new-queue);
            nqp::p6bindattrinvres(nqp::create(Holder), Holder, '$!queue', $new-queue)
        }
    }

    # Base states for Holder
    my constant NO_HOLDER = Holder;
    my constant SINGLE_HOLDER = nqp::create(Holder);

    # The current holder record, with waiters queue, of the lock.
    has Holder $!holder = Holder;

    # Singleton Promise to be used when there's no need to wait.
    my \KEPT-PROMISE := do {
        my \p = Promise.new;
        p.keep(True);
        p
    }

    method lock(Lock::Async:D: --> Promise) {
        loop {
            my $holder := $!holder;
            if $holder.DEFINITE {
                my $p := Promise.new;
                my $v := $p.vow;
                my $holder-update = $holder.queue-vow($v);
                if cas($!holder, $holder, $holder-update) =:= $holder {
                    return $p;
                }
            }
            else {
                if cas($!holder, NO_HOLDER, SINGLE_HOLDER) =:= NO_HOLDER {
                    # Successfully acquired and we're the only holder
                    return KEPT-PROMISE;
                }
            }
        }
    }

    method unlock(Lock::Async:D: --> Nil) {
        loop {
            my $holder := $!holder;
            if $holder =:= SINGLE_HOLDER {
                # We're the single holder and there's no wait queue.
                if cas($!holder, SINGLE_HOLDER, NO_HOLDER) =:= SINGLE_HOLDER {
                    # Successfully released to NO_HOLDER state.
                    return;
                }
            }
            elsif $holder.DEFINITE {
                my int $queue-length = $holder.waiter-queue-length();
                my $v := $holder.head-vow;
                if $queue-length == 1 {
                    if cas($!holder, $holder, SINGLE_HOLDER) =:= $holder {
                        # Successfully released; keep the head vow, thus
                        # giving the lock to the next waiter.
                        $v.keep(True);
                        return;
                    }
                }
                else {
                    my $new-holder := $holder.without-head-vow();
                    if cas($!holder, $holder, $new-holder) =:= $holder {
                        # Successfully released and installed remaining queue;
                        # keep the head vow which we successfully removed.
                        $v.keep(True);
                        return;
                    }
                }
            }
            else {
                die X::Lock::Async::NotLocked.new;
            }
        }
    }

    method protect(Lock::Async:D: &code) {
        my int $acquired = 0;
        $*AWAITER.await(self.lock());
        $acquired = 1;
        LEAVE self.unlock() if $acquired;
        code()
    }

    # This either runs the code now if we can obtain the lock, releasing the
    # lock afterwards, or queues the code to run if a recursive use of the
    # lock is observed. It relies on all users of the lock to use it through
    # this method only. This is useful for providing back-pressure while also
    # avoiding code deadlocking on itself by providing a way for it to get run
    # later on. Returns Nil if the code was run now (maybe after blocking), or
    # a Promise if it was queued for running later.
    method protect-or-queue-on-recursion(Lock::Async:D: &code) {
        my $try-acquire = self.lock();
        if $try-acquire {
            # We could acquire the lock. Run the code right now.
            LEAVE self.unlock();
            self!run-with-updated-recursion-list(&code);
            Nil
        }
        elsif self!on-recursion-list() {
            # Lock is already held on the stack, so we're recursing. Queue.
            $try-acquire.then({
                LEAVE self.unlock();
                self!run-with-updated-recursion-list(&code);
            });
        }
        else {
            # Lock is held but by something else. Await it's availability.
            my int $acquired = 0;
            $*AWAITER.await($try-acquire);
            $acquired = 1;
            LEAVE self.unlock() if $acquired;
            self!run-with-updated-recursion-list(&code);
            Nil
        }
    }

    method !on-recursion-list() {
        my $rec-list := nqp::getlexdyn('$*LOCK-ASYNC-RECURSION-LIST');
        if nqp::isnull($rec-list) {
            False
        }
        else {
            my int $n = nqp::elems($rec-list);
            loop (my int $i = 0; $i < $n; $i++) {
                return True if nqp::eqaddr(nqp::atpos($rec-list, $i), self);
            }
            False
        }
    }

    method !run-with-updated-recursion-list(&code) {
        my $current := nqp::getlexdyn('$*LOCK-ASYNC-RECURSION-LIST');
        my $new-held := nqp::isnull($current) ?? nqp::list() !! nqp::clone($current);
        nqp::push($new-held, self);
        {
            my $*LOCK-ASYNC-RECURSION-LIST := $new-held;
            code();
        }
    }

    method with-lock-hidden-from-recursion-check(&code) {
        my $current := nqp::getlexdyn('$*LOCK-ASYNC-RECURSION-LIST');
        my $new-held;
        if nqp::isnull($current) {
            $new-held := nqp::null();
        }
        else {
            $new-held := nqp::list();
            my int $n = nqp::elems($current);
            loop (my int $i = 0; $i < $n; $i++) {
                my $lock := nqp::atpos($current, $i);
                nqp::push($new-held, $lock) unless nqp::eqaddr($lock, self);
            }
        }
        {
            my $*LOCK-ASYNC-RECURSION-LIST := $new-held;
            code();
        }
    }
}

#line 1 SETTING::src/core/Semaphore.pm
my class Semaphore is repr('Semaphore') {
    method new(int $permits) {
        nqp::box_i($permits, Semaphore);
    }
    method acquire() {
        nqp::semacquire(self);
    }
    method try_acquire(--> Bool:D) {
        nqp::p6bool(nqp::semtryacquire(self))
    }
    method release() {
        nqp::semrelease(self);
    }
}

#line 1 SETTING::src/core/Cancellation.pm
my class Cancellation {
    has $.cancelled;
    has $!lock;
    has @!async_handles;

    submethod BUILD(:@!async_handles --> Nil) {
        $!cancelled = False;
        $!lock      = Lock.new;
    }

    method cancel() {
        $!lock.protect({
            unless $!cancelled {
                for @!async_handles {
                    nqp::cancel(nqp::decont($_));
                }
                $!cancelled = True;
            }
        })
    }
}

#line 1 SETTING::src/core/Awaitable.pm
# An Awaitable is something we can use the `await` operator on. To support
# this, it requires a `get-await-handle` method be implemented, which returns
# an `Awaitable::AwaitHandle`.
my role Awaitable {
    method get-await-handle() { ... }
}

# An Awaitable::Handle implementation is an immutable object that conveys the
# status of the requested asynchronous result at the point we obtain the
# handle. If the `.already` property is `True`, then there is no need to block
# or suspend execution; the `.result` or `.cause` of failure can be used right
# away (depending on the value of `.success). Otherwise, the consumer of the
# handle should call the `subscribe-awaiter` method with its unblock/resume
# handler, and then proceed to block/suspend. In this case, the handler will
# be passed two arguments: a `Bool` success, and a result/cause (result if
# success is `True`, cause if it's `False`). The `Awaitable::Handle` will
# *not* have its success/result/cause updated; this would open the door to
# data races (including subtle ones related to read/write ordering), when
# the point of the fast-path is to test if we've got a result already with
# minimal overhead (and thus minimal concurrency control).
my role Awaitable::Handle {
    has Bool $.already;
    has Bool $.success;
    has Mu $.result;
    has Exception $.cause;

    method already-success(Mu \result) {
        nqp::create(self)!already-success(result)
    }
    method !already-success(Mu \result) {
        $!already := True;
        $!success := True;
        $!result := result;
        self
    }

    method already-failure(Mu \cause) {
        self.CREATE!already-failure(cause)
    }
    method !already-failure(Mu \cause) {
        $!already := True;
        $!success := False;
        $!cause := cause;
        self
    }

    method subscribe-awaiter(&subscriber) { ... }
}

#line 1 SETTING::src/core/Awaiter.pm
my role Awaiter {
    method await(Awaitable:D $a) { ... }
    method await-all(Iterable:D $i) { ... }
}

my class Awaiter::Blocking does Awaiter {
    method await(Awaitable:D $a) {
        my $handle := $a.get-await-handle;
        if $handle.already {
            $handle.success
                ?? $handle.result
                !! $handle.cause.rethrow
        }
        else {
            my $s = Semaphore.new(0);
            my $success;
            my $result;
            $handle.subscribe-awaiter(-> \success, \result {
                $success := success;
                $result := result;
                $s.release;
            });
            $s.acquire;
            $success
                ?? $result
                !! $result.rethrow
        }
    }

    method await-all(Iterable:D \i) {
        # Collect results that are already available, and handles where the
        # results are not yet available together with the matching insertion
        # indices.
        my \results = nqp::list();
        my \handles = nqp::list();
        my \indices = nqp::list_i();
        my int $insert = 0;
        my $saw-slip = False;
        for i -> $awaitable {
            unless nqp::istype($awaitable, Awaitable) {
                die "Can only specify Awaitable objects to await (got a $awaitable.^name())";
            }
            unless nqp::isconcrete($awaitable) {
                die "Must specify a defined Awaitable to await (got an undefined $awaitable.^name())";
            }

            my $handle := $awaitable.get-await-handle;
            if $handle.already {
                if $handle.success {
                    my \result = $handle.result;
                    nqp::bindpos(results, $insert, result);
                    $saw-slip = True if nqp::istype(result, Slip);
                }
                else {
                    $handle.cause.rethrow
                }
            }
            else {
                nqp::push(handles, $handle);
                nqp::push_i(indices, $insert);
            }

            $insert++;
        }

        # See if we have anything that we need to really block on. If so, we
        # use a lock and condition variable to handle the blocking. The lock
        # protects writes into the array.
        my int $num-handles = nqp::elems(handles);
        if $num-handles {
            my $exception = Mu;
            my $l = Lock.new;
            my $ready = $l.condition();
            my int $remaining = $num-handles;
            loop (my int $i = 0; $i < $num-handles; $i++) {
                my $handle := nqp::atpos(handles, $i);
                my int $insert = nqp::atpos_i(indices, $i);
                $handle.subscribe-awaiter(-> \success, \result {
                    $l.protect: {
                        if success && $remaining {
                            nqp::bindpos(results, $insert, result);
                            $saw-slip = True if nqp::istype(result, Slip);
                            --$remaining;
                            $ready.signal unless $remaining;
                        }
                        elsif !nqp::isconcrete($exception) {
                            $exception := result;
                            $remaining = 0;
                            $ready.signal;
                        }
                    }
                });
            }

            # Block until remaining is 0 (need the loop to cope with suprious
            # wakeups).
            loop {
                $l.protect: {
                    last if $remaining == 0;
                    $ready.wait;
                }
            }

            # If we got an exception, throw it.
            $exception.rethrow if nqp::isconcrete($exception);
        }

        my \result-list = nqp::p6bindattrinvres(nqp::create(List), List, '$!reified', results);
        $saw-slip ?? result-list.map(-> \val { val }).List !! result-list
    }
}

PROCESS::<$AWAITER> := Awaiter::Blocking;

#line 1 SETTING::src/core/Scheduler.pm
# Schedulers do this role. It mostly serves as an interface for the things
# that schedulers must do, as well as a way to factor out some common "sugar"
# and infrastructure.

my role Scheduler {
    has &.uncaught_handler is rw;

    method handle_uncaught($exception) {
        my $ch = &!uncaught_handler;
        if $ch {
            $ch($exception);
        }
        else {
            # No default handler, so terminate the application.
            note "Unhandled exception in code scheduled on thread " ~ $*THREAD.id;
            if Rakudo::Internals.LL-EXCEPTION {
                note $exception.message;
                note $exception.backtrace.full;
            }
            else {
                note $exception.gist;
            }
            exit(1);
        }
    }

    method cue { ... }

    method loads() { ... }
}

#line 1 SETTING::src/core/Env.pm
Rakudo::Internals.REGISTER-DYNAMIC: '$*CWD', {
#    PROCESS::<$CWD> = nqp::p6box_s(nqp::cwd());
    my $CWD := nqp::p6box_s(nqp::cwd());
    PROCESS::<$CWD> = IO::Path.new($CWD, :$CWD); # need :CWD to prevent looping
}

#line 1 SETTING::src/core/atomicops.pm
#-- fetching a value atomically
proto sub atomic-fetch($) {*}
multi sub atomic-fetch($source is rw) {
    nqp::atomicload($source)
}

proto sub prefix:<>($) {*}
multi sub prefix:<>($source is rw) {
    nqp::atomicload($source)
}

#-- assigning a value atomically
proto sub atomic-assign($, $) {*}
multi sub atomic-assign($target is rw, \value) {
    nqp::atomicstore($target, value)
}

#-- atomic compare and swap
proto sub cas(|) {*}
multi sub cas($target is rw, \expected, \value) {
    nqp::cas($target, expected, value)
}
multi sub cas($target is rw, &code) {
    my $current := nqp::atomicload($target);
    loop {
        my $updated := code($current);
        my $seen := nqp::cas($target, $current, $updated);
        return $updated if nqp::eqaddr($seen, $current);
        $current := $seen;
    }
}

# Native integer atomics only available on MoarVM

my native atomicint is repr('P6int') is Int is ctype('atomic') { }

#-- fetching a value atomically
multi sub atomic-fetch(atomicint $source is rw) {
    nqp::atomicload_i($source)
}

multi sub prefix:<>(atomicint $source is rw) {
    nqp::atomicload_i($source)
}

#-- assigning a value atomically
multi sub atomic-assign(atomicint $target is rw, int $value) {
    nqp::atomicstore_i($target, $value)
}
multi sub atomic-assign(atomicint $target is rw, Int $value) {
    nqp::atomicstore_i($target, $value)
}
multi sub atomic-assign(atomicint $target is rw, $value) {
    nqp::atomicstore_i($target, $value.Int)
}

proto sub infix:<=>($, $) {*}
multi sub infix:<=>($target is rw, \value) {
    nqp::atomicstore($target, value)
}
multi sub infix:<=>(atomicint $target is rw, int $value) {
    nqp::atomicstore_i($target, $value)
}
multi sub infix:<=>(atomicint $target is rw, Int $value) {
    nqp::atomicstore_i($target, $value)
}
multi sub infix:<=>(atomicint $target is rw, $value) {
    nqp::atomicstore_i($target, $value.Int)
}

#-- atomically fetch value and increment it
sub atomic-fetch-inc(atomicint $target is rw --> atomicint) {
    nqp::atomicinc_i($target)
}

sub postfix:<++>(atomicint $target is rw --> atomicint) {
    nqp::atomicinc_i($target)
}

#-- atomically increment value and fetch it
sub atomic-inc-fetch(atomicint $target is rw --> atomicint) {
    my atomicint $ = nqp::atomicinc_i($target) + 1
}
sub prefix:<++>(atomicint $target is rw --> atomicint) {
    my atomicint $ = nqp::atomicinc_i($target) + 1
}

#-- atomically fetch value and decrement it
sub atomic-fetch-dec(atomicint $target is rw --> atomicint) {
    nqp::atomicdec_i($target)
}

sub postfix:<-->(atomicint $target is rw --> atomicint) {
    nqp::atomicdec_i($target)
}

#-- atomically decrement value and fetch it
sub atomic-dec-fetch(atomicint $target is rw --> atomicint) {
    my atomicint $ = nqp::atomicdec_i($target) - 1
}
sub prefix:<-->(atomicint $target is rw --> atomicint) {
    my atomicint $ = nqp::atomicdec_i($target) - 1
}

#-- atomically fetch value and then add given value to it
proto sub atomic-fetch-add($, $) {*}
multi sub atomic-fetch-add(atomicint $target is rw, int $add --> atomicint) {
    nqp::atomicadd_i($target, $add)
}
multi sub atomic-fetch-add(atomicint $target is rw, Int $add --> atomicint) {
    nqp::atomicadd_i($target, $add)
}
multi sub atomic-fetch-add(atomicint $target is rw, $add --> atomicint) {
    nqp::atomicadd_i($target, $add.Int)
}

#-- atomically add given value to value and return that
proto sub atomic-add-fetch($, $) {*}
multi sub atomic-add-fetch(atomicint $target is rw, int $add --> atomicint) {
    my atomicint $ = nqp::atomicadd_i($target, $add) + $add
}
multi sub atomic-add-fetch(atomicint $target is rw, Int $add --> atomicint) {
    my atomicint $ = nqp::atomicadd_i($target, $add) + $add
}
multi sub atomic-add-fetch(atomicint $target is rw, $add --> atomicint) {
    my int $add-int = $add.Int;
    my atomicint $ = nqp::atomicadd_i($target, $add-int) + $add-int
}

proto sub infix:<+=>($, $) {*}
multi sub infix:<+=>(atomicint $target is rw, int $add --> atomicint) {
    my atomicint $ = nqp::atomicadd_i($target, $add) + $add
}
multi sub infix:<+=>(atomicint $target is rw, Int $add --> atomicint) {
    my atomicint $ = nqp::atomicadd_i($target, $add) + $add
}
multi sub infix:<+=>(atomicint $target is rw, $add --> atomicint) {
    my int $add-int = $add.Int;
    my atomicint $ = nqp::atomicadd_i($target, $add-int) + $add-int
}

#-- atomically fetch value and then subtract given value from it
proto sub atomic-fetch-sub($, $) {*}
multi sub atomic-fetch-sub(atomicint $target is rw, int $add --> atomicint) {
    nqp::atomicadd_i($target, nqp::neg_i($add))
}
multi sub atomic-fetch-sub(atomicint $target is rw, Int $add --> atomicint) {
    nqp::atomicadd_i($target, nqp::neg_i($add))
}
multi sub atomic-fetch-sub(atomicint $target is rw, $add --> atomicint) {
    nqp::atomicadd_i($target, nqp::neg_i($add.Int))
}

#-- atomically subtract given value from value and return that
proto sub atomic-sub-fetch($, $) {*}
multi sub atomic-sub-fetch(atomicint $target is rw, int $add --> atomicint) {
    my atomicint $ = nqp::atomicadd_i($target, nqp::neg_i($add)) - $add
}
multi sub atomic-sub-fetch(atomicint $target is rw, Int $add --> atomicint) {
    my atomicint $ = nqp::atomicadd_i($target, nqp::neg_i($add)) - $add
}
multi sub atomic-sub-fetch(atomicint $target is rw, $add --> atomicint) {
    my int $add-int = nqp::neg_i($add.Int);
    my atomicint $ = nqp::atomicadd_i($target, $add-int) + $add-int
}

proto sub infix:<-=>($, $) {*}
multi sub infix:<-=>(atomicint $target is rw, int $add --> atomicint) {
    my atomicint $ = nqp::atomicadd_i($target, nqp::neg_i($add)) - $add
}
multi sub infix:<-=>(atomicint $target is rw, Int $add --> atomicint) {
    my atomicint $ = nqp::atomicadd_i($target, nqp::neg_i($add)) - $add
}
multi sub infix:<-=>(atomicint $target is rw, $add --> atomicint) {
    my int $add-int = nqp::neg_i($add.Int);
    my atomicint $ = nqp::atomicadd_i($target, $add-int) + $add-int
}
my constant &infix:<=> := &infix:<-=>;

#-- provide full barrier semantics
sub full-barrier(--> Nil) {
    nqp::barrierfull()
}

#-- atomic compare and swap
multi sub cas(atomicint $target is rw, int $expected, int $value) {
    nqp::cas_i($target, $expected, $value)
}

multi sub cas(atomicint $target is rw, Int $expected, Int $value) {
    nqp::cas_i($target, $expected, $value)
}

multi sub cas(atomicint $target is rw, $expected, $value) {
    nqp::cas_i($target, $expected.Int, $value.Int)
}

multi sub cas(atomicint $target is rw, &code) {
    my int $current = nqp::atomicload_i($target);
    loop {
        my int $updated = code($current);
        my int $seen = nqp::cas_i($target, $current, $updated);
        return $updated if $seen == $current;
        $current = $seen;
    }
}


#line 1 SETTING::src/core/ThreadPoolScheduler.pm
my class ThreadPoolScheduler does Scheduler {
    # A concurrent, blocking-on-receive queue.
    my class Queue is repr('ConcBlockingQueue') {
        method elems() { nqp::elems(self) }
    }

    # Scheduler debug, controlled by an environment variable.
    my $scheduler-debug = so %*ENV<RAKUDO_SCHEDULER_DEBUG>;
    my $scheduler-debug-status = so %*ENV<RAKUDO_SCHEDULER_DEBUG_STATUS>;
    sub scheduler-debug($message) {
        if $scheduler-debug {
            note "[SCHEDULER] $message";
        }
    }
    sub scheduler-debug-status($message) {
        if $scheduler-debug-status {
            note "[SCHEDULER] $message";
        }
    }

    # Infrastructure for non-blocking `await` for code running on the
    # scheduler.
    my constant THREAD_POOL_PROMPT = Mu.new;
    class ThreadPoolAwaiter does Awaiter {
        has $!queue;

        submethod BUILD(:$queue!) {
            $!queue := nqp::decont($queue);
        }

        sub holding-locks() {
            nqp::p6bool(nqp::threadlockcount(nqp::currentthread()))
        }

        method await(Awaitable:D $a) {
            holding-locks() || !nqp::isnull(nqp::getlexdyn('$*RAKUDO-AWAIT-BLOCKING'))
                ?? Awaiter::Blocking.await($a)
                !! self!do-await($a)
        }

        method !do-await(Awaitable:D $a) {
            my $handle := $a.get-await-handle;
            if $handle.already {
                $handle.success
                    ?? $handle.result
                    !! $handle.cause.rethrow
            }
            else {
                my $success;
                my $result;
                nqp::continuationcontrol(1, THREAD_POOL_PROMPT, -> Mu \c {
                    $handle.subscribe-awaiter(-> \success, \result {
                        $success := success;
                        $result := result;
                        nqp::push($!queue, { nqp::continuationinvoke(c, nqp::null()) });
                        Nil
                    });
                });
                $success
                    ?? $result
                    !! $result.rethrow
            }
        }

        method await-all(Iterable:D \i) {
            holding-locks() || !nqp::isnull(nqp::getlexdyn('$*RAKUDO-AWAIT-BLOCKING'))
                ?? Awaiter::Blocking.await-all(i)
                !! self!do-await-all(i)
        }

        method !do-await-all(Iterable:D \i) {
            # Collect results that are already available, and handles where the
            # results are not yet available together with the matching insertion
            # indices.
            my \results = nqp::list();
            my \handles = nqp::list();
            my \indices = nqp::list_i();
            my int $insert = 0;
            my $saw-slip = False;
            for i -> $awaitable {
                unless nqp::istype($awaitable, Awaitable) {
                    die "Can only specify Awaitable objects to await (got a $awaitable.^name())";
                }
                unless nqp::isconcrete($awaitable) {
                    die "Must specify a defined Awaitable to await (got an undefined $awaitable.^name())";
                }

                my $handle := $awaitable.get-await-handle;
                if $handle.already {
                    if $handle.success {
                        my \result = $handle.result;
                        nqp::bindpos(results, $insert, result);
                        $saw-slip = True if nqp::istype(result, Slip);
                    }
                    else {
                        $handle.cause.rethrow
                    }
                }
                else {
                    nqp::push(handles, $handle);
                    nqp::push_i(indices, $insert);
                }

                $insert++;
            }

            # See if we have anything that we really need to suspend for. If
            # so, we need to take great care that the continuation taking is
            # complete before we try to resume it (completions can happen on
            # different threads, and so concurrent with us subscribing, not
            # to mention concurrent with each other wanting to resume). We
            # use a lock to take care of this, holding the lock until the
            # continuation has been taken.
            my int $num-handles = nqp::elems(handles);
            if $num-handles {
                my $continuation;
                my $exception;
                my $l = Lock.new;
                $l.lock;
                {
                    my int $remaining = $num-handles;
                    loop (my int $i = 0; $i < $num-handles; $i++) {
                        my $handle := nqp::atpos(handles, $i);
                        my int $insert = nqp::atpos_i(indices, $i);
                        $handle.subscribe-awaiter(-> \success, \result {
                            my int $resume;
                            $l.protect: {
                                if success && $remaining {
                                    nqp::bindpos(results, $insert, result);
                                    $saw-slip = True if nqp::istype(result, Slip);
                                    --$remaining;
                                    $resume = 1 unless $remaining;
                                }
                                elsif !nqp::isconcrete($exception) {
                                    $exception := result;
                                    $remaining = 0;
                                    $resume = 1;
                                }
                            }
                            if $resume {
                                nqp::push($!queue, {
                                    nqp::continuationinvoke($continuation, nqp::null())
                                });
                            }
                        });
                    }
                    CATCH {
                        # Unlock if we fail here, and let the exception
                        # propagate outwards.
                        $l.unlock();
                    }
                }
                nqp::continuationcontrol(1, THREAD_POOL_PROMPT, -> Mu \c {
                    $continuation := c;
                    $l.unlock;
                });

                # If we got an exception, throw it.
                $exception.rethrow if nqp::isconcrete($exception);
            }

            my \result-list = nqp::p6bindattrinvres(nqp::create(List), List, '$!reified', results);
            $saw-slip ?? result-list.map(-> \val { val }).List !! result-list
        }
    }

    # There are three kinds of worker:
    # * General worker threads all pull from the main queue. If they have no
    #   work, they may steal from timer threads.
    # * Timer worker threads are intended to handle time-based events. They
    #   pull events from the time-sensitive queue, and they will not do any
    #   work stealing so as to be ready and available for timer events. The
    #   time-sensitive queue will only be returned when a queue is requested
    #   with the :hint-time-sensitive named argument. Only one timer worker
    #   will be created on the first request for such a queue; the supervisor
    #   will then monitor the time-sensitive queue length and add more if
    #   needed.
    # * Affinity worker threads each have their own queue. They are used when
    #   a queue is requested and :hint-affinity is passed. These are useful
    #   for things like Proc::Async and IO::Socket::Async, where events will
    #   be processed using a Supply, which is serial, and so there's no point
    #   at all in contending over the data. Work will not be stolen from an
    #   affinity worker thread.
    my role Worker {
        has $.thread;
        has $!scheduler;

        # Completed is the number of tasks completed since the last time the
        # supervisor checked in.

        has atomicint $.completed;





        # Working is 1 if the worker is currently busy, 0 if not.
        has int $.working;

        # Number of times take-completed has returned zero in a row.
        has int $.times-nothing-completed;

        # Resets the completed to zero.
        method take-completed() {

            my atomicint $taken;
            cas $!completed, -> atomicint $current { $taken = $current; 0 }





            if $taken == 0 {
                $!times-nothing-completed++;
            }
            else {
                $!times-nothing-completed = 0;
            }
            $taken
        }

        method !run-one(\task) {
            $!working = 1;
            nqp::continuationreset(THREAD_POOL_PROMPT, {
                if nqp::istype(task, List) {
                    my Mu $code := nqp::shift(nqp::getattr(task, List, '$!reified'));
                    $code(|task);
                }
                else {
                    task.();
                }
                CONTROL {
                    default {
                        my Mu $vm-ex := nqp::getattr(nqp::decont($_), Exception, '$!ex');
                        nqp::getcomp('perl6').handle-control($vm-ex);
                    }
                }
                CATCH {
                    default {
                        $!scheduler.handle_uncaught($_)
                    }
                }
            });
            $!working = 0;

            $!completed++;




        }
    }
    my class GeneralWorker does Worker {
        has Queue $!queue;

        submethod BUILD(Queue :$queue!, :$!scheduler!) {
            $!queue := $queue;
            $!thread = Thread.start(:app_lifetime, {
                my $*AWAITER := ThreadPoolAwaiter.new(:$!queue);
                loop {
                    self!run-one(nqp::shift($queue));
                }
            });
        }
    }
    my class TimerWorker does Worker {
        has Queue $!queue;

        submethod BUILD(Queue :$queue!, :$!scheduler!) {
            $!queue := $queue;
            $!thread = Thread.start(:app_lifetime, {
                my $*AWAITER := ThreadPoolAwaiter.new(:$!queue);
                loop {
                    self!run-one(nqp::shift($queue));
                }
            });
        }
    }
    my class AffinityWorker does Worker {
        has Queue $.queue;

        submethod BUILD(:$!scheduler!) {
            my $queue := $!queue := Queue.CREATE;
            $!thread = Thread.start(:app_lifetime, {
                my $*AWAITER := ThreadPoolAwaiter.new(:$!queue);
                loop {
                    self!run-one(nqp::shift($queue));
                }
            });
        }
    }

    # Initial and maximum threads allowed.
    has Int $.initial_threads;
    has Int $.max_threads;

    # All of the worker and queue state below is guarded by this lock.
    has Lock $!state-lock = Lock.new;

    # The general queue and timer queue, if created.
    has Queue $!general-queue;
    has Queue $!timer-queue;

    # The current lists of workers. Immutable lists; new ones are produced
    # upon changes.
    has $!general-workers;
    has $!timer-workers;
    has $!affinity-workers;

    # The supervisor thread, if started.
    has Thread $!supervisor;

    method !general-queue() {
        unless $!general-queue.DEFINITE {
            $!state-lock.protect: {
                unless $!general-queue.DEFINITE {
                    # We don't have any workers yet, so start one.
                    $!general-queue := nqp::create(Queue);
                    my $workers := nqp::create(IterationBuffer);
                    nqp::push(
                      $workers,
                      GeneralWorker.new(
                        queue => $!general-queue,
                        scheduler => self
                      )
                    );
                    $!general-workers := $workers;
                    scheduler-debug "Created initial general worker thread";
                    self!maybe-start-supervisor();
                }
            }
        }
        $!general-queue
    }

    method !timer-queue() {
        unless $!timer-queue.DEFINITE {
            $!state-lock.protect: {
                unless $!timer-queue.DEFINITE {
                    # We don't have any workers yet, so start one.
                    $!timer-queue := nqp::create(Queue);
                    my $workers := nqp::create(IterationBuffer);
                    nqp::push(
                      $workers,
                      TimerWorker.new(
                        queue => $!timer-queue,
                        scheduler => self
                      )
                    );
                    $!timer-workers := $workers;
                    scheduler-debug "Created initial timer worker thread";
                    self!maybe-start-supervisor();
                }
            }
        }
        $!timer-queue
    }

    constant @affinity-add-thresholds = 1, 5, 10, 20, 50, 100;
    method !affinity-queue() {
        # If there's no affinity workers, start one.
        my $cur-affinity-workers := $!affinity-workers;
        if $cur-affinity-workers.elems == 0 {
            $!state-lock.protect: {
                if $!affinity-workers.elems == 0 {
                    # We don't have any affinity workers yet, so start one
                    # and return its queue.
                    my $workers := nqp::create(IterationBuffer);
                    nqp::push(
                      $workers,
                      AffinityWorker.new(
                        scheduler => self
                      )
                    );
                    $!affinity-workers := $workers;
                    scheduler-debug "Created initial affinity worker thread";
                    self!maybe-start-supervisor();
                    return $!affinity-workers[0].queue;
                }
            }
            $cur-affinity-workers := $!affinity-workers; # lost race for first
        }

        # Otherwise, see which has the least load (this is inherently racey
        # and approximate, but enough to help us avoid a busy worker). If we
        # find an empty queue, return it immediately.
        my $most-free-worker;
        my int $i = -1;
        nqp::while(
          nqp::islt_i(($i = nqp::add_i($i,1)),nqp::elems($cur-affinity-workers)),
          nqp::if(
            $most-free-worker.DEFINITE,
            nqp::stmts(
              (my $cand := nqp::atpos($cur-affinity-workers,$i)),
              nqp::unless(
                (my $queue := $cand.queue).elems,
                (return $queue)
              ),
              nqp::if(
                nqp::islt_i($queue.elems,$most-free-worker.queue.elems),
                $most-free-worker := $cand
              )
            ),
            ($most-free-worker := nqp::atpos($cur-affinity-workers,$i))
          )
        );

        # Otherwise, check if the queue beats the threshold to add another
        # worker thread.
        my $chosen-queue := $most-free-worker.queue;
        my $threshold = @affinity-add-thresholds[
            ($cur-affinity-workers.elems min @affinity-add-thresholds) - 1
        ];
        if $chosen-queue.elems > $threshold {
            # Add another one, unless another thread did too.
            $!state-lock.protect: {
                if self!total-workers() >= $!max_threads {
                    scheduler-debug "Will not add extra affinity worker; hit $!max_threads thread limit";
                    return $chosen-queue;
                }
                if $cur-affinity-workers.elems != $!affinity-workers.elems {
                    return $chosen-queue;
                }
                my $new-worker := AffinityWorker.new(scheduler => self);
                $!affinity-workers := push-worker($!affinity-workers,$new-worker);
                scheduler-debug "Added an affinity worker thread";
                $new-worker.queue
            }
        }
        else {
            $chosen-queue
        }
    }

    # Since the worker lists can be changed during copying, we need to
    # just take whatever we can get and assume that it may be gone by
    # the time we get to it.
    sub push-worker(\workers, \to-push) is raw {
        my $new-workers := nqp::clone(workers);
        nqp::push($new-workers,to-push);
        $new-workers
    }

    # The supervisor sits in a loop, mostly sleeping. Each time it wakes up,
    # it takes stock of the current situation and decides whether or not to
    # add threads.
    my constant SUPERVISION_INTERVAL = 0.01;
    my constant LAST_UTILS_NUM       = 5;
    method !maybe-start-supervisor() {
        unless $!supervisor.DEFINITE {
            $!supervisor = Thread.start(:app_lifetime, {
                sub add-general-worker() {
                    $!state-lock.protect: {
                        $!general-workers := push-worker(
                          $!general-workers,
                          GeneralWorker.new(
                            queue => $!general-queue,
                            scheduler => self
                          )
                        );

                    }
                    scheduler-debug "Added a general worker thread";
                }
                sub add-timer-worker() {
                    $!state-lock.protect: {
                        $!timer-workers := push-worker(
                          $!timer-workers,
                          TimerWorker.new(
                            queue => $!timer-queue,
                            scheduler => self
                          )
                        );
                    }
                    scheduler-debug "Added a timer worker thread";
                }

                scheduler-debug "Supervisor started";
                my num $last-rusage-time = nqp::time_n;
                my int $last-usage = self!getrusage-total();
                my num @last-utils = 0e0 xx LAST_UTILS_NUM;
                my int $cpu-cores = nqp::cpucores();
                scheduler-debug "Supervisor thinks there are $cpu-cores CPU cores";
                loop {
                    # Wait until the next time we should check how things
                    # are.
                    sleep SUPERVISION_INTERVAL;

                    # Work out the delta of CPU usage since last supervision
                    # and the time period that measurement spans.
                    my num $now = nqp::time_n;
                    my num $rusage-period = $now - $last-rusage-time;
                    $last-rusage-time = $now;
                    my int $current-usage = self!getrusage-total();
                    my int $usage-delta = $current-usage - $last-usage;
                    $last-usage = $current-usage;

                    # Scale this by the time between rusage calls and turn it
                    # into a per-core utilization percentage.
                    my num $normalized-delta = $usage-delta / $rusage-period;
                    my num $per-core = $normalized-delta / $cpu-cores;
                    my num $per-core-util =
                      100 * ($per-core / (1000000 * LAST_UTILS_NUM));

                    # Since those values are noisy, average the last
                    # LAST_UTILS_NUM values to get a smoothed value.
                    @last-utils.shift;
                    @last-utils.push: $per-core-util;
                    my $smooth-per-core-util = @last-utils.sum;
                    scheduler-debug-status "Per-core utilization (approx): $smooth-per-core-util%";

                    if $!general-queue.DEFINITE {
                        self!tweak-workers: $!general-queue, $!general-workers,
                            &add-general-worker, $cpu-cores, $smooth-per-core-util;
                    }
                    if $!timer-queue.DEFINITE {
                        self!tweak-workers: $!timer-queue, $!timer-workers,
                            &add-timer-worker, $cpu-cores, $smooth-per-core-util;
                    }
                    self!prod-affinity-workers: $!affinity-workers
                        if $!affinity-workers.DEFINITE;

                    CATCH {
                        default {
                            scheduler-debug .gist;
                        }
                    }
                }
            });
        }
    }

    method !prod-affinity-workers (\worker-list) {
        for ^worker-list.elems {
            my $worker := worker-list[$_];
            if $worker.working {
                $worker.take-completed;

                # If an affinity worker completed nothing for some time,
                # steal an item from its queue, moving it to general queue.
                # This resolves deadlocks in certain cases.
                if $worker.times-nothing-completed > 10 {
                    scheduler-debug "Stealing queue from affinity worker";
                    my $item := nqp::queuepoll($worker.queue);
                    nqp::push($!general-queue, $item) unless nqp::isnull($item);
                }
            }
        }
    }

    method !getrusage-total() {
        my \rusage = nqp::getrusage();
        nqp::atpos_i(rusage, nqp::const::RUSAGE_UTIME_SEC) * 1000000 +
            nqp::atpos_i(rusage, nqp::const::RUSAGE_UTIME_MSEC) +
            nqp::atpos_i(rusage, nqp::const::RUSAGE_STIME_SEC) * 1000000 +
            nqp::atpos_i(rusage, nqp::const::RUSAGE_STIME_MSEC)
    }

    method !tweak-workers(\queue, \worker-list, &add-worker, $cores, $per-core-util) {
        # If there's nothing in the queue, nothing could need an extra worker.
        return if queue.elems == 0;

        # Go through the worker list. If something is not working, then there
        # is at lesat one worker free to process things in the queue, so we
        # don't need to add one.
        my int $total-completed;
        my int $total-times-nothing-completed;
        my int $i = -1;
        nqp::while(
          nqp::islt_i(($i = nqp::add_i($i,1)),nqp::elems(worker-list)),
          nqp::if(
            (my $worker := nqp::atpos(worker-list,$i)).working,
            nqp::stmts(
              ($total-completed = nqp::add_i(
                $total-completed,
                $worker.take-completed
              )),
              ($total-times-nothing-completed = nqp::add_i(
                $total-times-nothing-completed,
                $worker.times-nothing-completed
              ))
            ),
            return
          )
        );

        sub heuristic-check-for-deadlock {
            my int $average-times-nothing-completed
            = $total-times-nothing-completed div (worker-list.elems || 1);
            if $average-times-nothing-completed > 20 {
                scheduler-debug "Heuristic queue progress deadlock situation detected";
                add-worker();
            }
        }

        # If we didn't complete anything, then consider adding more threads.
        my int $total-workers = self!total-workers();
        if $total-completed == 0 {
            if $total-workers < $!max_threads {
                # There's something in the queue and we haven't completed it.
                # If we are still below the CPU core count, just add a worker.
                if $total-workers < $cores {
                    add-worker();
                }

                # Otherwise, consider utilization. If it's very little then a
                # further thread may be needed for deadlock breaking.
                elsif $per-core-util < 2 {
                    scheduler-debug "Heuristic low utilization deadlock situation detected";
                    add-worker();
                }

                # Another form of deadlock can happen when one kind of queue
                # is being processed but another is not. In that case, the
                # number of iterations since nothing was completed by any
                # worker will grow.
                else {
                    heuristic-check-for-deadlock
                }
            }
            else {
                scheduler-debug "Will not add extra worker; hit $!max_threads thread limit [branch with 0 total completed]";
            }
        }
        elsif $total-times-nothing-completed > 20*$cores {
            if $total-workers < $!max_threads {
                heuristic-check-for-deadlock
            }
            else {
                scheduler-debug "Will not add extra worker; hit $!max_threads thread limit [branch with some total completed]";
            }
        }
    }

    method !total-workers() {
        $!general-workers.elems + $!timer-workers.elems + $!affinity-workers.elems
    }

    submethod BUILD(
        Int :$!initial_threads = 0,
        Int :$!max_threads = (%*ENV<RAKUDO_MAX_THREADS> // 64).Int
        --> Nil
    ) {
        die "Initial thread pool threads ($!initial_threads) must be less than or equal to maximum threads ($!max_threads)"
            if $!initial_threads > $!max_threads;

        $!timer-workers    := nqp::create(IterationBuffer);
        $!affinity-workers := nqp::create(IterationBuffer);

        if $!initial_threads > 0 {
            # We've been asked to make some initial threads; we interpret this
            # as general workers.
            self!general-queue(); # Starts one worker
            if $!initial_threads > 1 {
                my $workers := nqp::create(IterationBuffer);
                my int $i = -1;
                nqp::while(
                  nqp::islt_i(($i = nqp::add_i($i,1)),$!initial_threads),
                  nqp::push(
                    $workers,
                    GeneralWorker.new(
                        queue => $!general-queue,
                        scheduler => self
                    )
                  )
                );
                $!general-workers := $workers;
            }
        }
        else {
            $!general-workers  := nqp::create(IterationBuffer);
        }
    }

    method queue(Bool :$hint-time-sensitive, :$hint-affinity) {
        if $hint-affinity {
            self!affinity-queue()
        }
        elsif $hint-time-sensitive {
            self!timer-queue()
        }
        else {
            self!general-queue()
        }
    }

    my class TimerCancellation is repr('AsyncTask') { }
    method cue(&code, :$at, :$in, :$every, :$times = 1, :&stop is copy, :&catch ) {
        die "Cannot specify :at and :in at the same time"
          if $at.defined and $in.defined;
        die "Cannot specify :every, :times and :stop at the same time"
          if $every.defined and $times > 1 and &stop;

        # For $in/$at times, if the resultant delay is less than 0.001 (including
        # negatives) equate those to zero. For $every intervals, we convert
        # such values to minimum resolution of 0.001 and warn about that
        sub to-millis(Numeric() $value, $allow-zero = False) {
            my $proposed := (1000 * $value).Int;
            $proposed > 0 ?? $proposed
                !! $allow-zero ?? 0
                    !! do {warn "Minimum timer resolution is 1ms; using that "
                            ~ "instead of {1000 * $value}ms";
                        1}
        }
        my $delay = to-millis ($at ?? $at - now !! $in // 0), True;

        # Wrap any catch handler around the code to run.
        my &run := &catch ?? wrap-catch(&code, &catch) !! &code;

        # need repeating
        if $every {
            # generate a stopper if needed
            if $times > 1 {
                my $todo = $times;
                &stop = sub { $todo ?? !$todo-- !! True }
            }

            # we have a stopper
            if &stop {
                my $handle;
                my $cancellation;
                sub cancellation() {
                    $cancellation //=
                      Cancellation.new(async_handles => [$handle]);
                }
                $handle := nqp::timer(self!timer-queue(),
                    { stop() ?? cancellation().cancel !! run() },
                    $delay, to-millis($every),
                    TimerCancellation);
                cancellation()
            }

            # no stopper
            else {
                my $handle := nqp::timer(self!timer-queue(), &run,
                    $delay, to-millis($every),
                    TimerCancellation);
                Cancellation.new(async_handles => [$handle])
            }
        }

        # only after waiting a bit or more than once
        elsif $delay or $times > 1 {
            my @async_handles;
            @async_handles.push(
              nqp::timer(self!timer-queue(), &run, $delay, 0, TimerCancellation)
            ) for 1 .. $times;
            Cancellation.new(:@async_handles)
        }

        # just cue the code
        else {
            nqp::push(self!general-queue(), &run);
            Nil
        }
    }

    sub wrap-catch(&code, &catch) {
        -> { code(); CATCH { default { catch($_) } } }
    }

    method loads() {
        my int $loads = 0;
        $loads = $loads + $!general-queue.elems if $!general-queue;
        $loads = $loads + $!timer-queue.elems   if $!timer-queue;

        my int $i = -1;
        nqp::while(
          nqp::islt_i(($i = nqp::add_i($i,1)),nqp::elems($!affinity-workers)),
          $loads = $loads + nqp::atpos($!affinity-workers,$i).queue.elems
        );

        $loads
    }
}

#line 1 SETTING::src/core/CurrentThreadScheduler.pm
# Scheduler that always does things immediately, on the current thread.

my class CurrentThreadScheduler does Scheduler {

    method handle_uncaught($exception) {
        $exception.throw
    }

    method cue(&code, :$at, :$in, :$every, :$times = 1, :&catch is copy ) {
        die "Cannot specify :at and :in at the same time"
          if $at.defined and $in.defined;
        die "Cannot specify :every and :times at the same time"
          if $every.defined and $times > 1;
        die "Cannot specify :every in {self.^name}"
          if $every;

        my $delay = $at ?? $at - now !! $in;
        sleep $delay if $delay;
        &catch //=
          (self && self.uncaught_handler) // -> $ex { self.handle_uncaught($ex) };

        for 1 .. $times {
            code();
            CATCH { default { catch($_) } };
        }
        class { method cancel() {} }
    }

    method loads(--> 0) { }
}

#line 1 SETTING::src/core/Promise.pm
# A promise is a synchronization mechanism for a piece of work that will
# produce a single result (keeping the promise) or fail (breaking the
# promise).
my enum PromiseStatus (:Planned(0), :Kept(1), :Broken(2));
my class X::Promise::Combinator is Exception {
    has $.combinator;
    method message() { "Can only use $!combinator to combine defined Promise objects" }
}
my class X::Promise::CauseOnlyValidOnBroken is Exception {
    has $.promise;
    has $.status;
    method message() { "Can only call cause on a broken promise (status: $.status)" }
}
my class X::Promise::Vowed is Exception {
    has $.promise;
    method message() { "Access denied to keep/break this Promise; already vowed" }
}
my role X::Promise::Broken {
    has $.result-backtrace;
    multi method gist(::?CLASS:D:) {
        "Tried to get the result of a broken Promise\n" ~
            ((try $!result-backtrace ~ "\n") // '') ~
            "Original exception:\n" ~
            callsame().indent(4)
    }
}
my class Promise does Awaitable {
    has $.scheduler;
    has $.status;
    has $!result is default(Nil);
    has int $!vow_taken;
    has $!lock;
    has $!cond;
    has @!thens;
    has Mu $!dynamic_context;

    submethod BUILD(:$!scheduler = $*SCHEDULER --> Nil) {
        $!lock            := nqp::create(Lock);
        $!cond            := $!lock.condition();
        $!status           = Planned;
    }

    # A Vow is used to enable the right to keep/break a promise
    # to be restricted to a given "owner". Taking the Vow for a Promise
    # prevents anybody else from getting hold of it.
    my class Vow { ... }
    trusts Vow;
    my class Vow {
        has $.promise;
        method keep(Mu \result) {
            $!promise!Promise::keep(result)
        }
        method break(\exception) {
            $!promise!Promise::break(exception)
        }
    }
    method vow() {
        nqp::lock($!lock);
        if $!vow_taken {
            nqp::unlock($!lock);
            X::Promise::Vowed.new(promise => self).throw
        }
        my $vow := nqp::create(Vow);
        nqp::bindattr($vow, Vow, '$!promise', self);
        $!vow_taken = 1;
        nqp::unlock($!lock);
        $vow
    }

    proto method kept(|) { * }
    multi method kept(Promise:U:) {
        my \rv := self.new;
        rv!keep(True);
        rv;
    }
    multi method kept(Promise:U: Mu \result) {
        my \rv := self.new;
        rv!keep(result);
        rv;
    }

    proto method keep(|) { * }
    multi method keep(Promise:D:) {
        self.vow.keep(True)
    }
    multi method keep(Promise:D: Mu \result) {
        self.vow.keep(result)
    }

    method !keep(Mu \result --> Nil) {
        $!lock.protect({
            $!result := result;
            $!status = Kept;
            self!schedule_thens();
            $!cond.signal_all;
        });
    }

    proto method broken(|) { * }
    multi method broken(Promise:U:) {
        my \rv := self.new;
        rv!break("Died");
        rv;
    }
    multi method broken(Promise:U: Mu \exception) {
        my \rv := self.new;
        rv!break(exception);
        rv;
    }

    proto method break(|) { * }
    multi method break(Promise:D:) {
        self.vow.break("Died")
    }
    multi method break(Promise:D: \result) {
        self.vow.break(result)
    }

    method !break(\result --> Nil) {
        $!lock.protect({
            $!result = nqp::istype(result, Exception)
                ?? result
                !! X::AdHoc.new(payload => result);
            $!status = Broken;
            self!schedule_thens();
            $!cond.signal_all;
        });
    }

    method !schedule_thens(--> Nil) {
        while @!thens {
            $!scheduler.cue(@!thens.shift, :catch(@!thens.shift))
        }
    }

    method result(Promise:D:) {
        # One important missing optimization here is that if the promise is
        # not yet started, then the work can be done immediately by the
        # thing that is blocking on it. (Note the while loop is there to cope
        # with spurious wake-ups).
        while $!status == Planned {
            $!lock.protect({
                # Re-check planned to avoid data race.
                $!cond.wait() if $!status == Planned;
            });
        }
        if $!status == Kept {
            $!result
        }
        elsif $!status == Broken {
            ($!result but X::Promise::Broken(Backtrace.new)).rethrow
        }
    }

    multi method Bool(Promise:D:) {
        so $!status == Broken || $!status == Kept
    }

    method cause(Promise:D:) {
        my $status = $!status;
        if $status == Broken {
            $!result
        } else {
            X::Promise::CauseOnlyValidOnBroken.new(
                promise => self,
                status  => $status,
            ).throw
        }
    }

    method then(Promise:D: &code) {
        nqp::lock($!lock);
        if $!status == Broken || $!status == Kept {
            # Already have the result, start immediately.
            nqp::unlock($!lock);
            self.WHAT.start( { code(self) }, :$!scheduler);
        }
        else {
            # Create a Promise, and push 2 entries to @!thens: something that
            # starts the then code, and something that handles its exceptions.
            # They will be sent to the scheduler when this promise is kept or
            # broken.
            my $then-p := self.new(:$!scheduler);
            nqp::bindattr($then-p, Promise, '$!dynamic_context', nqp::ctx());
            my $vow = $then-p.vow;
            @!thens.push({ my $*PROMISE := $then-p; $vow.keep(code(self)) });
            @!thens.push(-> $ex { $vow.break($ex) });
            nqp::unlock($!lock);
            $then-p
        }
    }

    my class PromiseAwaitableHandle does Awaitable::Handle {
        has &!add-subscriber;

        method not-ready(&add-subscriber) {
            nqp::create(self)!not-ready(&add-subscriber)
        }
        method !not-ready(&add-subscriber) {
            $!already = False;
            &!add-subscriber := &add-subscriber;
            self
        }

        method subscribe-awaiter(&subscriber --> Nil) {
            &!add-subscriber(&subscriber);
        }
    }

    method get-await-handle(--> Awaitable::Handle:D) {
        if $!status == Broken {
            PromiseAwaitableHandle.already-failure($!result)
        }
        elsif $!status == Kept {
            PromiseAwaitableHandle.already-success($!result)
        }
        else {
            PromiseAwaitableHandle.not-ready: -> &on-ready {
                nqp::lock($!lock);
                if $!status == Broken || $!status == Kept {
                    # Already have the result, call on-ready immediately.
                    nqp::unlock($!lock);
                    on-ready($!status == Kept, $!result)
                }
                else {
                    # Push 2 entries to @!thens (only need the first one in
                    # this case; second we push 'cus .then uses it).
                    @!thens.push({ on-ready($!status == Kept, $!result) });
                    @!thens.push(Callable);
                    nqp::unlock($!lock);
                }
            }
        }
    }

    method start(Promise:U: &code, :&catch, :$scheduler = $*SCHEDULER, |c) {
        my $p := self.new(:$scheduler);
        nqp::bindattr($p, Promise, '$!dynamic_context', nqp::ctx());
        my $vow = $p.vow;
        $scheduler.cue(
            { my $*PROMISE := $p; $vow.keep(code(|c)) },
            :catch(-> $ex { catch($ex) if &catch; $vow.break($ex); }) );
        $p
    }

    method in(Promise:U: $seconds, :$scheduler = $*SCHEDULER) {
        my $p   = self.new(:$scheduler);
        my $vow = $p.vow;
        $scheduler.cue({ $vow.keep(True) }, :in($seconds));
        $p
    }
    method at(Promise:U: $at, :$scheduler = $*SCHEDULER) {
        self.in( $at - now, :$scheduler )
    }

    method anyof(Promise:U: *@p) { self!until_n_kept(@p,   1, 'anyof') }
    method allof(Promise:U: *@p) { self!until_n_kept(@p, +@p, 'allof') }

    method !until_n_kept(@promises, Int $N, Str $combinator) {
        my $p = self.new;
        unless @promises {
            $p.keep;
            return $p
        }

        X::Promise::Combinator.new(:$combinator).throw
          unless Rakudo::Internals.ALL_DEFINED_TYPE(@promises, Promise);

        my int $n  = $N;
        my int $c  = $n;
        my $lock  := nqp::create(Lock);
        my $vow    = $p.vow;
        for @promises -> $cand {
            $cand.then({
                if $lock.protect({ $c = $c - 1 }) == 0 {
                    $vow.keep(True)
                }
            })
        }
        $p
    }

    multi method Supply(Promise:D:) {
        Supply.on-demand: -> $s {
            self.then({
                if self.status == Kept {
                    $s.emit(self.result);
                    $s.done();
                }
                else {
                    $s.quit(self.cause);
                }
            });
        }
    }
}

multi sub infix:<eqv>(Promise:D \a, Promise:D \b) {
    nqp::p6bool(
      nqp::eqaddr(a,b) || a.result eqv b.result
    )
}

#line 1 SETTING::src/core/Channel.pm
# A channel provides a thread-safe way to send a series of values from some
# producer(s) to some consumer(s).
my class X::Channel::SendOnClosed is Exception {
    has $.channel;
    method message() { "Cannot send a message on a closed channel" }
}
my class X::Channel::ReceiveOnClosed is Exception {
    has $.channel;
    method message() { "Cannot receive a message on a closed channel" }
}
my class Channel does Awaitable {
    # The queue of events moving through the channel.
    my class Queue is repr('ConcBlockingQueue') { }
    has $!queue;

    # Promise that is triggered when all values are received, or an error is
    # received and the channel is thus closed.
    has $!closed_promise;

    # Closed promise's vow.
    has $!closed_promise_vow;

    # Flag for if the channel is closed to senders.
    has $!closed;

    # We use a Supplier to send async notifications that there may be a new
    # message to read from the channel (there may be many things competing
    # over them).
    has $!async-notify;

    # Magical objects for various ways a channel can end.
    my class CHANNEL_CLOSE { }
    my class CHANNEL_FAIL  { has $.error }

    submethod BUILD(--> Nil) {
        $!queue := nqp::create(Queue);
        $!closed_promise = Promise.new;
        $!closed_promise_vow = $!closed_promise.vow;
        $!async-notify = Supplier.new;
    }

    method send(Channel:D: \item) {
        X::Channel::SendOnClosed.new(channel => self).throw if $!closed;
        nqp::push($!queue, nqp::decont(item));
        $!async-notify.emit(True);
        Nil
    }

    method !receive(Channel:D: $fail-on-close) {
        my \msg := nqp::shift($!queue);
        if nqp::istype(msg, CHANNEL_CLOSE) {
            nqp::push($!queue, msg);  # make sure other readers see it
            $!closed_promise_vow.keep(Nil);
            X::Channel::ReceiveOnClosed.new(channel => self).throw
              if $fail-on-close;
            Nil
        }
        elsif nqp::istype(msg, CHANNEL_FAIL) {
            nqp::push($!queue, msg);  # make sure other readers see it
            $!closed_promise_vow.break(msg.error);
            msg.error.rethrow;
        }
        else {
            msg
        }
    }

    method receive(Channel:D:)              { self!receive(1) }
    method receive-nil-on-close(Channel:D:) { self!receive(0) }

    method poll(Channel:D:) {
        my \msg := nqp::queuepoll($!queue);
        if nqp::isnull(msg) {
            Nil
        } else {
            if nqp::istype(msg, CHANNEL_CLOSE) {
                $!closed_promise_vow.keep(Nil);
                Nil
            }
            elsif nqp::istype(msg, CHANNEL_FAIL) {
                $!closed_promise_vow.break(msg.error);
                Nil
            }
            else {
                msg
            }
        }
    }

    method !peek(Channel:D:) {
        my \msg := nqp::atpos($!queue, 0);
        if nqp::isnull(msg) {
            Nil
        } else {
            if nqp::istype(msg, CHANNEL_CLOSE) {
                $!closed_promise_vow.keep(Nil);
                Nil
            }
            elsif nqp::istype(msg, CHANNEL_FAIL) {
                $!closed_promise_vow.break(msg.error);
                Nil
            }
            else {
                msg
            }
        }
    }

    method Capture(Channel:D:) { self.List.Capture }
    multi method Supply(Channel:D:) {
        supply {
            # Tap the async notification for new values supply.
            whenever $!async-notify.unsanitized-supply.schedule-on($*SCHEDULER) {
                my Mu \got = self.poll;
                if nqp::eqaddr(got, Nil) {
                    if $!closed_promise {
                        $!closed_promise.status == Kept
                            ?? done()
                            !! die $!closed_promise.cause
                    }
                }
                else {
                    emit got;
                }
            }

            # Grab anything that's in the channel and emit it. Note that
            # it's important to do this after tapping the supply, or a
            # value sent between us draining it and doing the tap would
            # not result in a notification, and so we'd not emit it on
            # the supply. This lost event can then cause a deadlock.
            loop {
                my Mu \got = self.poll;
                last if nqp::eqaddr(got, Nil);
                emit got;
            }
            self!peek();
            if $!closed_promise {
                $!closed_promise.status == Kept
                    ?? done()
                    !! die $!closed_promise.cause
            }
        }
    }

    method iterator(Channel:D:) {
        class :: does Iterator {
            has $!channel;
            method !SET-SELF($!channel) { self }
            method new(\c) { nqp::create(self)!SET-SELF(c) }
            method pull-one() {
                my Mu \got = $!channel.receive-nil-on-close;
                nqp::eqaddr(got, Nil) ?? IterationEnd !! got
            }
        }.new(self)
    }

    method list(Channel:D:) { self.Seq.list }

    my class ChannelAwaitableHandle does Awaitable::Handle {
        has $!channel;
        has $!closed_promise;
        has $!async-notify;

        method not-ready(Channel:D $channel, Promise:D $closed_promise, Supplier:D $async-notify) {
            nqp::create(self)!not-ready($channel, $closed_promise, $async-notify)
        }
        method !not-ready($channel, $closed_promise, $async-notify) {
            $!already = False;
            $!channel := $channel;
            $!closed_promise := $closed_promise;
            $!async-notify := $async-notify;
            self
        }

        method subscribe-awaiter(&subscriber --> Nil) {
            # Need some care here to avoid a race. We must tap the notification
            # supply first, and then do an immediate poll after it, just to be
            # sure we won't miss notifications between the two. Also, we need
            # to take some care that we never call subscriber twice.
            my $notified := False;
            my $l := Lock.new;
            my $t;
            $l.protect: {
                # Lock ensures $t will be assigned before we run the logic
                # inside of poll-now, which relies on being able to do
                # $t.close.
                $t := $!async-notify.unsanitized-supply.tap: &poll-now;
            }
            poll-now();

            sub poll-now($discard?) {
                $l.protect: {
                    unless $notified {
                        my \maybe = $!channel.poll;
                        if maybe === Nil {
                            if $!closed_promise.status == Kept {
                                $notified := True;
                                subscriber(False, X::Channel::ReceiveOnClosed.new(:$!channel))
                            }
                            elsif $!closed_promise.status == Broken {
                                $notified := True;
                                subscriber(False, $!closed_promise.cause)
                            }
                        }
                        else {
                            $notified := True;
                            subscriber(True, maybe);
                        }
                        $t.close if $notified;
                    }
                }
            }
        }
    }

    method get-await-handle(--> Awaitable::Handle:D) {
        my \maybe = self.poll;
        if maybe === Nil {
            if $!closed_promise {
                ChannelAwaitableHandle.already-failure(
                    $!closed_promise.status == Kept
                        ?? X::Channel::ReceiveOnClosed.new(channel => self)
                        !! $!closed_promise.cause
                )
            }
            else {
                ChannelAwaitableHandle.not-ready(self, $!closed_promise, $!async-notify)
            }
        }
        else {
            ChannelAwaitableHandle.already-success(maybe)
        }
    }

    method close() {
        $!closed = 1;
        nqp::push($!queue, CHANNEL_CLOSE);
        # if $!queue is otherwise empty, make sure that $!closed_promise
        # learns about the new value
        self!peek();
        $!async-notify.emit(True);
        Nil
    }

    method elems() {
        Failure.new("Cannot determine number of elements on a {self.^name}")
    }

    method fail($error is copy) {
        $!closed = 1;
        $error = X::AdHoc.new(payload => $error) unless nqp::istype($error, Exception);
        nqp::push($!queue, CHANNEL_FAIL.new(:$error));
        $!async-notify.emit(True);
        Nil
    }

    method closed() {
        self!peek();
        $!closed_promise
    }
}

#line 1 SETTING::src/core/Supply.pm
# When we tap a Supply, we get back a Tap object. We close the tap in order
# to turn off the flow of values.
my class Tap {
    has &!on-close;

    submethod BUILD(:&!on-close --> Nil) { }

    method new(&on-close) {
        self.bless(:&on-close)
    }

    method close() {
        if &!on-close {
            my \close-result = &!on-close();
            await close-result if nqp::istype(close-result, Promise);
        }
        True
    }
}

# The asynchronous dual of the Iterator role; goes inside of a Supply, which
# is the asynchronous dual of the Seq class. So just as a Seq wraps around an
# Iterator so we don't expose all the internal iterator types to the world, a
# Supply wraps about a Tappable so we don't expose all of those. (It may
# surprise you that it's a Tappable, not a Tap, given Seq wraps an Iterator,
# not an Iterable. Guess that's part of the duality too. Ask your local
# category theorist. :-))
my role Tappable {
    method tap(&emit, &done, &quit, &tap) { ... }
    method live() { ... }    # Taps into a live data source
    method serial() { ... }  # Promises no concurrent emits
    method sane() { ... }    # Matches emit* [done|quit]? grammar
}

# A few Supply-related exception types.
my class X::Supply::Combinator is Exception {
    has $.combinator;
    method message() { "Can only use $!combinator to combine defined Supply objects" }
}
my class X::Supply::Migrate::Needs is Exception {
    method message() {
        ".migrate needs Supplies to be emitted"
    }
}
my class X::Supply::New is Exception {
    method message() {
        "Cannot directly create a Supply. You might want:\n" ~
        " - To use a Supplier in order to get a live supply\n" ~
        " - To use Supply.on-demand to create an on-demand supply\n" ~
        " - To create a Supply using a supply block"
    }
}


# A Supply is like an asynchronous Seq. All the methods that you can do on
# a Supply go in here.
my class Supplier { ... }
my class Supplier::Preserving { ... }
my class Supply does Awaitable {
    has Tappable $!tappable;

    proto method new(|) { * }
    multi method new() {
        X::Supply::New.new.throw
    }
    multi method new(Tappable $tappable) {
        self.bless(:$tappable);
    }
    submethod BUILD(:$!tappable! --> Nil) { }

    method Capture(Supply:D:) { self.List.Capture }

    method live(Supply:D:) { $!tappable.live }
    method serial(Supply:D:) { $!tappable.serial }
    method Tappable(--> Tappable) { $!tappable }

    my \DISCARD = -> $ {};
    my \NOP = -> {};
    my \DEATH = -> $ex { $ex.throw };
    method tap(Supply:D: &emit = DISCARD, :&done = NOP, :&quit = DEATH, :&tap = DISCARD) {
        $!tappable.tap(&emit, &done, &quit, &tap)
    }

    method act(Supply:D: &actor, *%others) {
        self.sanitize.tap(&actor, |%others)
    }

    ##
    ## Supply factories
    ##

    my class OnDemand does Tappable {
        has &!producer;
        has &!closing;
        has $!scheduler;

        submethod BUILD(:&!producer!, :&!closing!, :$!scheduler! --> Nil) {}

        method tap(&emit, &done, &quit, &tap) {
            my int $closed = 0;
            my $t = Tap.new: {
                if &!closing {
                    &!closing() unless $closed++;
                }
            }
            tap($t);
            my $p = Supplier.new;
            $p.Supply.tap(&emit,
                done => {
                    done();
                    $t.close();
                },
                quit => -> \ex {
                    quit(ex);
                    $t.close();
                });
            $!scheduler.cue({ &!producer($p) },
                catch => -> \ex { $p.quit(ex) });
            $t
        }

        method live(--> False) { }
        method sane(--> False) { }
        method serial(--> False) { }
    }
    method on-demand(Supply:U: &producer, :&closing, :$scheduler = CurrentThreadScheduler) {
        Supply.new(OnDemand.new(:&producer, :&closing, :$scheduler)).sanitize
    }

    method from-list(Supply:U: +@values, :$scheduler = CurrentThreadScheduler) {
        self.on-demand(-> $p {
            $p.emit($_) for @values;
            $p.done();
        }, :$scheduler);
    }

    my class Interval does Tappable {
        has $!scheduler;
        has $!interval;
        has $!delay;

        submethod BUILD(:$!scheduler, :$!interval, :$!delay --> Nil) { }

        method tap(&emit, &, &, &tap) {
            my $i = 0;
            my $lock = Lock::Async.new;
            $lock.protect: {
                my $cancellation = $!scheduler.cue(
                    {
                        emit($lock.protect: { $i++ });
                        CATCH { $cancellation.cancel if $cancellation }
                    },
                    :every($!interval), :in($!delay)
                );
                my $t = Tap.new({ $cancellation.cancel });
                tap($t);
                $t
            }
        }

        method live(--> False) { }
        method sane(--> True) { }
        method serial(--> False) { }
    }
    method interval(Supply:U: $interval, $delay = 0, :$scheduler = $*SCHEDULER) {
        Supply.new(Interval.new(:$interval, :$delay, :$scheduler));
    }

    ##
    ## Simple operations are those that operate on a single Supply, carry its
    ## liveness, and are always serial. We implement the directly as they are
    ## common and fairly "hot path".
    ##

    my role SimpleOpTappable does Tappable {
        has $!source;
        method live() { $!source.live }
        method sane(--> True) { }
        method serial(--> True) { }
        method !cleanup(int $cleaned-up is rw, $source-tap) {
            if $source-tap && !$cleaned-up  {
                $cleaned-up = 1;
                $source-tap.close;
            }
        }
    }

    my class Serialize does SimpleOpTappable {
        submethod BUILD(:$!source! --> Nil) { }

        method tap(&emit, &done, &quit, &tap) {
            my $lock = Lock::Async.new;
            my int $cleaned-up = 0;
            my $source-tap;
            my $t;
            $!source.tap(
                tap => {
                    $source-tap = $_;
                    $t = Tap.new({ self!cleanup($cleaned-up, $source-tap) });
                    tap($t);
                },
                -> \value{
                    $lock.protect-or-queue-on-recursion: { emit(value); }
                },
                done => -> {
                    $lock.protect-or-queue-on-recursion: {
                        done();
                        self!cleanup($cleaned-up, $source-tap);
                    }
                },
                quit => -> $ex {
                    $lock.protect-or-queue-on-recursion: {
                        quit($ex);
                        self!cleanup($cleaned-up, $source-tap);
                    }
                });
            $t
        }
    }
    method serialize(Supply:D:) {
        $!tappable.serial ?? self !! Supply.new(Serialize.new(source => self))
    }

    my class Sanitize does SimpleOpTappable {
        submethod BUILD(:$!source! --> Nil) { }

        method tap(&emit, &done, &quit, &tap) {
            my int $cleaned-up = 0;
            my int $finished = 0;
            my $source-tap;
            my $t;
            $!source.tap(
                tap => {
                    $source-tap = $_;
                    $t = Tap.new({ self!cleanup($cleaned-up, $source-tap) });
                    tap($t);
                },
                -> \value{
                    emit(value) unless $finished;
                },
                done => -> {
                    unless $finished {
                        $finished = 1;
                        done();
                        self!cleanup($cleaned-up, $source-tap);
                    }
                },
                quit => -> $ex {
                    unless $finished {
                        $finished = 1;
                        quit($ex);
                        self!cleanup($cleaned-up, $source-tap);
                    }
                });
            $t
        }
    }
    method sanitize() {
        $!tappable.sane ?? self !! Supply.new(Sanitize.new(source => self.serialize))
    }

    my class OnClose does SimpleOpTappable {
        has &!on-close;

        submethod BUILD(:$!source!, :&!on-close! --> Nil) { }

        method tap(&emit, &done, &quit, &tap) {
            my int $cleaned-up = 0;
            my $t;
            $!source.tap: &emit, :&done, :&quit, tap => -> $source-tap {
                $t = Tap.new({
                    &!on-close();
                    self!cleanup($cleaned-up, $source-tap)
                });
                tap($t);
            }
            $t
        }
    }
    method on-close(Supply:D: &on-close) {
        return Supply.new(OnClose.new(source => self, :&on-close))
    }

    my class MapSupply does SimpleOpTappable {
        has &!mapper;

        submethod BUILD(:$!source!, :&!mapper! --> Nil) { }

        method tap(&emit, &done, &quit, &tap) {
            my int $cleaned-up = 0;
            my $source-tap;
            my $t;
            $!source.tap(
                tap => {
                    $source-tap = $_;
                    $t = Tap.new({ self!cleanup($cleaned-up, $source-tap) });
                    tap($t);
                },
                -> \value {
                    my \result = try &!mapper(value);
                    if $! {
                        quit($!);
                        self!cleanup($cleaned-up, $source-tap);
                    }
                    else {
                        emit(result)
                    }
                },
                done => -> {
                    done();
                    self!cleanup($cleaned-up, $source-tap);
                },
                quit => -> $ex {
                    quit($ex);
                    self!cleanup($cleaned-up, $source-tap);
                });
            $t
        }
    }
    method map(Supply:D: &mapper) {
        Supply.new(MapSupply.new(source => self.sanitize, :&mapper))
    }

    my class Grep does SimpleOpTappable {
        has Mu $!test;

        submethod BUILD(:$!source!, Mu :$!test! --> Nil) { }

        method tap(&emit, &done, &quit, &tap) {
            my int $cleaned-up = 0;
            my $source-tap;
            my $t;
            $!source.tap(
                tap => {
                    $source-tap = $_;
                    $t = Tap.new({ self!cleanup($cleaned-up, $source-tap) });
                    tap($t);
                },
                -> \value {
                    my \accepted = try $!test.ACCEPTS(value);
                    if accepted {
                        emit(value);
                    }
                    elsif $! {
                        quit($!);
                        self!cleanup($cleaned-up, $source-tap);
                    }
                },
                done => -> {
                    done();
                    self!cleanup($cleaned-up, $source-tap);
                },
                quit => -> $ex {
                    quit($ex);
                    self!cleanup($cleaned-up, $source-tap);
                });
            $t
        }
    }
    method grep(Supply:D: Mu $test) {
        Supply.new(Grep.new(source => self.sanitize, :$test))
    }

    my class ScheduleOn does SimpleOpTappable {
        has $!scheduler;

        submethod BUILD(:$!source!, :$!scheduler! --> Nil) { }

        method tap(&emit, &done, &quit, &tap) {
            my int $cleaned-up = 0;
            my $source-tap;
            my $t;
            $!source.tap(
                tap => {
                    $source-tap = $_;
                    $t = Tap.new({ self!cleanup($cleaned-up, $source-tap) });
                    tap($t);
                },
                -> \value {
                    $!scheduler.cue: { emit(value) }
                },
                done => -> {
                    $!scheduler.cue: { done(); self!cleanup($cleaned-up, $source-tap); }
                },
                quit => -> $ex {
                    $!scheduler.cue: { quit($ex); self!cleanup($cleaned-up, $source-tap); }
                });
            $t
        }
    }
    method schedule-on(Supply:D: Scheduler $scheduler) {
        Supply.new(ScheduleOn.new(source => self.sanitize, :$scheduler))
    }

    my class Start does SimpleOpTappable {
        has $!value;
        has &!startee;

        submethod BUILD(:$!value, :&!startee --> Nil) { }

        method tap(&emit, &done, &quit, &tap) {
            my int $closed = 0;
            my $t = Tap.new({ $closed = 1 });
            tap($t);
            Promise.start({ &!startee($!value) }).then({
                unless $closed {
                    if .status == Kept {
                        emit(.result);
                        done();
                    }
                    else {
                        quit(.cause);
                    }
                }
            });
            $t
        }
    }
    method start(Supply:D: &startee) {
        self.map: -> \value {
            Supply.new(Start.new(:value(value), :&startee))
        }
    }

    my class Stable does SimpleOpTappable {
        has $!time;
        has $!scheduler;

        submethod BUILD(:$!source!, :$!time!, :$!scheduler! --> Nil) { }

        method tap(&emit, &done, &quit, &tap) {
            my int $cleaned-up = 0;
            my $lock = Lock::Async.new;
            my $last_cancellation;
            my $source-tap;
            my $t;
            $!source.tap(
                tap => {
                    $source-tap = $_;
                    $t = Tap.new({ self!cleanup($cleaned-up, $source-tap) });
                    tap($t);
                },
                -> \value {
                    $lock.protect: {
                        if $last_cancellation {
                            $last_cancellation.cancel;
                        }
                        $last_cancellation = $!scheduler.cue(
                            :in($!time),
                            {
                                $lock.protect: { $last_cancellation = Nil; }
                                try {
                                    emit(value);
                                    CATCH {
                                        default {
                                            quit($_);
                                            self!cleanup($cleaned-up, $source-tap);
                                        }
                                    }
                                }
                            });
                    }
                },
                done => -> {
                    done();
                    self!cleanup($cleaned-up, $source-tap);
                },
                quit => -> $ex {
                    quit($ex);
                    self!cleanup($cleaned-up, $source-tap);
                });
            $t
        }
    }
    method stable(Supply:D: $time, :$scheduler = $*SCHEDULER) {
        return self unless $time;
        Supply.new(Stable.new(source => self.sanitize, :$time, :$scheduler))
    }

    my class Delayed does SimpleOpTappable {
        has $!time;
        has $!scheduler;

        submethod BUILD(:$!source!, :$!time, :$!scheduler! --> Nil) { }

        method tap(&emit, &done, &quit, &tap) {
            my int $cleaned-up = 0;
            my $source-tap;
            my $t;
            $!source.tap(
                tap => {
                    $source-tap = $_;
                    my $t = Tap.new({ self!cleanup($cleaned-up, $source-tap) });
                    tap($t);
                },
                -> \value {
                    $!scheduler.cue: { emit(value) }, :in($!time)
                },
                done => -> {
                    $!scheduler.cue:
                        { done(); self!cleanup($cleaned-up, $source-tap); },
                        :in($!time)
                },
                quit => -> $ex {
                    $!scheduler.cue:
                        { quit($ex); self!cleanup($cleaned-up, $source-tap); },
                        :in($!time)
                });
            $t
        }
    }
    method delayed(Supply:D: $time, :$scheduler = $*SCHEDULER) {
        return self unless $time;  # nothing to do
        Supply.new(Delayed.new(source => self.sanitize, :$time, :$scheduler))
    }

    ##
    ## A bunch of the more complex combinators, implemented as supply blocks
    ##

    method do(Supply:D $self: &side-effect) {
        supply {
            whenever self -> \value {
                side-effect(value);
                emit(value);
            }
        }
    }

    method flat(Supply:D:) {
        supply {
            whenever self -> \inner {
                whenever inner -> \value {
                    emit value;
                }
            }
        }
    }

    method merge(*@s) {
        @s.unshift(self) if self.DEFINITE;  # add if instance method
        return supply { } unless +@s;       # nothing to be done

        X::Supply::Combinator.new(
           combinator => 'merge'
        ).throw unless Rakudo::Internals.ALL_DEFINED_TYPE(@s,Supply);

        return @s[0].sanitize  if +@s == 1; # nothing to be done

        supply {
            for @s {
                whenever $_ -> \value { emit(value) }
            }
        }
    }

    method reduce(Supply:D $self: &with) {
        supply {
            my $first := True;
            my $reduced := Nil;
            whenever self -> \value {
                if $first {
                    $reduced := value;
                    $first := False;
                }
                else {
                    $reduced := with($reduced, value);
                }
                LAST {
                    emit $reduced;
                }
            }
        }
    }

    method produce(Supply:D $self: &with) {
        supply {
            my $first := True;
            my $reduced := Nil;
            whenever self -> \value {
                if $first {
                    $reduced := value;
                    $first := False;
                }
                else {
                    $reduced := with($reduced, value);
                }
                emit $reduced;
            }
        }
    }

    method migrate(Supply:D:) {
        supply {
            my $current;
            whenever self -> \inner {
                X::Supply::Migrate::Needs.new.throw
                    unless nqp::istype(inner, Supply);
                $current.close if $current;
                $current = do whenever inner -> \value {
                    emit(value);
                }
            }
        }
    }

    proto method classify(|) { * }
    multi method classify(Supply:D: &mapper )  {
        self!classify(&mapper);
    }
    multi method classify(Supply:D: %mapper )  {
        self!classify({ %mapper{$^a} });
    }
    multi method classify(Supply:D: @mapper )  {
        self!classify({ @mapper[$^a] });
    }

    proto method categorize (|) { * }
    multi method categorize(Supply:D: &mapper )  {
        self!classify(&mapper, :multi);
    }
    multi method categorize(Supply:D: %mapper )  {
        self!classify({ %mapper{$^a} }, :multi);
    }
    multi method categorize(Supply:D: @mapper )  {
        self!classify({ @mapper[$^a] }, :multi);
    }

    method !classify(&mapper, :$multi) {
        supply {
            my %mapping;

            sub find-target($key) {
                %mapping{ $key.WHICH } //= do {
                    my $p = Supplier::Preserving.new;
                    emit($key => $p.Supply);
                    $p
                };
            }

            whenever self -> \value {
                if $multi {
                    for @(mapper(value)) -> $key {
                        find-target($key).emit(value);
                    }
                }
                else {
                    find-target(mapper(value)).emit(value);
                }
                LAST {
                    %mapping.values>>.done;
                }
            }
        }
    }

    ##
    ## Coercions
    ##

    multi method Supply(Supply:D:) { self }

    method Channel(Supply:D:) {
        my $c = Channel.new();
        self.sanitize.tap:
            -> \val { $c.send(val) },
            done => { $c.close },
            quit => -> $ex { $c.fail($ex) };
        $c
    }

    my class ConcQueue is repr('ConcBlockingQueue') { }
    multi method list(Supply:D:) {
        gather {
            my Mu \queue = nqp::create(ConcQueue);
            my $exception;
            self.tap(
                -> \val { nqp::push(queue, val) },
                done => -> { nqp::push(queue, ConcQueue) }, # type obj as sentinel
                quit => -> \ex { $exception := ex; nqp::push(queue, ConcQueue) });
            loop {
                my \got = nqp::shift(queue);
                if got =:= ConcQueue {
                    $exception.DEFINITE
                        ?? $exception.throw
                        !! last
                }
                else {
                    take got;
                }
            }
        }
    }

    method Promise(Supply:D:) {
        my $p = Promise.new;
        my $v = $p.vow;
        my $final := Nil;
        my $t = self.tap:
            -> \val { $final := val },
            done => { $v.keep($final) },
            quit => -> \ex { $v.break(ex) };
        $p
    }

    method wait(Supply:D:) { await self.Promise }

    my class SupplyAwaitableHandle does Awaitable::Handle {
        has $!supply;

        method not-ready(Supply:D \supply) {
            nqp::create(self)!not-ready(supply)
        }
        method !not-ready(\supply) {
            $!already = False;
            $!supply := supply;
            self
        }

        method subscribe-awaiter(&subscriber --> Nil) {
            my $final := Nil;
            $!supply.tap:
                -> \val { $final := val },
                done => { subscriber(True, $final) },
                quit => -> \ex { subscriber(False, ex) };
        }
    }

    method get-await-handle(--> Awaitable::Handle) {
        SupplyAwaitableHandle.not-ready(self)
    }

    method unique(Supply:D $self: :&as, :&with, :$expires) {
        supply {
            if $expires {
                if &with and !(&with === &[===]) {
                    my @seen;  # really Mu, but doesn't work in settings
                    my Mu $target;
                    if &as {
                        whenever self -> \val {
                            my $now := now;
                            $target = &as(val);
                            my $index =
                              @seen.first({&with($target,$_[0])},:k);
                            with $index {
                                if $now > @seen[$index][1] {  # expired
                                    @seen[$index][1] = $now+$expires;
                                    emit(val);
                                }
                            }
                            else {
                                @seen.push: [$target, $now+$expires];
                                emit(val);
                            }
                        }
                    }
                    else {
                        whenever self -> \val {
                            my $now := now;
                            my $index =
                              @seen.first({&with(val,$_[0])},:k);
                            with $index {
                                if $now > @seen[$index][1] {  # expired
                                    @seen[$index][1] = $now+$expires;
                                    emit(val);
                                }
                            }
                            else {
                                @seen.push: [val, $now+$expires];
                                emit(val);
                            }
                        }
                    }
                }
                else {
                    my $seen := nqp::hash();
                    my str $target;
                    if &as {
                        whenever self -> \val {
                            my $now := now;
                            $target = nqp::unbox_s(&as(val).WHICH);
                            if !nqp::existskey($seen,$target) ||
                              $now > nqp::atkey($seen,$target) { #expired
                                emit(val);
                                nqp::bindkey($seen,$target,$now+$expires);
                            }
                        }
                    }
                    else {
                        whenever self -> \val {
                            my $now := now;
                            $target = nqp::unbox_s(val.WHICH);
                            if !nqp::existskey($seen,$target) ||
                              $now > nqp::atkey($seen,$target) { #expired
                                emit(val);
                                nqp::bindkey($seen,$target,$now+$expires);
                            }
                        }
                    }
                }
            }
            else { # !$!expires
                if &with and !(&with === &[===]) {
                    my @seen;  # really Mu, but doesn't work in settings
                    my Mu $target;
                    if &as {
                        whenever self -> \val {
                            $target = &as(val);
                            if @seen.first({ &with($target,$_) } ) =:= Nil {
                                @seen.push($target);
                                emit(val);
                            }
                        }
                    }
                    else {
                        whenever self -> \val {
                            if @seen.first({ &with(val,$_) } ) =:= Nil {
                                @seen.push(val);
                                emit(val);
                            }
                        }
                    }
                }
                else {
                    my $seen := nqp::hash();
                    my str $target;
                    if &as {
                        whenever self -> \val {
                            $target = nqp::unbox_s(&as(val).WHICH);
                            unless nqp::existskey($seen, $target) {
                                nqp::bindkey($seen, $target, 1);
                                emit(val);
                            }
                        }
                    }
                    else {
                        whenever self -> \val {
                            $target = nqp::unbox_s(val.WHICH);
                            unless nqp::existskey($seen, $target) {
                                nqp::bindkey($seen, $target, 1);
                                emit(val);
                            }
                        }
                    }
                }
            }
        }
    }

    method squish(Supply:D $self: :&as, :&with is copy) {
        &with //= &[===];
        supply {
            my int $first = 1;
            my Mu $last;
            my Mu $target;

            if &as {
                whenever self -> \val {
                    $target = &as(val);
                    if $first || !&with($last,$target) {
                        $first = 0;
                        emit(val);
                    }
                    $last  = $target;
                }
            }
            else {
                whenever self -> \val {
                    if $first || !&with($last, val) {
                        $first = 0;
                        emit(val);
                    }
                    $last = val;
                }
            }
        }
    }

    multi method rotor(Supply:D $self: Int:D $batch, :$partial) {
        self.rotor(($batch,), :$partial)
    }
    multi method rotor(Supply:D $self: *@cycle, :$partial) {
        my @c := @cycle.is-lazy ?? @cycle !! (@cycle xx *).flat.cache;
        supply {
            my Int $elems;
            my Int $gap;
            my int $to-skip;
            my int $skip;
            my \c = @c.iterator;

            sub next-batch(--> Nil) {
                given c.pull-one {
                    when Pair {
                        $elems   = +.key;
                        $gap     = +.value;
                        $to-skip = $gap > 0 ?? $gap !! 0;
                    }
                    default {
                        $elems   = +$_;
                        $gap     = 0;
                        $to-skip = 0;
                    }
                }
            }
            next-batch;

            my @batched;
            sub flush(--> Nil) {
                emit( @batched.splice(0, +@batched, @batched[* + $gap .. *]) );
                $skip = $to-skip;
            }

            whenever self -> \val {
                @batched.push: val unless $skip && $skip--;
                if @batched.elems == $elems {
                    flush;
                    next-batch;
                }
                LAST {
                    flush if @batched and $partial;
                }
            }
        }
    }

    method batch(Supply:D $self: Int(Cool) :$elems = 0, :$seconds) {
        supply {
            my int $max = $elems >= 0 ?? $elems !! 0;
            my $batched := nqp::list;
            my $last_time;
            sub flush(--> Nil) {
                emit($batched);
                $batched := nqp::list;
            }
            sub final-flush(--> Nil) {
                flush if nqp::elems($batched);
            }

            if $seconds {
                $last_time = time div $seconds;

                if $elems > 0 { # and $seconds
                    whenever self -> \val {
                        my $this_time = time div $seconds;
                        if $this_time != $last_time {
                            flush if nqp::elems($batched);
                            $last_time = $this_time;
                            nqp::push($batched,val);
                        }
                        else {
                            nqp::push($batched,val);
                            flush if nqp::iseq_i(nqp::elems($batched),$max);
                        }
                        LAST { final-flush; }
                    }
                }
                else {
                    whenever self -> \val {
                        my $this_time = time div $seconds;
                        if $this_time != $last_time {
                            flush if nqp::elems($batched);
                            $last_time = $this_time;
                        }
                        nqp::push($batched,val);
                        LAST { final-flush; }
                    }
                }
            }
            else { # just $elems
                whenever self -> \val {
                    nqp::push($batched,val);
                    flush if nqp::isge_i(nqp::elems($batched),$max);
                    LAST { final-flush; }
                }
            }
        }
    }

    method lines(Supply:D $self: :$chomp = True ) {
        supply {
            my str $str;
            my int $chars;
            my int $left;
            my int $pos;
            my int $nextpos;
            my int $found;

            whenever self -> \val {
                $str   = $str ~ nqp::unbox_s(val);
                $chars = nqp::chars($str);
                $pos   = 0;

                while ($left = $chars - $pos) > 0 {
                    $nextpos = nqp::findcclass(
                      nqp::const::CCLASS_NEWLINE, $str, $pos, $left
                    );

                    last
                      if $nextpos >= $chars     # no line delimiter
                      or $nextpos == $chars - 1 # broken CRLF ?
                        && nqp::eqat($str, "\r", $nextpos); # yes!

                    if $chomp {
                        emit( ($found = $nextpos - $pos)
                          ?? nqp::p6box_s(nqp::substr($str,$pos,$found))
                          !! ''
                        );
                        $pos = $nextpos + 1;
                    }
                    else {
                        $found = $nextpos - $pos + 1;
                        emit(
                          nqp::p6box_s(nqp::substr($str,$pos,$found)));
                        $pos = $pos + $found;
                    }
                }
                $str = $pos < $chars
                  ?? nqp::substr($str,$pos)
                  !! '';

                LAST {
                    if $str {
                        $chars = nqp::chars($str);
                        emit( $chomp && nqp::iscclass(
                          nqp::const::CCLASS_NEWLINE,$str,$chars-1)
                            ?? nqp::p6box_s(nqp::substr($str,0,$chars - 1))
                            !! nqp::p6box_s($str)
                        );
                    }
                }
            }
        }
    }

    method words(Supply:D $self:) {
        supply {
            my str $str;
            my int $chars;
            my int $left;
            my int $pos;
            my int $nextpos;
            my int $found;
            my int $cr;
            my int $crlf;

            whenever self -> \val {
                $str   = $str ~ nqp::unbox_s(val);
                $chars = nqp::chars($str);
                $pos   = nqp::findnotcclass(
                  nqp::const::CCLASS_WHITESPACE, $str, 0, $chars);

                while ($left = $chars - $pos) > 0 {
                    $nextpos = nqp::findcclass(
                      nqp::const::CCLASS_WHITESPACE, $str, $pos, $left
                    );

                    last unless $left = $chars - $nextpos; # broken word

                    emit( nqp::box_s(
                      nqp::substr( $str, $pos, $nextpos - $pos ), Str)
                    );

                    $pos = nqp::findnotcclass(
                      nqp::const::CCLASS_WHITESPACE,$str,$nextpos,$left);
                }
                $str = $pos < $chars
                  ?? nqp::substr($str,$pos)
                  !! '';

                LAST {
                    emit( nqp::box_s($str, Str) ) if $str;
                }
            }
        }
    }

    method elems(Supply:D $self: $seconds? ) {
        supply {
            my int $elems = 0;
            if $seconds {
                my $last_time = time div $seconds;
                my int $last_elems = $elems;
                whenever self -> \val {
                    $last_elems = $elems = $elems + 1;
                    my $this_time = time div $seconds;
                    if $this_time != $last_time {
                        emit $elems;
                        $last_time = $this_time;
                    }
                    LAST emit($elems) if $elems != $last_elems;
                }
            }
            else {
                whenever self -> \val { emit $elems = $elems + 1 }
            }
        }
    }

    method head(Supply:D: Int(Cool) $number = 1) {
        supply {
            my int $todo = $number;
            whenever self -> \val {
                if $todo > 0 {
                    emit val;
                    $todo = $todo - 1;
                }
                done if $todo <= 0;  # nothing left to do
            }
        }
    }

    method tail(Supply:D: Int(Cool) $number = 1) {
        my int $size = $number;

        supply {
            if $size == 1 {
                my $last;
                whenever self -> \val {
                    $last := val;
                    LAST emit $last;
                }
            }
            elsif $size > 1 {
                my $lastn := nqp::list;
                my int $index = 0;
                nqp::setelems($lastn,$number);  # presize list
                nqp::setelems($lastn,0);

                whenever self -> \val {
                    nqp::bindpos($lastn,$index,val);
                    $index = ($index + 1) % $size;
                    LAST {
                        my int $todo = nqp::elems($lastn);
                        $index = 0           # start from beginning
                          if $todo < $size;  # if not a full set
                        while $todo {
                            emit nqp::atpos($lastn,$index);
                            $index = ($index + 1) % $size;
                            $todo = $todo - 1;
                        }
                    }
                }
            }
            else {  # number <= 0, needed to keep tap open
                whenever self -> \val { }
            }
        }
    }

    method skip(Supply:D: Int(Cool) $number = 1) {
        supply {
            my int $size = $number + 1;
            my int $skipping = $size > 1;
            whenever self {
                .emit unless $skipping && ($skipping = --$size)
            }
        }
    }

    method min(Supply:D $self: &by = &infix:<cmp>) {
        my &cmp = &by.arity == 2 ?? &by !! { by($^a) cmp by($^b) }
        supply {
            my $min;
            whenever self -> \val {
                if val.defined and !$min.defined || cmp(val,$min) < 0 {
                    emit( $min := val );
                }
            }
        }
    }

    method max(Supply:D $self: &by = &infix:<cmp>) {
        my &cmp = &by.arity == 2 ?? &by !! { by($^a) cmp by($^b) }
        supply {
            my $max;
            whenever self -> \val {
                 if val.defined and !$max.defined || cmp(val,$max) > 0 {
                     emit( $max = val );
                 }
            }
        }
    }

    method minmax(Supply:D $self: &by = &infix:<cmp>) {
        my &cmp = &by.arity == 2 ?? &by !! { by($^a) cmp by($^b) }
        supply {
            my $min;
            my $max;
            whenever self -> \val {
                if nqp::istype(val,Failure) {
                    val.throw;  # XXX or just ignore ???
                }
                elsif val.defined {
                    if !$min.defined {
                        emit( Range.new($min = val, $max = val) );
                    }
                    elsif cmp(val,$min) < 0 {
                        emit( Range.new( $min = val, $max ) );
                    }
                    elsif cmp(val,$max) > 0 {
                        emit( Range.new( $min, $max = val ) );
                    }
                }
            }
        }
    }

    method grab(Supply:D $self: &when_done) {
        supply {
            my @seen;
            whenever self -> \val {
                @seen.push: val;
                LAST {
                    emit($_) for when_done(@seen);
                }
            }
        }
    }

    method reverse(Supply:D:)        { self.grab( {.reverse} ) }
    multi method sort(Supply:D:)     { self.grab( {.sort} ) }
    multi method sort(Supply:D: &by) { self.grab( {.sort(&by)} ) }

    method zip(**@s, :&with) {
        @s.unshift(self) if self.DEFINITE;  # add if instance method
        return supply { } unless +@s;       # nothing to be done

        X::Supply::Combinator.new(
           combinator => 'zip'
        ).throw unless Rakudo::Internals.ALL_DEFINED_TYPE(@s,Supply);

        return @s[0]  if +@s == 1;          # nothing to be done

        supply {
            my @values = [] xx +@s;
            for @s.kv -> $index, $supply {
                if &with {
                    whenever $supply -> \val {
                        @values[$index].push(val);
                        emit( [[&with]] @values.map(*.shift) ) if all(@values);
                    }
                }
                else {
                    whenever $supply -> \val {
                        @values[$index].push(val);
                        emit( $(@values.map(*.shift).list.eager) ) if all(@values);
                    }
                }
            }
        }
    }

    method zip-latest(**@s, :&with, :$initial ) {
        @s.unshift(self) if self.DEFINITE;  # add if instance method
        return supply { } unless +@s;       # nothing to do.

        X::Supply::Combinator.new(
           combinator => 'zip-latest'
        ).throw unless Rakudo::Internals.ALL_DEFINED_TYPE(@s,Supply);

        return @s[0] if +@s == 1;           # nothing to do.

        supply {
            my @values;

            my $uninitialised = +@s; # how many supplies have yet to emit until we
                                     # can start emitting, too?

            if $initial {
                @values = @$initial;
                $uninitialised = 0 max $uninitialised - @$initial;
            }

            for @s.kv -> $index, $supply {
                if &with {
                    whenever $supply -> \val {
                        --$uninitialised
                        if $uninitialised > 0 && not @values.EXISTS-POS($index);
                        @values[$index] = val;
                        emit( [[&with]] @values ) unless $uninitialised;
                    }
                }
                else {
                    whenever $supply -> \val {
                        --$uninitialised
                            if $uninitialised > 0 && not @values.EXISTS-POS($index);
                        @values[$index] = val;
                        emit( @values.List.item ) unless $uninitialised;
                    }
                }
            }
        }
    }

    proto method throttle(|) { * }
    multi method throttle(Supply:D $self:
      Int()  $elems,
      Real() $seconds,
      Real() $delay  = 0,
      :$scheduler    = $*SCHEDULER,
      :$control,
      :$status,
      :$bleed,
      :$vent-at,
    ) {
        my $timer = Supply.interval($seconds,$delay,:$scheduler);
        my int $limit   = $elems;
        my int $vent = $vent-at if $bleed;;
        supply {
            my @buffer;
            my int $allowed = $limit;
            my int $emitted;
            my int $bled;
            my int $done;
            sub emit-status($id --> Nil) {
               $status.emit(
                 { :$allowed, :$bled, :buffered(+@buffer),
                   :$emitted, :$id,   :$limit,  :$vent-at } );
            }

            whenever $timer -> \tick {
                if +@buffer -> \buffered {
                    my int $todo = buffered > $limit ?? $limit !! buffered;
                    emit(@buffer.shift) for ^$todo;
                    $emitted = $emitted + $todo;
                    $allowed = $limit   - $todo;
                }
                else {
                    $allowed = $limit;
                }
                if $done && !@buffer {
                    done;
                }
            }

            whenever self -> \val {
                if $allowed {
                    emit(val);
                    $emitted = $emitted + 1;
                    $allowed = $allowed - 1;
                }
                elsif $vent && +@buffer >= $vent {
                    $bleed.emit(val);
                }
                else {
                    @buffer.push(val);
                }
                LAST {
                    if $status {
                        emit-status("done");
                        $status.done;
                    }
                    if $bleed && @buffer {
                        $bleed.emit(@buffer.shift) while @buffer;
                        $bleed.done;
                    }
                    $done = 0;
                }
            }

            if $control {
                whenever $control -> \val {
                   my str $type;
                   my str $value;
                   Rakudo::Internals.KEY_COLON_VALUE(val,$type,$value);

                   if $type eq 'limit' {
                       my int $extra = $value - $limit;
                       $allowed = $extra > 0 || $allowed + $extra >= 0
                         ?? $allowed + $extra
                         !! 0;
                       $limit = $value;
                   }
                   elsif $type eq 'bleed' && $bleed {
                       my int $todo = $value min +@buffer;
                       $bleed.emit(@buffer.shift) for ^$todo;
                       $bled = $bled + $todo;
                   }
                   elsif $type eq 'status' && $status {
                       emit-status($value);
                   }
                   elsif $type eq 'vent-at' && $bleed {
                       $vent = $value;
                       if $vent && +@buffer > $vent {
                           $bleed.emit(@buffer.shift)
                             until !@buffer || +@buffer == $vent;
                       }
                   }
                }
            }
        }
    }
    multi method throttle(Supply:D $self:
      Int()  $elems,
      Callable:D $process,
      Real() $delay = 0,
      :$scheduler   = $*SCHEDULER,
      :$control,
      :$status,
      :$bleed,
      :$vent-at,
    ) {
        sleep $delay if $delay;
        my @buffer;
        my int $limit   = $elems;
        my int $allowed = $limit;
        my int $running;
        my int $emitted;
        my int $bled;
        my int $done;
        my int $vent = $vent-at if $bleed;
        my $ready = Supplier::Preserving.new;
        sub start-process(\val --> Nil) {
            my $p = Promise.start( $process, :$scheduler, val );
            $running = $running + 1;
            $allowed = $allowed - 1;
            $p.then: { $ready.emit($p) };
        }
        sub emit-status($id --> Nil) {
           $status.emit(
             { :$allowed, :$bled, :buffered(+@buffer),
               :$emitted, :$id,   :$limit, :$running } );
        }
        supply {
            whenever $ready.Supply -> \val { # when a process is ready
                $running = $running - 1;
                $allowed = $allowed + 1;
                emit(val);
                $emitted = $emitted + 1;
                start-process(@buffer.shift) if $allowed > 0 && @buffer;

                if $done && !$running {
                    $control.done if $control;
                    if $status {
                        emit-status("done");
                        $status.done;
                    }
                    if $bleed && @buffer {
                        $bleed.emit(@buffer.shift) while @buffer;
                        $bleed.done;
                    }
                    done;
                }
            }

            if $control {
                whenever $control -> \val {
                    my str $type;
                    my str $value;
                    Rakudo::Internals.KEY_COLON_VALUE(val,$type,$value);

                    if $type eq 'limit' {
                        $allowed = $allowed + $value - $limit;
                        $limit   = $value;
                        start-process(@buffer.shift)
                          while $allowed > 0 && @buffer;
                    }
                    elsif $type eq 'bleed' && $bleed {
                        my int $todo = $value min +@buffer;
                        $bleed.emit(@buffer.shift) for ^$todo;
                        $bled = $bled + $todo;
                    }
                    elsif $type eq 'status' && $status {
                        emit-status($value);
                    }
                    elsif $type eq 'vent-at' && $bleed {
                        $vent = $value;
                        if $vent && +@buffer > $vent {
                            $bleed.emit(@buffer.shift)
                              until !@buffer || +@buffer == $vent;
                        }
                    }
                }
            }

            whenever self -> \val {
                $allowed > 0
                  ?? start-process(val)
                  !! $vent && $vent == +@buffer
                    ?? $bleed.emit(val)
                    !! @buffer.push(val);
                LAST { $done = 1 }
            }
        }
    }

    method share(Supply:D:) {
        my $sup = Supplier.new;
        self.tap:
            -> \msg { $sup.emit(msg) },
            done => -> { $sup.done() },
            quit => -> \ex { $sup.quit(ex) }
        $sup.Supply
    }
}

# A Supplier is a convenient way to create a live Supply. The publisher can
# be used to emit/done/quit. The Supply objects obtained from it will tap into
# the same live Supply.
my class Supplier {
    my class TapList does Tappable {
        my class TapListEntry {
            has &.emit;
            has &.done;
            has &.quit;
        }

        # Lock serializes updates to tappers.
        has Lock $!lock = Lock.new;

        # An immutable list of tappers. Always replaced on change, never
        # mutated in-place ==> thread safe together with lock (and only
        # need lock on modification).
        has Mu $!tappers;

        method tap(&emit, &done, &quit, &tap) {
            my $tle := TapListEntry.new(:&emit, :&done, :&quit);
            my $t = Tap.new({
                $!lock.protect({
                    my Mu $update := nqp::list();
                    for nqp::hllize($!tappers) -> \entry {
                        nqp::push($update, entry) unless entry =:= $tle;
                    }
                    $!tappers := $update;
                });
            });
            tap($t);
            $!lock.protect({
                my Mu $update := nqp::isconcrete($!tappers)
                    ?? nqp::clone($!tappers)
                    !! nqp::list();
                nqp::push($update, $tle);
                $!tappers := $update;
            });
            $t
        }

        method emit(\value --> Nil) {
            my $snapshot := $!tappers;
            if nqp::isconcrete($snapshot) {
                my int $n = nqp::elems($snapshot);
                loop (my int $i = 0; $i < $n; $i = $i + 1) {
                    nqp::atpos($snapshot, $i).emit()(value);
                }
            }
        }

        method done(--> Nil) {
            my $snapshot := $!tappers;
            if nqp::isconcrete($snapshot) {
                my int $n = nqp::elems($snapshot);
                loop (my int $i = 0; $i < $n; $i = $i + 1) {
                    nqp::atpos($snapshot, $i).done()();
                }
            }
        }

        method quit($ex --> Nil) {
            my $snapshot := $!tappers;
            if nqp::isconcrete($snapshot) {
                my int $n = nqp::elems($snapshot);
                loop (my int $i = 0; $i < $n; $i = $i + 1) {
                    nqp::atpos($snapshot, $i).quit()($ex);
                }
            }
        }

        method live(--> True) { }
        method serial(--> False) { }
        method sane(--> False)  { }
    }

    has $!taplist;

    method new() {
        self.bless(taplist => TapList.new)
    }
    submethod BUILD(:$!taplist! --> Nil) { }

    method emit(Supplier:D: Mu \value) {
        $!taplist.emit(value);
    }

    method done(Supplier:D:) {
        $!taplist.done();
    }

    proto method quit($) { * }
    multi method quit(Supplier:D: Exception $ex) {
        $!taplist.quit($ex);
    }
    multi method quit(Supplier:D: Str() $message) {
        $!taplist.quit(X::AdHoc.new(payload => $message));
    }

    method Supply(Supplier:D:) {
        Supply.new($!taplist).sanitize
    }

    method unsanitized-supply(Supplier:D:) {
        Supply.new($!taplist)
    }
}

# A preserving supplier holds on to emitted values and state when nobody is
# tapping. As soon as there a tap is made, any preserved events will be
# immediately sent to that tapper.
my class Supplier::Preserving is Supplier {
    my class PreservingTapList does Tappable {
        my class TapListEntry {
            has &.emit;
            has &.done;
            has &.quit;
        }

        # Lock serializes updates to tappers.
        has Lock $!lock = Lock.new;

        # An immutable list of tappers. Always replaced on change, never
        # mutated in-place ==> thread safe together with lock (and only
        # need lock on modification).
        has Mu $!tappers;

        # Events to reply, whether the replay was done, and a lock to protect
        # updates to these.
        has @!replay;
        has int $!replay-done;
        has $!replay-lock = Lock.new;

        method tap(&emit, &done, &quit, &tap) {
            my $tle := TapListEntry.new(:&emit, :&done, :&quit);
            my int $replay = 0;
            my $t = Tap.new({
                $!lock.protect({
                    my Mu $update := nqp::list();
                    for nqp::hllize($!tappers) -> \entry {
                        nqp::push($update, entry) unless entry =:= $tle;
                    }
                    $!replay-done = 0 if nqp::elems($update) == 0;
                    $!tappers := $update;
                });
            });
            tap($t);
            $!lock.protect({
                my Mu $update := nqp::isconcrete($!tappers)
                    ?? nqp::clone($!tappers)
                    !! nqp::list();
                nqp::push($update, $tle);
                $replay = 1 if nqp::elems($update) == 1;
                self!replay($tle) if $replay;
                $!tappers := $update;
            });
            $t
        }

        method emit(\value --> Nil) {
            loop {
                my int $sent = 0;
                my $snapshot := $!tappers;
                if nqp::isconcrete($snapshot) {
                    $sent = nqp::elems($snapshot);
                    loop (my int $i = 0; $i < $sent; $i = $i + 1) {
                        nqp::atpos($snapshot, $i).emit()(value);
                    }
                }
                return if $sent;
                return if self!add-replay({ $_.emit()(value) });
            }
        }

        method done(--> Nil) {
            loop {
                my int $sent = 0;
                my $snapshot := $!tappers;
                if nqp::isconcrete($snapshot) {
                    $sent = nqp::elems($snapshot);
                    loop (my int $i = 0; $i < $sent; $i = $i + 1) {
                        nqp::atpos($snapshot, $i).done()();
                    }
                }
                return if $sent;
                return if self!add-replay({ $_.done()() });
            }
        }

        method quit($ex --> Nil) {
            loop {
                my int $sent = 0;
                my $snapshot := $!tappers;
                if nqp::isconcrete($snapshot) {
                    $sent = nqp::elems($snapshot);
                    loop (my int $i = 0; $i < $sent; $i = $i + 1) {
                        nqp::atpos($snapshot, $i).quit()($ex);
                    }
                }
                return if $sent;
                return if self!add-replay({ $_.quit()($ex) });
            }
        }

        method !add-replay(&replay --> Bool) {
            $!replay-lock.protect: {
                if $!replay-done {
                    False
                }
                else {
                    @!replay.push(&replay);
                    True
                }
            }
        }

        method !replay($tle) {
            $!replay-lock.protect: {
                while @!replay.shift -> $rep {
                    $rep($tle);
                }
                $!replay-done = 1;
            }
        }

        method live(--> True) { }
        method serial(--> False) { }
        method sane(--> False) { }
    }

    method new() {
        self.bless(taplist => PreservingTapList.new)
    }
}

augment class Rakudo::Internals {
    my constant ADD_WHENEVER_PROMPT = Mu.new;

    class CachedAwaitHandle does Awaitable {
        has $.get-await-handle;
    }

    class SupplyBlockAddWheneverAwaiter does Awaiter {
        has $!continuations;

        method await(Awaitable:D $a) {
            my $handle := $a.get-await-handle;
            if $handle.already {
                $handle.success
                    ?? $handle.result
                    !! $handle.cause.rethrow
            }
            else {
                my $reawaitable := CachedAwaitHandle.new(get-await-handle => $handle);
                $!continuations := nqp::list() unless nqp::isconcrete($!continuations);
                nqp::continuationcontrol(0, ADD_WHENEVER_PROMPT, -> Mu \c {
                    nqp::push($!continuations, -> $delegate-awaiter {
                        nqp::continuationinvoke(c, {
                            $delegate-awaiter.await($reawaitable);
                        });
                    });
                });
            }
        }

        method await-all(Iterable:D \i) {
            $!continuations := nqp::list() unless nqp::isconcrete($!continuations);
            nqp::continuationcontrol(0, ADD_WHENEVER_PROMPT, -> Mu \c {
                nqp::push($!continuations, -> $delegate-awaiter {
                    nqp::continuationinvoke(c, {
                        $delegate-awaiter.await-all(i);
                    });
                });
            });
        }

        method take-all() {
            if nqp::isconcrete($!continuations) {
                my \result = $!continuations;
                $!continuations := Mu;
                result
            }
            else {
                Empty
            }
        }
    }

    class SupplyBlockState {
        has &.emit;
        has &.done;
        has &.quit;
        has @.close-phasers;
        has $.active;
        has $!lock;
        has %!active-taps;
        has $.run-async-lock;
        has $.awaiter;

        method new(:&emit!, :&done!, :&quit!) {
            self.CREATE!SET-SELF(&emit, &done, &quit)
        }

        method !SET-SELF(&!emit, &!done, &!quit) {
            $!active = 1;
            $!lock := Lock.new;
            $!run-async-lock := Lock::Async.new;
            $!awaiter := SupplyBlockAddWheneverAwaiter.CREATE;
            self
        }

        method decrement-active() {
            $!lock.protect: { --$!active }
        }

        method get-and-zero-active() {
            $!lock.protect: {
                my $result = $!active;
                $!active = 0;
                $result
            }
        }

        method add-active-tap($tap --> Nil) {
            $!lock.protect: {
                ++$!active;
                %!active-taps{nqp::objectid($tap)} = $tap;
            }
        }

        method delete-active-tap($tap --> Nil) {
            $!lock.protect: {
                %!active-taps{nqp::objectid($tap)}:delete;
            }
        }

        method consume-active-taps() {
            my @active;
            $!lock.protect: {
                @active = %!active-taps.values;
                %!active-taps = ();
                $!active = 0;
            }
            @active
        }
    }

    class SupplyBlockTappable does Tappable {
        has &!block;

        submethod BUILD(:&!block --> Nil) { }

        method tap(&emit, &done, &quit, &tap) {
            # Create state for this tapping.
            my $state = Rakudo::Internals::SupplyBlockState.new(:&emit, :&done, :&quit);

            # Placed here so it can close over $state, but we only need to
            # closure-clone it once per Supply block, not once per whenever.
            sub add-whenever($supply, &whenever-block) {
                my $tap;
                $state.run-async-lock.with-lock-hidden-from-recursion-check: {
                    my $*AWAITER := $state.awaiter;
                    nqp::continuationreset(ADD_WHENEVER_PROMPT, {
                        $supply.tap(
                            tap => {
                                $tap = $_;
                                $state.add-active-tap($tap);
                            },
                            -> \value {
                                self!run-supply-code(&whenever-block, value, $state,
                                    &add-whenever)
                            },
                            done => {
                                $state.delete-active-tap($tap);
                                my @phasers := &whenever-block.phasers('LAST');
                                if @phasers {
                                    self!run-supply-code({ .() for @phasers }, Nil, $state,
                                        &add-whenever)
                                }
                                $tap.close;
                                self!deactivate-one($state);
                            },
                            quit => -> \ex {
                                $state.delete-active-tap($tap);
                                my $handled;
                                self!run-supply-code({
                                    my $phaser := &whenever-block.phasers('QUIT')[0];
                                    if $phaser.DEFINITE {
                                        $handled = $phaser(ex) === Nil;
                                    }
                                    if !$handled && $state.get-and-zero-active() {
                                        $state.quit().(ex) if $state.quit;
                                        self!teardown($state);
                                    }
                                }, Nil, $state, &add-whenever);
                                if $handled {
                                    $tap.close;
                                    self!deactivate-one($state);
                                }
                            });
                    });
                }
                $tap
            }

            # Stash the close phasers away.
            if nqp::istype(&!block,Block) {
                $state.close-phasers.push(.clone) for &!block.phasers('CLOSE')
            }

            # Create and pass on tap; when closed, tear down the state and all
            # of our subscriptions.
            my $t = Tap.new(-> { self!teardown($state) });
            tap($t);

            # Run the Supply block, then decrease active count afterwards (it
            # counts as an active runner).
            self!run-supply-code:
                { &!block(); self!deactivate-one-internal($state) },
                Nil, $state, &add-whenever;

            # Evaluate to the Tap.
            $t
        }

        method !run-supply-code(&code, \value, $state, &add-whenever) {
            my @run-after;
            my $queued := $state.run-async-lock.protect-or-queue-on-recursion: {
                if $state.active > 0 {
                    my &*ADD-WHENEVER = &add-whenever;
                    my $emitter = {
                        if $state.active {
                            my \ex := nqp::exception();
                            my $emit-handler := $state.emit;
                            $emit-handler(nqp::getpayload(ex)) if $emit-handler.DEFINITE;
                            nqp::resume(ex)
                        }
                    }
                    my $done = {
                        $state.get-and-zero-active();
                        self!teardown($state);
                        my $done-handler := $state.done;
                        $done-handler() if $done-handler.DEFINITE;
                    }
                    my $catch = {
                        my \ex = EXCEPTION(nqp::exception());
                        $state.get-and-zero-active();
                        self!teardown($state);
                        my $quit-handler = $state.quit;
                        $quit-handler(ex) if $quit-handler;
                    }
                    nqp::handle(code(value),
                        'EMIT', $emitter(),
                        'DONE', $done(),
                        'CATCH', $catch(),
                        'NEXT', 0);
                    @run-after = $state.awaiter.take-all;
                }
            }
            if $queued.defined {
                $queued.then({ self!run-add-whenever-awaits(@run-after) });
            }
            else {
                self!run-add-whenever-awaits(@run-after);
            }
        }

        method !run-add-whenever-awaits(@run-after --> Nil) {
            if @run-after {
                my $nested-awaiter := SupplyBlockAddWheneverAwaiter.CREATE;
                my $delegate-awaiter := $*AWAITER;
                while @run-after.elems {
                    my $*AWAITER := $nested-awaiter;
                    nqp::continuationreset(ADD_WHENEVER_PROMPT, {
                        @run-after.shift()($delegate-awaiter);
                    });
                    @run-after.append($nested-awaiter.take-all);
                }
            }
        }

        method !deactivate-one($state) {
            $state.run-async-lock.protect-or-queue-on-recursion:
                { self!deactivate-one-internal($state) };
        }

        method !deactivate-one-internal($state) {
            if $state.decrement-active() == 0 {
                my $done-handler = $state.done;
                $done-handler() if $done-handler;
                self!teardown($state);
            }
        }

        method !teardown($state) {
            .close for $state.consume-active-taps;
            my @close-phasers := $state.close-phasers;
            while @close-phasers {
                @close-phasers.pop()();
            }
        }

        method live(--> False) { }
        method sane(--> True) { }
        method serial(--> True) { }
    }
}

sub SUPPLY(&block) {
    Supply.new(Rakudo::Internals::SupplyBlockTappable.new(:&block))
}

sub WHENEVER(Supply() $supply, &block) {
    my \adder = &*ADD-WHENEVER;
    adder.defined
        ?? adder.($supply, &block)
        !! X::WheneverOutOfScope.new.throw
}

sub REACT(&block) {
    my $s = SUPPLY(&block);
    my $p = Promise.new;
    $s.tap(
        { warn "Useless use of emit in react" },
        done => { $p.keep(Nil) },
        quit => { $p.break($_) });
    await $p;
}

#line 1 SETTING::src/core/asyncops.pm
# Waits for a promise to be kept or a channel to be able to receive a value
# and, once it can, unwraps or returns the result. Under Perl 6.c, await will
# really block the calling thread. In 6.d, if the thread is on the thread pool
# then a continuation will be taken, and the thread is freed up.

my role X::Await::Died {
    has $.await-backtrace;
    multi method gist(::?CLASS:D:) {
        "An operation first awaited:\n" ~
            ((try $!await-backtrace ~ "\n") // '<unknown location>') ~
            "Died with the exception:\n" ~
            callsame().indent(4)
    }
}

proto sub await(|) { * }
multi sub await() {
    die "Must specify a Promise or Channel to await on (got an empty list)";
}
multi sub await(Any:U $x) {
    die "Must specify a defined Promise, Channel, or Supply to await on (got an undefined $x.^name())";
}
multi sub await(Any:D $x) {
    die "Must specify a Promise, Channel, or Supply to await on (got a $x.^name())";
}
multi sub await(Promise:D $p) {
    CATCH {
        unless nqp::istype($_, X::Await::Died) {
            ($_ but X::Await::Died(Backtrace.new(5))).rethrow
        }
    }
    my $*RAKUDO-AWAIT-BLOCKING := True;
    $*AWAITER.await($p)
}
multi sub await(Channel:D $c) {
    CATCH {
        unless nqp::istype($_, X::Await::Died) {
            ($_ but X::Await::Died(Backtrace.new(5))).rethrow
        }
    }
    my $*RAKUDO-AWAIT-BLOCKING := True;
    $*AWAITER.await($c)
}
multi sub await(Supply:D $s) {
    CATCH {
        unless nqp::istype($_, X::Await::Died) {
            ($_ but X::Await::Died(Backtrace.new(5))).rethrow
        }
    }
    my $*RAKUDO-AWAIT-BLOCKING := True;
    $*AWAITER.await($s)
}
multi sub await(Iterable:D $i) { $i.eager.map({ await $_ }) }
multi sub await(*@awaitables)  { @awaitables.eager.map({await $_}) }

sub awaiterator(@promises) {
    Seq.new(class :: does Iterator {
        has @!todo;
        has @!done;
        method !SET-SELF(\todo) { @!todo = todo; self }
        method new(\todo) { nqp::create(self)!SET-SELF(todo) }
        method pull-one() is raw {
            if @!done {
                @!done.shift
            }
            elsif @!todo {
                Promise.anyof(@!todo).result;
                my @next;
                .status == Planned
                  ?? @next.push($_)
                  !! @!done.push($_.result)
                    for @!todo;
                @!todo := @next;
                @!done.shift
            }
            else {
                IterationEnd
            }
        }
        method sink-all(--> IterationEnd) { Promise.allof(@promises).result }
    }.new(@promises))
}

#line 1 SETTING::src/core/IO/Socket.pm
my role IO::Socket {
    has $!PIO;
    has Str $.encoding = 'utf8';
    has $.nl-in is rw = ["\n", "\r\n"];
    has Str:D $.nl-out is rw = "\n";
    has Encoding::Decoder $!decoder;
    has Encoding::Encoder $!encoder;

    method !ensure-coders(--> Nil) {
        unless $!decoder.DEFINITE {
            my $encoding = Encoding::Registry.find($!encoding);
            $!decoder := $encoding.decoder();
            $!decoder.set-line-separators($!nl-in.list);
            $!encoder := $encoding.encoder();
        }
    }

    # The if bin is true, will return Buf, Str otherwise
    method recv(Cool $limit? is copy, :$bin) {
        fail('Socket not available') unless $!PIO;
        $limit = 65535 if !$limit.DEFINITE || $limit === Inf;
        if $bin {
            nqp::readfh($!PIO, nqp::decont(buf8.new), $limit)
        }
        else {
            self!ensure-coders();
            my $result = $!decoder.consume-exactly-chars($limit);
            without $result {
                $!decoder.add-bytes(nqp::readfh($!PIO, nqp::decont(buf8.new), 65535));
                $result = $!decoder.consume-exactly-chars($limit);
                without $result {
                    $result = $!decoder.consume-all-chars();
                }
            }
            $result
        }
    }

    method read(IO::Socket:D: Int(Cool) $bufsize) {
        fail('Socket not available') unless $!PIO;
        my int $toread = $bufsize;
        my $res := nqp::readfh($!PIO,buf8.new,$toread);

        while nqp::elems($res) < $toread {
            my $buf := nqp::readfh($!PIO,buf8.new,$toread - nqp::elems($res));
            nqp::elems($buf)
              ?? $res.append($buf)
              !! return $res
        }
        $res
    }

    method nl-in is rw {
        Proxy.new(
            FETCH => { $!nl-in },
            STORE => -> $, $nl-in {
                $!nl-in = $nl-in;
                with $!decoder {
                    .set-line-separators($!nl-in.list);
                }
                $nl-in
            }
        )
    }

    method get() {
        self!ensure-coders();
        my Str $line = $!decoder.consume-line-chars(:chomp);
        if $line.DEFINITE {
            $line
        }
        else {
            loop {
                my $read = nqp::readfh($!PIO, nqp::decont(buf8.new), 65535);
                $!decoder.add-bytes($read);
                $line = $!decoder.consume-line-chars(:chomp);
                last if $line.DEFINITE;
                if $read == 0 {
                    $line = $!decoder.consume-line-chars(:chomp, :eof);
                    last;
                }
            }
            $line.DEFINITE ?? $line !! Nil
        }
    }

    method lines() {
        gather while (my $line = self.get()).DEFINITE {
            take $line;
        }
    }

    method print(Str(Cool) $string --> True) {
        self!ensure-coders();
        self.write($!encoder.encode-chars($string));
    }

    method put(Str(Cool) $string --> True) {
        self.print($string ~ $!nl-out);
    }

    method write(Blob:D $buf --> True) {
        fail('Socket not available') unless $!PIO;
        nqp::writefh($!PIO, nqp::decont($buf));
    }

    method close(--> True) {
        fail("Not connected!") unless $!PIO;
        nqp::closefh($!PIO);
        $!PIO := nqp::null;
    }

    method native-descriptor(::?CLASS:D:) {
        nqp::filenofh($!PIO)
    }
}

#line 1 SETTING::src/core/IO/Socket/INET.pm
my class IO::Socket::INET does IO::Socket {
    my module PIO {
        constant PF_LOCAL       = 0;
        constant PF_UNIX        = 1;
        constant PF_INET        = 2;
        constant PF_INET6       = 3;
        constant PF_MAX         = 4;
        constant SOCK_PACKET    = 0;
        constant SOCK_STREAM    = 1;
        constant SOCK_DGRAM     = 2;
        constant SOCK_RAW       = 3;
        constant SOCK_RDM       = 4;
        constant SOCK_SEQPACKET = 5;
        constant SOCK_MAX       = 6;
        constant PROTO_TCP      = 6;
        constant PROTO_UDP      = 17;
        constant MIN_PORT       = 0;
        constant MAX_PORT       = 65_535; # RFC 793: TCP/UDP port limit
    }

    has Str $.host;
    has Int $.port;
    has Str $.localhost;
    has Int $.localport;
    has Int $.backlog;
    has Bool $.listening;
    has $.family = PIO::PF_INET;
    has $.proto = PIO::PROTO_TCP;
    has $.type = PIO::SOCK_STREAM;

    my sub split-host-port(:$host is copy, :$port is copy, :$family) {
        if ($host) {
            my ($split-host, $split-port) = $family == PIO::PF_INET6
                ?? v6-split($host)
                !! v4-split($host);

            if $split-port {
                $host = $split-host.Str;
                $port //= $split-port.Int
            }
        }

        fail "Invalid port $port.gist(). Must be {PIO::MIN_PORT}..{PIO::MAX_PORT}"
            unless $port.defined and PIO::MIN_PORT <= $port <= PIO::MAX_PORT;

        return ($host, $port);
    }

    my sub v4-split($uri) {
        return $uri.split(':', 2);
    }

    my sub v6-split($uri) {
        my ($host, $port) = ($uri ~~ /^'[' (.+) ']' \: (\d+)$/)[0,1];
        return $host ?? ($host, $port) !! $uri;
    }

    # Create new socket that listens on $localhost:$localport
    multi method new(
        Bool:D :$listen!,
        Str    :$localhost is copy,
        Int    :$localport is copy,
        Int    :$family where {
                $family == PIO::PF_INET
             || $family == PIO::PF_INET6
        } = PIO::PF_INET,
               *%rest,
        --> IO::Socket::INET:D) {

        ($localhost, $localport) = (
            split-host-port :host($localhost), :port($localport), :$family
        orelse fail $_);

        #TODO: Learn what protocols map to which socket types and then determine which is needed.
        self.bless(
            :$localhost,
            :$localport,
            :$family,
            :listening($listen),
            |%rest,
        )!initialize()
    }

    # Open new connection to socket on $host:$port
    multi method new(
        Str:D :$host! is copy,
        Int   :$port is copy,
        Int   :$family where {
               $family == PIO::PF_INET
            || $family == PIO::PF_INET6
        } = PIO::PF_INET,
              *%rest,
        --> IO::Socket::INET:D) {

        ($host, $port) = split-host-port(
            :$host,
            :$port,
            :$family,
        );

        #TODO: Learn what protocols map to which socket types and then determine which is needed.
        self.bless(
            :$host,
            :$port,
            :$family,
            |%rest,
        )!initialize()
    }

    # Fail if no valid parameters are passed
    multi method new() {
        fail "Nothing given for new socket to connect or bind to. "
            ~ "Invalid arguments to .new?";
    }

    method !initialize() {
        my $PIO := nqp::socket($.listening ?? 10 !! 0);
        #Quoting perl5's SIO::INET:
        #If Listen is defined then a listen socket is created, else if the socket type,
        #which is derived from the protocol, is SOCK_STREAM then connect() is called.
        if $.listening || $.localhost || $.localport {
            nqp::bindsock($PIO, nqp::unbox_s($.localhost || "0.0.0.0"),
                                 nqp::unbox_i($.localport || 0), nqp::unbox_i($.backlog || 128));
        }

        if $.listening {

            $!localport = nqp::getport($PIO) if !$!localport;

        }
        elsif $.type == PIO::SOCK_STREAM {
            nqp::connect($PIO, nqp::unbox_s($.host), nqp::unbox_i($.port));
        }

        nqp::bindattr(self, $?CLASS, '$!PIO', $PIO);
        self;
    }

    method connect(IO::Socket::INET:U: Str() $host, Int() $port) {
        self.new(:$host, :$port)
    }

    method listen(IO::Socket::INET:U: Str() $localhost, Int() $localport) {
        self.new(:$localhost, :$localport, :listen)
    }

    method accept() {
        ## A solution as proposed by moritz
        my $new_sock := $?CLASS.bless(:$!family, :$!proto, :$!type, :$!nl-in);
        nqp::bindattr($new_sock, $?CLASS, '$!PIO',
            nqp::accept(nqp::getattr(self, $?CLASS, '$!PIO'))
        );
        return $new_sock;
    }
}

#line 1 SETTING::src/core/IO/Socket/Async.pm
my class IO::Socket::Async {
    my class SocketCancellation is repr('AsyncTask') { }

    has $!VMIO;
    has int $!udp;
    has $.enc;
    has $!encoder;
    has $!close-promise;
    has $!close-vow;

    has Str $.peer-host;
    has Int $.peer-port;

    has Str $.socket-host;
    has Int $.socket-port;

    method new() {
        die "Cannot create an asynchronous socket directly; please use\n" ~
            "IO::Socket::Async.connect, IO::Socket::Async.listen,\n" ~
            "IO::Socket::Async.udp, or IO::Socket::Async.udp-bind";
    }

    method print(IO::Socket::Async:D: Str() $str, :$scheduler = $*SCHEDULER) {
        self.write($!encoder.encode-chars($str))
    }

    method write(IO::Socket::Async:D: Blob $b, :$scheduler = $*SCHEDULER) {
        my $p = Promise.new;
        my $v = $p.vow;
        nqp::asyncwritebytes(
            $!VMIO,
            $scheduler.queue,
            -> Mu \bytes, Mu \err {
                if err {
                    $v.break(err);
                }
                else {
                    $v.keep(bytes);
                }
            },
            nqp::decont($b), SocketCancellation);
        $p
    }

    my class SocketReaderTappable does Tappable {
        has $!VMIO;
        has $!scheduler;
        has $!buf;
        has $!close-promise;

        method new(Mu :$VMIO!, :$scheduler!, :$buf!, :$close-promise!) {
            self.CREATE!SET-SELF($VMIO, $scheduler, $buf, $close-promise)
        }

        method !SET-SELF(Mu $!VMIO, $!scheduler, $!buf, $!close-promise) { self }

        method tap(&emit, &done, &quit, &tap) {
            my $buffer := nqp::list();
            my int $buffer-start-seq = 0;
            my int $done-target = -1;
            my int $finished = 0;

            sub emit-events() {
                until nqp::elems($buffer) == 0 || nqp::isnull(nqp::atpos($buffer, 0)) {
                    emit(nqp::shift($buffer));
                    $buffer-start-seq = $buffer-start-seq + 1;
                }
                if $buffer-start-seq == $done-target {
                    done();
                    $finished = 1;
                }
            }

            my $lock = Lock::Async.new;
            my $tap;
            $lock.protect: {
                my $cancellation := nqp::asyncreadbytes(nqp::decont($!VMIO),
                    $!scheduler.queue(:hint-affinity),
                    -> Mu \seq, Mu \data, Mu \err {
                        $lock.protect: {
                            unless $finished {
                                if err {
                                    quit(err);
                                    $finished = 1;
                                }
                                elsif nqp::isconcrete(data) {
                                    my int $insert-pos = seq - $buffer-start-seq;
                                    nqp::bindpos($buffer, $insert-pos, data);
                                    emit-events();
                                }
                                else {
                                    $done-target = seq;
                                    emit-events();
                                }
                            }
                        }
                    },
                    nqp::decont($!buf), SocketCancellation);
                $tap := Tap.new({ nqp::cancel($cancellation) });
                tap($tap);
            }
            $!close-promise.then: {
                $lock.protect: {
                    unless $finished {
                        done();
                        $finished = 1;
                    }
                }
            }

            $tap
        }

        method live(--> False) { }
        method sane(--> True) { }
        method serial(--> True) { }
    }

    multi method Supply(IO::Socket::Async:D: :$bin, :$buf = buf8.new, :$enc, :$scheduler = $*SCHEDULER) {
        if $bin {
            Supply.new: SocketReaderTappable.new:
                :$!VMIO, :$scheduler, :$buf, :$!close-promise
        }
        else {
            my $bin-supply = self.Supply(:bin);
            if $!udp {
                supply {
                    whenever $bin-supply {
                        emit .decode($enc // $!enc);
                    }
                }
            }
            else {
                Rakudo::Internals.BYTE_SUPPLY_DECODER($bin-supply, $enc // $!enc)
            }
        }
    }

    method close(IO::Socket::Async:D: --> True) {
        nqp::closefh($!VMIO);
        $!close-vow.keep(True);
    }

    method connect(IO::Socket::Async:U: Str() $host, Int() $port,
                   :$enc = 'utf-8', :$scheduler = $*SCHEDULER) {
        my $p = Promise.new;
        my $v = $p.vow;
        my $encoding = Encoding::Registry.find($enc);
        nqp::asyncconnect(
            $scheduler.queue,
            -> Mu \socket, Mu \err, Mu \peer-host, Mu \peer-port, Mu \socket-host, Mu \socket-port {
                if err {
                    $v.break(err);
                }
                else {
                    my $client_socket := nqp::create(self);
                    nqp::bindattr($client_socket, IO::Socket::Async, '$!VMIO', socket);
                    nqp::bindattr($client_socket, IO::Socket::Async, '$!enc', $encoding.name);
                    nqp::bindattr($client_socket, IO::Socket::Async, '$!encoder',
                        $encoding.encoder());
                    nqp::bindattr($client_socket, IO::Socket::Async, '$!peer-host', peer-host);
                    nqp::bindattr($client_socket, IO::Socket::Async, '$!peer-port', peer-port);
                    nqp::bindattr($client_socket, IO::Socket::Async, '$!socket-host', socket-host);
                    nqp::bindattr($client_socket, IO::Socket::Async, '$!socket-port', socket-port);

                    setup-close($client_socket);
                    $v.keep($client_socket);
                }
            },
            $host, $port, SocketCancellation);
        $p
    }

    my class SocketListenerTappable does Tappable {
        has $!host;
        has $!port;
        has $!backlog;
        has $!encoding;
        has $!scheduler;

        method new(:$host!, :$port!, :$backlog!, :$encoding!, :$scheduler!) {
            self.CREATE!SET-SELF($host, $port, $backlog, $encoding, $scheduler)
        }

        method !SET-SELF($!host, $!port, $!backlog, $!encoding, $!scheduler) { self }

        method tap(&emit, &done, &quit, &tap) {
            my $lock := Lock::Async.new;
            my $tap;
            my int $finished = 0;
            $lock.protect: {
                my $cancellation := nqp::asynclisten(
                    $!scheduler.queue(:hint-affinity),
                    -> Mu \socket, Mu \err, Mu \peer-host, Mu \peer-port,
                       Mu \socket-host, Mu \socket-port {
                        $lock.protect: {
                            if $finished {
                                # do nothing
                            }
                            elsif err {
                                quit(X::AdHoc.new(message => err));
                                $finished = 1;
                            }
                            else {
                                my $client_socket := nqp::create(IO::Socket::Async);
                                nqp::bindattr($client_socket, IO::Socket::Async,
                                    '$!VMIO', socket);
                                nqp::bindattr($client_socket, IO::Socket::Async,
                                    '$!enc', $!encoding.name);
                                nqp::bindattr($client_socket, IO::Socket::Async,
                                    '$!encoder', $!encoding.encoder());
                                nqp::bindattr($client_socket, IO::Socket::Async,
                                    '$!peer-host', peer-host);
                                nqp::bindattr($client_socket, IO::Socket::Async,
                                    '$!peer-port', peer-port);
                                nqp::bindattr($client_socket, IO::Socket::Async,
                                    '$!socket-host', socket-host);
                                nqp::bindattr($client_socket, IO::Socket::Async,
                                    '$!socket-port', socket-port);
                                setup-close($client_socket);
                                emit($client_socket);
                            }
                        }
                    },
                    $!host, $!port, $!backlog, SocketCancellation);
                $tap = Tap.new: {
                    my $p = Promise.new;
                    my $v = $p.vow;
                    nqp::cancelnotify($cancellation, $!scheduler.queue, { $v.keep(True); });
                    $p
                }
                tap($tap);
                CATCH {
                    default {
                        tap($tap = Tap.new({ Nil })) unless $tap;
                        quit($_);
                    }
                }
            }
            $tap
        }

        method live(--> False) { }
        method sane(--> True) { }
        method serial(--> True) { }
    }

    method listen(IO::Socket::Async:U: Str() $host, Int() $port, Int() $backlog = 128,
                  :$enc = 'utf-8', :$scheduler = $*SCHEDULER) {
        my $encoding = Encoding::Registry.find($enc);
        Supply.new: SocketListenerTappable.new:
            :$host, :$port, :$backlog, :$encoding, :$scheduler
    }

    sub setup-close(\socket --> Nil) {
        my $p := Promise.new;
        nqp::bindattr(socket, IO::Socket::Async, '$!close-promise', $p);
        nqp::bindattr(socket, IO::Socket::Async, '$!close-vow', $p.vow);
    }


    method udp(IO::Socket::Async:U: :$broadcast, :$enc = 'utf-8', :$scheduler = $*SCHEDULER) {
        my $p = Promise.new;
        my $encoding = Encoding::Registry.find($enc);
        nqp::asyncudp(
            $scheduler.queue,
            -> Mu \socket, Mu \err {
                if err {
                    $p.break(err);
                }
                else {
                    my $client_socket := nqp::create(self);
                    nqp::bindattr($client_socket, IO::Socket::Async, '$!VMIO', socket);
                    nqp::bindattr_i($client_socket, IO::Socket::Async, '$!udp', 1);
                    nqp::bindattr($client_socket, IO::Socket::Async, '$!enc', $encoding.name);
                    nqp::bindattr($client_socket, IO::Socket::Async, '$!encoder',
                        $encoding.encoder());
                    setup-close($client_socket);
                    $p.keep($client_socket);
                }
            },
            nqp::null_s(), 0, $broadcast ?? 1 !! 0,
            SocketCancellation);
        await $p
    }

    method bind-udp(IO::Socket::Async:U: Str() $host, Int() $port, :$broadcast,
                    :$enc = 'utf-8', :$scheduler = $*SCHEDULER) {
        my $p = Promise.new;
        my $encoding = Encoding::Registry.find($enc);
        nqp::asyncudp(
            $scheduler.queue(:hint-affinity),
            -> Mu \socket, Mu \err {
                if err {
                    $p.break(err);
                }
                else {
                    my $client_socket := nqp::create(self);
                    nqp::bindattr($client_socket, IO::Socket::Async, '$!VMIO', socket);
                    nqp::bindattr_i($client_socket, IO::Socket::Async, '$!udp', 1);
                    nqp::bindattr($client_socket, IO::Socket::Async, '$!enc', $encoding.name);
                    nqp::bindattr($client_socket, IO::Socket::Async, '$!encoder',
                        $encoding.encoder());
                    setup-close($client_socket);
                    $p.keep($client_socket);
                }
            },
            nqp::unbox_s($host), nqp::unbox_i($port), $broadcast ?? 1 !! 0,
            SocketCancellation);
        await $p
    }

    method print-to(IO::Socket::Async:D: Str() $host, Int() $port, Str() $str, :$scheduler = $*SCHEDULER) {
        self.write-to($host, $port, $!encoder.encode-chars($str))
    }

    method write-to(IO::Socket::Async:D: Str() $host, Int() $port, Blob $b, :$scheduler = $*SCHEDULER) {
        my $p = Promise.new;
        my $v = $p.vow;
        nqp::asyncwritebytesto(
            $!VMIO,
            $scheduler.queue,
            -> Mu \bytes, Mu \err {
                if err {
                    $v.break(err);
                }
                else {
                    $v.keep(bytes);
                }
            },
            nqp::decont($b), SocketCancellation,
            nqp::unbox_s($host), nqp::unbox_i($port));
        $p
    }

}

#line 1 SETTING::src/core/Proc.pm
# Proc is a wrapper around Proc::Async, providing a synchronous API atop of
# the asynchronous API.
my class Proc::Async { ... }
my class Proc {
    has IO::Pipe $.in;
    has IO::Pipe $.out;
    has IO::Pipe $.err;
    has $.exitcode = -1;  # distinguish uninitialized from 0 status
    has $.signal;
    has @.command;

    has Proc::Async $!proc;
    has Bool $!w;
    has @!pre-spawn;
    has @!post-spawn;
    has $!active-handles = 0;
    has &!start-stdout;
    has &!start-stderr;
    has $!finished;

    submethod BUILD(:$in = '-', :$out = '-', :$err = '-', :$exitcode,
                    Bool :$bin, Bool :$chomp = True, Bool :$merge, :$command,
                    Str :$enc, Str:D :$nl = "\n", :$signal --> Nil) {
        @!command = |$command if $command;
        if nqp::istype($in, IO::Handle) && $in.DEFINITE {
            @!pre-spawn.push({ $!proc.bind-stdin($in) });
        }
        elsif $in === True {
            my $cur-promise = Promise.new;
            $cur-promise.keep(True);
            $!in = IO::Pipe.new(:proc(self), :$chomp, :$enc, :$bin, nl-out => $nl,
                :on-write(-> $blob {
                    $cur-promise .= then({ await $!proc.write($blob) });
                }),
                :on-close({
                    $cur-promise .= then({ $!proc.close-stdin; });
                    self!await-if-last-handle
                }));
            $!active-handles++;
            $!w := True;
        }
        elsif nqp::istype($in, Str) && $in eq '-' {
            # Inherit; nothing to do
        }
        else {
            $!w := True;
            @!post-spawn.push({ $!proc.close-stdin });
        }

        if $merge {
            my $chan = Channel.new;
            $!out = IO::Pipe.new(:proc(self), :$chomp, :$enc, :$bin, nl-in => $nl,
                :on-read({ (try $chan.receive) // buf8 }),
                :on-close({ self!await-if-last-handle }));
            $!active-handles++;
            @!pre-spawn.push({
                $!proc.stdout(:bin).merge($!proc.stderr(:bin)).act: { $chan.send($_) },
                    done => { $chan.close },
                    quit => { $chan.fail($_) }
            });
        }
        else {
            if $out === True {
                my $chan;
                my $stdout-supply;
                &!start-stdout = {
                    $chan = $stdout-supply.Channel;
                    &!start-stdout = Nil;
                }
                $!out = IO::Pipe.new(:proc(self), :$chomp, :$enc, :$bin, nl-in => $nl,
                    :on-read({
                        &!start-stdout() if &!start-stdout;
                        (try $chan.receive) // buf8
                    }),
                    :on-close({
                        $chan //= $stdout-supply.Channel; # If we never read
                        self!await-if-last-handle
                    }),
                    :on-native-descriptor({
                        $!active-handles--;
                        &!start-stdout = Nil;
                        await $stdout-supply.native-descriptor
                    }));
                $!active-handles++;
                @!pre-spawn.push({
                    $stdout-supply = $!proc.stdout(:bin)
                });
            }
            elsif nqp::istype($out, IO::Handle) && $out.DEFINITE {
                @!pre-spawn.push({ $!proc.bind-stdout($out) });
            }
            elsif nqp::istype($out, Str) && $out eq '-' {
                # Inherit; nothing to do
            }
            else {
                @!pre-spawn.push({
                    $!proc.stdout(:bin).tap: -> $ { }, quit => -> $ { }
                });
            }

            if $err === True {
                my $chan;
                my $stderr-supply;
                &!start-stderr = {
                    $chan = $stderr-supply.Channel;
                    &!start-stderr = Nil;
                }
                $!err = IO::Pipe.new(:proc(self), :$chomp, :$enc, :$bin, nl-in => $nl,
                    :on-read({
                        &!start-stderr() if &!start-stderr;
                        (try $chan.receive) // buf8
                    }),
                    :on-close({
                        $chan //= $stderr-supply.Channel; # If we never read
                        self!await-if-last-handle
                    }),
                    :on-native-descriptor({
                        &!start-stderr = Nil;
                        $!active-handles--;
                        await $stderr-supply.native-descriptor
                    }));
                $!active-handles++;
                @!pre-spawn.push({
                    $stderr-supply = $!proc.stderr(:bin);
                });
            }
            elsif nqp::istype($err, IO::Handle) && $err.DEFINITE {
                @!pre-spawn.push({ $!proc.bind-stderr($err) });
            }
            elsif nqp::istype($err, Str) && $err eq '-' {
                # Inherit; nothing to do
            }
            else {
                @!pre-spawn.push({
                    $!proc.stderr(:bin).tap: -> $ { }, quit => -> $ { }
                });
            }
        }

        if nqp::istype($exitcode, Int) && $exitcode.DEFINITE {
            $!exitcode = $exitcode;
        }
        if nqp::istype($signal, Int) && $signal.DEFINITE {
            $!signal = $signal;
        }
    }

    method !await-if-last-handle() {
        self!wait-for-finish unless --$!active-handles;
        self
    }

    method !wait-for-finish {
        CATCH { default { self.status(0x100) } }
        &!start-stdout() if &!start-stdout;
        &!start-stderr() if &!start-stderr;
        self.status(await($!finished).status) if $!exitcode == -1;
    }

    method spawn(*@args where .so, :$cwd = $*CWD, :$env --> Bool:D) {
        @!command = @args;
        self!spawn-internal(@args, $cwd, $env)
    }

    method shell($cmd, :$cwd = $*CWD, :$env --> Bool:D) {
        @!command = $cmd;
        my @args := Rakudo::Internals.IS-WIN
            ?? (%*ENV<ComSpec>, '/c', $cmd)
            !! ('/bin/sh', '-c', $cmd);
        self!spawn-internal(@args, $cwd, $env)
    }

    method !spawn-internal(@args, $cwd, $env --> Bool:D) {
        my %ENV := $env ?? $env.hash !! %*ENV;
        $!proc := Proc::Async.new(|@args, :$!w);
        .() for @!pre-spawn;
        $!finished = $!proc.start(:$cwd, :%ENV, scheduler => $PROCESS::SCHEDULER);
        my $is-spawned := do {
            CATCH { default { self.status(0x100) } }
            await $!proc.ready;
            True
        } // False;
        .() for @!post-spawn;
        self!wait-for-finish unless $!out || $!err || $!in;
        $is-spawned
    }

    proto method status(|) { * }
    multi method status($new_status) {
        $!exitcode = $new_status +> 8;
        $!signal   = $new_status +& 0xFF;
    }
    multi method status(Proc:D:)  {
        self!wait-for-finish;
        ($!exitcode +< 8) +| $!signal
    }
    multi method Numeric(Proc:D:) {
        self!wait-for-finish;
        $!exitcode
    }
    multi method Bool(Proc:D:) {
        self!wait-for-finish;
        $!exitcode == 0
    }
    method exitcode {
        self!wait-for-finish;
        $!exitcode
    }

    method sink(--> Nil) {
        self!wait-for-finish;
        X::Proc::Unsuccessful.new(:proc(self)).throw if $!exitcode > 0;
    }
}

sub run(*@args where .so, :$in = '-', :$out = '-', :$err = '-',
        Bool :$bin, Bool :$chomp = True, Bool :$merge,
        Str  :$enc, Str:D :$nl = "\n", :$cwd = $*CWD, :$env) {
    my $proc = Proc.new(:$in, :$out, :$err, :$bin, :$chomp, :$merge, :$enc, :$nl);
    $proc.spawn(@args, :$cwd, :$env);
    $proc
}

sub shell($cmd, :$in = '-', :$out = '-', :$err = '-',
        Bool :$bin, Bool :$chomp = True, Bool :$merge,
        Str  :$enc, Str:D :$nl = "\n", :$cwd = $*CWD, :$env) {
    my $proc = Proc.new(:$in, :$out, :$err, :$bin, :$chomp, :$merge, :$enc, :$nl);
    $proc.shell($cmd, :$cwd, :$env);
    $proc
}

sub QX($cmd, :$cwd = $*CWD, :$env) {
    my $proc = Proc.new(:out);
    $proc.shell($cmd, :$cwd, :$env);
    $proc.out.slurp(:close) // Failure.new("Unable to read from '$cmd'")
}

#line 1 SETTING::src/core/signals.pm
my enum Signal ( :SIGHUP(1), :SIGINT(2), :SIGQUIT(3), :SIGILL(4), :SIGTRAP(5),
    :SIGABRT(6), :SIGEMT(7), :SIGFPE(8), :SIGKILL(9), :SIGBUS(10), :SIGSEGV(11),
    :SIGSYS(12), :SIGPIPE(13), :SIGALRM(14), :SIGTERM(15), :SIGURG(16),
    :SIGSTOP(17), :SIGTSTP(18), :SIGCONT(19), :SIGCHLD(20), :SIGTTIN(21),
    :SIGTTOU(22), :SIGIO(23), :SIGXCPU(24), :SIGXFSZ(25), :SIGVTALRM(26),
    :SIGPROF(27), :SIGWINCH(28), :SIGINFO(29), :SIGUSR1(30), :SIGUSR2(31),
    :SIGTHR(32), :SIGSTKFLT(116), :SIGPWR(130), :SIGBREAK(221) );

sub signal(Signal $signal, *@signals, :$scheduler = $*SCHEDULER) {

    if @signals.grep( { !nqp::istype($_,Signal) } ).list -> @invalid {
        die "Found invalid signals: {@invalid}";
    }
    @signals.unshift: $signal;
    @signals .= unique;

    my constant %sigmap = (

        SIGHUP,   nqp::const::SIG_HUP,

        SIGINT,   nqp::const::SIG_INT,

        SIGQUIT,  nqp::const::SIG_QUIT,
        SIGILL,   nqp::const::SIG_ILL,
        SIGTRAP,  nqp::const::SIG_TRAP,
        SIGABRT,  nqp::const::SIG_ABRT,
        SIGEMT,   nqp::const::SIG_EMT,
        SIGFPE,   nqp::const::SIG_FPE,

        SIGKILL,  nqp::const::SIG_KILL,

        SIGBUS,   nqp::const::SIG_BUS,
        SIGSEGV,  nqp::const::SIG_SEGV,
        SIGSYS,   nqp::const::SIG_SYS,
        SIGPIPE,  nqp::const::SIG_PIPE,
        SIGALRM,  nqp::const::SIG_ALRM,
        SIGTERM,  nqp::const::SIG_TERM,
        SIGURG,   nqp::const::SIG_URG,
        SIGSTOP,  nqp::const::SIG_STOP, # hammer time
        SIGTSTP,  nqp::const::SIG_TSTP,
        SIGCONT,  nqp::const::SIG_CONT,
        SIGCHLD,  nqp::const::SIG_CHLD,
        SIGTTIN,  nqp::const::SIG_TTIN,
        SIGTTOU,  nqp::const::SIG_TTOU,
        SIGIO,    nqp::const::SIG_IO,
        SIGXCPU,  nqp::const::SIG_XCPU,
        SIGXFSZ,  nqp::const::SIG_XFSZ,
        SIGVTALRM,nqp::const::SIG_VTALRM,
        SIGPROF,  nqp::const::SIG_PROF,
        SIGWINCH, nqp::const::SIG_WINCH,
        SIGINFO,  nqp::const::SIG_INFO,
        SIGUSR1,  nqp::const::SIG_USR1,
        SIGUSR2,  nqp::const::SIG_USR2,
        SIGTHR,   nqp::const::SIG_THR,
        SIGSTKFLT,nqp::const::SIG_STKFLT,
        SIGPWR,   nqp::const::SIG_PWR,
        SIGBREAK, nqp::const::SIG_BREAK

    ).hash;

    my @known_signals := $*KERNEL.signals;

    my class SignalCancellation is repr('AsyncTask') { }
    Supply.merge( @signals.map(-> $sig {
        my $s = Supplier.new;
        nqp::signal($scheduler.queue,
            -> $signum { $s.emit(@known_signals[$signum] // $signum) },
            nqp::unbox_i(%sigmap{$sig}),
            SignalCancellation);
        $s.Supply
    }) );
}

#line 1 SETTING::src/core/Proc/Async.pm
my class Proc::Async { ... }

my role X::Proc::Async is Exception {
    has Proc::Async $.proc;
}

my class X::Proc::Async::TapBeforeSpawn does X::Proc::Async {
    has $.handle;
    method message() {
        "To avoid data races, you must tap $!handle before running the process"
    }
}

my class X::Proc::Async::SupplyOrStd does X::Proc::Async {
    method message() {
        "Using .Supply on a Proc::Async implies merging stdout and stderr; .stdout " ~
            "and .stderr cannot therefore be used in combination with it"
    }
}

my class X::Proc::Async::BindOrUse does X::Proc::Async {
    has $.handle;
    has $.use;
    method message() {
        "Cannot both bind $.handle to a handle and also $.use"
    }
}

my class X::Proc::Async::CharsOrBytes does X::Proc::Async {
    has $.handle;
    method message() {
        "Can only tap one of chars or bytes supply for $!handle"
    }
}

my class X::Proc::Async::AlreadyStarted does X::Proc::Async {
    method message() {
        "Process has already been started"
    }
}

my class X::Proc::Async::MustBeStarted does X::Proc::Async {
    has $.method;
    method message() {
        "Process must be started first before calling '$!method'"
    }
}

my class X::Proc::Async::OpenForWriting does X::Proc::Async {
    has $.method;
    method message() {
        "Process must be opened for writing with :w to call '$!method'"
    }
}

my class Proc::Async {
    # An asynchornous process output pipe is a Supply that also can provide
    # the native descriptor of the underlying pipe.
    class Pipe is Supply {
        my class PermitOnTap does Tappable {
            has Tappable $.delegate;
            has &.on-tap;
            method tap(|c) {
                &!on-tap();
                $!delegate.tap(|c)
            }
            method live() { self.delegate.live }
            method serial() { self.delegate.serial }
            method sane() { self.delegate.sane }
        }

        has Promise $.native-descriptor;
        has &!on-nd-used;

        submethod BUILD(:$!native-descriptor!, :&!on-nd-used) {}

        method native-descriptor() {
            &!on-nd-used();
            $!native-descriptor
        }

        method new($delegate, $native-descriptor, &on-tap, &on-nd-used) {
            self.bless(
                tappable => PermitOnTap.bless(:$delegate, :&on-tap),
                :$native-descriptor, :&on-nd-used
            )
        }
    }

    my class ProcessCancellation is repr('AsyncTask') { }
    my enum  CharsOrBytes ( :Bytes(0), :Chars(1) );

    has $!ready_promise = Promise.new;
    has $!ready_vow = $!ready_promise.vow;
    has $!handle_available_promise = Promise.new;
    has $!stdout_descriptor_vow;
    has $!stderr_descriptor_vow;
    has $!stdout_descriptor_used = Promise.new;
    has $!stderr_descriptor_used = Promise.new;
    has $.path;
    has @.args;
    has $.w;
    has $.enc = 'utf8';
    has $.translate-nl = True;
    has Bool $.started = False;
    has $!stdout_supply;
    has CharsOrBytes $!stdout_type;
    has $!stderr_supply;
    has CharsOrBytes $!stderr_type;
    has $!merge_supply;
    has CharsOrBytes $!merge_type;
    has $!stdin-fd;
    has $!stdout-fd;
    has $!stderr-fd;
    has $!process_handle;
    has $!exit_promise;
    has @!promises;
    has $!encoder;
    has @!close-after-exit;

    proto method new(|) { * }
    multi method new(*@args where .so) {
        my $path = @args.shift;
        self.bless(:$path, :@args, |%_)
    }

    submethod TWEAK(--> Nil) {
        $!encoder := Encoding::Registry.find($!enc).encoder(:$!translate-nl);
    }

    method !pipe-cbs(\channel) {
        -> { $!handle_available_promise.then({ nqp::permit($!process_handle, channel, -1) }) },
        -> { (channel == 1 ?? $!stdout_descriptor_used !! $!stderr_descriptor_used).keep(True) }
    }

    method !pipe(\what, \the-supply, \type, \value, \fd-vow, \permit-channel) {
        X::Proc::Async::TapBeforeSpawn.new(handle => what, proc => self).throw
          if $!started;
        X::Proc::Async::CharsOrBytes.new(handle => what, proc => self).throw
          if the-supply and type != value;

        type         = value;
        the-supply //= Supplier::Preserving.new;

        if nqp::iscont(fd-vow) {
            my $native-descriptor = Promise.new;
            fd-vow = $native-descriptor.vow;
            Pipe.new(the-supply.Supply.Tappable, $native-descriptor, |self!pipe-cbs(permit-channel))
        }
        else {
            the-supply.Supply
        }
    }

    method !wrap-decoder(Supply:D $bin-supply, $enc, \fd-vow, \permit-channel, :$translate-nl) {
        my \sup = Rakudo::Internals.BYTE_SUPPLY_DECODER($bin-supply, $enc // $!enc,
            :translate-nl($translate-nl // $!translate-nl));
        if nqp::iscont(fd-vow) {
            my $native-descriptor = Promise.new;
            fd-vow = $native-descriptor.vow;
            Pipe.new(sup.Supply.Tappable, $native-descriptor, |self!pipe-cbs(permit-channel))
        }
        else {
            sup
        }
    }

    proto method stdout(|) { * }
    multi method stdout(Proc::Async:D: :$bin!) {
        die X::Proc::Async::SupplyOrStd.new if $!merge_supply;
        die X::Proc::Async::BindOrUse.new(:handle<stdout>, :use('get the stdout Supply'))
            if $!stdout-fd;
        $bin
            ?? self!pipe('stdout', $!stdout_supply, $!stdout_type, Bytes, $!stdout_descriptor_vow, 1)
            !! self.stdout(|%_)
    }
    multi method stdout(Proc::Async:D: :$enc, :$translate-nl) {
        die X::Proc::Async::SupplyOrStd.new if $!merge_supply;
        die X::Proc::Async::BindOrUse.new(:handle<stdout>, :use('get the stdout Supply'))
            if $!stdout-fd;
        self!wrap-decoder:
            self!pipe('stdout', $!stdout_supply, $!stdout_type, Chars, Nil, 1),
            $enc, $!stdout_descriptor_vow, 1, :$translate-nl
    }

    proto method stderr(|) { * }
    multi method stderr(Proc::Async:D: :$bin!) {
        die X::Proc::Async::SupplyOrStd.new if $!merge_supply;
        die X::Proc::Async::BindOrUse.new(:handle<stderr>, :use('get the stderr Supply'))
            if $!stderr-fd;
        $bin
            ?? self!pipe('stderr', $!stderr_supply, $!stderr_type, Bytes, $!stderr_descriptor_vow, 2)
            !! self.stderr(|%_)
    }
    multi method stderr(Proc::Async:D: :$enc, :$translate-nl) {
        die X::Proc::Async::SupplyOrStd.new if $!merge_supply;
        die X::Proc::Async::BindOrUse.new(:handle<stderr>, :use('get the stderr Supply'))
            if $!stderr-fd;
        self!wrap-decoder:
            self!pipe('stderr', $!stderr_supply, $!stderr_type, Chars, Nil, 2),
            $enc, $!stderr_descriptor_vow, 2, :$translate-nl
    }

    proto method Supply(|) { * }
    multi method Supply(Proc::Async:D: :$bin!) {
        die X::Proc::Async::SupplyOrStd.new if $!stdout_supply || $!stderr_supply;
        die X::Proc::Async::BindOrUse.new(:handle<stdout>, :use('get the output Supply'))
            if $!stdout-fd;
        die X::Proc::Async::BindOrUse.new(:handle<stderr>, :use('get the output Supply'))
            if $!stderr-fd;
        $bin
            ?? self!pipe('merge', $!merge_supply, $!merge_type, Bytes, Nil, 0)
            !! self.Supply(|%_)
    }
    multi method Supply(Proc::Async:D: :$enc, :$translate-nl) {
        die X::Proc::Async::SupplyOrStd.new if $!stdout_supply || $!stderr_supply;
        die X::Proc::Async::BindOrUse.new(:handle<stdout>, :use('get the output Supply'))
            if $!stdout-fd;
        die X::Proc::Async::BindOrUse.new(:handle<stderr>, :use('get the output Supply'))
            if $!stderr-fd;
        self!wrap-decoder:
            self!pipe('merge', $!merge_supply, $!merge_type, Chars, Nil, 0),
            $enc, Nil, 0, :$translate-nl
    }

    proto method bind-stdin($) {*}
    multi method bind-stdin(IO::Handle:D $handle --> Nil) {
        die X::Proc::Async::BindOrUse.new(:handle<stdin>, :use('use :w')) if $!w;
        $!stdin-fd := $handle.native-descriptor;
        @!close-after-exit.push($handle) if $handle ~~ IO::Pipe;
    }
    multi method bind-stdin(Proc::Async::Pipe:D $pipe --> Nil) {
        die X::Proc::Async::BindOrUse.new(:handle<stdin>, :use('use :w')) if $!w;
        $!stdin-fd := $pipe.native-descriptor;
    }

    method bind-stdout(IO::Handle:D $handle --> Nil) {
        die X::Proc::Async::BindOrUse.new(:handle<stdout>, :use('get the stdout Supply'))
            if $!stdout_supply;
        die X::Proc::Async::BindOrUse.new(:handle<stdout>, :use('get the output Supply'))
            if $!merge_supply;
        $!stdout-fd := $handle.native-descriptor;
    }

    method bind-stderr(IO::Handle:D $handle --> Nil) {
        die X::Proc::Async::BindOrUse.new(:handle<stderr>, :use('get the stderr Supply'))
            if $!stderr_supply;
        die X::Proc::Async::BindOrUse.new(:handle<stderr>, :use('get the output Supply'))
            if $!merge_supply;
        $!stderr-fd := $handle.native-descriptor;
    }

    method ready(--> Promise) {
        $!ready_promise;
    }

    method !capture(\callbacks,\std,\the-supply) {
        my $promise = Promise.new;
        my $vow = $promise.vow;
        my $ss = Rakudo::Internals::SupplySequencer.new(
            on-data-ready => -> \data { the-supply.emit(data) },
            on-completed  => -> { the-supply.done(); $vow.keep(the-supply) },
            on-error      => -> \err { the-supply.quit(err); $vow.keep((the-supply,err)) });
        nqp::bindkey(callbacks,
            std ~ '_bytes' ,
            -> Mu \seq, Mu \data, Mu \err { $ss.process(seq, data, err) });
        $promise;
    }

    method start(Proc::Async:D: :$scheduler = $*SCHEDULER, :$ENV, :$cwd = $*CWD) {
        X::Proc::Async::AlreadyStarted.new(proc => self).throw if $!started;
        $!started = True;

        my @blockers;
        if $!stdin-fd ~~ Promise {
            @blockers.push($!stdin-fd.then({ $!stdin-fd := .result }));
        }
        @blockers
            ?? start { await @blockers; await self!start-internal(:$scheduler, :$ENV, :$cwd) }
            !! self!start-internal(:$scheduler, :$ENV, :$cwd)
    }

    method !start-internal(:$scheduler, :$ENV, :$cwd) {
        my %ENV := $ENV ?? $ENV.hash !! %*ENV;

        $!exit_promise = Promise.new;

        my Mu $callbacks := nqp::hash();
        nqp::bindkey($callbacks, 'done', -> Mu \status {
           $!exit_promise.keep(Proc.new(
               :exitcode(status +> 8), :signal(status +& 0xFF),
               :command[ $!path, |@!args ],
           ))
        });

        nqp::bindkey($callbacks, 'ready', -> Mu \handles = Nil {
            if nqp::isconcrete(handles) {
                with $!stdout_descriptor_vow {
                    my $fd = nqp::atpos_i(handles, 0);
                    $fd < 0
                        ?? .break("Descriptor not available")
                        !! .keep($fd)
                }
                with $!stderr_descriptor_vow {
                    my $fd = nqp::atpos_i(handles, 1);
                    $fd < 0
                        ?? .break("Descriptor not available")
                        !! .keep($fd)
                }
            }
            $!ready_vow.keep(Nil);
        });

        nqp::bindkey($callbacks, 'error', -> Mu \err {
            my $error = X::OS.new(os-error => err);
            $!exit_promise.break($error);
            $!ready_vow.break($error);
        });

        @!promises.push(Promise.anyof(
          self!capture($callbacks,'stdout',$!stdout_supply),
          $!stdout_descriptor_used
        )) if $!stdout_supply;
        @!promises.push(Promise.anyof(
          self!capture($callbacks,'stderr',$!stderr_supply),
          $!stderr_descriptor_used
        )) if $!stderr_supply;
        @!promises.push(
          self!capture($callbacks,'merge',$!merge_supply)
        ) if $!merge_supply;

        nqp::bindkey($callbacks, 'buf_type', buf8.new);
        nqp::bindkey($callbacks, 'write', True) if $.w;
        nqp::bindkey($callbacks, 'stdin_fd', $!stdin-fd) if $!stdin-fd.DEFINITE;
        nqp::bindkey($callbacks, 'stdout_fd', $!stdout-fd) if $!stdout-fd.DEFINITE;
        nqp::bindkey($callbacks, 'stderr_fd', $!stderr-fd) if $!stderr-fd.DEFINITE;

        $!process_handle := nqp::spawnprocasync($scheduler.queue(:hint-affinity),
            CLONE-LIST-DECONTAINERIZED($!path,@!args),
            $cwd.Str,
            CLONE-HASH-DECONTAINERIZED(%ENV),
            $callbacks,
        );
        $!handle_available_promise.keep(True);
        nqp::permit($!process_handle, 0, -1) if $!merge_supply;
        Promise.allof( $!exit_promise, @!promises ).then({
            .close for @!close-after-exit;
            $!exit_promise.status == Broken
                ?? $!exit_promise.cause.throw
                !! $!exit_promise.result
        })
    }

    method print(Proc::Async:D: Str() $str, :$scheduler = $*SCHEDULER) {
        X::Proc::Async::OpenForWriting.new(:method<print>, proc => self).throw if !$!w;
        X::Proc::Async::MustBeStarted.new(:method<print>, proc => self).throw  if !$!started;

        self.write($!encoder.encode-chars($str))
    }

    method put(Proc::Async:D: \x, |c) {
        X::Proc::Async::OpenForWriting.new(:method<say>, proc => self).throw if !$!w;
        X::Proc::Async::MustBeStarted.new(:method<say>, proc => self).throw  if !$!started;

        self.print( x.join ~ "\n", |c );
    }

    method say(Proc::Async:D: \x, |c) {
        X::Proc::Async::OpenForWriting.new(:method<say>, proc => self).throw if !$!w;
        X::Proc::Async::MustBeStarted.new(:method<say>, proc => self).throw  if !$!started;

        self.print( x.gist ~ "\n", |c );
    }

    method write(Proc::Async:D: Blob:D $b, :$scheduler = $*SCHEDULER) {
        X::Proc::Async::OpenForWriting.new(:method<write>, proc => self).throw if !$!w;
        X::Proc::Async::MustBeStarted.new(:method<write>, proc => self).throw  if !$!started;

        my $p = Promise.new;
        my $v = $p.vow;
        nqp::asyncwritebytes(
            $!process_handle,
            $scheduler.queue,
            -> Mu \bytes, Mu \err {
                if err {
                    $v.break(err);
                }
                else {
                    $v.keep(bytes);
                }
            },
            nqp::decont($b), ProcessCancellation);
        $p
    }

    method close-stdin(Proc::Async:D:) {
        X::Proc::Async::OpenForWriting.new(:method<close-stdin>, proc => self).throw
          if !$!w;
        X::Proc::Async::MustBeStarted.new(:method<close-stdin>, proc => self).throw
          if !$!started;

        nqp::closefh($!process_handle);
        True;
    }

    # Note: some of the duplicated code in methods could be moved to
    # proto, but at the moment (2017-06-02) that makes the call 24% slower
    proto method kill(|) { * }
    multi method kill(Proc::Async:D: Signal:D \signal = SIGHUP) {
        X::Proc::Async::MustBeStarted.new(:method<kill>, proc => self).throw if !$!started;
        nqp::killprocasync($!process_handle, signal.value)
    }
    multi method kill(Proc::Async:D: Int:D \signal) {
        X::Proc::Async::MustBeStarted.new(:method<kill>, proc => self).throw if !$!started;
        nqp::killprocasync($!process_handle, signal)
    }

    multi method kill(Proc::Async:D: Str:D \signal) {
        X::Proc::Async::MustBeStarted.new(:method<kill>, proc => self).throw if !$!started;
        nqp::killprocasync($!process_handle, $*KERNEL.signal: signal)
    }
}

#line 1 SETTING::src/core/Systemic.pm
role Systemic {
    has Str $.name;
    has Str $.auth;
    has Version $.version;
    has Blob $.signature;
    has Str $.desc;

    submethod BUILD(
      :$!name    = "unknown",
      :$!auth    = "unknown",
      :$!version = Version.new("unknown")
      --> Nil
    ) { }
    multi method gist(Systemic:D:) {
        $.name ~ (" ($!version)" if $.version.gist ne "vunknown")
    }
    method Str  { $.name }
}

# Since we cannot see attributes of roles done by other roles, the below is
# a copy of the above (minus .desc), instead of doing the Universal role in
# Systemic (as is the spec).  Once we can see attributes of roles of roles
# inside a class, we can fix this abomination.
role Universal {
    has Str $.name;
    has Str $.auth;
    has Version $.version;
    has Blob $.signature;

    submethod BUILD(
      :$!name    = "unknown",
      :$!auth    = "unknown",
      :$!version = Version.new("unknown"),
      --> Nil
    ) {}
    multi method gist(Universal:D:) {
        $!name ~ (" ($!version)" if $!version.gist ne "vunknown")
    }
    method Str  { $!name }
}

#line 1 SETTING::src/core/VM.pm
my constant $?COMPILATION-ID :=
  nqp::sha1(nqp::concat(
    $*W.handle,
    nqp::getcomp('perl6').compilation-id
  ));

class VM does Systemic {
    has $.config;



    has $.prefix;
    has $.precomp-ext;
    has $.precomp-target;

    submethod BUILD(
      :$!config,
      :$!desc = Str,



      --> Nil
    ) {

        $!name           = 'moar';
        $!auth           = "The MoarVM Team";
        $!version        = Version.new($!config<version> // "unknown");
        $!prefix         = $!config<prefix>;
        $!precomp-ext    = "moarvm";
        $!precomp-target = "mbc";










# add new backends here please
    }

    method platform-library-name(IO::Path $library, Version :$version) {
        my int $is-win = Rakudo::Internals.IS-WIN;
        my int $is-darwin = self.osname eq 'darwin';

        my $basename  = $library.basename;
        my int $full-path = $library ne $basename;
        my $dirname   = $library.dirname;

        # OS X needs version before extension
        $basename ~= ".$version" if $is-darwin && $version.defined;


        my $dll = self.config<dll>;
        my $platform-name = sprintf($dll, $basename);






        $platform-name ~= '.' ~ $version
            if $version.defined and nqp::iseq_i(nqp::add_i($is-darwin,$is-win),0);

        $full-path
          ?? $dirname.IO.add($platform-name).absolute
          !! $platform-name.IO
    }

    proto method osname(|) { * }
    multi method osname(VM:U:) {




        nqp::lc(nqp::atkey(nqp::backendconfig,'osname'))

    }
    multi method osname(VM:D:) {




        nqp::lc($!config<osname>)

    }
}

sub INITIALIZE-A-VM-NOW() {
    my $desc := DateTime.now.Str;

    VM.new(:config(nqp::backendconfig),:$desc);


























}

Rakudo::Internals.REGISTER-DYNAMIC: '$*VM', {
    PROCESS::<$VM> := INITIALIZE-A-VM-NOW();
}

#line 1 SETTING::src/core/Distro.pm
# The Distro class and its methods, underlying $*DISTRO, are a work in progress.
# It is very hard to capture data about a changing universe in a stable API.
# If you find errors for your hardware or OS distribution, please report them
# with the values that you expected and how to get them in your situation.

class Distro does Systemic {
    has Str $.release;
    has Bool $.is-win;
    has Str $.path-sep;

    submethod BUILD (
      :$name,
      :$version,
      :$!release,
      :$!auth,
      :$!path-sep,
      :$!signature  = Blob,
      :$!desc = Str
      --> Nil
    ) {
        $!name = $name.lc;    # lowercase
        $!name ~~ s:g/" "//;  # spaceless
        $!version = Version.new($version);
        $!is-win  = so $!name eq any <mswin32 mingw msys cygwin>;
    }

    # This is a temporary migration method needed for installation
    method cur-sep() { "," }
}

sub INITIALIZE-A-DISTRO-NOW() {







    my $config   := INITIALIZE-A-VM-NOW.config;
    my $name     := $config<osname>;
    my $version  := $config<osvers>;
    my $path-sep := $name eq 'MSWin32' ?? ';' !! ':';

    my Str $release := "unknown";
    my Str $auth    := "unknown";

    # darwin specific info
    if $name eq 'darwin' {
        if qx/sw_vers/ ~~ m/^
        ProductName\: \s+ (<[\w\ ]>+) \s+
        ProductVersion\: \s+ (<[\d\.]>+) \s+
        BuildVersion\: \s+ (<[\w\d]>+)
        / {
            $name    := ~$0;
            $version := ~$1;
            $release := ~$2;
        }
        else {
            $name    := 'Mac OS X'; # we assume
            $version := "unknown";
            $release := qx/uname -r/.chomp;
        }
        $auth := 'Apple Computer, Inc.'; # presumably
    }
    elsif Rakudo::Internals.FILETEST-E('/etc/os-release') {
        $_ := '/etc/os-release'.IO.slurp.subst(:g, '"','');
        $auth    := ~$0 if m/^^ HOME_URL   \= (\N*) /;
        $name    := ~$0 if m/^^ ID         \= (\N*) /;
        $version := ~$0 if m/^^ VERSION    \= (\N*) /;
        $release := ~$0 if m/^^ VERSION_ID \= (\N*) /;
    }
    elsif $name eq 'linux' {
        if try qx{lsb_release -a 2> /dev/null} ~~ m/
            Distributor \s+ ID\: \s+ (<[\w\ ]>+) \s+
            Description\: \s+ (<[\w\ ]>+) \s+ (<[\d\.]>+) \s+
            Release\: \s+ (<[\d\.]>+)
        / {
            $auth    := ~$0;
            $name    := ~$1;
            $version := ~$2;
            $release := ~$3;
        }
    }
    my $desc := DateTime.now.Str;
    Distro.new(:$name, :$version, :$release, :$auth, :$path-sep, :$desc);
}

# set up $*DISTRO
Rakudo::Internals.REGISTER-DYNAMIC: '$*DISTRO', {
    PROCESS::<$DISTRO> := INITIALIZE-A-DISTRO-NOW();
}

#line 1 SETTING::src/core/Kernel.pm
# The Kernel class and its methods, underlying $*KERNEL, are a work in progress.
# It is very hard to capture data about a changing universe in a stable API.
# If you find errors for your hardware or OS distribution, please report them
# with the values that you expected and how to get them in your situation.

class Kernel does Systemic {
    has Str $.release;
    has Str $!hardware;
    has Str $!arch;
    has Int $!bits;

    sub uname($opt) {
        state $has_uname = "/bin/uname".IO.x || "/usr/bin/uname".IO.x;
        $has_uname ?? qqx/uname $opt/.chomp !! 'unknown';
    }

    submethod BUILD(:$!auth = "unknown" --> Nil) { }

    method name {
        $!name //= do {
            given $*DISTRO.name {
                when 'mswin32' {
                    'win32'
                }
                default {
                    lc uname '-s';
                }
            }
        }
    }

    method version {
        $!version //= Version.new( do {
            given $*DISTRO.name {
                when 'freebsd' {
                    uname '-r'; # -K -U not introduced until 10.0
                }
                when 'macosx' {
                    my $unamev = uname '-v';
                    $unamev ~~ m/^Darwin \s+ Kernel \s+ Version \s+ (<[\d\.]>+)/
                      ?? ~$0
                      !! $unamev.chomp;
                }
                default {
                    given $.name {
                        when 'linux' {
                            # somewhat counter-intuitively the '-r' is what
                            # most people think of the kernel version
                            uname '-r';
                        }
                        default {
                            uname '-v';
                        }
                    }
                }
            }
        } );
    }

    method release {
        $!release //= do {
            given $*DISTRO.name {
                when any <openbsd netbsd dragonfly> { # needs adapting
                    uname '-r';
                }
                default {
                    uname '-v';
                }
            }
        }
    }

    method hardware {
        $!hardware //= do {
            given $*DISTRO.name {
                default {
                    uname '-m';
                }
            }
        }
    }

    method arch {
        $!arch //= do {
            given $*DISTRO.name {
                when 'raspbian' {
                    uname '-m';
                }
                default {
                    uname '-p';
                }
            }
        }
    }

    method archname {
        self.hardware ~ '-' ~ self.name
    }

    method bits {
        $!bits //= $.hardware ~~ m/_64|w|amd64/ ?? 64 !! 32;  # naive approach
    }

    has @!signals;  # Signal





    has $!signals-setup-lock = Lock.new;

    has $!signals-setup = False;
    method signals (Kernel:D:) {
        unless $!signals-setup {
            $!signals-setup-lock.protect: {
                unless $!signals-setup {
                    my @names;
                    if self.name eq 'win32' {
                        # These are the ones libuv emulates on Windows.
                        @names = flat "", <INT BREAK HUP WINCH>;
                    } else {
                        if self.name eq 'openbsd' {
                            # otherwise it uses a shell buildin
                            @names = flat "", qx!/bin/kill -l!.words;
                        }
                        else {
                            @names = flat "", qx/kill -l/.words;
                        }
                        @names.splice(1,1) if @names[1] eq "0";  # Ubuntu fudge
                        @names.=map({.uc}) if $*KERNEL.name eq 'dragonfly';
                    }

                    for Signal.^enum_value_list -> $signal {
                        my $name = substr($signal.key,3);
                        if @names.first( * eq $name, :k ) -> $index {
                            @!signals[$index] = $signal;
                        }
                    }
                }
            }
            $!signals-setup = True;
        }
        @!signals
    }


    has %!signals-by-Str;
    has $!signals-by-Str-setup = False;

    proto method signal (|) { * }
    multi method signal(Kernel:D: Str:D $signal --> Int:D) {
        unless $!signals-by-Str-setup {
            $!signals-setup-lock.protect: {
                unless $!signals-by-Str-setup {
                    nqp::stmts(
                      (my int $els = @.signals.elems),
                      (my int $i = -1),
                      nqp::while(
                        nqp::isgt_i($els, $i = nqp::add_i($i, 1)),
                        ($_ := @!signals.AT-POS($i)).defined
                          && %!signals-by-Str.ASSIGN-KEY(.Str, nqp::decont($i))))
                }
            }
            $!signals-by-Str-setup = True;
        }
        %!signals-by-Str{$signal} // %!signals-by-Str{"SIG$signal"} // Int;
    }

    multi method signal(Kernel:D: Signal:D \signal --> Int:D) { signal.value }
    multi method signal(Kernel:D: Int:D    \signal --> Int:D) { signal       }
}

Rakudo::Internals.REGISTER-DYNAMIC: '$*KERNEL', {
    PROCESS::<$KERNEL> := Kernel.new;
}

#line 1 SETTING::src/core/Compiler.pm
class Compiler does Systemic {
    has Str $.id;
    has Str $.release;
    has Str $!build-date;
    has Str $.codename;
    BEGIN my $id = $*W.handle.Str ~ '.' ~ nqp::time_n();

    submethod BUILD (
      :$!name      = 'rakudo',
      :$!auth      = 'The Perl Foundation',
      :$version,
      :$release,
      :$build-date,
      :$codename
      --> Nil
    ) {
# XXX Various issues with this stuff on JVM
        my Mu $compiler := nqp::getcurhllsym('$COMPILER_CONFIG');
        $!id = nqp::p6box_s(nqp::ifnull(nqp::atkey($compiler,'id'),$id));
        $!version = Version.new(
          $version // nqp::p6box_s(nqp::atkey($compiler, 'version')) );
        $!release =
          $release // nqp::p6box_s(nqp::atkey($compiler, 'release-number'));
        $!build-date =
          $build-date // nqp::p6box_s(nqp::atkey($compiler, 'build-date'));
        $!codename =
          $codename // nqp::p6box_s(nqp::atkey($compiler, 'codename'));
    }

    method build-date() {
        DateTime.new($!build-date)
    }

    method verbose-config(:$say) {
        my $compiler := nqp::getcomp("perl6");
        my $backend  := $compiler.backend;
        my $name     := $backend.name;

        my $items := nqp::list_s;
        nqp::push_s($items,$name ~ '::' ~ .key ~ '=' ~ .value)
          for $backend.config;

        my $language := $compiler.language;
        nqp::push_s($items,$language ~ '::' ~ .key ~ '=' ~ .value)
          for $compiler.config;

        nqp::push_s(
          $items,
          'repo::chain=' ~ (try $*REPO.repo-chain.map( *.gist ).join(" ")) // ''
        );

        nqp::push_s($items,"distro::$_={ $*DISTRO."$_"() // '' }")
          for <auth desc is-win name path-sep release signature version>;

        nqp::push_s($items,"kernel::$_={ $*KERNEL."$_"() // '' }")
          for <arch archname auth bits desc
               hardware name release signature version>;

        try {
            require System::Info;

            my $sysinfo = System::Info.new;
            nqp::push_s($items,"sysinfo::{ .name }={ $sysinfo.$_ // '' }")
              for $sysinfo.^methods.grep: { .count == 1 && .name ne 'new' };
        }

        my str $string = nqp::join("\n",Rakudo::Sorting.MERGESORT-str($items));

        if $say {
            nqp::say($string);
            Nil
        }
        else {
            my %config;
            my $iter := nqp::iterator($items);
            while $iter {
                my ($main,$key,$value) = nqp::shift($iter).split(<:: =>);
                %config.AT-KEY($main).AT-KEY($key) = $value
            }

            %config but role {
                has $!string = $string;
                proto method Str()  { $!string }
                proto method gist() { $!string }
            }
        }
    }
}

#line 1 SETTING::src/core/Perl.pm
class Perl does Systemic {
    has Compiler $.compiler;

    submethod BUILD(
      :$!name      = 'Perl 6',
      :$!auth      = "The Perl Foundation",
      :$!version   = Version.new(nqp::getcomp('perl6').language_version()),
      :$!compiler  = Compiler.new
      --> Nil
    ) { }

    method VMnames { <moar jvm > }

    method DISTROnames {
        (




        <macosx linux freebsd mswin32 openbsd dragonfly netbsd>

        )
    }

    method KERNELnames { <darwin linux freebsd openbsd netbsd dragonfly win32> }
}

Rakudo::Internals.REGISTER-DYNAMIC: '$*PERL', {
    PROCESS::<$PERL> := Perl.new;
}

#line 1 SETTING::src/core/OS.pm
sub gethostname( --> Str:D){
    nqp::p6box_s(nqp::gethostname());
}

#line 1 SETTING::src/core/Rakudo/Internals/JSON.pm
my class JSONException is Exception {
    has $.text;

    method message {
        'Invalid JSON: ' ~ $!text
    }
}

my class Rakudo::Internals::JSON {
    my class JSONPrettyActions {
        method TOP($/) {
            make $/.values.[0].ast;
        };
        method object($/) {
            make $<pairlist>.ast.hash.item;
        }

        method pairlist($/) {
            make $<pair>>>.ast.flat;
        }

        method pair($/) {
            make $<string>.ast => $<value>.ast;
        }

        method array($/) {
            make $<arraylist>.ast.item;
        }

        method arraylist($/) {
            make [$<value>.map(*.made)];
        }

        method string($/) {
            make $0.elems == 1
                ?? ($0[0].<str> || $0[0].<str_escape>).ast
                !! join '', $0.list.map({ (.<str> || .<str_escape>).ast });
        }
        method value:sym<number>($/) { make +$/.Str }
        method value:sym<string>($/) { make $<string>.ast }
        method value:sym<true>($/)   { make Bool::True  }
        method value:sym<false>($/)  { make Bool::False }
        method value:sym<null>($/)   { make Any }
        method value:sym<object>($/) { make $<object>.ast }
        method value:sym<array>($/)  { make $<array>.ast }

        method str($/)               { make ~$/ }

        my $escapes := nqp::hash(
          '\\' , "\\",
          '/'  , "/",
          'b'  , "\b",
          'n'  , "\x0A",
          't'  , "\t",
          'f'  , "\f",
          'r'  , "\r",
          '"'  , "\"",
        );
        method str_escape($/) {
            make $<xdigit> ?? chr(:16($<xdigit>.join)) !! nqp::atkey($escapes,~$/)
        }
    }

    my grammar JSONPrettyGrammar {
        token TOP       { ^ \s* [ <object> | <array> ] \s* $ }
        rule object     { '{' ~ '}' <pairlist>     }
        rule pairlist   { <pair> * % \,            }
        rule pair       { <string> ':' <value>     }
        rule array      { '[' ~ ']' <arraylist>    }
        rule arraylist  {  <value> * % [ \, ]        }

        proto token value {*};
        token value:sym<number> {
            '-'?
            [ 0 | <[1..9]> <[0..9]>* ]
            [ \. <[0..9]>+ ]?
            [ <[eE]> [\+|\-]? <[0..9]>+ ]?
        }
        token value:sym<true>    { <sym>    };
        token value:sym<false>   { <sym>    };
        token value:sym<null>    { <sym>    };
        token value:sym<object>  { <object> };
        token value:sym<array>   { <array>  };
        token value:sym<string>  { <string> }

        token string {
            \" ~ \" ( <str> | \\ <str_escape> )*
        }

        token str {
            <-["\\\t\n]>+
        }

        token str_escape {
            <["\\/bfnrt]> | u <xdigit>**4
        }
    }


    proto sub to-json(|) {*}

    multi sub to-json(Version:D $v, :$indent = 0, :$first = 0) { to-json(~$v, :$indent, :$first) }
    multi sub to-json(Real:D $d, :$indent = 0, :$first = 0) { (' ' x $first) ~ ~$d }
    multi sub to-json(Bool:D $d, :$indent = 0, :$first = 0) { (' ' x $first) ~ ($d ?? 'true' !! 'false') }
    multi sub to-json(Str:D $d, :$indent = 0, :$first = 0) {
        (' ' x $first) ~ '"'
        ~ $d.trans(['"', '\\', "\b", "\f", "\x0A", "\r", "\t", "\r\n"]
                => ['\"', '\\\\', '\b', '\f', '\n', '\r', '\t', '\r\n'])\
                .subst(/<-[\c32..\c126]>/, { ord(~$_).fmt('\u%04x') }, :g)
        ~ '"'
    }
    multi sub to-json(Positional:D $d, :$indent = 0, :$first = 0) {
        (' ' x $first) ~ "\["
                ~ ($d ?? $d.map({ "\n" ~ to-json($_, :indent($indent + 2), :first($indent + 2)) }).join(",") ~ "\n" ~ (' ' x $indent) !! ' ')
                ~ ']';
    }
    multi sub to-json(Associative:D $d, :$indent = 0, :$first = 0) {
        (' ' x $first) ~ "\{"
                ~ ($d ?? $d.map({ "\n" ~ to-json(.key, :first($indent + 2)) ~ ' : ' ~ to-json(.value, :indent($indent + 2)) }).join(",") ~ "\n" ~ (' ' x $indent) !! ' ')
                ~ '}';
    }

    multi sub to-json(Mu:U $, :$indent = 0, :$first = 0) { 'null' }
    multi sub to-json(Mu:D $s, :$indent = 0, :$first = 0) {
        die "Can't serialize an object of type " ~ $s.WHAT.perl
    }

    method from-json($text) {
        my $a = JSONPrettyActions.new();
        my $o = JSONPrettyGrammar.parse($text, :actions($a));
        JSONException.new(:$text).throw unless $o;
        $o.ast;
    }
    method to-json(|c) { to-json(|c) }
}

#line 1 SETTING::src/core/JSON/Pretty.pm
sub to-json(|c) {
    DEPRECATED('JSON::Fast, JSON::Tiny or JSON::Pretty from https://modules.perl6.org/');
    Rakudo::Internals::JSON.to-json(|c);
}

sub from-json($text) {
    DEPRECATED('JSON::Fast, JSON::Tiny or JSON::Pretty from https://modules.perl6.org/');
    Rakudo::Internals::JSON.from-json($text);
}

#line 1 SETTING::src/core/Distribution.pm
# API to obtain the data of any addressable content
role Distribution { ... }

role Distribution {
    # `meta` provides an API to the meta data in META6 spec (s22)
    #   -   A Distribution may be represented internally by some other
    #       spec (such as using the file system itself for prereqs), as
    #       long as it can also be represented as the META6 hash format
    method meta(--> Hash:D) {
        # Cannot just use ... here as that would break legacy code
        my $class-name = ::?CLASS.^name;

        die $class-name eq 'Distribution'
            ?? 'Legacy Distribution object used in code expecting an object consuming the Distribution role'
            !! "Method 'meta' must be implemented by $class-name because it is required by role Distribution"
    }

    # `content($content-id)` provides an API to the data itself
    #   -   Use `.meta` to determine the $address of a specific $content-id
    #   -   IO::Handle is meant to be a data stream that may or may not be available; for now
    #       it would return an IO::Handle and have `.open.slurp-rest(:bin)` called on it. So if
    #       a socket wants to handle this role currently it would have to wrap `open` or `.slurp-rest`
    #       to handle any protocol negotiation as well as probably saving the data to a tmpfile and
    #       return an IO::Handle to that
    method content($content-id --> IO::Handle:D) {
        # Cannot just use ... here as that would break legacy code
        my $class-name = ::?CLASS.^name;

        die $class-name eq 'Distribution'
            ?? 'Legacy Distribution object used in code expecting an object consuming the Distribution role'
            !! "Method 'content' must be implemented by $class-name because it is required by role Distribution"
    }

    # Backwards compatibility shim
    submethod new(*%_) {
        ::?CLASS.^name eq 'Distribution'
            ?? class :: {
                has $.name;
                has $.auth;
                has $.author;
                has $.authority;
                has $.api;
                has $.ver;
                has $.version;
                has $.description;
                has @.depends;
                has %.provides;
                has %.files;
                has $.source-url;
                method auth { $!auth // $!author // $!authority }
                method ver  { $!ver // $!version }
                method meta(--> Hash:D) {
                    {
                        :$!name,
                        :$.auth,
                        :$.ver,
                        :$!description,
                        :@!depends,
                        :%!provides,
                        :%!files,
                        :$!source-url,
                    }
                }
                method Str() {
                    return "{$.meta<name>}"
                    ~ ":ver<{$.meta<ver>   // ''}>"
                    ~ ":auth<{$.meta<auth> // ''}>"
                    ~ ":api<{$.meta<api>   // ''}>";

                }
                method content($content-id --> IO::Handle:D) { }
            }.new(|%_)
            !! self.bless(|%_)
    }
}

role Distribution::Locally does Distribution {
    has IO::Path $.prefix;
    method content($address) {
        my $handle = IO::Handle.new: path => IO::Path.new($address, :CWD($!prefix // $*CWD));
        $handle // $handle.throw;
    }
}

# A distribution passed to `CURI.install()` will get encapsulated in this
# class, which normalizes the meta6 data and adds identifiers/content-id
class CompUnit::Repository::Distribution {
    has Distribution $!dist handles 'content';
    has $!meta;
    submethod BUILD(:$!meta, :$!dist --> Nil) { }
    method new(Distribution $dist) {
        my $meta = $dist.meta.hash;
        $meta<ver>  //= $meta<version>;
        $meta<auth> //= $meta<authority> // $meta<author>;
        self.bless(:$dist, :$meta);
    }
    method meta { $!meta }

    method Str() {
        return "{$.meta<name>}"
        ~ ":ver<{$.meta<ver>   // ''}>"
        ~ ":auth<{$.meta<auth> // ''}>"
        ~ ":api<{$.meta<api>   // ''}>";

    }

    method id() {
        return nqp::sha1(self.Str);
    }
}

class Distribution::Hash does Distribution::Locally {
    has $!meta;
    submethod BUILD(:$!meta, :$!prefix --> Nil) { }
    method new($hash, :$prefix) { self.bless(:meta($hash), :$prefix) }
    method meta { $!meta }
}

class Distribution::Path does Distribution::Locally {
    has $!meta;
    submethod BUILD(:$!meta, :$!prefix --> Nil) { }
    method new(IO::Path $prefix, IO::Path :$meta-file is copy) {
        $meta-file //= $prefix.add('META6.json');
        die "No meta file located at {$meta-file.path}" unless $meta-file.e;
        my $meta = Rakudo::Internals::JSON.from-json($meta-file.slurp);

        # generate `files` (special directories) directly from the file system
        my %bins = Rakudo::Internals.DIR-RECURSE($prefix.add('bin').absolute).map(*.IO).map: -> $real-path {
            my $name-path = $real-path.is-relative
                ?? $real-path
                !! $real-path.relative($prefix);
            $name-path => $real-path.absolute
        }

        my $resources-dir = $prefix.add('resources');
        my %resources = $meta<resources>.grep(*.?chars).map(*.IO).map: -> $path {
            my $real-path = $path ~~ m/^libraries\/(.*)/
                ?? $resources-dir.add('libraries').add( $*VM.platform-library-name($0.Str.IO) )
                !! $resources-dir.add($path);
            my $name-path = $path.is-relative
                ?? "resources/{$path}"
                !! "resources/{$path.relative($prefix)}";
            $name-path => $real-path.absolute;
        }

        $meta<files> = |%bins, |%resources;

        self.bless(:$meta, :$prefix);
    }
    method meta { $!meta }
}

role CompUnit::Repository { ... }

class Distribution::Resource {
    has $.repo;
    has $.repo-name;
    has $.dist-id;
    has $.key;

    method IO() {
        my $repo := self.repo-name
            ?? CompUnit::RepositoryRegistry.repository-for-name(self.repo-name)
            !! CompUnit::RepositoryRegistry.repository-for-spec(self.repo);
        $repo.resource(self.dist-id, "resources/$.key")
    }

    method platform-library-name() {
        my $library = self.IO;
        ($library ~~ /\.<.alpha>+$/ or $library ~~ /\.so(\.<.digit>+)+$/) #Already a full name?
            ??  $library
            !!  $*VM.platform-library-name($library)
    }

    # delegate appropriate IO::Path methods to the resource IO::Path object
    method Str(|c) {
        self.IO.Str(|c)
    }
    method gist(|c) {
        self.IO.gist(|c)
    }
    method perl(|c) {
        self.IO.perl(|c)
    }
    method absolute(|c) {
        self.IO.absolute(|c)
    }
    method is-absolute(|c) {
        self.IO.is-absolute(|c)
    }
    method relative(|c) {
        self.IO.relative(|c)
    }
    method is-relative(|c) {
        self.IO.is-relative(|c)
    }
    method parts(|c) {
        self.IO.parts(|c)
    }
    method volume(|c) {
        self.IO.volume(|c)
    }
    method dirname(|c) {
        self.IO.dirname(|c)
    }
    method basename(|c) {
        self.IO.basename(|c)
    }
    method extension(|c) {
        self.IO.extension(|c)
    }
    method open(|c) {
        self.IO.open(|c)
    }
    method resolve(|c) {
        self.IO.resolve(|c)
    }
    method slurp(|c) {
        self.IO.slurp(|c)
    }
    method lines(|c) {
        self.IO.lines(|c)
    }
    method comb(|c) {
        self.IO.comb(|c)
    }
    method split(|c) {
        self.IO.split(|c)
    }
    method words(|c) {
        self.IO.words(|c)
    }
    method copy(|c) {
        self.IO.copy(|c)
    }
}

class Distribution::Resources does Associative {
    has Str $.dist-id;
    has Str $.repo;
    has Str $.repo-name;

    proto method BUILD(|) { * }

    multi method BUILD(:$!dist-id, CompUnit::Repository :$repo --> Nil) {
        unless $repo.can('name') and $!repo-name = $repo.name and $!repo-name ne '' {
            $!repo = $repo.path-spec;
            $!repo-name = Str;
        }
    }

    multi method BUILD(:$!dist-id, :$repo, Str :$!repo-name --> Nil) { }
    multi method BUILD(:$!dist-id, Str :$!repo, :$repo-name --> Nil) { }

    method from-precomp() {
        if %*ENV<RAKUDO_PRECOMP_DIST> -> \dist {
            my %data := Rakudo::Internals::JSON.from-json: dist;
            self.new(:repo(%data<repo>), :repo-name(%data<repo-name>), :dist-id(%data<dist-id>))
        }
        else {
            Nil
        }
    }

    method AT-KEY($key) {
        Distribution::Resource.new(:$.repo, :$.repo-name, :$.dist-id, :$key)
    }

    method Str() {
        Rakudo::Internals::JSON.to-json: {:$.repo, :$.repo-name, :$.dist-id}
    }
}

#line 1 SETTING::src/core/CompUnit/DependencySpecification.pm
class CompUnit::DependencySpecification {
    has str $.short-name is required;
    has int $.source-line-number = 0;
    has str $.from = 'Perl6';
    has $.version-matcher = True;
    has $.auth-matcher = True;
    has $.api-matcher = True;

    method Str(CompUnit::DependencySpecification:D:) {
        join '', $.short-name,
          ($.version-matcher//True) ~~ Bool ?? '' !! ":ver<$.version-matcher>",
          ($.auth-matcher   //True) ~~ Bool ?? '' !! ":auth<$.auth-matcher>",
          ($.api-matcher    //True) ~~ Bool ?? '' !! ":api<$.api-matcher>";
    }
}

#line 1 SETTING::src/core/CompUnit/Handle.pm
class CompUnit::Handle {
    has Mu $!module_ctx;
    has Mu $!unit;

    multi submethod new() {
        nqp::create(self)
    }

    method ctxsave() {
        $!module_ctx := nqp::ctxcaller(nqp::ctx()) unless $!module_ctx;
    }

    multi submethod new(Mu \module_ctx) {
        nqp::p6bindattrinvres(
          nqp::create(self),CompUnit::Handle,'$!module_ctx', module_ctx
        )
    }

    submethod from-unit(Stash $unit) {
        nqp::p6bindattrinvres(
          nqp::create(self),CompUnit::Handle,'$!unit',nqp::decont($unit)
        )
    }

    # If the compilation unit has a callable EXPORT subroutine, it will
    # be returned here. Nil otherwise.
    method export-sub(--> Callable:D) {
        my $module := self.unit;
        $module && nqp::existskey($module, '&EXPORT')
          ?? nqp::atkey($module, '&EXPORT')
          !! Nil
    }

    # The EXPORT package from the UNIT of the compilation unit; a
    # Nil if none
    method export-package(--> Stash:D) {
        my $module := self.unit;
        if $module and nqp::existskey($module, 'EXPORT') {
            my $EXPORT := nqp::atkey($module, 'EXPORT');
            nqp::istype($EXPORT.WHO, Stash)
                ?? $EXPORT.WHO
                !! nqp::p6bindattrinvres(nqp::create(Stash), Map, '$!storage', $EXPORT.WHO);
        }
        else {
            Nil
        }
    }

    # The EXPORTHOW package from the UNIT of the compilation unit;
    # Nil if none.
    method export-how-package(--> Stash:D) {
        my $module := self.unit;
        if $module and nqp::existskey($module, 'EXPORTHOW') {
            my $EXPORTHOW := nqp::atkey($module, 'EXPORTHOW');
            my $who := $EXPORTHOW.WHO;
            nqp::istype($who, Stash)
                ?? $who
                !! nqp::p6bindattrinvres(nqp::create(Stash), Map, '$!storage', $who);
        }
        else {
            Nil
        }
    }

    # The GLOBALish package from the UNIT of the compilation unit
    # (the module's contributions to GLOBAL, for merging);
    # Nil if none.
    method globalish-package() { # returns Stash {
        nqp::if(
          nqp::defined($!module_ctx),
          nqp::ifnull(nqp::atkey(nqp::ctxlexpad($!module_ctx),'GLOBALish').WHO, Nil),
          nqp::if(nqp::defined($!unit), $!unit, Nil)
        )
    }

    method unit() {
        nqp::defined($!unit)
            ?? $!unit
            !! nqp::defined($!module_ctx) ?? nqp::ctxlexpad($!module_ctx) !! {}
    }
}

#line 1 SETTING::src/core/CompUnit/Loader.pm
class CompUnit::Loader is repr('Uninstantiable') {
    # Load a file from source and compile it
    method load-source-file(IO::Path $path --> CompUnit::Handle) {
        # Get the compiler and compile the code, then run it
        # (which runs the mainline and captures UNIT).
        my $?FILES   := $path.Str;
        self.load-source($path.slurp(:bin))
    }

    # Decode the specified byte buffer as source code, and compile it
    method load-source(Blob:D $bytes --> CompUnit::Handle:D) {
        my $preserve_global := nqp::ifnull(nqp::gethllsym('perl6', 'GLOBAL'), Mu);

        my $handle   := CompUnit::Handle.new;
        my $*CTXSAVE := $handle;
        my $eval     := nqp::getcomp('perl6').compile($bytes.decode);

        $eval();

        nqp::bindhllsym('perl6', 'GLOBAL', $preserve_global);

        CATCH {
            default {
                nqp::bindhllsym('perl6', 'GLOBAL', $preserve_global);
                .throw;
            }
        }

        $handle
    }

    # Load a pre-compiled file
    proto method load-precompilation-file(|) { * }
    multi method load-precompilation-file(IO::Path $path --> CompUnit::Handle:D) {
        my $handle     := CompUnit::Handle.new;
        my $*CTXSAVE   := $handle;
        my %*COMPILING := nqp::hash();
        nqp::loadbytecode($path.Str);
        $handle
    }

    multi method load-precompilation-file(IO::Handle $file --> CompUnit::Handle:D) {
        my $handle     := CompUnit::Handle.new;
        my $*CTXSAVE   := $handle;
        my %*COMPILING := nqp::hash();

        # Switch file handle to binary mode before passing it off to the VM,
        # so we don't lose things hanging around in the decoder.
        $file.encoding(Nil);
        nqp::loadbytecodefh(nqp::getattr($file, IO::Handle, '$!PIO'), $file.path.Str);

        $handle
    }

    # Load the specified byte buffer as if it was the contents of a
    # precompiled file
    method load-precompilation(Blob:D $bytes --> CompUnit::Handle:D) {
        my $handle     := CompUnit::Handle.new;
        my $*CTXSAVE   := $handle;
        my %*COMPILING := nqp::hash();
        nqp::loadbytecodebuffer($bytes);
        $handle
    }
}

#line 1 SETTING::src/core/CompUnit/PrecompilationUnit.pm
class CompUnit::PrecompilationId {
    has $.id;

    my $cache-lock = Lock.new;
    my %cache;

    method new(Str:D $id) {
        $cache-lock.protect: {
            %cache{$id} //= 2 < $id.chars < 64 && $id ~~ /^<[A..Za..z0..9._-]>+$/
                ?? self.bless(:$id)
                !! die "Invalid precompilation id: $id"
        }
    }

    method Str()      { $!id }
    method IO()       { $!id.IO }
    method substr(|c) { $!id.substr(|c) }
}

role CompUnit::PrecompilationDependency {
    method id(--> CompUnit::PrecompilationId:D) { ... }
    method src(--> Str:D) { ... }
    method spec(--> CompUnit::DependencySpecification:D) { ... }
    method checksum(--> Str:D) { ... }
    method Str() {
        "$.id $.src $.spec"
    }
    method serialize(--> Str:D) { ... }
    method deserialize(Str, --> CompUnit::PrecompilationDependency:D) { ... }
}

role CompUnit::PrecompilationUnit {
    method id(--> CompUnit::PrecompilationId:D) { ... }
    method path(--> IO::Path:D) { ... }
    method modified(--> Instant:D) { ... }
    method dependencies(--> Array[CompUnit::PrecompilationDependency]) { ... }
    method bytecode(--> Buf:D) { ... }
    method checksum(--> Str:D) { ... }
    method source-checksum(--> Str:D) { ... }
    method bytecode-handle(--> IO::Handle:D) { ... }
    method close(--> Nil) { ... }
    method is-up-to-date(CompUnit::PrecompilationDependency $dependency, Bool :$check-source --> Bool) {
        my $RMD = $*RAKUDO_MODULE_DEBUG;
        if $check-source { # a repo changed, so maybe it's a change in our source file
            my $source-checksum = $.source-checksum;

            my $srcIO = CompUnit::RepositoryRegistry.file-for-spec($dependency.src) // $dependency.src.IO;
            unless $srcIO {
                return False unless $srcIO.e;
            }
            my $current-source-checksum := nqp::sha1($srcIO.slurp(:enc<iso-8859-1>));
            $RMD(
                "$.path\nspec: $dependency.spec()\nsource: $srcIO\n"
                ~ "source-checksum: $source-checksum\ncurrent-source-checksum: $current-source-checksum"
            ) if $RMD;
            return False if $source-checksum ne $current-source-checksum;
        }

        $RMD("dependency checksum $dependency.checksum() unit: $.checksum()") if $RMD;

        $.checksum eq $dependency.checksum
    }
}

class CompUnit::PrecompilationDependency::File does CompUnit::PrecompilationDependency {
    has CompUnit::PrecompilationId $.id;
    has Str $.src;
    has Str $.checksum is rw;
    has Str $!serialized-spec;
    has CompUnit::DependencySpecification $.spec;

    method source-name() {
        "$.src ($.spec.short-name())"
    }

    method deserialize(Str $str) {
        my ($id, $src, $checksum, $spec) = $str.split("\0", 4);
        nqp::p6bindattrinvres(
            self.new(:id(CompUnit::PrecompilationId.new($id)), :$src, :$checksum),
            CompUnit::PrecompilationDependency::File,
            '$!serialized-spec',
            $spec,
        );
    }

    method spec(--> CompUnit::DependencySpecification:D) {
        $!spec //= $!serialized-spec
            ?? do {









                use MONKEY-SEE-NO-EVAL;
                EVAL $!serialized-spec;

            }
            !! Nil;
    }

    method serialize(--> Str:D) {








        "$.id\0$.src\0$.checksum\0{$!serialized-spec ?? $!serialized-spec !! $!spec.perl}"

    }

    method Str() {
        "$.id $.src $.checksum {$!serialized-spec ?? $!serialized-spec !! $!spec.perl}"
    }
}

#line 1 SETTING::src/core/CompUnit/PrecompilationStore.pm
role CompUnit::PrecompilationStore {
    # Prepare a new implementation specific PrecompilationUnit for storage
    method new-unit(| --> CompUnit::PrecompilationUnit:D)
    { ... }

    # Load the precompilation identified by the pairing of the specified
    # compiler and precompilation ID.
    method load-unit(CompUnit::PrecompilationId $compiler-id,
                CompUnit::PrecompilationId $precomp-id)
    { ... }

    # Return the repository id for which the specified precomp file's
    # dependencies have been validated
    method load-repo-id(CompUnit::PrecompilationId $compiler-id,
                CompUnit::PrecompilationId $precomp-id)
    { ... }

    # Store the file at the specified path in the precompilation store,
    # under the given compiler ID and precompilation ID.
    method store-file(CompUnit::PrecompilationId $compiler-id,
                 CompUnit::PrecompilationId $precomp-id,
                 IO::Path:D $path,
                 :$extension = '')
    { ... }

    # Store the given precompilation unit in the precompilation store
    # under the given compiler ID and precompilation ID.
    method store-unit(CompUnit::PrecompilationId $compiler-id,
                 CompUnit::PrecompilationId $precomp-id,
                 CompUnit::PrecompilationUnit $unit)
    { ... }

    # Store the given repo-id for a precompilation under the given
    # compiler ID and precompilation ID.
    method store-repo-id(CompUnit::PrecompilationId $compiler-id,
                 CompUnit::PrecompilationId $precomp-id,
                 :$repo-id!)
    { ... }

    # Delete an individual precompilation.
    method delete(CompUnit::PrecompilationId $compiler-id,
                  CompUnit::PrecompilationId $precomp-id)
    { ... }

    # Delete all precompilations for a particular compiler.
    method delete-by-compiler(CompUnit::PrecompilationId $compiler-id)
    { ... }
}

#line 1 SETTING::src/core/CompUnit/PrecompilationStore/File.pm
class CompUnit::PrecompilationStore::File does CompUnit::PrecompilationStore {
    my class CompUnit::PrecompilationUnit::File does CompUnit::PrecompilationUnit {
        has CompUnit::PrecompilationId $.id;
        has IO::Path $.path;
        has IO::Handle $!file;
        has CompUnit::PrecompilationDependency @!dependencies;
        has $!initialized = False;
        has $.checksum;
        has $.source-checksum;
        has $!bytecode;
        has $!store;
        has Lock $!update-lock = Lock.new;

        submethod BUILD(
            CompUnit::PrecompilationId :$!id,
            IO::Path :$!path,
            :$!source-checksum,
            :@!dependencies,
            :$!bytecode,
            :$!store,
            --> Nil
        ) {
            if $!bytecode {
                $!initialized = True;
                $!checksum = nqp::sha1($!bytecode.decode('iso-8859-1'));
            }
        }

        method !open() {
            $!file = $!path.open(:r);
        }

        method modified(--> Instant:D) {
            $!path.modified
        }

        method !read-dependencies() {
            $!update-lock.protect: {
                return if $!initialized;
                self!open(:r) unless $!file;

                $!checksum        = $!file.get;
                $!source-checksum = $!file.get;
                my $dependency    = $!file.get;
                while $dependency {
                    @!dependencies.push: CompUnit::PrecompilationDependency::File.deserialize($dependency);
                    $dependency = $!file.get;
                }
                $!initialized = True;
            }
        }

        method dependencies(--> Array[CompUnit::PrecompilationDependency]) {
            self!read-dependencies;
            @!dependencies
        }

        method bytecode(--> Buf:D) {
            $!update-lock.protect: {
                self!read-dependencies;
                $!bytecode //= $!file.slurp-rest(:bin,:close)
            }
        }

        method bytecode-handle(--> IO::Handle:D) {
            self!read-dependencies;
            $!file
        }

        method source-checksum() is rw {
            self!read-dependencies;
            $!source-checksum
        }

        method checksum() is rw {
            self!read-dependencies;
            $!checksum
        }

        method Str(--> Str:D) {
            self.path.Str
        }

        method close(--> Nil) {
            $!update-lock.protect: {
                $!file.close if $!file;
                $!file = Nil;
            }
        }

        method save-to(IO::Path $precomp-file) {
            my $handle = $precomp-file.open(:w);
            $handle.print($!checksum ~ "\n");
            $handle.print($!source-checksum ~ "\n");
            $handle.print($_.serialize ~ "\n") for @!dependencies;
            $handle.print("\n");
            $handle.write($!bytecode);
            $handle.close;
            $!path = $precomp-file;
        }

        method is-up-to-date(CompUnit::PrecompilationDependency $dependency, Bool :$check-source --> Bool) {
            my $result = self.CompUnit::PrecompilationUnit::is-up-to-date($dependency, :$check-source);
            $!store.remove-from-cache($.id) unless $result;
            $result
        }
    }

    has IO::Path $.prefix is required;
    has IO::Handle $!lock;
    has int $!lock-count = 0;
    has %!loaded;
    has %!compiler-cache;
    has %!dir-cache;
    has Lock $!update-lock = Lock.new;

    submethod BUILD(IO::Path :$!prefix --> Nil) {
    }

    method new-unit(|c) {
        CompUnit::PrecompilationUnit::File.new(|c, :store(self))
    }

    method !dir(CompUnit::PrecompilationId $compiler-id,
                CompUnit::PrecompilationId $precomp-id)
    {
        $!update-lock.protect: {
            %!dir-cache{$compiler-id ~ $precomp-id} //=
                (%!compiler-cache{$compiler-id} //= self.prefix.add($compiler-id))
                    .add($precomp-id.substr(0, 2))
        }
    }

    method path(CompUnit::PrecompilationId $compiler-id,
                 CompUnit::PrecompilationId $precomp-id,
                 Str :$extension = '')
    {
        self!dir($compiler-id, $precomp-id).add($precomp-id ~ $extension)
    }

    method !lock(--> Nil) {
        return if $*W && $*W.is_precompilation_mode();
        my int $acquire-file-lock = $!update-lock.protect: {
            $!lock //= $.prefix.add('.lock').open(:create, :rw);
            $!lock-count++
        }
        $!lock.lock if $acquire-file-lock == 0;
    }

    method unlock() {
        return if $*W && $*W.is_precompilation_mode();
        $!update-lock.protect: {
            die "unlock when we're not locked!" if $!lock-count == 0;
            $!lock-count-- if $!lock-count > 0;
            $!lock && $!lock-count == 0 ?? $!lock.unlock !! True
        }
    }

    method load-unit(CompUnit::PrecompilationId $compiler-id,
                CompUnit::PrecompilationId $precomp-id)
    {
        $!update-lock.protect: {
            %!loaded{$precomp-id} //= do {
                my $path = self.path($compiler-id, $precomp-id);
                $path ~~ :e
                    ?? CompUnit::PrecompilationUnit::File.new(:id($precomp-id), :$path, :store(self))
                    !! Nil
            }
        }
    }

    method load-repo-id(CompUnit::PrecompilationId $compiler-id,
                CompUnit::PrecompilationId $precomp-id)
    {
        my $path = self.path($compiler-id, $precomp-id, :extension<.repo-id>);
        if $path ~~ :e {
            $path.slurp
        }
        else {
            Nil
        }
    }

    method remove-from-cache(CompUnit::PrecompilationId $precomp-id) {
        $!update-lock.protect: { %!loaded{$precomp-id}:delete };
    }

    method destination(CompUnit::PrecompilationId $compiler-id,
                       CompUnit::PrecompilationId $precomp-id,
                       Str :$extension = ''
                       --> IO::Path:D)
    {
        unless $!prefix.e {
            $!prefix.mkdir or return;
        }
        return unless $!prefix.w;
        self!lock();
        self!file($compiler-id, $precomp-id, :$extension);
    }

    method !file(CompUnit::PrecompilationId $compiler-id,
                 CompUnit::PrecompilationId $precomp-id,
                 Str :$extension = ''
                 --> IO::Path:D)
    {
        my $compiler-dir = self.prefix.add($compiler-id);
        $compiler-dir.mkdir unless $compiler-dir.e;
        my $dest = self!dir($compiler-id, $precomp-id);
        $dest.mkdir unless $dest.e;
        $dest.add($precomp-id ~ $extension)
    }

    method store-file(CompUnit::PrecompilationId $compiler-id,
                 CompUnit::PrecompilationId $precomp-id,
                 IO::Path:D $path,
                 :$extension = '')
    {
        $path.rename(self!file($compiler-id, $precomp-id, :$extension));
    }

    method store-unit(CompUnit::PrecompilationId $compiler-id,
                 CompUnit::PrecompilationId $precomp-id,
                 CompUnit::PrecompilationUnit $unit)
    {
        my $precomp-file = self!file($compiler-id, $precomp-id, :extension<.tmp>);
        $unit.save-to($precomp-file);
        $precomp-file.rename(self!file($compiler-id, $precomp-id));
        self.remove-from-cache($precomp-id);
    }

    method store-repo-id(CompUnit::PrecompilationId $compiler-id,
                 CompUnit::PrecompilationId $precomp-id,
                 :$repo-id!)
    {
        try self!file($compiler-id, $precomp-id, :extension<.repo-id>).spurt($repo-id);
    }

    method delete(
        CompUnit::PrecompilationId $compiler-id,
        CompUnit::PrecompilationId $precomp-id,
        Str :$extension = '')
    {
        self.path($compiler-id, $precomp-id, :$extension).unlink;
    }

    method delete-by-compiler(CompUnit::PrecompilationId $compiler-id)
    {
         my $compiler-dir = self.prefix.add($compiler-id);
         for $compiler-dir.dir -> $subdir {
             $subdir.dir>>.unlink;
             $subdir.rmdir;
         }
         $compiler-dir.rmdir;
    }
}

#line 1 SETTING::src/core/CompUnit/PrecompilationRepository.pm
{
    role CompUnit::PrecompilationRepository {
        method try-load(
            CompUnit::PrecompilationDependency::File $dependency,
            IO::Path :$source,
            CompUnit::PrecompilationStore :@precomp-stores,
            --> CompUnit::Handle:D) {
            Nil
        }

        method load(CompUnit::PrecompilationId $id --> Nil) { }

        method may-precomp(--> Bool:D) {
            True # would be a good place to check an environment variable
        }
    }
}

BEGIN CompUnit::PrecompilationRepository::<None> := CompUnit::PrecompilationRepository.new;

class CompUnit { ... }
class CompUnit::PrecompilationRepository::Default does CompUnit::PrecompilationRepository {
    has CompUnit::PrecompilationStore $.store;
    my %loaded;
    my $loaded-lock = Lock.new;
    my $first-repo-id;

    my $lle;
    my $profile;
    my $optimize;

    method try-load(
        CompUnit::PrecompilationDependency::File $dependency,
        IO::Path :$source = $dependency.src.IO,
        CompUnit::PrecompilationStore :@precomp-stores = Array[CompUnit::PrecompilationStore].new($.store),
     --> CompUnit::Handle:D) {
        my $RMD = $*RAKUDO_MODULE_DEBUG;
        my $id = $dependency.id;
        $RMD("try-load $id: $source") if $RMD;

        # Even if we may no longer precompile, we should use already loaded files
        $loaded-lock.protect: {
            return %loaded{$id} if %loaded{$id}:exists;
        }

        my ($handle, $checksum) = (
            self.may-precomp and (
                my $loaded = self.load($id, :source($source), :checksum($dependency.checksum), :@precomp-stores) # already precompiled?
                or self.precompile($source, $id, :source-name($dependency.source-name), :force($loaded ~~ Failure))
                    and self.load($id, :@precomp-stores) # if not do it now
            )
        );

        if $*W and $*W.record_precompilation_dependencies {
            if $handle {
                $dependency.checksum = $checksum;
                say $dependency.serialize;
            }
            else {
                nqp::exit(0);
            }
        }

        $handle ?? $handle !! Nil
    }

    method !load-handle-for-path(CompUnit::PrecompilationUnit $unit) {
        my $preserve_global := nqp::ifnull(nqp::gethllsym('perl6', 'GLOBAL'), Mu);
        if $*RAKUDO_MODULE_DEBUG -> $RMD { $RMD("Loading precompiled\n$unit") }

        my $handle := CompUnit::Loader.load-precompilation-file($unit.bytecode-handle);
        $unit.close;




        nqp::bindhllsym('perl6', 'GLOBAL', $preserve_global);
        CATCH {
            default {
                nqp::bindhllsym('perl6', 'GLOBAL', $preserve_global);
                .throw;
            }
        }
        $handle
    }

    method !load-file(
        CompUnit::PrecompilationStore @precomp-stores,
        CompUnit::PrecompilationId $id,
        :$repo-id,
    ) {
        my $compiler-id = CompUnit::PrecompilationId.new($*PERL.compiler.id);
        my $RMD = $*RAKUDO_MODULE_DEBUG;
        for @precomp-stores -> $store {
            $RMD("Trying to load {$id ~ ($repo-id ?? '.repo-id' !! '')} from $store.prefix()") if $RMD;
            my $file = $repo-id
                ?? $store.load-repo-id($compiler-id, $id)
                !! $store.load-unit($compiler-id, $id);
            return $file if $file;
        }
        Nil
    }

    method !load-dependencies(CompUnit::PrecompilationUnit:D $precomp-unit, @precomp-stores) {
        my $compiler-id = CompUnit::PrecompilationId.new($*PERL.compiler.id);
        my $RMD = $*RAKUDO_MODULE_DEBUG;
        my $resolve = False;
        my $repo = $*REPO;
        $first-repo-id //= $repo.id;
        my $repo-id = self!load-file(@precomp-stores, $precomp-unit.id, :repo-id);
        if $repo-id ne $repo.id {
            $RMD("Repo changed: $repo-id ne {$repo.id}. Need to re-check dependencies.") if $RMD;
            $resolve = True;
        }
        if $repo-id ne $first-repo-id {
            $RMD("Repo chain changed: $repo-id ne {$first-repo-id}. Need to re-check dependencies.") if $RMD;
            $resolve = True;
        }
        $resolve = False unless %*ENV<RAKUDO_RERESOLVE_DEPENDENCIES> // 1;
        my @dependencies;
        for $precomp-unit.dependencies -> $dependency {
            $RMD("dependency: $dependency") if $RMD;

            if $resolve {
                my $comp-unit = $repo.resolve($dependency.spec);
                $RMD("Old id: $dependency.id(), new id: {$comp-unit.repo-id}") if $RMD;
                return False unless $comp-unit and $comp-unit.repo-id eq $dependency.id;
            }

            my $dependency-precomp = @precomp-stores
                .map({ $_.load-unit($compiler-id, $dependency.id) })
                .first(*.defined)
                or do {
                    $RMD("Could not find $dependency.spec()") if $RMD;
                    return False;
                }
            unless $dependency-precomp.is-up-to-date($dependency, :check-source($resolve)) {
                $dependency-precomp.close;
                return False;
            }

            @dependencies.push: $dependency-precomp;
        }

        $loaded-lock.protect: {
            for @dependencies -> $dependency-precomp {
                unless %loaded{$dependency-precomp.id}:exists {
                    %loaded{$dependency-precomp.id} = self!load-handle-for-path($dependency-precomp);
                }
            }
        }

        # report back id and source location of dependency to dependant
        if $*W and $*W.record_precompilation_dependencies {
            for $precomp-unit.dependencies -> $dependency {
                say $dependency.serialize;
            }
        }

        if $resolve {
            self.store.store-repo-id($compiler-id, $precomp-unit.id, :repo-id($repo.id));
        }
        True
    }

    proto method load(|) {*}

    multi method load(
        Str $id,
        Instant :$since,
        IO::Path :$source,
        CompUnit::PrecompilationStore :@precomp-stores = Array[CompUnit::PrecompilationStore].new($.store),
    ) {
        self.load(CompUnit::PrecompilationId.new($id), :$since, :@precomp-stores)
    }

    multi method load(
        CompUnit::PrecompilationId $id,
        IO::Path :$source,
        Str :$checksum is copy,
        Instant :$since,
        CompUnit::PrecompilationStore :@precomp-stores = Array[CompUnit::PrecompilationStore].new($.store),
    ) {
        $loaded-lock.protect: {
            return %loaded{$id} if %loaded{$id}:exists;
        }
        my $RMD = $*RAKUDO_MODULE_DEBUG;
        my $compiler-id = CompUnit::PrecompilationId.new($*PERL.compiler.id);
        my $unit = self!load-file(@precomp-stores, $id);
        if $unit {
            if (not $since or $unit.modified > $since)
                and (not $source or ($checksum //= nqp::sha1($source.slurp(:enc<iso-8859-1>))) eq $unit.source-checksum)
                and self!load-dependencies($unit, @precomp-stores)
            {
                my \loaded = self!load-handle-for-path($unit);
                $loaded-lock.protect: { %loaded{$id} = loaded };
                return (loaded, $unit.checksum);
            }
            else {
                $RMD("Outdated precompiled {$unit}{$source ?? " for $source" !! ''}\n"
                     ~ "    mtime: {$unit.modified}{$since ?? ", since: $since" !! ''}\n"
                     ~ "    checksum: {$unit.source-checksum}, expected: $checksum") if $RMD;
                $unit.close;
                fail "Outdated precompiled $unit";
            }
        }
        Nil
    }

    proto method precompile(|) {*}

    multi method precompile(
        IO::Path:D $path,
        Str $id,
        Bool :$force = False,
        :$source-name = $path.Str
    ) {
        self.precompile($path, CompUnit::PrecompilationId.new($id), :$force, :$source-name)
    }

    multi method precompile(
        IO::Path:D $path,
        CompUnit::PrecompilationId $id,
        Bool :$force = False,
        :$source-name = $path.Str
    ) {
        my $compiler-id = CompUnit::PrecompilationId.new($*PERL.compiler.id);
        my $io = self.store.destination($compiler-id, $id);
        return False unless $io;
        my $RMD = $*RAKUDO_MODULE_DEBUG;
        if not $force and $io.e and $io.s {
            $RMD("$source-name\nalready precompiled into\n$io") if $RMD;
            self.store.unlock;
            return True;
        }
        my $source-checksum = nqp::sha1($path.slurp(:enc<iso-8859-1>));
        my $bc = "$io.bc".IO;

        $lle     //= Rakudo::Internals.LL-EXCEPTION;
        $profile //= Rakudo::Internals.PROFILE;
        $optimize //= Rakudo::Internals.OPTIMIZE;
        my %env = %*ENV; # Local copy for us to tweak
        %env<RAKUDO_PRECOMP_WITH> = $*REPO.repo-chain.map(*.path-spec).join(',');

        my $rakudo_precomp_loading = %env<RAKUDO_PRECOMP_LOADING>;
        my $modules = $rakudo_precomp_loading ?? Rakudo::Internals::JSON.from-json: $rakudo_precomp_loading !! [];
        die "Circular module loading detected trying to precompile $path" if $modules.Set{$path.Str}:exists;
        %env<RAKUDO_PRECOMP_LOADING> = Rakudo::Internals::JSON.to-json: [|$modules, $path.Str];
        %env<RAKUDO_PRECOMP_DIST> = $*RESOURCES ?? $*RESOURCES.Str !! '{}';

        $RMD("Precompiling $path into $bc ($lle $profile $optimize)") if $RMD;
        my $perl6 = $*EXECUTABLE
            .subst('perl6-debug', 'perl6') # debugger would try to precompile it's UI
            .subst('perl6-gdb', 'perl6')
            .subst('perl6-jdb-server', 'perl6-j') ;
        if %env<RAKUDO_PRECOMP_NESTED_JDB> {
            $perl6.subst-mutate('perl6-j', 'perl6-jdb-server');
            note "starting jdb on port " ~ ++%env<RAKUDO_JDB_PORT>;
        }
        my $out = '';
        my $err = '';
        my $status;
        react {
            my $proc = Proc::Async.new(
                $perl6,
                $lle,
                $profile,
                $optimize,
                "--target=" ~ Rakudo::Internals.PRECOMP-TARGET,
                "--output=$bc",
                "--source-name=$source-name",
                $path
            );

            whenever $proc.stdout {
                $out ~= $_
            }
            unless $RMD {
                whenever $proc.stderr {
                    $err ~= $_
                }
            }
            whenever $proc.start(ENV => %env) {
                $status = .exitcode
            }
        }

        my @result = $out.lines.unique;
        if $status {  # something wrong
            self.store.unlock;
            $RMD("Precompiling $path failed: $status") if $RMD;
            Rakudo::Internals.VERBATIM-EXCEPTION(1);
            die $RMD ?? @result !! $err;
        }

        if not $RMD and $err -> $warnings {
            $*ERR.print($warnings);
        }
        unless $bc.e {
            $RMD("$path aborted precompilation without failure") if $RMD;
            self.store.unlock;
            return False;
        }
        $RMD("Precompiled $path into $bc") if $RMD;
        my str $dependencies = '';
        my CompUnit::PrecompilationDependency::File @dependencies;
        my %dependencies;
        for @result -> $dependency-str {
            unless $dependency-str ~~ /^<[A..Z0..9]> ** 40 \0 .+/ {
                say $dependency-str;
                next
            }
            my $dependency = CompUnit::PrecompilationDependency::File.deserialize($dependency-str);
            next if %dependencies{$dependency.Str}++; # already got that one
            $RMD($dependency.Str()) if $RMD;
            @dependencies.push: $dependency;
        }
        $RMD("Writing dependencies and byte code to $io.tmp for source checksum: $source-checksum") if $RMD;
        self.store.store-unit(
            $compiler-id,
            $id,
            self.store.new-unit(:$id, :@dependencies, :$source-checksum, :bytecode($bc.slurp(:bin))),
        );
        $bc.unlink;
        self.store.store-repo-id($compiler-id, $id, :repo-id($*REPO.id));
        self.store.unlock;
        True
    }
}

#line 1 SETTING::src/core/CompUnit/Repository.pm
role CompUnit::Repository {
    has CompUnit::Repository $.next-repo is rw;

    # Resolves a dependency specification to a concrete dependency. If the
    # dependency was not already loaded, loads it. Returns a CompUnit
    # object that represents the selected dependency. If there is no
    # matching dependency, throws X::CompUnit::UnsatisfiedDependency.
    method need(CompUnit::DependencySpecification $spec,
                # If we're first in the chain, our precomp repo is the chosen one.
                CompUnit::PrecompilationRepository $precomp = self.precomp-repository(),
                CompUnit::PrecompilationStore :@precomp-stores = Array[CompUnit::PrecompilationStore].new($precomp.store)
                --> CompUnit:D)
        { ... }

    # Resolves a dependency specification to a concrete dependency.
    # Returns a CompUnit object that represents the selected dependency.
    # If there is no matching dependency, Nil is returned.
    method resolve(CompUnit::DependencySpecification $spec --> CompUnit:D)
    {
        self.next-repo
          ?? self.next-repo.resolve($spec)
          !! Nil
    }

    # Just load the file and return a CompUnit object representing it.
    method load(IO::Path:D $file --> CompUnit:D)
    {
        self.next-repo
          ?? self.next-repo.load($file)
          !! nqp::die("Could not find $file in:\n"
              ~ $*REPO.repo-chain.map(*.Str).join("\n").indent(4));
    }

    # Returns the CompUnit objects describing all of the compilation
    # units that have been loaded by this repository in the current
    # process.
    method loaded(--> Iterable:D)
        { ... }

    # Returns a unique ID of this repository
    method id(--> Str:D)
        { ... }

    method precomp-store(--> CompUnit::PrecompilationStore)
        { CompUnit::PrecompilationStore }

    method precomp-repository(--> CompUnit::PrecompilationRepository)
        { CompUnit::PrecompilationRepository::None }

    method repo-chain() {
        ($.next-repo and $.next-repo.defined) ?? (self, |$.next-repo.repo-chain()) !! (self, );
    }
}

#line 1 SETTING::src/core/CompUnit/Repository/Installable.pm
role CompUnit::Repository::Installable does CompUnit::Repository {
    # Installs a distribution into the repository.
    method install(Distribution $dist) { ... }

    # Returns True if we can install modules (this will typically do a
    # .w check on the module database).
    method can-install(--> Bool:D) { ... }

    # Returns the Distribution objects for all installed distributions.
    method installed(--> Iterable:D) { }
}

#line 1 SETTING::src/core/CompUnit.pm
class CompUnit {
    has Str     $.from;
    has Str     $.short-name;
    has Version $.version;
    has Str     $.auth;
    has Str     $!WHICH;

    # The CompUnit::Repository that loaded this CompUnit.
    has CompUnit::Repository $.repo is required;

    # That repository's identifier for the compilation unit. This is not globally unique.
    has Str:D $.repo-id is required;

    # The low-level handle.
    has CompUnit::Handle $.handle is required;

    # Whether the module was loaded from a precompilation or not.
    has Bool $.precompiled = False;

    # The distribution that this compilation unit was installed as part of
    # (if known).
    has Distribution $.distribution;

    my $default-from = 'Perl6';

    method new(CompUnit:U:
      Str                  :$short-name is copy,
      Version              :$version,
      Str                  :$auth,
      Str                  :$from = $default-from,
      CompUnit::Handle     :$handle = CompUnit::Handle,
      CompUnit::Repository :$repo,
      Str                  :$repo-id,
      Bool                 :$precompiled = False,
      Distribution         :$distribution,
    ) {
        self.bless(
          :$short-name,
          :$version,
          :$auth,
          :$from,
          :$handle,
          :$repo,
          :$repo-id,
          :$precompiled,
          :$distribution,
        );
    }

    multi method WHICH(CompUnit:D:) { $!WHICH //= self.^name }
    multi method Str(CompUnit:D: --> Str:D)  { $!short-name }
    multi method gist(CompUnit:D: --> Str:D) { self.short-name }

    method unit() {
        $.handle.unit
    }
}

#line 1 SETTING::src/core/CompUnit/RepositoryRegistry.pm
class CompUnit::Repository::FileSystem   { ... }
class CompUnit::Repository::Installation { ... }
class CompUnit::Repository::AbsolutePath { ... }
class CompUnit::Repository::Unknown      { ... }
class CompUnit::Repository::NQP { ... }
class CompUnit::Repository::Perl5 { ... }





class CompUnit::RepositoryRegistry {
    my $lock     = Lock.new;

    method repository-for-spec(Str $spec, CompUnit::Repository :$next-repo) {
        state %include-spec2cur;
        state $lock = Lock.new;

        my ($short-id,%options,$path) := parse-include-spec($spec);
        my $class := short-id2class($short-id);
        return CompUnit::Repository::Unknown.new(:path-spec($spec), :short-name($short-id))
            if so $class && nqp::istype($class, Failure) or $class === Any;

        my $abspath = $class.?absolutify($path) // $path;
        my $id      = "$short-id#$abspath";
        %options<next-repo> = $next-repo if $next-repo;
        $lock.protect( {
            %include-spec2cur{$id}:exists
              ?? %include-spec2cur{$id}
              !! (%include-spec2cur{$id} := $class.new(:prefix($abspath), |%options));
        } );
    }

    my $custom-lib := nqp::hash();
    method setup-repositories() {
        my $raw-specs;
        # only look up environment once
        my $ENV := nqp::getattr(%*ENV,Map,'$!storage');

        # starting up for creating precomp
        my $precomp-specs = nqp::existskey($ENV,'RAKUDO_PRECOMP_WITH')
            ?? nqp::atkey($ENV,'RAKUDO_PRECOMP_WITH')
            !! False;
        if $precomp-specs {
            # assume well formed strings
            $raw-specs := nqp::split(',', $precomp-specs);
        }

        # normal start up
        else {
            $raw-specs := nqp::list();
            for Rakudo::Internals.INCLUDE -> $specs {
               nqp::push($raw-specs,nqp::unbox_s($_))
                 for parse-include-specS($specs);
            }

            if nqp::existskey($ENV,'RAKUDOLIB') {
                nqp::push($raw-specs,nqp::unbox_s($_))
                  for parse-include-specS(nqp::atkey($ENV,'RAKUDOLIB'));
            }
            if nqp::existskey($ENV,'PERL6LIB') {
                nqp::push($raw-specs,nqp::unbox_s($_))
                  for parse-include-specS(nqp::atkey($ENV,'PERL6LIB'));
            }
        }

        my $prefix := nqp::existskey($ENV,'RAKUDO_PREFIX')
          ?? nqp::atkey($ENV,'RAKUDO_PREFIX')
          !! nqp::concat(
               nqp::atkey(nqp::getcomp('perl6').config,'libdir'),
               '/perl6'
             );

        # XXX Various issues with this stuff on JVM , TEMPORARY
        try {
            if nqp::existskey($ENV,'HOME')
              ?? nqp::atkey($ENV,'HOME')
              !! nqp::concat(
                   (nqp::existskey($ENV,'HOMEDRIVE')
                     ?? nqp::atkey($ENV,'HOMEDRIVE') !! ''),
                   (nqp::existskey($ENV,'HOMEPATH')
                     ?? nqp::atkey($ENV,'HOMEPATH') !! '')
                 ) -> $home {
                my str $path = "inst#$home/.perl6";
                nqp::bindkey($custom-lib,'home',$path);
                nqp::push($raw-specs, $path) unless $precomp-specs;
            }
        }

        # set up custom libs
        my str $site = "inst#$prefix/site";
        nqp::bindkey($custom-lib,'site',$site);
        nqp::push($raw-specs, $site) unless $precomp-specs;

        my str $vendor = "inst#$prefix/vendor";
        nqp::bindkey($custom-lib,'vendor',$vendor);
        nqp::push($raw-specs, $vendor) unless $precomp-specs;

        my str $perl = "inst#$prefix";
        nqp::bindkey($custom-lib,'perl',$perl);
        nqp::push($raw-specs, $perl) unless $precomp-specs;

        # your basic repo chain
        my CompUnit::Repository $next-repo :=
            $precomp-specs
            ?? CompUnit::Repository
            !! CompUnit::Repository::AbsolutePath.new(
                :next-repo( CompUnit::Repository::NQP.new(
                    :next-repo(CompUnit::Repository::Perl5.new(



                    ))
                )
            )
        );

        my %repos;
        my $SPEC := $*SPEC;
        sub normalize(\spec){
            my $parts := nqp::split('#', spec);
            my $path := nqp::elems($parts) - 1;
            nqp::bindpos($parts, $path, nqp::unbox_s($SPEC.canonpath(nqp::atpos($parts, $path))));
            nqp::join('#', $parts)
        };

        # create reverted, unique list of path-specs
        my $iter   := nqp::iterator($raw-specs);
        my $unique := nqp::hash();
        my $specs  := nqp::list();
        while $iter {
            my str $path-spec = normalize(nqp::shift($iter));
            unless nqp::existskey($unique,$path-spec) {
                nqp::bindkey($unique,$path-spec,1);
                nqp::unshift($specs,$path-spec);
            }
        }

        # convert path-specs to repos
        $iter := nqp::iterator($specs);
        my $repos := nqp::hash();
        while $iter {
            my str $spec = nqp::shift($iter);
            $next-repo := self.use-repository(
              self.repository-for-spec($spec), :current($next-repo));
            nqp::bindkey($repos,$spec,$next-repo);
        }

        # convert custom-lib path-specs to repos
        $iter := nqp::iterator($custom-lib);
        while $iter {
            my \pair = nqp::shift($iter);
            my $repo := nqp::atkey($repos, normalize(nqp::iterval(pair)));
            if nqp::isnull($repo) {
                nqp::deletekey($custom-lib, nqp::iterkey_s(pair));
            }
            else {
                nqp::bindkey($custom-lib, nqp::iterkey_s(pair), $repo);
            }
        }

        $next-repo
    }

    method !remove-from-chain(CompUnit::Repository $repo, CompUnit::Repository :$current = $*REPO) {
        my $item = $current;
        while $item {
            if $item.next-repo === $repo {
                $item.next-repo = $repo.next-repo;
                last;
            }
            $item = $item.next-repo;
        }
    }

    method use-repository(CompUnit::Repository $repo, CompUnit::Repository :$current = $*REPO) {
        return $repo if $current === $repo;
        self!remove-from-chain($repo, :$current);
        $repo.next-repo = $current;
        PROCESS::<$REPO> := $repo;
    }

    method repository-for-name(Str:D \name) {
        $*REPO; # initialize if not yet done
        my str $name = nqp::unbox_s(name);
        nqp::existskey($custom-lib,$name)
          ?? nqp::atkey($custom-lib,$name)
          !! Nil
    }

    method register-name($name, CompUnit::Repository $repo) {
        nqp::bindkey($custom-lib, $name, $repo);
    }

    method name-for-repository(CompUnit::Repository $repo) {
        $*REPO; # initialize if not yet done
        my $iter := nqp::iterator($custom-lib);
        while $iter {
            my \pair = nqp::shift($iter);
            return nqp::iterkey_s(pair) if nqp::iterval(pair).prefix eq $repo.prefix;
        }
        Nil
    }

    method file-for-spec(Str $spec) {
        my @parts = $spec.split('#', 2);
        if @parts.elems == 2 {
            my $repo = self.repository-for-name(@parts[0]);
            return $repo.source-file(@parts[1]) if $repo.can('source-file');
        }
        Nil
    }

    method run-script($script, :$dist-name, :$name is copy, :$auth, :$ver) {
        shift @*ARGS if $name;
        shift @*ARGS if $auth;
        shift @*ARGS if $ver;
        $name //= $dist-name;
        my @installations = $*REPO.repo-chain.grep(CompUnit::Repository::Installation);
        my @binaries = @installations.map({ .script("bin/$script", :$name, :$auth, :$ver) }).grep(*.defined);
        unless +@binaries {
            @binaries = flat @installations.map: { .script("bin/$script", :$name) };
            if +@binaries {
                note "===SORRY!===\n"
                    ~ "No candidate found for '$script' that match your criteria.\n"
                    ~ "Did you perhaps mean one of these?";
                my %caps = :name(['Distribution', 12]), :auth(['Author(ity)', 11]), :ver(['Version', 7]);
                for @binaries -> $dist {
                    for %caps.kv -> $caption, @opts {
                        @opts[1] = max @opts[1], ($dist{$caption} // '').Str.chars
                    }
                }
                note '  ' ~ %caps.values.map({ sprintf('%-*s', .[1], .[0]) }).join(' | ');
                for @binaries -> $dist {
                    note '  ' ~ %caps.kv.map( -> $k, $v { sprintf('%-*s', $v.[1], $dist{$k} // '') } ).join(' | ')
                }
            }
            else {
                note "===SORRY!===\nNo candidate found for '$script'.\n";
            }
            exit 1;
        }

        my $bin = @binaries[0];
        require "$bin";
    }

    method head() { # mostly usefull for access from NQP
        $*REPO
    }

    method resolve-unknown-repos(@repos) {
        # Cannot just use GLOBAL.WHO here as that gives a BOOTHash
        my $global := nqp::list("GLOBAL");
        for @repos.pairs {
            if nqp::istype($_.value, CompUnit::Repository::Unknown) {
                my $i = $_.key;
                my $next-repo := @repos[$i + 1];

                my $head := PROCESS<$REPO>;
                PROCESS::<$REPO> := $next-repo;
                my $comp_unit = $next-repo.need(
                    CompUnit::DependencySpecification.new(:short-name($_.value.short-name))
                );
                PROCESS::<$REPO> := $head;

                $*W.find_symbol($global).WHO.merge-symbols($comp_unit.handle.globalish-package);
                my $new-repo = self.repository-for-spec($_.value.path-spec, :$next-repo);
                if $i > 0 {
                    @repos[$i - 1].next-repo = $new-repo if $i > 0;
                }
                else {
                    PROCESS::<$REPO> := $new-repo;
                }
            }
        }
    }

    # Handles any object repossession conflicts that occurred during module load,
    # or complains about any that cannot be resolved.
    method resolve_repossession_conflicts(@conflicts) {
        for @conflicts -> $orig is raw, $current is raw {
            # If it's a Stash in conflict, we make sure any original entries get
            # appropriately copied.
            if $orig.HOW.name($orig) eq 'Stash' {
                $current.merge-symbols($orig);
            }
            # We could complain about anything else, and may in the future; for
            # now, we let it pass by with "latest wins" semantics.
        }
    }

    sub short-id2class(Str:D $short-id) {
        state %short-id2class;
        state $lock = Lock.new;

        Proxy.new(
          FETCH => {
              $lock.protect( {
                  if %short-id2class.EXISTS-KEY($short-id) {
                      %short-id2class.AT-KEY($short-id);
                  }
                  else {
                      my $type = try ::($short-id);
                      if $type !=== Any {
                          if $type.?short-id -> $id {
                              if %short-id2class.EXISTS-KEY($id) {
                                  %short-id2class.AT-KEY($id);
                              }
                              else {
                                  %short-id2class.BIND-KEY($id, $type);
                              }
                          }
                          else {
                              die "Class '$type.^name()' is not a CompUnit::Repository";
                          }
                      }
                      else {
                          Any
                      }
                  }
              } );
          },
          STORE => -> $, $class {
              my $type = ::($class);
              die "Must load class '$class' first" if nqp::istype($type,Failure);
              $lock.protect( { %short-id2class{$short-id} := $type } );
          },
        );
    }

# prime the short-id -> class lookup
    short-id2class('file')  = 'CompUnit::Repository::FileSystem';
    short-id2class('inst')  = 'CompUnit::Repository::Installation';
    short-id2class('ap')    = 'CompUnit::Repository::AbsolutePath';
    short-id2class('nqp')   = 'CompUnit::Repository::NQP';
    short-id2class('perl5') = 'CompUnit::Repository::Perl5';





    sub parse-include-spec(Str:D $spec, Str:D $default-short-id = 'file') {
        # something we understand
        if $spec ~~ /^
          <before .>
          [
            $<type>=[ <.ident>+ % '::' ]
            [ '#' $<option-name>=\w+
              <[ < ( [ { ]> $<option-value>=<[\w-]>+? <[ > ) \] } ]>
            ]*
            '#'
          ]?
          $<path>=.*
        $/ {
            ( ~($<type> // $default-short-id), %($<option-name>>>.Str Z=> $<option-value>>>.Str), ~$<path> );
        }
    }

    sub parse-include-specS(Str:D $specs) {
        my @found;
        my $default-short-id = 'file';

        if $*RAKUDO_MODULE_DEBUG -> $RMD { $RMD("Parsing specs: $specs") }

        # for all possible specs
        for $specs.split(',') -> $spec {
            if parse-include-spec($spec.trim, $default-short-id) -> $triplet {
                @found.push: join "#",
                  $triplet[0],
                  $triplet[1].map({ .key ~ "<" ~ .value ~ ">" }),
                  $triplet[2];
                $default-short-id = $triplet[0];
            }
            elsif $spec {
                die "Don't know how to handle $spec";
            }
        }
        @found;
    }
}

#line 1 SETTING::src/core/CompUnit/Repository/Locally.pm
role CompUnit::Repository::Locally {
    has Lock     $!lock;
    has IO::Path $.prefix is required;
    has Str      $.WHICH;

    method new(CompUnit::Repository::Locally: Str:D :$prefix, CompUnit::Repository :$next-repo, *%args) {
        my $abspath := $*SPEC.rel2abs($prefix);
        my $IO      := $abspath.IO;

        state %instances;
        my $WHICH = self.^name ~ '|' ~ $abspath;
        %instances{$WHICH} //=
          self.bless(:prefix($IO), :lock(Lock.new), :$WHICH, :$next-repo, |%args);
    }

    multi method Str(CompUnit::Repository::Locally:D:) { $!prefix.absolute }
    multi method gist(CompUnit::Repository::Locally:D:) {
        self.path-spec
    }
    multi method perl(CompUnit::Repository::Locally:D:) {
        $?CLASS.perl ~ '.new(' ~ $!prefix.absolute.perl ~ ')';
    }

    multi method WHICH(CompUnit::Repository::Locally:D:) { $!WHICH }

    method path-spec(CompUnit::Repository::Locally:D:) {
        self.short-id ~ '#' ~ $!prefix.absolute;
    }

    method source-file(Str $name --> IO::Path:D) {
        self.prefix.add($name)
    }

    method prefix { "{$!prefix}".IO }

    method id() {
        my $name = self.path-spec;
        $name ~= ',' ~ self.next-repo.id if self.next-repo;
        return nqp::sha1($name);
    }

    # stubs
    method short-id(CompUnit::Repository::Locally:D:)                             {...}
}

#line 1 SETTING::src/core/CompUnit/Repository/FileSystem.pm
class CompUnit::Repository::FileSystem does CompUnit::Repository::Locally does CompUnit::Repository {
    has %!loaded;
    has $!precomp;
    has $!id;
    has %!meta;
    has $!precomp-stores;
    has $!precomp-store;

    my @extensions = <pm6 pm>;
    my $extensions := nqp::hash('pm6',1,'pm',1);

    # global cache of files seen
    my %seen;

    method !matching-file(CompUnit::DependencySpecification $spec) {
        if $spec.from eq 'Perl6' {
            my $name = $spec.short-name;
            return %!loaded{$name} if %!loaded{$name}:exists;

            my $base := $!prefix.add($name.subst(:g, "::", $*SPEC.dir-sep) ~ '.').Str;
            return $base if %seen{$base}:exists;
            my $found;

            # find source file
            # pick a META6.json if it is there
            if not %!meta and (my $meta = $!prefix.add('META6.json')) and $meta.f {
                try {
                    %!meta = Rakudo::Internals::JSON.from-json: $meta.slurp;
                    CATCH {
                        when JSONException {
                            fail "Invalid JSON found in META6.json";
                        }
                    }
                }
            }
            if %!meta {
                if %!meta<provides>{$name} -> $file {
                    my $path = $file.IO.is-absolute ?? $file.IO !! $!prefix.add($file);
                    $found = $path if $path.f;
                }
            }

            unless ?$found {
                # deduce path to compilation unit from package name
                for @extensions -> $extension {
                    my $path = ($base ~ $extension).IO;
                    $found = $path if $path.f;
                    last if $found;
                }
            }

            return $base, $found if $found;
        }
        False
    }

    method !comp-unit-id($name) {
        CompUnit::PrecompilationId.new(nqp::sha1($name));
    }

    method id() {
        my $parts := nqp::list_s;
        my $prefix = self.prefix;
        my $dir  := { .match(/ ^ <.ident> [ <[ ' - ]> <.ident> ]* $ /) }; # ' hl
        my $file := -> str $file {
            nqp::eqat($file,'.pm',nqp::sub_i(nqp::chars($file),3))
            || nqp::eqat($file,'.pm6',nqp::sub_i(nqp::chars($file),4))
        };
        nqp::if(
          $!id,
          $!id,
          ($!id = nqp::if(
            $prefix.e,
            nqp::stmts(
              (my $iter := Rakudo::Internals.DIR-RECURSE(
                $prefix.absolute,:$dir,:$file).iterator),
              nqp::until(
                nqp::eqaddr((my $pulled := $iter.pull-one),IterationEnd),
                nqp::if(
                  nqp::filereadable($pulled),
                  nqp::push_s($parts,nqp::sha1(slurp($pulled, :enc<iso-8859-1>))),
                )
              ),
              nqp::if(
                (my $next := self.next-repo),
                nqp::push_s($parts,$next.id),
              ),
              nqp::sha1(nqp::join('',$parts))
            ),
            nqp::sha1('')
          ))
        )
    }

    method resolve(CompUnit::DependencySpecification $spec --> CompUnit:D) {
        my ($base, $file) = self!matching-file($spec);

        return CompUnit.new(
            :short-name($spec.short-name),
            :repo-id(self!comp-unit-id($spec.short-name).Str),
            :repo(self)
        ) if $base;
        return self.next-repo.resolve($spec) if self.next-repo;
        Nil
    }

    method !precomp-stores() {
        $!precomp-stores //= Array[CompUnit::PrecompilationStore].new(
            self.repo-chain.map(*.precomp-store).grep(*.defined)
        )
    }

    method need(
        CompUnit::DependencySpecification $spec,
        CompUnit::PrecompilationRepository $precomp = self.precomp-repository(),
        CompUnit::PrecompilationStore :@precomp-stores = self!precomp-stores(),

        --> CompUnit:D)
    {
        my ($base, $file) = self!matching-file($spec);
        if $base {
            my $name = $spec.short-name;
            return %!loaded{$name} if %!loaded{$name}:exists;
            return %seen{$base}    if %seen{$base}:exists;

            my $id = self!comp-unit-id($name);
            my $*RESOURCES = Distribution::Resources.new(:repo(self), :dist-id(''));
            my $handle = $precomp.try-load(
                CompUnit::PrecompilationDependency::File.new(
                    :$id,
                    :src($file.Str),
                    :$spec,
                ),
                :@precomp-stores,
            );
            my $precompiled = defined $handle;
            $handle //= CompUnit::Loader.load-source-file($file); # precomp failed

            return %!loaded{$name} = %seen{$base} = CompUnit.new(
                :short-name($name),
                :$handle,
                :repo(self),
                :repo-id($id.Str),
                :$precompiled,
            );
        }

        return self.next-repo.need($spec, $precomp, :@precomp-stores) if self.next-repo;
        X::CompUnit::UnsatisfiedDependency.new(:specification($spec)).throw;
    }

    method load(IO::Path:D $file --> CompUnit:D) {
        unless $file.is-absolute {

            # We have a $file when we hit: require "PATH" or use/require Foo:file<PATH>;
            my $precompiled =
              $file.Str.ends-with(Rakudo::Internals.PRECOMP-EXT);
            my $path = $!prefix.add($file);

            if $path.f {
                return %!loaded{$file.Str} //= %seen{$path.Str} = CompUnit.new(
                    :handle(
                        $precompiled
                            ?? CompUnit::Loader.load-precompilation-file($path)
                            !! CompUnit::Loader.load-source-file($path)
                    ),
                    :short-name($file.Str),
                    :repo(self),
                    :repo-id($file.Str),
                    :$precompiled,
                );
            }
        }

        return self.next-repo.load($file) if self.next-repo;
        nqp::die("Could not find $file in:\n" ~ $*REPO.repo-chain.map(*.Str).join("\n").indent(4));
    }

    method short-id() { 'file' }

    method loaded(--> Iterable:D) {
        return %!loaded.values;
    }

    method files($file, :$name, :$auth, :$ver) {
        my $base := $file.IO;
        $base.f
         ?? { files => { $file => $base.path }, ver => Version.new('0') }
         !! ();
    }

    method resource($dist-id, $key) {
        # We now save the 'resources/' part of a resource's path in files, i.e:
        # "files" : [ "resources/libraries/xxx" => "resources/libraries/xxx.so" ]
        # but we also want to root any path request to the CUR's resources directory

        # When $.prefix points at a directory containing a meta file (eg. -I.)
        return $.prefix.add( %!meta<files>{$key} )
            if %!meta<files> && %!meta<files>{$key};
        return $.prefix.add( $key )
            if %!meta<resources> && %!meta<resources>.first({ $_ eq $key.subst(/^resources\//, "") });

        # When $.prefix is presumably the 'lib' folder (eg. -Ilib)
        return $.prefix.parent.add($key);
    }

    method precomp-store(--> CompUnit::PrecompilationStore:D) {
        $!precomp-store //= CompUnit::PrecompilationStore::File.new(
            :prefix(self.prefix.add('.precomp')),
        )
    }

    method precomp-repository(--> CompUnit::PrecompilationRepository:D) {
        $!precomp := CompUnit::PrecompilationRepository::Default.new(
            :store(self.precomp-store),
        ) unless $!precomp;
        $!precomp
    }
}

#line 1 SETTING::src/core/CompUnit/Repository/Installation.pm
class CompUnit::Repository::Installation does CompUnit::Repository::Locally does CompUnit::Repository::Installable {
    has $!cver = nqp::hllize(nqp::atkey(nqp::gethllsym('perl6', '$COMPILER_CONFIG'), 'version'));
    has %!loaded;
    has $!precomp;
    has $!id;
    has Int $!version;
    has %!dist-metas;
    has $!precomp-stores;
    has $!precomp-store;

    my $verbose := nqp::getenvhash<RAKUDO_LOG_PRECOMP>;

    submethod BUILD(:$!prefix, :$!lock, :$!WHICH, :$!next-repo --> Nil) { }

    my class InstalledDistribution is Distribution::Hash {
        method content($address) {
            my $entry = $.meta<provides>.values.first: { $_{$address}:exists };
            my $file = $entry
                ?? $.prefix.add('sources').add($entry{$address}<file>)
                !! $.prefix.add('resources').add($.meta<files>{$address});

            $file.open(:r)
        }
    }

    method writeable-path {
        $.prefix.w ?? $.prefix !! IO::Path;
    }

    method !writeable-path {
        self.can-install ?? $.prefix !! IO::Path;
    }

    method can-install() {
        $.prefix.w || ?(!$.prefix.e && try { $.prefix.mkdir } && $.prefix.e);
    }

    my $windows_wrapper = '@rem = \'--*-Perl-*--
@echo off
if "%OS%" == "Windows_NT" goto WinNT
#perl# "%~dpn0" %1 %2 %3 %4 %5 %6 %7 %8 %9
goto endofperl
:WinNT
#perl# "%~dpn0" %*
if NOT "%COMSPEC%" == "%SystemRoot%\system32\cmd.exe" goto endofperl
if %errorlevel% == 9009 echo You do not have Perl in your PATH.
if errorlevel 1 goto script_failed_so_exit_with_non_zero_val 2>nul
goto endofperl
@rem \';
__END__
:endofperl
';
    my $perl_wrapper = '#!/usr/bin/env #perl#
sub MAIN(:$name is copy, :$auth, :$ver, *@, *%) {
    CompUnit::RepositoryRegistry.run-script("#name#", :dist-name<#dist-name#>, :$name, :$auth, :$ver);
}';

    method !sources-dir() {
        my $sources = $.prefix.add('sources');
        $sources.mkdir unless $sources.e;
        $sources
    }

    method !resources-dir() {
        my $resources = $.prefix.add('resources');
        $resources.mkdir unless $resources.e;
        $resources
    }

    method !dist-dir() {
        my $dist = $.prefix.add('dist');
        $dist.mkdir unless $dist.e;
        $dist
    }

    method !bin-dir() {
        my $bin = $.prefix.add('bin');
        $bin.mkdir unless $bin.e;
        $bin
    }

    method !add-short-name($name, $dist, $source?, $checksum?) {
        my $short-dir = $.prefix.add('short');
        my $id = nqp::sha1($name);
        my $lookup = $short-dir.add($id);
        $lookup.mkdir;
        $lookup.add($dist.id).spurt(
                "{$dist.meta<ver>  // ''}\n"
            ~   "{$dist.meta<auth> // ''}\n"
            ~   "{$dist.meta<api>  // ''}\n"
            ~   "{$source // ''}\n"
            ~   "{$checksum // ''}\n"
        );
    }

    method !remove-dist-from-short-name-lookup-files($dist --> Nil) {
        my $short-dir = $.prefix.add('short');
        return unless $short-dir.e;

        my $id = $dist.id;

        for $short-dir.dir -> $dir {
            $dir.add($id).unlink;
            $dir.rmdir unless $dir.dir;
        }
    }

    method !file-id(Str $name, Str $dist-id) {
        my $id = $name ~ $dist-id;
        nqp::sha1($id)
    }

    method name(--> Str:D) {
        CompUnit::RepositoryRegistry.name-for-repository(self)
    }

    method !repo-prefix() {
        my $repo-prefix = self.name // '';
        $repo-prefix ~= '#' if $repo-prefix;
        $repo-prefix
    }

    method !read-dist($id) {
        my $dist = Rakudo::Internals::JSON.from-json($.prefix.add('dist').add($id).slurp);
        $dist<ver> = $dist<ver> ?? Version.new( ~$dist<ver> ) !! Version.new('0');
        $dist
    }

    method !repository-version(--> Int:D) {
        return $!version if defined $!version;
        my $version-file = $.prefix.add('version');
        return $!version = 0 unless $version-file ~~ :f;
        $!version = $version-file.slurp.Int
    }

    method upgrade-repository() {
        my $version = self!repository-version;
        my $short-dir = $.prefix.add('short');
        mkdir $short-dir unless $short-dir.e;
        my $precomp-dir = $.prefix.add('precomp');
        mkdir $precomp-dir unless $precomp-dir.e;
        self!sources-dir;
        my $resources-dir = self!resources-dir;
        my $dist-dir = self!dist-dir;
        self!bin-dir;
        if ($version < 1) {
            for $short-dir.dir -> $file {
                my @ids = $file.lines.unique;
                $file.unlink;
                $file.mkdir;
                for @ids -> $id {
                    my $dist = self!read-dist($id);
                    $file.add($id).spurt("{$dist<ver> // ''}\n{$dist<auth> // ''}\n{$dist<api> // ''}\n");
                }
            }
        }
        if ($version < 2) {
            for $dist-dir.dir -> $dist-file {
                my %meta = Rakudo::Internals::JSON.from-json($dist-file.slurp);
                my $files = %meta<files> //= [];
                for eager $files.keys -> $file {
                    $files{"resources/$file"} = $files{$file}:delete
                        if $resources-dir.add($files{$file}).e
                        and not $.prefix.add($file).e; # bin/ is already included in the path
                }
                $dist-file.spurt: Rakudo::Internals::JSON.to-json(%meta);
            }
        }
        $.prefix.add('version').spurt('2');
        $!version = 2;
    }

    proto method install(|) {*}
    multi method install($dist, %sources, %scripts?, %resources?, Bool :$force) {
        # XXX: Deprecation shim
        my %files;
        %files{"bin/$_.key()"} = $_.value for %scripts.pairs;
        %files{"resources/$_.key()"} = $_.value for %resources.pairs;
        my %meta6 = %(
            name     => $dist.?name,
            ver      => $dist.?ver // $dist.?version,
            auth     => $dist.?auth // $dist.?authority,
            provides => %sources,
            files    => %files,
        );

        return samewith(Distribution::Hash.new(%meta6, :prefix($*CWD)), :$force);
    }
    multi method install(Distribution $distribution, Bool :$force) {
        my $dist  = CompUnit::Repository::Distribution.new($distribution);
        my %files = $dist.meta<files>.grep(*.defined).map: -> $link {
            $link ~~ Str ?? ($link => $link) !! ($link.keys[0] => $link.values[0])
        }

        $!lock.protect( {
        my @*MODULES;
        my $path   = self!writeable-path or die "No writeable path found, $.prefix not writeable";
        my $lock = $.prefix.add('repo.lock').open(:create, :w);
        $lock.lock;

        my $version = self!repository-version;
        self.upgrade-repository unless $version == 2;

        my $dist-id = $dist.id;
        my $dist-dir = self!dist-dir;
        if not $force and $dist-dir.add($dist-id) ~~ :e {
            $lock.unlock;
            fail "$dist already installed";
        }

        my $sources-dir   = self!sources-dir;
        my $resources-dir = self!resources-dir;
        my $bin-dir       = self!bin-dir;
        my $is-win        = Rakudo::Internals.IS-WIN;

        self!add-short-name($dist.meta<name>, $dist); # so scripts can find their dist

        my %links; # map name-path to new content address
        my %provides; # meta data gets added, but the format needs to change to
                      # only extend the structure, not change it

        # the following 3 `for` loops should be a single loop, but has been
        # left this way due to impeding precomp changes

        # lib/ source files
        for $dist.meta<provides>.kv -> $name, $file is copy {
            # $name is "Inline::Perl5" while $file is "lib/Inline/Perl5.pm6"
            my $id          = self!file-id(~$name, $dist-id);
            my $destination = $sources-dir.add($id);
            my $handle      = $dist.content($file);
            my $content     = $handle.open(:bin).slurp(:close);

            self!add-short-name($name, $dist, $id,
              nqp::sha1(nqp::join("\n", nqp::split("\r\n",
                $content.decode('iso-8859-1')))));
            %provides{ $name } = ~$file => {
                :file($id),
                :time(try $file.IO.modified.Num),
                :$!cver
            };
            note("Installing {$name} for {$dist.meta<name>}") if $verbose and $name ne $dist.meta<name>;
            $destination.spurt($content);
        }

        # bin/ scripts
        for %files.kv -> $name-path, $file is copy {
            next unless $name-path.starts-with('bin/');
            my $id          = self!file-id(~$file, $dist-id);
            my $destination = $resources-dir.add($id); # wrappers are put in bin/; originals in resources/
            my $withoutext  = $name-path.subst(/\.[exe|bat]$/, '');
            for '', '-j', '-m' -> $be {
                $.prefix.add("$withoutext$be").IO.spurt:
                    $perl_wrapper.subst('#name#', $name-path.IO.basename, :g).subst('#perl#', "perl6$be").subst('#dist-name#', $dist.meta<name>);
                if $is-win {
                    $.prefix.add("$withoutext$be.bat").IO.spurt:
                        $windows_wrapper.subst('#perl#', "perl6$be", :g);
                }
                else {
                    $.prefix.add("$withoutext$be").IO.chmod(0o755);
                }
            }
            self!add-short-name($name-path, $dist, $id);
            %links{$name-path} = $id;
            my $handle  = $dist.content($file);
            my $content = $handle.open.slurp-rest(:bin,:close);
            $destination.spurt($content);
            $handle.close;
        }

        # resources/
        for %files.kv -> $name-path, $file is copy {
            next unless $name-path.starts-with('resources/');
            # $name-path is 'resources/libraries/p5helper' while $file is 'resources/libraries/libp5helper.so'
            my $id             = self!file-id(~$name-path, $dist-id) ~ '.' ~ $file.IO.extension;
            my $destination    = $resources-dir.add($id);
            %links{$name-path} = $id;
            my $handle  = $dist.content($file);
            my $content = $handle.open.slurp-rest(:bin,:close);
            $destination.spurt($content);
            $handle.close;
        }

        my %meta = %($dist.meta);
        %meta<files>    = %links;    # add our new name-path => conent-id mapping
        %meta<provides> = %provides; # new meta data added to provides
        %!dist-metas{$dist-id} = %meta;
        $dist-dir.add($dist-id).spurt: Rakudo::Internals::JSON.to-json(%meta);

        # reset cached id so it's generated again on next access.
        # identity changes with every installation of a dist.
        $!id = Any;

        {
            my $head = $*REPO;
            PROCESS::<$REPO> := self; # Precomp files should only depend on downstream repos
            my $precomp = $*REPO.precomp-repository;
            my $repo-prefix = self!repo-prefix;
            my $*RESOURCES = Distribution::Resources.new(:repo(self), :$dist-id);
            my %done;

            my $compiler-id = CompUnit::PrecompilationId.new($*PERL.compiler.id);
            for %provides.kv -> $source-name, $source-meta {
                my $id = CompUnit::PrecompilationId.new($source-meta.values[0]<file>);
                $precomp.store.delete($compiler-id, $id);
            }

            for %provides.kv -> $source-name, $source-meta {
                my $id = $source-meta.values[0]<file>;
                my $source = $sources-dir.add($id);
                my $source-file = $repo-prefix ?? $repo-prefix ~ $source.relative($.prefix) !! $source;

                if %done{$id} {
                    note "(Already did $id)" if $verbose;
                    next;
                }
                note("Precompiling $id ($source-name)") if $verbose;
                $precomp.precompile(
                    $source,
                    CompUnit::PrecompilationId.new($id),
                    :source-name("$source-file ($source-name)"),
                );
                %done{$id} = 1;
            }
            PROCESS::<$REPO> := $head;
        }

        $lock.unlock;
    } ) }

    method uninstall(Distribution $distribution) {
        my $repo-version = self!repository-version;
        self.upgrade-repository unless $repo-version == 2;

        # xxx: currently needs to be passed in a distribution object that
        # has meta<files> pointing at content-ids, so you cannot yet just
        # pass in the original meta data and have it discovered and deleted
        # (i.e. update resolve to return such a ::Installation::Distribution)
        my $dist  = CompUnit::Repository::Distribution.new($distribution);
        my %provides      = $dist.meta<provides>;
        my %files         = $dist.meta<files>;
        my $sources-dir   = self.prefix.add('sources');
        my $resources-dir = self.prefix.add('resources');
        my $bin-dir       = self.prefix.add('bin');
        my $dist-dir      = self.prefix.add('dist');

        self!remove-dist-from-short-name-lookup-files($dist);
        my sub unlink-if-exists($path) { unlink($path) if $path.IO.e }

        # delete special directory files
        for %files.kv -> $name-path, $file {
            given $name-path {
                when /^bin\/(.*)/ {
                    # wrappers are located in $bin-dir (only delete if no other versions use wrapper)
                    unless self.files($name-path, :name($dist.meta<name>)).elems {
                        unlink-if-exists( $bin-dir.add("$0$_") ) for '', '-m', '-j';
                    }

                    # original bin scripts are in $resources-dir
                    unlink-if-exists( $resources-dir.add($file) )
                }
                when /^resources\// {
                    unlink-if-exists( $resources-dir.add($file) )
                }
            }
        }

        # delete sources
        unlink-if-exists( $sources-dir.add($_) ) for %provides.values.flatmap(*.values.map(*.<file>));

        # delete the meta file
        unlink( $dist-dir.add($dist.id) )
    }

    method script($file, :$name!, :$auth, :$ver) {
        my $prefix = self.prefix;
        my $lookup = $prefix.add('short').add(nqp::sha1($file));
        return unless $lookup.e;

        # Scripts using this interface could only have been installed long after the introduction of
        # repo version 1, so we don't have to care about very old repos in this method.
        my @dists = $lookup.dir.map({
                my ($ver, $auth, $api, $resource-id) = $_.slurp.split("\n");
                $resource-id ||= self!read-dist($_.basename)<files>{$file};
                (id => $_.basename, ver => Version.new( $ver || 0 ), :$auth, :$api, :$resource-id).hash
            }).grep({
                $_.<auth> ~~ $auth
                and $_.<ver> ~~ $ver
            });
        for @dists.sort(*.<ver>).reverse {
            return self!resources-dir.add($_<resource-id>);
        }
    }

    method files($file, :$name!, :$auth, :$ver) {
        my @candi;
        my $prefix = self.prefix;
        my $lookup = $prefix.add('short').add(nqp::sha1($name));
        if $lookup.e {
            my $repo-version = self!repository-version;
            my @dists = $repo-version < 1
                ?? $lookup.lines.unique.map({
                        self!read-dist($_)
                    })
                !! $lookup.dir.map({
                        my ($ver, $auth, $api) = $_.slurp.split("\n");
                        (id => $_.basename, ver => Version.new( $ver || 0 ), auth => $auth, api => $api).hash
                    });
            for @dists.grep({$_<auth> ~~ $auth and $_<ver> ~~ $ver}) -> $dist is copy {
                $dist = self!read-dist($dist<id>) if $repo-version >= 1;
                with $dist<files>{$file} {
                    my $candi = %$dist;
                    $candi<files>{$file} = self!resources-dir.add($candi<files>{$file});
                    @candi.push: $candi;
                }
            }
        }
        @candi
    }

    method !matching-dist(CompUnit::DependencySpecification $spec) {
        if $spec.from eq 'Perl6' {
            my $repo-version = self!repository-version;
            my $lookup = $.prefix.add('short').add(nqp::sha1($spec.short-name));
            if $lookup.e {
                my @dists = (
                        $repo-version < 1
                        ?? $lookup.lines.unique.map({
                                $_ => self!read-dist($_)
                            })
                        !! $lookup.dir.map({
                                my ($ver, $auth, $api, $source, $checksum) = $_.slurp.split("\n");
                                $_.basename => {
                                    ver      => Version.new( $ver || 0 ),
                                    auth     => $auth,
                                    api      => $api,
                                    source   => $source || Any,
                                    checksum => $checksum || Str,
                                }
                            })
                    ).grep({
                        $_.value<auth> ~~ $spec.auth-matcher
                        and $_.value<ver> ~~ (($spec.version-matcher ~~ Bool)
                            ?? $spec.version-matcher # fast path for matching Version.new(*)
                            !! Version.new($spec.version-matcher))
                    });
                for @dists.sort(*.value<ver>).reverse.map(*.kv) -> ($dist-id, $dist) {
                    return ($dist-id, $dist);
                }
            }
        }
        Nil
    }

    method !lazy-distribution($dist-id) {
        class :: does Distribution::Locally {
            has $.dist-id;
            has $.read-dist;
            has $!installed-dist;
            method !dist {
                $!installed-dist //= InstalledDistribution.new($.read-dist()(), :$.prefix)
            }
            method meta(--> Hash:D)                      { self!dist.meta }
            method content($content-id --> IO::Handle:D) { self!dist.content($content-id) }
            method Str()                               { self!dist.Str }
        }.new(
            :$dist-id,
            :read-dist(-> { self!read-dist($dist-id) })
            :$.prefix,
        )
    }

    method resolve(
        CompUnit::DependencySpecification $spec,
        --> CompUnit:D)
    {
        my ($dist-id, $dist) = self!matching-dist($spec);
        if $dist-id {
            # xxx: replace :distribution with meta6
            return CompUnit.new(
                :handle(CompUnit::Handle),
                :short-name($spec.short-name),
                :version($dist<ver>),
                :auth($dist<auth> // Str),
                :repo(self),
                :repo-id($dist<source> // self!read-dist($dist-id)<provides>{$spec.short-name}.values[0]<file>),
                :distribution(self!lazy-distribution($dist-id)),
            );
        }
        return self.next-repo.resolve($spec) if self.next-repo;
        Nil
    }

    method !precomp-stores() {
        $!precomp-stores //= Array[CompUnit::PrecompilationStore].new(
            self.repo-chain.map(*.precomp-store).grep(*.defined)
        )
    }

    method need(
        CompUnit::DependencySpecification $spec,
        CompUnit::PrecompilationRepository $precomp = self.precomp-repository(),
        CompUnit::PrecompilationStore :@precomp-stores = self!precomp-stores(),
        --> CompUnit:D)
    {
        my ($dist-id, $dist) = self!matching-dist($spec);
        if $dist-id {
            return %!loaded{~$spec} if %!loaded{~$spec}:exists;
            my $source-file-name = $dist<source>
                // do {
                    my $provides = self!read-dist($dist-id)<provides>;
                    X::CompUnit::UnsatisfiedDependency.new(:specification($spec)).throw
                        unless $provides{$spec.short-name}:exists;
                    $provides{$spec.short-name}.values[0]<file>
                };
            my $loader = $.prefix.add('sources').add($source-file-name);
            my $*RESOURCES = Distribution::Resources.new(:repo(self), :$dist-id);
            my $id = $loader.basename;
            my $repo-prefix = self!repo-prefix;
            my $handle = $precomp.try-load(
                CompUnit::PrecompilationDependency::File.new(
                    :id(CompUnit::PrecompilationId.new($id)),
                    :src($repo-prefix ?? $repo-prefix ~ $loader.relative($.prefix) !! $loader.absolute),
                    :checksum($dist<checksum>:exists ?? $dist<checksum> !! Str),
                    :$spec,
                ),
                :source($loader),
                :@precomp-stores,
            );
            my $precompiled = defined $handle;
            $handle //= CompUnit::Loader.load-source-file($loader);

            # xxx: replace :distribution with meta6
            my $compunit = CompUnit.new(
                :$handle,
                :short-name($spec.short-name),
                :version($dist<ver>),
                :auth($dist<auth> // Str),
                :repo(self),
                :repo-id($id),
                :$precompiled,
                :distribution(self!lazy-distribution($dist-id)),
            );
            return %!loaded{~$spec} = $compunit;
        }
        return self.next-repo.need($spec, $precomp, :@precomp-stores) if self.next-repo;
        X::CompUnit::UnsatisfiedDependency.new(:specification($spec)).throw;
    }

    method resource($dist-id, $key) {
        my $dist = %!dist-metas{$dist-id} //= Rakudo::Internals::JSON.from-json(self!dist-dir.add($dist-id).slurp);
        # need to strip the leading resources/ on old repositories
        self!resources-dir.add($dist<files>{$key.substr(self!repository-version < 2 ?? 10 !! 0)})
    }

    method id() {
        return $!id if $!id;
        my $name = self.path-spec;
        $name ~= ',' ~ self.next-repo.id if self.next-repo;
        my $dist-dir = $.prefix.add('dist');
        $!id = nqp::sha1(nqp::sha1($name) ~ ($dist-dir.e ?? $dist-dir.dir !! ''))
    }

    method short-id() { 'inst' }

    method loaded(--> Iterable:D) {
        return %!loaded.values;
    }

    method distribution($id) {
        InstalledDistribution.new(self!read-dist($id), :prefix(self.prefix))
    }

    method installed(--> Iterable:D) {
        my $dist-dir = self.prefix.add('dist');
        $dist-dir.e
            ?? $dist-dir.dir.map({ self.distribution($_.basename) })
            !! Nil
    }

    method precomp-store(--> CompUnit::PrecompilationStore:D) {
        $!precomp-store //= CompUnit::PrecompilationStore::File.new(
            :prefix(self.prefix.add('precomp')),
        )
    }

    method precomp-repository(--> CompUnit::PrecompilationRepository:D) {
        $!precomp := CompUnit::PrecompilationRepository::Default.new(
            :store(self.precomp-store),
        ) unless $!precomp;
        $!precomp
    }

    sub provides-warning($is-win, $name --> Nil) {
        my ($red,$clear) = Rakudo::Internals.error-rcgye;

        note "$red==={$clear}WARNING!$red===$clear
The distribution $name does not seem to have a \"provides\" section in its META.info file,
and so the packages will not be installed in the correct location.
Please ask the author to add a \"provides\" section, mapping every exposed namespace to a
file location in the distribution.
See http://design.perl6.org/S22.html#provides for more information.\n";
    }
}

#line 1 SETTING::src/core/CompUnit/Repository/AbsolutePath.pm
class CompUnit::Repository::AbsolutePath does CompUnit::Repository {
    has %!loaded;

    method need(CompUnit::DependencySpecification $spec,
                CompUnit::PrecompilationRepository $precomp = self.precomp-repository()
        --> CompUnit:D)
    {
        return self.next-repo.need($spec, $precomp) if self.next-repo;
        X::CompUnit::UnsatisfiedDependency.new(:specification($spec)).throw;
    }

    method load(IO::Path:D $file --> CompUnit:D) {
        if $file.is-absolute {

            # We have a $file when we hit: require "PATH" or use/require Foo:file<PATH>;
            my $precompiled =
              $file.Str.ends-with(Rakudo::Internals.PRECOMP-EXT);

            if $file.f {
                return %!loaded{$file} = CompUnit.new(
                    :handle(
                        $precompiled
                            ?? CompUnit::Loader.load-precompilation-file($file)
                            !! CompUnit::Loader.load-source-file($file)
                    ),
                    :short-name($file.Str),
                    :repo(self),
                    :repo-id($file.Str),
                    :$precompiled,
                );
            }
        }

        return self.next-repo.load($file) if self.next-repo;
        die("Could not find $file in:\n" ~ $*REPO.repo-chain.map(*.Str).join("\n").indent(4));
    }

    method loaded(--> Iterable:D) {
        return %!loaded.values;
    }

    method id() {
        'ap'
    }

    method path-spec() {
        'ap#'
    }
}

#line 1 SETTING::src/core/CompUnit/Repository/NQP.pm
class CompUnit::Repository::NQP does CompUnit::Repository {
    method need(
        CompUnit::DependencySpecification $spec,
        CompUnit::PrecompilationRepository $precomp = self.precomp-repository(),
        --> CompUnit:D)
    {
        if $spec.from eq 'NQP' {
            my $nqp := nqp::gethllsym('perl6', 'ModuleLoader');

            return CompUnit.new(
                :short-name($spec.short-name),
                :handle(CompUnit::Handle.new($nqp.load_module($spec.short-name, {:from<NQP>}))),
                :repo(self),
                :repo-id($spec.short-name),
                :from($spec.from),
            );
        }

        return self.next-repo.need($spec, $precomp) if self.next-repo;
        X::CompUnit::UnsatisfiedDependency.new(:specification($spec)).throw;
    }

    method loaded() {
        []
    }

    method id() {
        'NQP'
    }

    method path-spec() {
        'nqp#'
    }
}

#line 1 SETTING::src/core/CompUnit/Repository/Perl5.pm
class CompUnit::Repository::Perl5 does CompUnit::Repository {
    method need(
        CompUnit::DependencySpecification $spec,
        CompUnit::PrecompilationRepository $precomp = self.precomp-repository(),
        --> CompUnit:D)
    {
        if $spec.from eq 'Perl5' {
            require Inline::Perl5;
            my $perl5 = ::('Inline::Perl5').default_perl5;

            if $*RAKUDO_MODULE_DEBUG -> $RMD {
                $RMD("Loading {$spec.short-name} via Inline::Perl5");
            }
            my $handle := $perl5.require(
                $spec.short-name,
                $spec.version-matcher !== True ?? $spec.version-matcher.Num !! Num,
                :handle
            );
            return CompUnit.new(
                :short-name($spec.short-name),
                :$handle,
                :repo(self),
                :repo-id($spec.short-name),
                :from($spec.from),
            );

            CATCH {
                when X::CompUnit::UnsatisfiedDependency {
                    X::NYI::Available.new(:available('Inline::Perl5'), :feature('Perl 5')).throw;
                }
            }
        }

        return self.next-repo.need($spec, $precomp) if self.next-repo;
        X::CompUnit::UnsatisfiedDependency.new(:specification($spec)).throw;
    }

    method loaded() {
        []
    }

    method id() {
        'Perl5'
    }

    method path-spec() {
        'perl5#'
    }
}

#line 1 SETTING::src/core/CompUnit/Repository/Unknown.pm
class CompUnit::Repository::Unknown does CompUnit::Repository {
    has $.path-spec;
    has $.short-name;

    method need(
        CompUnit::DependencySpecification $spec,
        CompUnit::PrecompilationRepository $precomp?,
        CompUnit::PrecompilationStore :@precomp-stores = Array[CompUnit::PrecompilationStore].new(
            self.repo-chain.map(*.precomp-store).grep(*.defined)
        ),
        --> CompUnit:D)
    {
        return $precomp
            ?? self.next-repo.need($spec, $precomp, :@precomp-stores)
            !! self.next-repo.need($spec, :@precomp-stores)
            if self.next-repo;
        X::CompUnit::UnsatisfiedDependency.new(:specification($spec)).throw;
    }

    method loaded() {
        []
    }

    method id() {
        $.path-spec
    }

    method Str() { self.^name ~ " $.short-name $.path-spec" }
}

#line 1 SETTING::src/core/Argfiles.pm
Rakudo::Internals.REGISTER-DYNAMIC: '@*ARGS', {
    my @ARGS;
    my Mu $argiter := nqp::getcurhllsym('$!ARGITER');
    @ARGS.push(nqp::p6box_s(nqp::shift($argiter))) while $argiter;
    PROCESS::<@ARGS> := @ARGS;
}
Rakudo::Internals.REGISTER-DYNAMIC: '$*ARGFILES', {
    # Here, we use $*IN's attributes to init the arg files because
    # the $*ARGFILES won't get instantiated until first access and by that
    # time the user may have already modified $*IN's attributes to their liking
    PROCESS::<$ARGFILES> = @*ARGS
      ?? IO::ArgFiles.new(@*ARGS)
      !! IO::ArgFiles.new:
          (my $in := $*IN),
          :nl-in($in.nl-in), :chomp($in.chomp), :encoding($in.encoding),
          :bin(nqp::p6bool(nqp::isfalse($in.encoding)));
}

#line 1 SETTING::src/core/Process.pm
Rakudo::Internals.REGISTER-DYNAMIC: '$*RAKUDO_MODULE_DEBUG', {
    PROCESS::<$RAKUDO_MODULE_DEBUG> := ?%*ENV<RAKUDO_MODULE_DEBUG>
      ?? -> *@str --> Nil {
            state $level = %*ENV<RAKUDO_MODULE_DEBUG>++;
            my $indent = (($level - 1) * 4) + 1;
            my $str = @str>>.indent(7 + $indent).join("\n").substr(7 + $indent);
            note sprintf "%2d%sRMD: $str", $level, " " x $indent;
         }
      !! False
}

Rakudo::Internals.REGISTER-DYNAMIC: '$*PID', {
    PROCESS::<$PID> := nqp::p6box_i(nqp::getpid());
}

Rakudo::Internals.REGISTER-DYNAMIC: '$*EXECUTABLE', {
    PROCESS::<$EXECUTABLE> := (





      nqp::execname()
      || ($*VM.config<prefix> ~ '/bin/'
        ~ ($*VM.config<osname> eq 'MSWin32' ?? 'perl6-m.bat' !! 'perl6-m'))

    ).IO;
}

Rakudo::Internals.REGISTER-DYNAMIC: '$*EXECUTABLE-NAME', {
    PROCESS::<$EXECUTABLE-NAME> := $*EXECUTABLE.basename;
}

Rakudo::Internals.REGISTER-DYNAMIC: '$*PROGRAM-NAME', {
    PROCESS::<$PROGRAM-NAME> := nqp::getcomp('perl6').user-progname;
}

Rakudo::Internals.REGISTER-DYNAMIC: '$*PROGRAM', {
    PROCESS::<$PROGRAM> := IO::Path.new($*PROGRAM-NAME);
}

Rakudo::Internals.REGISTER-DYNAMIC: '$*TMPDIR', {
    PROCESS::<$TMPDIR> = $*SPEC.tmpdir;
}

Rakudo::Internals.REGISTER-DYNAMIC: '$*TOLERANCE', {
    PROCESS::<$TOLERANCE> := item 1e-15;
}

Rakudo::Internals.REGISTER-DYNAMIC: '$*REPO', {
    my $repo := PROCESS::<$REPO> := CompUnit::RepositoryRegistry.setup-repositories;
    my $world := $*W;
    $world.suspend_recording_precompilation_dependencies if $world;
    CompUnit::RepositoryRegistry.resolve-unknown-repos($repo.repo-chain);
    $world.resume_recording_precompilation_dependencies if $world;
    PROCESS::<$REPO>
}

Rakudo::Internals.REGISTER-DYNAMIC: '$*HOME', {
    my $HOME is default(Nil);

    if %*ENV<HOME> -> $home {
        $HOME = $home;
    }
    elsif Rakudo::Internals.IS-WIN {
        my $env := %*ENV;
        $env<HOMEDRIVE> && $env<HOMEPATH> && ($HOME
          = nqp::concat($env<HOMEDRIVE>, $env<HOMEPATH>));
    }

    $HOME = IO::Path.new($HOME) if $HOME;
    PROCESS::<$HOME> := $HOME # bind container so Nil default is kept
}

{
    sub fetch($what) {
        once if !Rakudo::Internals.IS-WIN && try { qx/id/ } -> $id {
            if $id ~~ m/^
              [ uid "=" $<uid>=(\d+) ]
              [ "(" $<user>=(<-[ ) ]>+) ")" ]
              \s+
              [ gid "=" $<gid>=(\d+) ]
              [ "(" $<group>=(<-[ ) ]>+) ")" ]
            / {
                PROCESS::<$USER>  := IntStr.new(+$<uid>,~$<user>);
                PROCESS::<$GROUP> := IntStr.new(+$<gid>,~$<group>);
            }

            # alas, no support yet
            else {
                PROCESS::<$USER>  := Nil;
                PROCESS::<$GROUP> := Nil;
            }
        }
        PROCESS::{$what}
    }

    Rakudo::Internals.REGISTER-DYNAMIC: '$*USER',  { fetch('$USER') };
    Rakudo::Internals.REGISTER-DYNAMIC: '$*GROUP', { fetch('$GROUP') };
}

#line 1 SETTING::src/core/Slang.pm
class Slang {
    has $.grammar;
    has $.actions;
    multi method gist(Slang:D:) {
        # Handle NQP objects like Perl6::Grammar
        'Slang.new('
            ~ (':grammar(' ~ $!grammar.^name ~ ')',
               ':actions(' ~ $!actions.^name ~ ')').join(', ')
            ~ ')'
    }
    method parse (|c) {
        $!grammar.parse(:$!actions, |c);
    }
}

#line 1 SETTING::src/core/Metamodel/Primitives.pm
my class Metamodel::Primitives {
    method create_type(Mu $how, $repr = 'P6opaque') {
        nqp::newtype($how, $repr.Str)
    }

    method set_package(Mu $type, $package) {
        nqp::setwho(nqp::decont($type), nqp::decont($package));
        $type
    }

    method install_method_cache(Mu $type, %cache, :$authoritative = True) {
        my Mu $cache := nqp::hash();
        for %cache.kv -> $name, $meth {
            nqp::bindkey($cache, $name, nqp::decont($meth));
        }
        nqp::setmethcache($type, $cache);
        nqp::setmethcacheauth($type, $authoritative ?? 1 !! 0);
        $type
    }

    method configure_type_checking(Mu $type, @cache, :$authoritative = True, :$call_accepts = False) {
        my Mu $cache := nqp::list();
        for @cache {
            nqp::push($cache, nqp::decont($_));
        }
        nqp::settypecache($type, $cache);
        nqp::settypecheckmode($type,
            ($authoritative ?? 0 !! 1) + ($call_accepts ?? 2 !! 0));
        $type
    }

    method configure_destroy(Mu $type, $destroy) {
        nqp::settypefinalize($type, $destroy ?? 1 !! 0);
        $type
    }

    method compose_type(Mu $type, $configuration) {
        multi sub to_vm_types(@array) {
            my Mu $list := nqp::list();
            for @array {
                nqp::push($list, to_vm_types($_));
            }
            $list
        }
        multi sub to_vm_types(%hash) {
            my Mu $hash := nqp::hash();
            for %hash.kv -> $k, $v {
                nqp::bindkey($hash, $k, to_vm_types($v));
            }
            $hash
        }
        multi sub to_vm_types($other) {
            nqp::decont($other)
        }
        nqp::composetype(nqp::decont($type), to_vm_types($configuration));
        $type
    }

    method rebless(Mu $obj, Mu $type) {
        nqp::rebless($obj, $type)
    }

    method is_type(Mu \obj, Mu \type) {
        nqp::p6bool(nqp::istype(obj, type))
    }
}

#line 1 SETTING::src/core/REPL.pm
class REPL { ... }

do {
    my sub sorted-set-insert(@values, $value) {
        my $low        = 0;
        my $high       = @values.end;
        my $insert_pos = 0;

        while $low <= $high {
            my $middle = floor($low + ($high - $low) / 2);

            my $middle_elem = @values[$middle];

            if $middle == @values.end {
                if $value eq $middle_elem {
                    return;
                } elsif $value lt $middle_elem {
                    $high = $middle - 1;
                } else {
                    $insert_pos = +@values;
                    last;
                }
            } else {
                my $middle_plus_one_elem = @values[$middle + 1];

                if $value eq $middle_elem || $value eq $middle_plus_one_elem {
                    return;
                } elsif $value lt $middle_elem {
                    $high = $middle - 1;
                } elsif $value gt $middle_plus_one_elem {
                    $low = $middle + 1;
                } else {
                    $insert_pos = $middle + 1;
                    last;
                }
            }
        }

        splice(@values, $insert_pos, 0, $value);
    }

    my role ReadlineBehavior[$WHO] {
        my &readline    = $WHO<&readline>;
        my &add_history = $WHO<&add_history>;
        my $Readline = try { require Readline }
        my $read = $Readline.new;
        if ! $*DISTRO.is-win {
            $read.read-init-file("/etc/inputrc");
            $read.read-init-file("~/.inputrc");
        }
        method init-line-editor {
            $read.read-history($.history-file);
        }
        method repl-read(Mu \prompt) {
            my $line = $read.readline(prompt);

            if $line.defined {
                $read.add-history($line);
                $read.append-history(1, $.history-file);
            }

            $line
        }
    }

    my role LinenoiseBehavior[$WHO] {
        my &linenoise                      = $WHO<&linenoise>;
        my &linenoiseHistoryAdd            = $WHO<&linenoiseHistoryAdd>;
        my &linenoiseSetCompletionCallback = $WHO<&linenoiseSetCompletionCallback>;
        my &linenoiseAddCompletion         = $WHO<&linenoiseAddCompletion>;
        my &linenoiseHistoryLoad           = $WHO<&linenoiseHistoryLoad>;
        my &linenoiseHistorySave           = $WHO<&linenoiseHistorySave>;

        method completions-for-line(Str $line, int $cursor-index) { ... }

        method history-file(--> Str:D) { ... }

        method init-line-editor {
            linenoiseSetCompletionCallback(sub ($line, $c) {
                eager self.completions-for-line($line, $line.chars).map(&linenoiseAddCompletion.assuming($c));
            });
            linenoiseHistoryLoad($.history-file);
        }

        method teardown-line-editor {
            my $err = linenoiseHistorySave($.history-file);
            return if !$err;
            note "Couldn't save your history to $.history-file";
        }

        method repl-read(Mu \prompt) {
            self.update-completions;
            my $line = linenoise(prompt);

            if $line.defined {
                linenoiseHistoryAdd($line);
            }

            $line
        }
    }

    my role FallbackBehavior {
        method repl-read(Mu \prompt) {
            print prompt;
            get
        }
    }

    my role Completions {
        # RT #129092: jvm can't do CORE::.keys
        has @!completions = $*VM.name eq 'jvm'
            ?? ()
            !! CORE::.keys.flatmap({
                    /^ "&"? $<word>=[\w* <.lower> \w*] $/ ?? ~$<word> !! []
                }).sort;

        method update-completions(--> Nil) {
            my $context := self.compiler.context;

            return unless $context;

            my $pad := nqp::ctxlexpad($context);
            my $it := nqp::iterator($pad);

            while $it {
                my $k := nqp::iterkey_s(nqp::shift($it));
                my $m = $k ~~ /^ "&"? $<word>=[\w* <.lower> \w*] $/;
                next if !$m;
                my $word = ~$m<word>;
                sorted-set-insert(@!completions, $word);
            }

            my $PACKAGE = self.compiler.eval('$?PACKAGE', :outer_ctx($context));

            for $PACKAGE.WHO.keys -> $k {
                sorted-set-insert(@!completions, $k);
            }
        }

        method extract-last-word(Str $line) {
            my $m = $line ~~ /^ $<prefix>=[.*?] <|w>$<last_word>=[\w*]$/;

            return ( $line, '') unless $m;

            ( ~$m<prefix>, ~$m<last_word> )
        }

        method completions-for-line(Str $line, int $cursor-index) {
            return @!completions unless $line;

            # ignore $cursor-index until we have a backend that provides it
            my ( $prefix, $word-at-cursor ) = self.extract-last-word($line);

            # XXX this could be more efficient if we had a smarter starting index
            gather for @!completions -> $word {
                if $word ~~ /^ "$word-at-cursor" / {
                    take $prefix ~ $word;
                }
            }
        }
    }

    class REPL {
        also does Completions;

        has Mu $.compiler;
        has Bool $!multi-line-enabled;
        has IO::Path $!history-file;

        has $!save_ctx;

        # Unique internal values for out-of-band eval results
        has $!need-more-input = {};
        has $!control-not-allowed = {};

        sub do-mixin($self, Str $module-name, $behavior, Str :$fallback) {
            my Bool $problem = False;
            try {
                CATCH {
                    when X::CompUnit::UnsatisfiedDependency & { .specification ~~ /"$module-name"/ } {
                        # ignore it
                    }
                    default {
                        say "I ran into a problem while trying to set up $module-name: $_";
                        if $fallback {
                            say "Falling back to $fallback (if present)";
                        }
                        $problem = True;
                    }
                }

                my $module = do require ::($module-name);
                my $new-self = $self but $behavior.^parameterize($module.WHO<EXPORT>.WHO<ALL>.WHO);
                $new-self.?init-line-editor();
                return ( $new-self, False );
            }

            ( Any, $problem )
        }

        sub mixin-readline($self, |c) {
            do-mixin($self, 'Readline', ReadlineBehavior, |c)
        }

        sub mixin-linenoise($self, |c) {
            do-mixin($self, 'Linenoise', LinenoiseBehavior, |c)
        }

        sub mixin-line-editor($self) {
            my %editor-to-mixin = (
                :Linenoise(&mixin-linenoise),
                :Readline(&mixin-readline),
                :none(-> $self { ( $self but FallbackBehavior, False ) }),
            );

            if %*ENV<RAKUDO_LINE_EDITOR> -> $line-editor {
                if !%editor-to-mixin{$line-editor} {
                    say "Unrecognized line editor '$line-editor'";
                    return $self but FallbackBehavior;
                }

                my $mixin = %editor-to-mixin{$line-editor};
                my ( $new-self, $problem ) = $mixin($self);
                return $new-self if $new-self;

                say "Could not find $line-editor module" unless $problem;
                return $self but FallbackBehavior;
            }

            my ( $new-self, $problem ) = mixin-readline($self, :fallback<Linenoise>);
            return $new-self if $new-self;

            ( $new-self, $problem ) = mixin-linenoise($self);
            return $new-self if $new-self;

            if $problem {
                say 'Continuing without tab completions or line editor';
                say 'You may want to consider using rlwrap for simple line editor functionality';
            }
            elsif !$*DISTRO.is-win and !( %*ENV<_>:exists and %*ENV<_>.ends-with: 'rlwrap' ) {
                say 'You may want to `zef install Readline` or `zef install Linenoise` or use rlwrap for a line editor';
            }
            say '';

            $self but FallbackBehavior
        }

        method new(Mu \compiler, Mu \adverbs) {
            my $multi-line-enabled = !%*ENV<RAKUDO_DISABLE_MULTILINE>;
            my $self = self.bless();
            $self.init(compiler, $multi-line-enabled);
            $self = mixin-line-editor($self);
            $self
        }

        method init(Mu \compiler, $multi-line-enabled --> Nil) {
            $!compiler := compiler;
            $!multi-line-enabled = $multi-line-enabled;
        }

        method teardown {
            self.?teardown-line-editor;
        }

        method repl-eval($code, \exception, *%adverbs) {

            CATCH {
                when X::Syntax::Missing {
                    return $!need-more-input
                      if $!multi-line-enabled && .pos == $code.chars;
                    .throw;
                }

                when X::Comp::FailGoal {
                    return $!need-more-input
                      if $!multi-line-enabled && .pos == $code.chars;
                    .throw;
                }

                when X::ControlFlow::Return {
                    return $!control-not-allowed;
                }

                default {
                    exception = $_;
                    return;
                }
            }

            CONTROL {
                when CX::Emit | CX::Take { .rethrow; }
                when CX::Warn { .gist.say; .resume;  }
                return $!control-not-allowed;
            }

            self.compiler.eval($code, |%adverbs);
        }

        method interactive_prompt() { '> ' }

        method repl-loop(*%adverbs) {

            say "To exit type 'exit' or '^D'";

            my $prompt;
            my $code;
            sub reset(--> Nil) {
                $code = '';
                $prompt = self.interactive_prompt;
            }
            reset;

            REPL: loop {
                my $newcode = self.repl-read(~$prompt);

                my $initial_out_position = $*OUT.tell;

                # An undef $newcode implies ^D or similar
                if !$newcode.defined {
                    last;
                }

                $code = $code ~ $newcode ~ "\n";

                if $code ~~ /^ <.ws> $/ {
                    next;
                }

                my $*CTXSAVE := self;
                my $*MAIN_CTX;

                my $output is default(Nil) = self.repl-eval(
                    $code,
                    my $exception,
                    :outer_ctx($!save_ctx),
                    |%adverbs);

                if self.input-incomplete($output) {
                    $prompt = '* ';
                    next;
                }

                if self.input-toplevel-control($output) {
                    say "Control flow commands not allowed in toplevel";
                    reset;
                    next;
                }

                if $*MAIN_CTX {
                    $!save_ctx := $*MAIN_CTX;
                }

                reset;

                # Print the result if:
                # - there wasn't some other output
                # - the result is an *unhandled* Failure
                # - print an exception if one had occured
                if $exception.DEFINITE {
                    self.repl-print($exception);
                }
                elsif $initial_out_position == $*OUT.tell
                    or $output ~~ Failure and not $output.handled {
                    self.repl-print($output);
                }

                # Why doesn't the catch-default in repl-eval catch all?
                CATCH {
                    default { say $_; reset }
                }

            }

            self.teardown;
        }

        # Inside of the EVAL it does like caller.ctxsave
        method ctxsave(--> Nil) {
            $*MAIN_CTX := nqp::ctxcaller(nqp::ctx());
            $*CTXSAVE := 0;
        }

        method input-incomplete(Mu $value) {
            $value.WHERE == $!need-more-input.WHERE
        }

        method input-toplevel-control(Mu $value) {
            $value.WHERE == $!control-not-allowed.WHERE
        }

        method repl-print(Mu $value --> Nil) {
            say $value;
            CATCH {
                default { say $_ }
            }
        }

        method history-file(--> Str:D) {
            return $!history-file.absolute if $!history-file.defined;

            $!history-file = $*ENV<RAKUDO_HIST>
                ?? $*ENV<RAKUDO_HIST>.IO
                !! ($*HOME || $*TMPDIR).add('.perl6/rakudo-history');

            without mkdir $!history-file.parent {
                note "I ran into a problem trying to set up history: {.exception.message}";
                note 'Sorry, but history will not be saved at the end of your session';
            }

            $!history-file.absolute
        }
    }
}

#line 1 SETTING::src/core/Rakudo/Metaops.pm
# This class contains methods for generating callables to be used
# in metaoperators.  There are two reasons for having this in a
# separate class:
#
# 1. It needs to know about all possible builtin operators.  If it
#    would be part of Rakudo::Internals, it would be too early in
#    building the settings.  Augmenting Rakudo::Internals at the
#    the end of building the settings would also have been an option,
#    but that would probably slow down settings building significantly.
#    And since the class name is really not that important, this seemed
#    like a good solution.
# 2. Nice to have a separate file for similar stuff.  Rakudo::Internals
#    has become a hodgepodge of stuff of late.

class Rakudo::Metaops {

    my $mappers := nqp::hash(
      nqp::tostr_I(&infix:<+>.WHERE),      # optimized version for &[+]
      -> \list {
          nqp::if(
            nqp::iseq_i(nqp::elems(list),2),
            (nqp::atpos(list,0) + nqp::atpos(list,1)),
            nqp::if(
              nqp::elems(list),
              nqp::stmts(
                (my $result := nqp::shift(list)),
                nqp::while(
                  nqp::elems(list),
                  ($result := $result + nqp::shift(list))
                ),
                $result
              ),
              0
            )
          )
      },
      nqp::tostr_I(&infix:<~>.WHERE),      # optimized version for &[~]
      -> \list {
          nqp::if(
            nqp::iseq_i(nqp::elems(list),2),
            (nqp::atpos(list,0) ~ nqp::atpos(list,1)),
            nqp::if(
              nqp::elems(list),
              nqp::stmts(                  # could possibly be done smarter
                (my $result := nqp::shift(list)),
                nqp::while(
                  nqp::elems(list),
                  ($result := $result ~ nqp::shift(list))
                ),
                $result
              ),
              ''
            )
          )
      },
      nqp::tostr_I(&infix:<< => >>.WHERE), # optimized version for &[=>]
      -> \list {
          nqp::if(
            nqp::iseq_i(nqp::elems(list),2),
            Pair.new(nqp::atpos(list,0),nqp::atpos(list,1)),
            nqp::if(
              nqp::isgt_i(nqp::elems(list),2),
              nqp::stmts(
                (my $result := nqp::pop(list)),
                nqp::while(
                  nqp::elems(list),
                  ($result := Pair.new(nqp::pop(list),$result))
                ),
                $result
              ),
              (die "Too few positionals passed; expected 2 arguments but got {nqp::elems(list)}")
            )
          )
      },
      nqp::tostr_I(&infix:<,>.WHERE),      # optimized version for &[,]
      -> \list {
          nqp::p6bindattrinvres(nqp::create(List),List,'$!reified',list)
      }
    );

    method MapperForOp(&op) is raw {
        nqp::if(
          nqp::existskey($mappers,(my str $where = nqp::tostr_I(&op.WHERE))),
          nqp::atkey($mappers,$where),
          nqp::if(
            nqp::iseq_i(nqp::chars(my str $assoc = &op.prec("assoc")),0)
              || nqp::iseq_s($assoc,'left'),
            -> \list {                   # generic left-assoc op
                nqp::if(
                  nqp::iseq_i(nqp::elems(list),2),
                  op(nqp::atpos(list,0),nqp::atpos(list,1)),
                  nqp::if(
                    nqp::elems(list),
                    nqp::stmts(
                      (my $result := nqp::shift(list)),
                      nqp::while(
                        nqp::elems(list),
                        ($result := op($result,nqp::shift(list)))
                      ),
                      $result
                    ),
                    op()
                  )
                )
            },
            nqp::if(
              nqp::iseq_s($assoc,"chain"),
              -> \list {                 # generic chain-assoc op
                  nqp::if(
                    nqp::iseq_i(nqp::elems(list),2),
                    op(nqp::atpos(list,0),nqp::atpos(list,1)),
                    nqp::if(
                      nqp::elems(list),
                      nqp::stmts(
                        (my $state = True),
                        (my $current := nqp::shift(list)),
                        nqp::while(
                          nqp::elems(list)
                            && ($state := op(
                              $current,
                              (my $next := nqp::shift(list))
                            )),
                          ($current := $next)
                        ),
                        $state
                      ),
                      op()
                    )
                  )
              },
              nqp::if(
                nqp::iseq_s($assoc,'right'),
                -> \list {                 # generic right-assoc op
                    nqp::if(
                      nqp::iseq_i(nqp::elems(list),2),
                      op(nqp::atpos(list,0),nqp::atpos(list,1)),
                      nqp::if(
                        nqp::elems(list),
                        nqp::stmts(
                          (my $result := nqp::pop(list)),
                          nqp::while(
                            nqp::elems(list),
                            ($result := op(nqp::pop(list),$result))
                          ),
                          $result
                        ),
                        op()
                      )
                    )
                },
                nqp::if(
                  nqp::iseq_s($assoc,'non'),
                  -> \list {               # generic non-assoc op
                      nqp::if(
                        nqp::iseq_i(nqp::elems(list),2),
                        op(nqp::atpos(list,0),nqp::atpos(list,1)),
                        (die "Incorrect number of elements for non-associative operator: expected 2, got {nqp::elems(list)}")
                      )
                  },
                  nqp::if(
                    nqp::iseq_s($assoc,"list"),
                    -> \list {               # generic list/listinfix op
                        op(
                          nqp::p6bindattrinvres(
                            nqp::create(List),List,'$!reified',list)
                        )
                    },
                    (die "Don't know how to process '$assoc' associativity")
                  )
                )
              )
            )
          )
        )
    }
}

#line 1 SETTING::src/core/core_epilogue.pm
# Re-parent meta-objects so they appear to be under Any.
BEGIN {
    Perl6::Metamodel::ClassHOW.HOW.reparent(Perl6::Metamodel::ClassHOW, Any);
    Perl6::Metamodel::ConcreteRoleHOW.HOW.reparent(Perl6::Metamodel::ConcreteRoleHOW, Any);
    Perl6::Metamodel::CurriedRoleHOW.HOW.reparent(Perl6::Metamodel::CurriedRoleHOW, Any);
    Perl6::Metamodel::EnumHOW.HOW.reparent(Perl6::Metamodel::EnumHOW, Any);
    Perl6::Metamodel::GenericHOW.HOW.reparent(Perl6::Metamodel::GenericHOW, Any);
    Perl6::Metamodel::ModuleHOW.HOW.reparent(Perl6::Metamodel::ModuleHOW, Any);
    Perl6::Metamodel::NativeHOW.HOW.reparent(Perl6::Metamodel::NativeHOW, Any);
    Perl6::Metamodel::PackageHOW.HOW.reparent(Perl6::Metamodel::PackageHOW, Any);
    Perl6::Metamodel::ParametricRoleGroupHOW.HOW.reparent(Perl6::Metamodel::ParametricRoleGroupHOW, Any);
    Perl6::Metamodel::ParametricRoleHOW.HOW.reparent(Perl6::Metamodel::ParametricRoleHOW, Any);
    Perl6::Metamodel::SubsetHOW.HOW.reparent(Perl6::Metamodel::SubsetHOW, Any);
    Perl6::Metamodel::GrammarHOW.HOW.compose(Perl6::Metamodel::GrammarHOW);
    Perl6::Metamodel::BaseDispatcher.HOW.reparent(Perl6::Metamodel::BaseDispatcher, Any);
    Perl6::Metamodel::MethodDispatcher.HOW.compose(Perl6::Metamodel::MethodDispatcher);
    Perl6::Metamodel::MultiDispatcher.HOW.compose(Perl6::Metamodel::MultiDispatcher);
    Perl6::Metamodel::WrapDispatcher.HOW.compose(Perl6::Metamodel::WrapDispatcher);
}

{YOU_ARE_HERE}


# vim: set ft=perl6 nomodifiable :
