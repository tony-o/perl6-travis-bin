# This file automatically generated by tools/build/gen-cat.nqp

#line 1 SETTING::src/Perl6/Metamodel/Configuration.nqp
# Keeps track of various special types or other things that the MOP may be
# configured with.
class Perl6::Metamodel::Configuration {
    my $stash_type := nqp::null();
    my $stash_attr_type := nqp::null();
    method set_stash_type($type, $attr_type) {
        $stash_type := $type;
        $stash_attr_type := $attr_type;
    }
    method stash_type() { $stash_type }
    method stash_attr_type() { $stash_attr_type }

    my $submethod_type := nqp::null();
    method set_submethod_type($type) {
        $submethod_type := $type;
    }
    method submethod_type() { $submethod_type }

    my $multi_sig_comparator;
    method set_multi_sig_comparator($comp) {
        $multi_sig_comparator := $comp;
    }
    method compare_multi_sigs($a, $b) {
        nqp::isconcrete($multi_sig_comparator)
            ?? $multi_sig_comparator($a, $b)
            !! 0
    }
}
#line 1 SETTING::src/Perl6/Metamodel/Archetypes.nqp
use Perl6::Ops;

# Provides various properties of the type of type a given meta-object
# implements. This are used in various ways by the compiler and meta-model
# to do correct code generation or to detect illegal use of types in
# contexts with certain requirements.
class Perl6::Metamodel::Archetypes {
    # Can this serve as a nominal type? Implies memoizability
    # amongst other things.
    has $!nominal;

    # If it's not nominal, does it know how to provide a nominal
    # type part of itself?
    has $!nominalizable;

    # Can this be inherited from?
    has $!inheritable;

    # If it's not inheritable, does it know how to produce something
    # that is?
    has $!inheritalizable;

    # Can this be composed (either with flattening composition, or used
    # as a mixin)?
    has $!composable;

    # If it's not composable, does it know how to produce something
    # that is?
    has $!composalizable;

    # Is it generic, in the sense of "we don't know what type this is
    # yet"? Note that a parametric type would not be generic - even if
    # it has missing parts, it defines a type. A type variable is generic,
    # however. This tends to cause various kinds of late (or at least
    # delayed) reification. In some contexts, an unresolved generic is
    # fatal.
    has $!generic;

    # Is it a parametric type - that is, it has missing bits that need
    # to be filled out before it can be used? Unlike generic, something
    # that is parametric does define a type - though we may need the gaps
    # filled it before it's useful in some way.
    has $!parametric;

    # Is it a coercive type?
    has $!coercive;

    # Is it a definite type?
    has $!definite;

    # Are we allowed to augment the type?
    has $!augmentable;

    method nominal() { $!nominal // 0 }
    method nominalizable() { $!nominalizable // 0 }
    method inheritable() { $!inheritable // 0 }
    method inheritalizable() { $!inheritalizable // 0 }
    method composable() { $!composable // 0 }
    method composalizable() { $!composalizable // 0 }
    method generic() { $!generic // 0 }
    method parametric() { $!parametric // 0 }
    method coercive() { $!coercive // 0 }
    method definite() { $!definite // 0 }
    method augmentable() { $!augmentable // 0 }
}
#line 1 SETTING::src/Perl6/Metamodel/Naming.nqp
role Perl6::Metamodel::Naming {
    has $!name;
    has $!shortname;
    method set_name($obj, $name) {
        $!name := $name;
        nqp::setdebugtypename($obj, $name);
        if $name {
            my @names := nqp::split('[', $name);
            if nqp::elems(@names) > 1 {
                my @main := nqp::split('::', @names[0]);
                my @sub  := nqp::split('::', @names[1]);
                $!shortname :=
                  @main[nqp::elems(@main) - 1]
                    ~ '[' ~ @sub[nqp::elems(@sub) - 1];
            }
            else {
                my @parts := nqp::split('::', $name);
                $!shortname := @parts[nqp::elems(@parts) - 1];
            }
        }
        else {
            $!shortname := '';
        }
    }
    method set_shortname($obj, $shortname) {
        $!shortname := $shortname;
    }
    method name($obj) {
        $!name
    }
    method shortname($obj) {
        $!shortname
    }
}
#line 1 SETTING::src/Perl6/Metamodel/Documenting.nqp
role Perl6::Metamodel::Documenting {
    has $!why;

    method WHY() {
        nqp::isnull($!why) ?? Nil !! $!why
    }

    method set_why($why) {
        $!why := $why;
    }
}
#line 1 SETTING::src/Perl6/Metamodel/Stashing.nqp
role Perl6::Metamodel::Stashing {
    method add_stash($type_obj) {
        my $stash_type := Perl6::Metamodel::Configuration.stash_type;
        unless nqp::isnull($stash_type) {
            my $attr_type := Perl6::Metamodel::Configuration.stash_attr_type;
            my $stash := nqp::create($stash_type);
            nqp::bindattr($stash, $attr_type, '$!storage', my %symbols);
            nqp::bindattr_s($stash, $stash.WHAT, '$!longname',
                $type_obj.HOW.name($type_obj));
            nqp::setwho($type_obj, $stash);
        }
        $type_obj
    }
}
#line 1 SETTING::src/Perl6/Metamodel/Versioning.nqp
role Perl6::Metamodel::Versioning {
    has $!ver;
    has $!auth;

    method ver($obj) { $!ver // nqp::null() }
    method auth($obj) { $!auth // '' }

    method set_ver($obj, $ver) { $!ver := $ver }
    method set_auth($obj, $auth) { $!auth := $auth }
}
#line 1 SETTING::src/Perl6/Metamodel/TypePretense.nqp
role Perl6::Metamodel::TypePretense {
    my @pretending;

    method pretend_to_be(@types) {
        @pretending := @types;
    }

    method pretending_to_be() {
        @pretending
    }

    method type_check($obj, $checkee) {
        if $obj =:= $checkee {
            return 1;
        }
        for self.pretending_to_be() {
            if $checkee =:= $_ {
                return 1;
            }
        }
        0;
    }
}
#line 1 SETTING::src/Perl6/Metamodel/MethodDelegation.nqp
role Perl6::Metamodel::MethodDelegation {
    my $delegate_type;

    method delegate_methods_to($type) {
        $delegate_type := $type
    }

    method delegating_methods_to() {
        $delegate_type
    }

    method find_method($obj, $name) {
        $delegate_type.HOW.find_method($delegate_type, $name);
    }
}
#line 1 SETTING::src/Perl6/Metamodel/BoolificationProtocol.nqp
role Perl6::Metamodel::BoolificationProtocol {
    has $!boolification_mode;

    method get_boolification_mode($obj) {
        $!boolification_mode
    }

    method set_boolification_mode($obj, $mode) {
        $!boolification_mode := $mode;
    }

    method publish_boolification_spec($obj) {
        if $!boolification_mode == 0 {
            my $meth := self.find_method($obj, 'Bool', :no_fallback(1));
            if nqp::defined($meth) {
                nqp::setboolspec($obj, 0, $meth)
            }
            else {
                # Default to "not a type object" if we've no available method.
                nqp::setboolspec($obj, 5, nqp::null())
            }
        }
        else {
            nqp::setboolspec($obj, $!boolification_mode, nqp::null())
        }
    }
}
#line 1 SETTING::src/Perl6/Metamodel/PackageHOW.nqp
class Perl6::Metamodel::PackageHOW
    does Perl6::Metamodel::Naming
    does Perl6::Metamodel::Documenting
    does Perl6::Metamodel::Stashing
    does Perl6::Metamodel::TypePretense
    does Perl6::Metamodel::MethodDelegation
{
    has $!composed;

    my $archetypes := Perl6::Metamodel::Archetypes.new( );
    method archetypes() {
        $archetypes
    }

    method new(*%named) {
        nqp::findmethod(NQPMu, 'BUILDALL')(nqp::create(self), |%named)
    }

    method new_type(:$name = '<anon>', :$repr, :$ver, :$auth) {
        if $repr { nqp::die("'package' does not support custom representations") }
        my $metaclass := nqp::create(self);
        my $obj := nqp::settypehll(nqp::newtype($metaclass, 'Uninstantiable'), 'perl6');
        $metaclass.set_name($obj, $name);
        self.add_stash($obj);
    }

    method compose($obj, :$compiler_services) {
        $!composed := 1;
    }

    method is_composed($obj) {
        $!composed
    }
}
#line 1 SETTING::src/Perl6/Metamodel/ModuleHOW.nqp
class Perl6::Metamodel::ModuleHOW
    does Perl6::Metamodel::Naming
    does Perl6::Metamodel::Documenting
    does Perl6::Metamodel::Versioning
    does Perl6::Metamodel::Stashing
    does Perl6::Metamodel::TypePretense
    does Perl6::Metamodel::MethodDelegation
{
    has $!composed;

    my $archetypes := Perl6::Metamodel::Archetypes.new( );
    method archetypes() {
        $archetypes
    }

    method new(*%named) {
        nqp::findmethod(NQPMu, 'BUILDALL')(nqp::create(self), |%named)
    }

    method new_type(:$name = '<anon>', :$repr, :$ver, :$auth) {
        if $repr { nqp::die("'module' does not support custom representations") }
        my $metaclass := self.new();
        my $obj := nqp::settypehll(nqp::newtype($metaclass, 'Uninstantiable'), 'perl6');
        $metaclass.set_name($obj, $name);
        $metaclass.set_ver($obj, $ver) if $ver;
        $metaclass.set_auth($obj, $auth) if $auth;
        self.add_stash($obj);
    }

    method compose($obj, :$compiler_services) {
        $!composed := 1;
    }

    method is_composed($obj) {
        $!composed
    }
}
#line 1 SETTING::src/Perl6/Metamodel/GenericHOW.nqp
# A HOW that represents a generic type. It's something of a
# placeholder for a type that we don't actually know yet.
# It sits anywhere that a type could, and possession of one
# of these confers genericity on the holder.
class Perl6::Metamodel::GenericHOW
    does Perl6::Metamodel::Naming
{
    my $archetypes := Perl6::Metamodel::Archetypes.new( :generic(1) );
    method archetypes() {
        $archetypes
    }

    method new(*%named) {
        nqp::findmethod(NQPMu, 'BUILDALL')(nqp::create(self), |%named)
    }

    # The name we're created with is both the name we'll claim
    # to be if asked, but also the name we'll look up in a
    # supplied type environment when we want to instantiate
    # ourself.
    method new_type(:$name) {
        my $meta := self.new();
        my $obj := nqp::settypehll(nqp::newtype($meta, 'Uninstantiable'), 'perl6');
        $meta.set_name($obj, $name);
        $obj
    }

    method instantiate_generic($obj, $type_environment) {
        my $name := self.name($obj);
        my $found := nqp::getlexrel($type_environment, $name);
        nqp::isnull($found) ?? $obj !! $found
    }

    method compose($obj) {
    }

    method find_method($obj, $name) {
        nqp::null()
    }

    method type_check($obj, $checkee) {
        0
    }
}
#line 1 SETTING::src/Perl6/Metamodel/AttributeContainer.nqp
role Perl6::Metamodel::AttributeContainer {
    # Attributes list.
    has @!attributes;
    has %!attribute_lookup;

    # Do we default them to rw?
    has $!attr_rw_by_default;

    # Adds an attribute.
    method add_attribute($obj, $meta_attr) {
        my $name := $meta_attr.name;
        if nqp::existskey(%!attribute_lookup, $name) {
            nqp::die("Package '" ~ self.name($obj) ~
                "' already has an attribute named '$name'");
        }
        @!attributes[+@!attributes] := $meta_attr;
        %!attribute_lookup{$name}   := $meta_attr;
    }

    # Composes all attributes.
    method compose_attributes($obj, :$compiler_services) {
        my %seen_with_accessor;
        my %meths := self.method_table($obj);
        my %orig_meths;
        for %meths {
            %orig_meths{$_.key} := 1;
        }
        for @!attributes {
            if $!attr_rw_by_default { $_.default_to_rw() }
            if $_.has_accessor() {
                my $acc_name := nqp::substr($_.name, 2);
                nqp::die("Two or more attributes declared that both want an accessor method '$acc_name'")
                    if %seen_with_accessor{$acc_name} && !nqp::existskey(%orig_meths, $acc_name);
                %seen_with_accessor{$acc_name} := 1;
            }

            # Heuristic to pass along compiler_services only to Perl 6 MOP,
            # not to NQP one.
            nqp::isconcrete($compiler_services) && nqp::can($_, 'gist')
                ?? $_.compose($obj, :$compiler_services)
                !! $_.compose($obj)
        }
    }

    # Makes setting the type represented by the meta-object rw mean that its
    # attributes are rw by default.
    method set_rw($obj) {
        $!attr_rw_by_default := 1;
    }

    # Is this type's attributes rw by default?
    method rw($obj) {
        $!attr_rw_by_default
    }

    # Gets the attribute meta-object for an attribute if it exists.
    # This is called by the parser so it should only return attributes
    # that are visible inside the current package.
    method get_attribute_for_usage($obj, $name) {
        unless nqp::existskey(%!attribute_lookup, $name) {
            nqp::die("No $name attribute in " ~ self.name($obj))
        }
        %!attribute_lookup{$name}
    }

    # Introspect attributes.
    method attributes($obj, :$local, :$excl, :$all) {
        my @attrs;

        for @!attributes {
            @attrs.push($_);
        }

        unless $local {
            for self.parents($obj, :excl($excl), :all($all)) {
                for $_.HOW.attributes($_, :local(1)) {
                    @attrs.push($_);
                }
            }
        }

        @attrs
    }
}
#line 1 SETTING::src/Perl6/Metamodel/Finalization.nqp
role Perl6::Metamodel::Finalization {
    has @!destroyers;

    method setup_finalization($obj) {
        my @mro   := self.mro($obj);
        my int $i := nqp::elems(@mro);
        my @destroyers;
        while --$i >= 0 {
            my $class   := @mro[$i];
            my $destroy := $class.HOW.find_method($class, 'DESTROY', :no_fallback(1));
            if !nqp::isnull($destroy) && $destroy {
                nqp::push(@destroyers, $destroy);
            }
        }
        @!destroyers := @destroyers;
        if @destroyers {
            nqp::settypefinalize($obj, 1);
        }
    }

    method destroyers($obj) {
        @!destroyers
    }
}
#line 1 SETTING::src/Perl6/Metamodel/MethodContainer.nqp
role Perl6::Metamodel::MethodContainer {
    # Lookup table of the methods.
    has %!methods;
    has %!submethods;

    # The order that the methods were added in.
    has @!method_order;

    # Cache that expires when we add methods (primarily to support NFA stuff).
    # The hash here is readonly; we copy/replace in on addition, for thread
    # safety (additions are dominated by lookups, so a lock - even a rw-lock -
    # is not ideal here).
    has %!cache;

    # Add a method.
    method add_method($obj, $name, $code_obj) {
        # Ensure we haven't already got it.
        $code_obj := nqp::decont($code_obj);
        if nqp::existskey(%!methods, $name) || nqp::existskey(%!submethods, $name) {
            nqp::die("Package '"
              ~ self.name($obj)
              ~ "' already has a "
              ~ (try { nqp::lc($code_obj.HOW.name($code_obj)) } // 'method')
              ~ " '"
              ~ $name
              ~ "' (did you mean to declare a multi-method?)");
        }

        # Add to correct table depending on if it's a Submethod.
        if !nqp::isnull(Perl6::Metamodel::Configuration.submethod_type)
            && nqp::istype($code_obj, Perl6::Metamodel::Configuration.submethod_type) {
            %!submethods{$name} := $code_obj;
        }
        else {
            %!methods{$name} := $code_obj;
        }

        # Adding a method means any cache is no longer authoritative.
        nqp::setmethcacheauth($obj, 0);
        %!cache := {};
        @!method_order[+@!method_order] := $code_obj;
    }

    # Gets the method hierarchy.
    method methods($obj, :$local, :$excl, :$all) {
        # Always need local methods on the list.
        my @meths;
        for @!method_order {
            @meths.push(nqp::hllizefor($_, 'perl6'));
        }

        # If local flag was not passed, include those from parents.
        unless $local {
            for self.parents($obj, :all($all), :excl($excl)) {
                for $_.HOW.method_table($_) {
                    @meths.push(nqp::hllizefor($_.value, 'perl6'));
                }
                for $_.HOW.submethod_table($_) {
                    @meths.push(nqp::hllizefor($_.value, 'perl6'));
                }
            }
        }

        # Return result list.
        @meths
    }

    # Get the method table. Only contains methods directly declared here,
    # and excludes submethods.
    method method_table($obj) {
        %!methods
    }

    # Gets the submethods table.
    method submethod_table($obj) {
        %!submethods
    }

    # Checks if this package (not its parents) declares a given
    # method. Checks submethods also.
    method declares_method($obj, $name) {
        %!methods{$name} || %!submethods{$name} ?? 1 !! 0
    }

    # Looks up a method with the provided name, for introspection purposes.
    method lookup($obj, $name) {
        for self.mro($obj) {
            my %meth := $_.HOW.method_table($obj);
            if nqp::existskey(%meth, $name) {
                return %meth{$name};
            }
            if nqp::can($_.HOW, 'submethod_table') {
                my %submeth := $_.HOW.submethod_table($obj);
                if nqp::existskey(%submeth, $name) {
                    return %submeth{$name};
                }
            }
        }
        nqp::null()
    }

    # Caches or updates a cached value.
    method cache($obj, str $key, $value_generator) {
        my %orig_cache := %!cache;
        nqp::ishash(%orig_cache) && nqp::existskey(%!cache, $key)
            ?? %!cache{$key}
            !! self.cache_add($obj, $key, $value_generator())
    }

    method cache_get($obj, str $key) {
        my %caches := %!cache;
        nqp::ishash(%caches) ?? nqp::atkey(%caches, $key) !! nqp::null()
    }

    method cache_add($obj, str $key, $value) {
        my %orig_cache := %!cache;
        my %copy := nqp::ishash(%orig_cache) ?? nqp::clone(%orig_cache) !! {};
        %copy{$key} := $value;
        %!cache := %copy;
        $value
    }
}
#line 1 SETTING::src/Perl6/Metamodel/PrivateMethodContainer.nqp
role Perl6::Metamodel::PrivateMethodContainer {
    has %!private_methods;

    # Adds a private method.
    method add_private_method($obj, $name, $code) {
        if nqp::existskey(%!private_methods, $name) {
            nqp::die("Private method '$name' already declared in package " ~
                self.name($obj));
        }
        %!private_methods{$name} := $code;
    }

    # Gets the table of private methods.
    method private_method_table($obj) {
        %!private_methods
    }

    # Locates a private method, and hands back null if it doesn't exist.
    method find_private_method($obj, $name) {
        nqp::existskey(%!private_methods, $name) ??
            %!private_methods{$name} !!
            nqp::null()
    }
}
#line 1 SETTING::src/Perl6/Metamodel/MultiMethodContainer.nqp
role Perl6::Metamodel::MultiMethodContainer {
    # Set of multi-methods to incorporate. Not just the method handles;
    # each is a hash containing keys name and body.
    has @!multi_methods_to_incorporate;

    # The proto we'll clone.
    my $autogen_proto;

    # Sets the proto we'll auto-gen based on.
    method set_autogen_proto($proto) {
        $autogen_proto := $proto
    }

    # We can't incorporate multis right away as we don't know all parents
    # yet, maybe, which influences whether we even can have multis, need to
    # generate a proto and so forth. So just queue them up in a todo list and
    # we handle it at class composition time.
    method add_multi_method($obj, $name, $code_obj) {
        # Represents a multi candidate to incorporate.
        my class MultiToIncorporate {
            has $!name;
            has $!code;
            method name() { $!name }
            method code() { $!code }
        }
        my $how := MultiToIncorporate.HOW.WHAT;
        my $todo := MultiToIncorporate.new( :name($name), :code(nqp::decont($code_obj)) );
        @!multi_methods_to_incorporate[+@!multi_methods_to_incorporate] := $todo;
        $code_obj;
    }

    # Gets the multi methods that are to be incorporated.
    method multi_methods_to_incorporate($obj) {
        @!multi_methods_to_incorporate
    }

    # Incorporates the multi candidates into the appropriate proto. Need to
    # implement proto incorporation yet.
    method incorporate_multi_candidates($obj) {
        my $num_todo := +@!multi_methods_to_incorporate;
        my $i := 0;
        my @new_protos;
        while $i != $num_todo {
            # Get method name and code.
            my $name := @!multi_methods_to_incorporate[$i].name;
            my $code := @!multi_methods_to_incorporate[$i].code;

            # Do we have anything in the methods table already in
            # this class?
            my %meths := self.method_table($obj);
            if nqp::existskey(%meths, $name) {
                # Yes. Only or dispatcher, though? If only, error. If
                # dispatcher, simply add new dispatchee.
                my $dispatcher := %meths{$name};
                if $dispatcher.is_dispatcher {
                    $dispatcher.add_dispatchee($code);
                }
                else {
                    nqp::die("Cannot have a multi candidate for '" ~ $name ~
                        "' when an only method is also in the package '" ~
                        self.name($obj) ~ "'");
                }
            }
            else {
                # Go hunting in the MRO for a proto.
                my @mro := self.mro($obj);
                my $j := 1;
                my $found := 0;
                while $j != +@mro && !$found {
                    my $parent := @mro[$j];
                    my %meths := $parent.HOW.method_table($parent);
                    if nqp::existskey(%meths, $name) {
                        # Found a possible - make sure it's a dispatcher, not
                        # an only.
                        my $dispatcher := %meths{$name};
                        if $dispatcher.is_dispatcher {
                            # Clone it and install it in our method table.
                            my $copy := $dispatcher.derive_dispatcher();
                            $copy.add_dispatchee($code);
                            self.add_method($obj, $name, $copy);
                            nqp::push(@new_protos, $copy);
                            $found := 1;
                        }
                    }
                    $j := $j + 1;
                }
                unless $found {
                    # No proto found, so we'll generate one here.
                    unless $autogen_proto {
                        nqp::die("Cannot auto-generate a proto method for '$name' in the setting");
                    }
                    my $proto := $autogen_proto.instantiate_generic(
                        nqp::hash('T', $obj));
                    $proto.set_name($name);
                    $proto.add_dispatchee($code);
                    self.add_method($obj, $name, $proto);
                    nqp::push(@new_protos, $proto);
                }
            }
            $i := $i + 1;
        }
        for @new_protos {
            if nqp::can($_, 'sort_dispatchees') {
                $_.sort_dispatchees();
            }
        }
        @!multi_methods_to_incorporate := [];
    }
}
#line 1 SETTING::src/Perl6/Metamodel/MetaMethodContainer.nqp
role Perl6::Metamodel::MetaMethodContainer {
    # Table of the methods.
    has %!meta_methods;

    # Add a meta-method.
    method add_meta_method($obj, $name, $code_obj) {
        if nqp::existskey(%!meta_methods, $name) {
            nqp::die("Package '" ~ self.name($obj)
                ~ "' already has a meta-method '$name'");
        }
        %!meta_methods{$name} := $code_obj;
    }

    # Get the meta-methods table: a hash of meta-methods added.
    method meta_method_table($obj) {
        %!meta_methods
    }

    # Applies the added meta-methods to the current meta-object instance by
    # building a role containing them, and mixing it in.
    method compose_meta_methods($obj) {
        # Build flattened meta-methods set.
        my %meta;
        for self.mro($obj) {
            if nqp::can($_.HOW, 'meta_method_table') {
                for $_.HOW.meta_method_table($obj) -> $meth_info {
                    my str $name := $meth_info.key;
                    unless nqp::existskey(%meta, $name) {
                        %meta{$name} := $meth_info.value;
                    }
                }
            }
        }

        # If we have any meta-methods, build a role for them to go in and
        # compose it into the meta-object..
        if %meta {
            my $role := $?PACKAGE.HOW.new_type();
            for %meta {
                $role.HOW.add_method($role, $_.key, $_.value);
            }
            $role.HOW.set_body_block($role, sub ($class) {
                nqp::list($role, nqp::hash('$?CLASS', $class))
            });
            $role.HOW.compose($role);
            self.HOW.mixin(self, $role);
        }
    }
}
#line 1 SETTING::src/Perl6/Metamodel/RoleContainer.nqp
role Perl6::Metamodel::RoleContainer {
    has @!roles_to_compose;

    method add_role($obj, $role) {
        @!roles_to_compose[+@!roles_to_compose] := $role
    }

    method roles_to_compose($obj) {
        @!roles_to_compose
    }
}
#line 1 SETTING::src/Perl6/Metamodel/MultipleInheritance.nqp
role Perl6::Metamodel::MultipleInheritance {
    # Array of parents.
    has @!parents;

    # Are any of the parents hidden?
    has @!hides;

    # Is this class hidden?
    has $!hidden;

    # Classes to exclude from the parents list in introspection by default.
    my @excluded;
    method exclude_parent($parent) {
        @excluded.push($parent);
    }

    # Adds a parent.
    method add_parent($obj, $parent, :$hides) {
        if self.is_composed($obj) {
            nqp::die("Parents cannot be added to class '" ~ self.name($obj) ~ "'after it has been composed");
        }
        if nqp::decont($parent) =:= nqp::decont($obj) {
            nqp::die("Class " ~ self.name($obj) ~ " cannot inherit from itself");
        }
        my $parent_how := $parent.HOW;
        if nqp::can($parent_how, 'repr_composed') && !$parent_how.repr_composed($parent) {
            my %ex := nqp::gethllsym('perl6', 'P6EX');
            if !nqp::isnull(%ex) && nqp::existskey(%ex, 'X::Inheritance::NotComposed') {
                %ex{'X::Inheritance::NotComposed'}(self.name($obj), $parent_how.name($parent))
            }
            nqp::die("Class " ~ self.name($obj) ~ " cannot inherit from "
                ~ $parent_how.name($parent) ~ " because the parent is not composed yet");
        }
        for @!parents {
            if nqp::decont($_) =:= nqp::decont($parent) {
                nqp::die("Package '" ~ self.name($obj) ~
                    "' already has parent '" ~
                    $parent.HOW.name($parent) ~ "'");
            }
        }
        if $hides {
            @!hides[+@!hides] := $parent;
        }
        @!parents[+@!parents] := $parent;
    }

    # Introspects the parents.
    method parents($obj, :$local, :$tree, :$excl, :$all) {
        if $local {
            @!parents
        }
        elsif $tree {
            my @result;
            for @!parents {
                my @pt := [$_];
                my @recursive_parents := $_.HOW.parents($_, :tree(1));
                @pt.push(@recursive_parents) if @recursive_parents;
                @result.push(nqp::hllizefor(@pt, 'perl6').Array);
            }
            @result := @result[0] if nqp::elems(@result) == 1;
            return nqp::hllizefor(@result, 'perl6');
        }
        else {
            # All parents is MRO minus the first thing (which is us).
            my @mro := self.mro($obj);
            my @parents;
            my $i := 1;
            while $i < +@mro {
                my $exclude := 0;
                unless $all {
                    for @excluded {
                        $exclude := 1 if @mro[$i] =:= $_;
                    }
                }
                @parents.push(@mro[$i]) unless $exclude;
                $i := $i + 1;
            }
            @parents
        }
    }

    method hides($obj) {
        @!hides
    }

    method hidden($obj) {
        $!hidden ?? 1 !! 0
    }

    method set_hidden($obj) {
        $!hidden := 1;
    }
}
#line 1 SETTING::src/Perl6/Metamodel/DefaultParent.nqp
role Perl6::Metamodel::DefaultParent {
    my @default_parent_type;

    method set_default_parent_type($type) {
        @default_parent_type[0] := $type;
    }

    method has_default_parent_type() {
        +@default_parent_type
    }

    method get_default_parent_type() {
        @default_parent_type[0]
    }
}
#line 1 SETTING::src/Perl6/Metamodel/BaseType.nqp
# Implemented by meta-objects that don't do inheritance per se,
# but want to base themselves on another type and mostly behave
# like they support it.
role Perl6::Metamodel::BaseType {
    has $!base_type;
    has $!base_type_set;
    has @!mro;

    method set_base_type($obj, $base_type) {
        if $!base_type_set {
            nqp::die("Base type has already been set for " ~ self.name($obj));
        }
        $!base_type := $base_type;
        $!base_type_set := 1;
    }

    # Our MRO is just that of base type.
    method mro($obj) {
        unless @!mro {
            @!mro[0] := $obj;
            for $!base_type.HOW.mro($!base_type) {
                @!mro.push($_);
            }
        }
        @!mro
    }

    method parents($obj, :$local, :$excl, :$all) {
        my @parents := [$!base_type];
        unless $local {
            for $!base_type.HOW.parents($!base_type, :excl($excl), :all($all)) {
                @parents.push($_);
            }
        }
        @parents
    }
}
#line 1 SETTING::src/Perl6/Metamodel/C3MRO.nqp
role Perl6::Metamodel::C3MRO {
    # Storage of the MRO.
    has @!mro;

    # The MRO minus anything that is hidden.
    has @!mro_unhidden;

    # Computes C3 MRO.
    method compute_mro($class) {
        my @immediate_parents := $class.HOW.parents($class, :local);

        # Provided we have immediate parents...
        my @result;
        if +@immediate_parents {
            if +@immediate_parents == 1 {
                @result := nqp::clone(@immediate_parents[0].HOW.mro(@immediate_parents[0]));
            } else {
                # Build merge list of linearizations of all our parents, add
                # immediate parents and merge.
                my @merge_list;
                for @immediate_parents {
                    @merge_list.push($_.HOW.mro($_));
                }
                @merge_list.push(@immediate_parents);
                @result := self.c3_merge(@merge_list);
            }
        }

        # Put this class on the start of the list, and we're done.
        @result.unshift($class);
        @!mro := @result;

        # Also compute the unhidden MRO (all the things in the MRO that
        # are not somehow hidden).
        my @unhidden;
        my @hidden;
        for @result -> $c {
            unless nqp::can($c.HOW, 'hidden') && $c.HOW.hidden($c) {
                my $is_hidden := 0;
                for @hidden {
                    if nqp::decont($c) =:= nqp::decont($_) {
                        $is_hidden := 1;
                    }
                }
                nqp::push(@unhidden, $c) unless $is_hidden;
            }
            if nqp::can($c.HOW, 'hides') {
                for $c.HOW.hides($c) {
                    nqp::push(@hidden, $_);
                }
            }
        }
        @!mro_unhidden := @unhidden;

        @!mro
    }

    # C3 merge routine.
    method c3_merge(@merge_list) {
        my @result;
        my $accepted;
        my $something_accepted := 0;
        my $cand_count := 0;

        # Try to find something appropriate to add to the MRO.
        for @merge_list {
            my @cand_list := $_;
            if +@cand_list {
                my $rejected := 0;
                my $cand_class := @cand_list[0];
                $cand_count := $cand_count + 1;
                for @merge_list {
                    # Skip current list.
                    unless $_ =:= @cand_list {
                        # Is current candidate in the tail? If so, reject.
                        my $cur_pos := 1;
                        while $cur_pos <= +$_ {
                            if nqp::decont($_[$cur_pos]) =:= nqp::decont($cand_class) {
                                $rejected := 1;
                            }
                            $cur_pos := $cur_pos + 1;
                        }
                    }

                }
                # If we didn't reject it, this candidate will do.
                unless $rejected {
                    $accepted := $cand_class;
                    $something_accepted := 1;
                    last;
                }
            }
        }

        # If we never found any candidates, return an empty list.
        if $cand_count == 0 {
            return @result;
        }

        # If we didn't find anything to accept, error.
        unless $something_accepted {
            nqp::die("Could not build C3 linearization: ambiguous hierarchy");
        }

        # Otherwise, remove what was accepted from the merge lists.
        my $i := 0;
        while $i < +@merge_list {
            my @new_list;
            for @merge_list[$i] {
                unless nqp::decont($_) =:= nqp::decont($accepted) {
                    @new_list.push($_);
                }
            }
            @merge_list[$i] := @new_list;
            $i := $i + 1;
        }

        # Need to merge what remains of the list, then put what was accepted on
        # the start of the list, and we're done.
        @result := self.c3_merge(@merge_list);
        @result.unshift($accepted);
        return @result;
    }

    # Introspects the Method Resolution Order.
    method mro($obj) {
        my @result := @!mro;
        if +@result {
            @result
        }
        else {
            # Never computed before; do it best we can so far (and it will
            # be finalized at compose time).
            self.compute_mro($obj)
        }
    }

    # Introspects the Method Resolution Order without anything that has
    # been hidden.
    method mro_unhidden($obj) {
        my @result := @!mro_unhidden;
        if +@result {
            @result
        }
        else {
            # Never computed before; do it best we can so far (and it will
            # be finalized at compose time).
            self.compute_mro($obj);
            @!mro_unhidden
        }
    }
}
#line 1 SETTING::src/Perl6/Metamodel/MROBasedMethodDispatch.nqp
role Perl6::Metamodel::MROBasedMethodDispatch {
    # While we normally end up locating methods through the method cache,
    # this is here as a fallback.
    method find_method($obj, $name, :$no_fallback, *%adverbs) {

# uncomment line below for verbose information about uncached method lookups
#nqp::say( "looking for " ~ $name ~ " in " ~ $obj.HOW.name($obj) );
#
        if nqp::can($obj.HOW, 'submethod_table') {
            my %submethods := $obj.HOW.submethod_table($obj);
            if nqp::existskey(%submethods, $name) {
                return %submethods{$name}
            }
        }
        my %methods;
        for self.mro($obj) {
            %methods := $_.HOW.method_table($_);
            if nqp::existskey(%methods, $name) {
                return %methods{$name}
            }
        }
        !$no_fallback && nqp::can(self, 'find_method_fallback') ??
            self.find_method_fallback($obj, $name) !!
            nqp::null();
    }

    method find_method_qualified($obj, $qtype, $name) {
        if $qtype.HOW.archetypes.parametric && nqp::can(self, 'concretization') {
            # Resolve it via the concrete form of this parametric.
            my $conc := self.concretization($obj, $qtype);
            $conc.HOW.method_table($conc){$name}
        }
        else {
            # Non-parametric, so just locate it from the already concrete
            # type (or fallback to this if no .concretization on ourself).
            nqp::findmethod($qtype, $name)
        }
    }

    # Maybe this belongs on a role. Also, may be worth memoizing.
    method can($obj, $name) {
        my @meths;
        my %smt := self.submethod_table($obj);
        if nqp::existskey(%smt, $name) {
            @meths.push(%smt{$name});
        }
        for self.mro($obj) {
            my %mt := $_.HOW.method_table($_);
            if nqp::existskey(%mt, $name) {
                @meths.push(%mt{$name})
            }
        }
        @meths
    }

    method publish_method_cache($obj) {
        # Walk MRO and add methods to cache, unless another method
        # lower in the class hierarchy "shadowed" it.
        my %cache;
        my @mro_reversed;
        my $authable := 1;
        for self.mro($obj) {
            @mro_reversed.unshift($_);
        }
        for @mro_reversed {
            for $_.HOW.method_table($_) {
                %cache{$_.key} := $_.value;
            }
            if nqp::can($_.HOW, 'is_composed') && !$_.HOW.is_composed($_) {
                $authable := 0;
            }
        }

        # Also add submethods.
        for $obj.HOW.submethod_table($obj) {
            %cache{$_.key} := $_.value;
        }

        nqp::setmethcache($obj, %cache);
        unless nqp::can(self, 'has_fallbacks') && self.has_fallbacks($obj) {
            nqp::setmethcacheauth($obj, $authable);
        }
    }
}
#line 1 SETTING::src/Perl6/Metamodel/MROBasedTypeChecking.nqp
role Perl6::Metamodel::MROBasedTypeChecking {
    method isa($obj, $type) {
        my $decont := nqp::decont($type);
        for self.mro($obj) {
            if nqp::decont($_) =:= $decont { return 1 }
        }
        0
    }

    method does($obj, $type) {
        nqp::p6bool(nqp::istype($obj, $type))
    }

    method type_check($obj, $checkee) {
        # The only time we end up in here is if the type check cache was
        # not yet published, which means the class isn't yet fully composed.
        # Just hunt through MRO.
        for self.mro($obj) {
            if $_ =:= $checkee {
                return 1;
            }
            if nqp::can($_.HOW, 'role_typecheck_list') {
                for $_.HOW.role_typecheck_list($_) {
                    if $_ =:= $checkee {
                        return 1;
                    }
                }
            }
        }
        0
    }

    method publish_type_cache($obj) {
        my @tc;
        for self.mro($obj) {
            @tc.push($_);
            if nqp::can($_.HOW, 'role_typecheck_list') {
                for $_.HOW.role_typecheck_list($_) {
                    @tc.push($_);
                }
            }
        }
        nqp::settypecache($obj, @tc)
    }
}
#line 1 SETTING::src/Perl6/Metamodel/Trusting.nqp
# Implements managing trust relationships between types.
role Perl6::Metamodel::Trusting {
    # Who do we trust?
    has @!trustees;

    # Adds a type that we trust.
    method add_trustee($obj, $trustee) {
        @!trustees[+@!trustees] := $trustee;
    }

    # Introspect the types that we trust.
    method trusts($obj) {
        @!trustees
    }

    # Checks if we trust a certain type. Can be used by the compiler
    # to check if a private call is allowable.
    method is_trusted($obj, $claimant) {
        # Always trust ourself.
        if $claimant.WHAT =:= $obj.WHAT {
            return 1;
        }

        # Otherwise, look through our trustee list.
        for @!trustees {
            if $_.WHAT =:= $claimant.WHAT {
                return 1;
            }
        }

        # If we get here, not trusted.
        0
    }
}
#line 1 SETTING::src/Perl6/Metamodel/Mixins.nqp
my class MixinCacheHOW {
    method new_type($class_type) {
        my $mo := self.new();
        my $type := nqp::newtype($mo, 'Uninstantiable');
        nqp::setparameterizer($type, sub ($type, @roles) {
            $class_type.HOW.generate_mixin($class_type, @roles);
        });
        $type
    }
}

role Perl6::Metamodel::Mixins {
    has $!mixin_cache;
    has $!is_mixin;
    has $!mixin_attribute;

    method set_is_mixin($obj) { $!is_mixin := 1 }
    method is_mixin($obj) { $!is_mixin }
    method set_mixin_attribute($obj, $attr) { $!mixin_attribute := $attr }
    method mixin_attribute($obj) { $!mixin_attribute }
    method flush_cache($obj) { }

    method setup_mixin_cache($obj) {
        $!mixin_cache := MixinCacheHOW.new_type($obj.WHAT);
    }

    method mixin($obj, *@roles, :$need-mixin-attribute) {
        # Lookup mixin, generating it if needed.
        my int $i := 0;
        my int $n := nqp::elems(@roles);
        while $i < $n {
            @roles[$i] := nqp::decont(@roles[$i]);
            $i++;
        }
        # XXX Workaround for mixing in to non-composed types; when this takes
        # place (a bunch during CORE.setting) the mixin is missing bits. This
        # has long been a problem, and needs a real solution (it's related to
        # the "augment does not convey additions to subclasses" issue); mixin
        # caching just makes the problem very visible. For now, don't cache if
        # the current type is not yet composed.
        my $mixin_type := self.is_composed($obj)
            ?? nqp::parameterizetype($!mixin_cache, @roles)
            !! self.generate_mixin($obj, @roles);

        # Ensure there's a mixin attribute, if we need it.
        if $need-mixin-attribute {
            my $found := $mixin_type.HOW.mixin_attribute($mixin_type);
            unless $found {
                my %ex := nqp::gethllsym('perl6', 'P6EX');
                if !nqp::isnull(%ex) && nqp::existskey(%ex, 'X::Role::Initialization') {
                    nqp::atkey(%ex, 'X::Role::Initialization')(@roles[0]);
                }
                else {
                    my $name := @roles[0].HOW.name(@roles[0]);
                    nqp::die("Can only supply an initialization value for a role if it has a single public attribute, but this is not the case for '$name'");
                }
            }
        }

        # If the original object was concrete, change its type by calling a
        # low level op. Otherwise, we just return the new type object
        nqp::isconcrete($obj) ?? nqp::rebless($obj, $mixin_type) !! $mixin_type
    }

    # Generates a new mixin. Not intended for direct use; use mixin, to hit
    # the mixin cache.
    method generate_mixin($obj, @roles) {
        # Flush its cache as promised, otherwise outdated NFAs will stick around.
        self.flush_cache($obj) if !nqp::isnull($obj) || self.is_mixin($obj);

        # Work out a type name for the post-mixed-in role.
        my @role_names;
        for @roles { @role_names.push(~$_.HOW.name($_)) }
        my $new_name := self.name($obj) ~ '+{' ~
            nqp::join(',', @role_names) ~ '}';

        my @role_shortnames;
        for @roles { my $cur := $_; @role_shortnames.push(~$_.HOW.shortname($_)); }
        my $new_shortname := $obj.HOW.shortname($obj) ~ '+{' ~
            nqp::join(',', @role_shortnames) ~ '}';

        # Create new type, derive it from ourself and then add
        # all the roles we're mixing it.
        my $new_type := self.new_type(:name($new_name), :repr($obj.REPR));
        $new_type.HOW.set_is_mixin($new_type);
        $new_type.HOW.add_parent($new_type, $obj.WHAT);
        for @roles {
            $new_type.HOW.add_role($new_type, $_);
        }
        $new_type.HOW.compose($new_type);
        $new_type.HOW.set_shortname($new_type, $new_shortname);
        $new_type.HOW.set_boolification_mode($new_type,
            nqp::existskey($new_type.HOW.method_table($new_type), 'Bool')
            || nqp::can($new_type.HOW, 'submethod_table')
                && nqp::existskey($new_type.HOW.submethod_table($new_type), 'Bool')
                ?? 0
                !! self.get_boolification_mode($obj));
        $new_type.HOW.publish_boolification_spec($new_type);

        # Locate an attribute that can serve as the initialization attribute,
        # if there is one.
        my $found;
        for $new_type.HOW.attributes($new_type, :local) {
            if $_.has_accessor {
                if $found {
                    $found := NQPMu;
                    last;
                }
                $found := $_;
            }
        }
        if $found {
            $new_type.HOW.set_mixin_attribute($new_type, $found);
        }

        $new_type
    }

    method mixin_base($obj) {
        for self.mro($obj) {
            unless $_.HOW.is_mixin($_) {
                return $_;
            }
        }
    }
}
#line 1 SETTING::src/Perl6/Metamodel/BUILDPLAN.nqp
role Perl6::Metamodel::BUILDPLAN {
    has @!BUILDALLPLAN;
    has @!BUILDPLAN;

    # Empty BUILDPLAN shared by all classes with empty BUILDPLANs
    my @EMPTY := nqp::list;

    # Creates the plan for building up the object. This works
    # out what we'll need to do up front, so we can just zip
    # through the "todo list" each time we need to make an object.
    # The plan is an array of code objects / arrays. If the element
    # is a code object, it should be called as a method without any
    # further parameters.  If it is an array, then the first element
    # of each array is an "op" # representing the task to perform:
    #   code = call as method (for BUILD or TWEAK)
    #    0 class name attr_name = set attribute from init hash
    #    1 class name attr_name = set a native int attribute from init hash
    #    2 class name attr_name = set a native num attribute from init hash
    #    3 class name attr_name = set a native str attribute from init hash
    #    4 class attr_name code = call default value closure if needed
    #    5 class attr_name code = call default value closure if needed, int attr
    #    6 class attr_name code = call default value closure if needed, num attr
    #    7 class attr_name code = call default value closure if needed, str attr
    #    8 die if a required attribute is not present
    #    9 class attr_name code = run attribute container initializer
    #   10 class attr_name = touch/vivify attribute if part of mixin
    #   11 same as 0, but init to nqp::list if value absent (nqp only)
    #   12 same as 0, but init to nqp::hash if value absent (nqp only)
    method create_BUILDPLAN($obj) {
        # First, we'll create the build plan for just this class.
        my @plan;
        my @attrs := $obj.HOW.attributes($obj, :local(1));

        # Emit any container initializers. Also build hash of attrs we
        # do not touch in any of the BUILDPLAN so we can spit out vivify
        # ops at the end.
        my %attrs_untouched;
        for @attrs {
            if nqp::can($_, 'container_initializer') {
                my $ci := $_.container_initializer;
                if nqp::isconcrete($ci) {
                    nqp::push(@plan,[9, $obj, $_.name, $ci]);
                    next;
                }
            }
            if nqp::objprimspec($_.type) == 0 {
                %attrs_untouched{$_.name} := NQPMu;
            }
        }

        # Does it have its own BUILD?
        my $build := $obj.HOW.find_method($obj, 'BUILD', :no_fallback(1));
        if !nqp::isnull($build) && $build {
            # We'll call the custom one.
            nqp::push(@plan,$build);
        }
        else {
            # No custom BUILD. Rather than having an actual BUILD
            # in Mu, we produce ops here per attribute that may
            # need initializing.
            for @attrs {
                if $_.has_accessor {
                    nqp::push(@plan,[
                      nqp::add_i(0,nqp::objprimspec($_.type)),
                      $obj,
                      $_.name,
                      nqp::substr($_.name, 2)
                    ]);
                }
            }
        }

        # Ensure that any required attributes are set
        for @attrs {
            if nqp::can($_, 'required') && $_.required {
                nqp::push(@plan,[8, $obj, $_.name, $_.required]);
                nqp::deletekey(%attrs_untouched, $_.name);
            }
        }

        # Check if there's any default values to put in place.
        for @attrs {
            if nqp::can($_, 'build') {
                my $default := $_.build;
                if nqp::isconcrete($default) {
                    nqp::push(@plan,[
                      nqp::add_i(4,nqp::objprimspec($_.type)),
                      $obj,
                      $_.name,
                      $default
                    ]);
                    nqp::deletekey(%attrs_untouched, $_.name);
                }
            }
        }

        # Add vivify instructions.
        for %attrs_untouched {
            nqp::push(@plan,[10, $obj, $_.key]);
        }

        # Does it have a TWEAK?
        my $TWEAK := $obj.HOW.find_method($obj, 'TWEAK', :no_fallback(1));
        if !nqp::isnull($TWEAK) && $TWEAK {
            nqp::push(@plan,$TWEAK);
        }

        # Something in the buildplan of this class
        if @plan {

            # Install plan for this class.
            @!BUILDPLAN := @plan;

            # Now create the full plan by getting the MRO, and working from
            # least derived to most derived, copying the plans.
            my @all_plan;
            my @mro := self.mro($obj);
            my $i := +@mro;
            my $noops := 0;
            while $i > 0 {
                $i := $i - 1;
                my $class := @mro[$i];
                for $class.HOW.BUILDPLAN($class) {
                    if nqp::islist($_) && $_[0] == 10 {   # noop in BUILDALLPLAN
                        $noops := 1;
                    }
                    else {
                        nqp::push(@all_plan, $_);
                    }
                }
            }

            # Same number of elems and no noops, identical, so just keep 1 copy
            @!BUILDALLPLAN := $noops || +@all_plan != +@plan
              ?? @all_plan
              !! @plan
        }

        # BUILDPLAN of class itself is empty
        else {

            # Share the empty BUILDPLAN
            @!BUILDPLAN := @EMPTY;

            # Take the first "super"class's BUILDALLPLAN if possible
            my @mro := self.mro($obj);
            @!BUILDALLPLAN := +@mro > 1
              ?? @mro[1].HOW.BUILDALLPLAN(@mro[1])
              !! @EMPTY    
        }
    }

    method BUILDPLAN($obj) {
        @!BUILDPLAN
    }

    method BUILDALLPLAN($obj) {
        @!BUILDALLPLAN
    }
}
#line 1 SETTING::src/Perl6/Metamodel/REPRComposeProtocol.nqp
role Perl6::Metamodel::REPRComposeProtocol {
    has $!composed_repr;

    method compose_repr($obj) {
        unless $!composed_repr {
            # Is it an array type?
            if nqp::can(self, 'is_array_type') && self.is_array_type($obj) {
                if self.attributes($obj) {
                    nqp::die("Cannot have attributes on an array representation");
                }
                nqp::composetype(nqp::decont($obj), nqp::hash('array',
                    nqp::hash('type', nqp::decont(self.array_type($obj)))));
            }

            # Otherwise, presume it's an attribute type.
            else {
                # Use any attribute information to produce attribute protocol
                # data. The protocol consists of an array...
                my @repr_info;

                # ...which contains an array per MRO entry...
                for self.mro($obj) -> $type_obj {
                    my @type_info;
                    nqp::push(@repr_info, @type_info);

                    # ...which in turn contains the current type in the MRO...
                    nqp::push(@type_info, $type_obj);

                    # ...then an array of hashes per attribute...
                    my @attrs;
                    nqp::push(@type_info, @attrs);
                    for $type_obj.HOW.attributes($type_obj, :local) -> $attr {
                        my %attr_info;
                        %attr_info<name> := $attr.name;
                        %attr_info<type> := $attr.type;
                        if $attr.box_target {
                            # Merely having the key serves as a "yes".
                            %attr_info<box_target> := 1;
                        }
                        if nqp::can($attr, 'auto_viv_container') {
                            %attr_info<auto_viv_container> := $attr.auto_viv_container;
                        }
                        if $attr.positional_delegate {
                            %attr_info<positional_delegate> := 1;
                        }
                        if $attr.associative_delegate {
                            %attr_info<associative_delegate> := 1;
                        }
                        if nqp::can($attr, 'inlined') {
                            %attr_info<inlined> := $attr.inlined;
                        }
                        nqp::push(@attrs, %attr_info);
                    }

                    # ...followed by a list of immediate parents.
                    nqp::push(@type_info, $type_obj.HOW.parents($type_obj, :local));
                }

                # Compose the representation using it.
                nqp::composetype(nqp::decont($obj), nqp::hash('attribute', @repr_info));
            }

            $!composed_repr := 1;
        }
    }

    method repr_composed($obj) {
        $!composed_repr;
    }
}
#line 1 SETTING::src/Perl6/Metamodel/InvocationProtocol.nqp
role Perl6::Metamodel::InvocationProtocol {
    has int $!has_invocation_attr;
    has $!invocation_attr_class;
    has str $!invocation_attr_name;

    has int $!has_invocation_handler;
    has $!invocation_handler;

    has int $!has_multi_attrs;
    has $!md_attr_class;
    has str $!md_valid_attr_name;
    has str $!md_cache_attr_name;

    my $default_invoke_handler;
    method set_default_invoke_handler($h) {
        $default_invoke_handler := $h;
    }

    method set_invocation_attr($obj, $class, str $name) {
        $!has_invocation_attr   := 1;
        $!invocation_attr_class := $class;
        $!invocation_attr_name  := $name;
    }

    method set_invocation_handler($obj, $handler) {
        $!has_invocation_handler := 1;
        $!invocation_handler     := $handler;
    }

    method has_invocation_attr($obj) { $!has_invocation_attr }
    method invocation_attr_class($obj) { $!invocation_attr_class }
    method invocation_attr_name($obj) { $!invocation_attr_name }

    method has_invocation_handler($obj) { $!has_invocation_handler }
    method invocation_handler($obj) { $!invocation_handler }

    method set_multi_invocation_attrs($obj, $class, str $valid_name, str $cache_name) {
        $!has_multi_attrs    := 1;
        $!md_attr_class      := $class;
        $!md_valid_attr_name := $valid_name;
        $!md_cache_attr_name := $cache_name;
    }
    method has_multi_invocation_attrs($obj) { $!has_multi_attrs }
    method multi_attr_class($obj) { $!md_attr_class }
    method multi_valid_attr_name($obj) { $!md_valid_attr_name }
    method multi_cache_attr_name($obj) { $!md_cache_attr_name }

    method compose_invocation($obj) {
        # Check if we have a invoke, and if so install
        # the default invocation forwarder. Otherwise, see if we or
        # a parent has an invocation attr.
        my $pcmeth := self.find_method($obj, 'CALL-ME', :no_fallback(1));
        if !nqp::isnull($pcmeth) && nqp::defined($pcmeth) {
            nqp::die('Default invocation handler is not invokable')
                unless nqp::isinvokable($default_invoke_handler);
            nqp::setinvokespec($obj, nqp::null(), nqp::null_s(),
                $default_invoke_handler);
        }
        else {
            for self.mro($obj) -> $class {
                if nqp::can($class.HOW, 'has_invocation_attr') {
                    if $class.HOW.has_invocation_attr($class) {
                        nqp::setinvokespec($obj,
                            $class.HOW.invocation_attr_class($class),
                            $class.HOW.invocation_attr_name($class),
                            nqp::null());
                        last;
                    }
                }
                if nqp::can($class.HOW, 'has_invocation_handler') {
                    if $class.HOW.has_invocation_handler($class) {
                        nqp::setinvokespec($obj,
                            nqp::null(), nqp::null_s(),
                            $class.HOW.invocation_handler($class));
                        last;
                    }
                }
            }

            for self.mro($obj) -> $class {
                if nqp::can($class.HOW, 'has_multi_invocation_attrs') {
                    if $class.HOW.has_multi_invocation_attrs($class) {
                        nqp::setmultispec($obj,
                            $class.HOW.multi_attr_class($class),
                            $class.HOW.multi_valid_attr_name($class),
                            $class.HOW.multi_cache_attr_name($class));
                        last;
                    }
                }
            }

        }
    }
}
#line 1 SETTING::src/Perl6/Metamodel/RolePunning.nqp
role Perl6::Metamodel::RolePunning {
    # Meta-object we use to make a pun.
    my $pun_meta;

    # Exceptions to the punning. Hash of name to actual object to call on.
    my %exceptions;

    # The pun for the current meta-object.
    has $!pun;

    # Did we make a pun?
    has $!made_pun;

    # Representation to pun to, if any.
    has str $!pun_repr;

    # Configures the punning.
    method configure_punning($my_pun_meta, %my_exceptions) {
        $pun_meta := $my_pun_meta;
        %exceptions := %my_exceptions;
    }

    method set_pun_repr($obj, $repr) {
        $!pun_repr := $repr
    }

    method pun_repr($obj) {
        $!pun_repr
    }

    # Produces the pun.
    method make_pun($obj) {
        my $pun := $!pun_repr
            ?? $pun_meta.new_type(:name(self.name($obj)), :repr($!pun_repr))
            !! $pun_meta.new_type(:name(self.name($obj)));
        $pun.HOW.add_role($pun, $obj);
        $pun.HOW.compose($pun);
        my $why := self.WHY;
        if $why {
            $pun.set_why(self.WHY);
        }
        $pun
    }

    # Returns the pun (only creating it if it wasn't already created)
    method pun($obj) {
        unless $!made_pun {
            $!pun := self.make_pun($obj);
            $!made_pun := 1;
        }
        $!pun
    }

    # Produces something that can be inherited from (the pun).
    method inheritalize($obj) {
        self.pun($obj)
    }

    # Do a pun-based dispatch. If we pun, return a thunk that will delegate.
    method find_method($obj, $name) {
        if nqp::existskey(%exceptions, $name) {
            return nqp::findmethod(%exceptions{$name}, $name);
        }
        unless $!made_pun {
            $!pun := self.make_pun($obj);
            $!made_pun := 1;
        }
        unless nqp::can($!pun, $name) {
            return nqp::null();
        }
        -> $inv, *@pos, *%named {
            $!pun."$name"(|@pos, |%named)
        }
    }
}
#line 1 SETTING::src/Perl6/Metamodel/ArrayType.nqp
# Handles type declarations that really map down to array types of some kind,
# and thus should be composed as an array-ish representation.
role Perl6::Metamodel::ArrayType {
    has int $!is_array_type;
    has $!array_type;

    method is_array_type($obj) {
        $!is_array_type
    }

    method array_type($obj) {
        $!array_type
    }

    method set_array_type($obj, $type) {
        $!is_array_type := 1;
        $!array_type := $type;
    }
}
#line 1 SETTING::src/Perl6/Metamodel/RoleToRoleApplier.nqp
my class RoleToRoleApplier {
    method apply($target, @roles) {
        # Ensure we actually have something to appply.
        unless +@roles {
            return [];
        }

        # Aggregate all of the methods sharing names, eliminating
        # any duplicates (a method can't collide with itself).
        my %meth_info;
        my %meth_providers;
        my %priv_meth_info;
        my %priv_meth_providers;
        for @roles {
            my $role := $_;
            sub build_meth_info(%methods, %meth_info_to_use, %meth_providers_to_use) {
                for %methods {
                    my $name := $_.key;
                    my $meth := $_.value;
                    my @meth_list;
                    my @meth_providers;
                    if nqp::existskey(%meth_info_to_use, $name) {
                        @meth_list := %meth_info_to_use{$name};
                        @meth_providers := %meth_providers_to_use{$name};
                    }
                    else {
                        %meth_info_to_use{$name} := @meth_list;
                        %meth_providers_to_use{$name} := @meth_providers;
                    }
                    my $found := 0;
                    for @meth_list {
                        if $meth =:= $_ {
                            $found := 1;
                        }
                        elsif nqp::can($meth, 'id') && nqp::can($_, 'id') {
                            $found := $meth.id == $_.id;
                        }
                    }
                    unless $found {
                        @meth_list.push($meth);
                        @meth_providers.push($role.HOW.name($role));
                    }
                }
            }
            build_meth_info($_.HOW.method_table($_), %meth_info, %meth_providers);
            build_meth_info($_.HOW.submethod_table($_), %meth_info, %meth_providers)
                if nqp::can($_.HOW, 'submethod_table');
            build_meth_info($_.HOW.private_method_table($_), %priv_meth_info, %priv_meth_providers)
                if nqp::can($_.HOW, 'private_method_table');
        }

        # Also need methods of target.
        my %target_meth_info := $target.HOW.method_table($target);

        # Process method list.
        for %meth_info {
            my $name := $_.key;
            my @add_meths := %meth_info{$name};

            # Do we already have a method of this name? If so, ignore all of the
            # methods we have from elsewhere.
            unless nqp::existskey(%target_meth_info, $name) {
                # No methods in the target role. If only one, it's easy...
                if +@add_meths == 1 {
                    $target.HOW.add_method($target, $name, @add_meths[0]);
                }
                else {
                    # Find if any of the methods are actually requirements, not
                    # implementations.
                    my @impl_meths;
                    for @add_meths {
                        my $yada := 0;
                        try { $yada := $_.yada; }
                        unless $yada {
                            @impl_meths.push($_);
                        }
                    }

                    # If there's still more than one possible - add to collisions list.
                    # If we got down to just one, add it. If they were all requirements,
                    # just choose one.
                    if +@impl_meths == 1 {
                        $target.HOW.add_method($target, $name, @impl_meths[0]);
                    }
                    elsif +@impl_meths == 0 {
                        $target.HOW.add_method($target, $name, @add_meths[0]);
                    }
                    else {
                        $target.HOW.add_collision($target, $name, %meth_providers{$name});
                    }
                }
            }
        }

        # Process private method list.
        if nqp::can($target.HOW, 'private_method_table') {
            my %target_priv_meth_info := $target.HOW.private_method_table($target);
            for %priv_meth_info {
                my $name := $_.key;
                my @add_meths := %priv_meth_info{$name};
                unless nqp::existskey(%target_priv_meth_info, $name) {
                    if +@add_meths == 1 {
                        $target.HOW.add_private_method($target, $name, @add_meths[0]);
                    }
                    else {
                        # Find if any of the methods are actually requirements, not
                        # implementations.
                        my @impl_meths;
                        for @add_meths {
                            my $yada := 0;
                            try { $yada := $_.yada; }
                            unless $yada {
                                @impl_meths.push($_);
                            }
                        }

                        # If there's still more than one possible - add to collisions list.
                        # If we got down to just one, add it. If they were all requirements,
                        # just choose one.
                        if +@impl_meths == 1 {
                            $target.HOW.add_private_method($target, $name, @impl_meths[0]);
                        }
                        elsif +@impl_meths == 0 {
                            # any of the method stubs will do
                            $target.HOW.add_private_method($target, $name, @add_meths[0]);
                        }
                        else {
                            $target.HOW.add_collision($target, $name, %priv_meth_providers{$name}, :private(1));
                        }
                    }
                }
            }
        }

        # Compose multi-methods; need to pay attention to the signatures.
        my %multis_by_name;
        my %multis_required_by_name;
        for @roles -> $role {
            my $how := $role.HOW;
            if nqp::can($how, 'multi_methods_to_incorporate') {
                for $how.multi_methods_to_incorporate($role) {
                    my $name := $_.name;
                    my $to_add := $_.code;
                    my $yada := 0;
                    try { $yada := $to_add.yada; }
                    if $yada {
                        %multis_required_by_name{$name} := []
                            unless %multis_required_by_name{$name};
                        nqp::push(%multis_required_by_name{$name}, $to_add);
                    }
                    else {
                        if %multis_by_name{$name} -> @existing {
                            # A multi-method can't conflict with itself.
                            my int $already := 0;
                            for @existing {
                                if $_[1] =:= $to_add {
                                    $already := 1;
                                    last;
                                }
                            }
                            nqp::push(@existing, [$role, $to_add]) unless $already;
                        }
                        else {
                            %multis_by_name{$name} := [[$role, $to_add],];
                        }
                    }
                }
            }
        }

        # Look for conflicts, and compose non-conflicting.
        for %multis_by_name {
            my $name := $_.key;
            my @cands := $_.value;
            my @collisions;
            for @cands -> $c1 {
                my @collides;
                for @cands -> $c2 {
                    unless $c1[1] =:= $c2[1] {
                        if Perl6::Metamodel::Configuration.compare_multi_sigs($c1[1], $c2[1]) {
                            for ($c1, $c2) {
                                nqp::push(@collides, $_[0].HOW.name($_[0]));
                            }
                            last;
                        }
                    }
                }
                if @collides {
                    $target.HOW.add_collision($target, $name, @collides, :multi($c1[1]));
                }
                else {
                    $target.HOW.add_multi_method($target, $name, $c1[1]);
                }
            }
        }

        # Pass on any unsatisfied requirements (note that we check for the
        # requirements being met when applying the summation of roles to a
        # class, so we can avoid duplicating that logic here.)
        for %multis_required_by_name {
            my $name := $_.key;
            for $_.value {
                $target.HOW.add_multi_method($target, $name, $_);
            }
        }

        # Now do the other bits.
        for @roles {
            my $how := $_.HOW;

            # Compose is any attributes, unless there's a conflict.
            my @attributes := $how.attributes($_, :local(1));
            for @attributes {
                my $add_attr := $_;
                my $skip := 0;
                my @cur_attrs := $target.HOW.attributes($target, :local(1));
                for @cur_attrs {
                    if $_ =:= $add_attr {
                        $skip := 1;
                    }
                    else {
                        if $_.name eq $add_attr.name {
                            nqp::die("Attribute '" ~ $_.name ~ "' conflicts in role composition");
                        }
                    }
                }
                unless $skip {
                    $target.HOW.add_attribute($target, $add_attr);
                }
            }
 
            # Any parents can also just be copied over.
            if nqp::can($how, 'parents') {
                my @parents := $how.parents($_, :local(1));
                for @parents {
                    $target.HOW.add_parent($target, $_);
                }
            }
        }

        1;
    }
}
#line 1 SETTING::src/Perl6/Metamodel/ConcreteRoleHOW.nqp
class Perl6::Metamodel::ConcreteRoleHOW
    does Perl6::Metamodel::Naming
    does Perl6::Metamodel::Versioning
    does Perl6::Metamodel::PrivateMethodContainer
    does Perl6::Metamodel::MethodContainer
    does Perl6::Metamodel::MultiMethodContainer
    does Perl6::Metamodel::AttributeContainer
    does Perl6::Metamodel::RoleContainer
    does Perl6::Metamodel::MultipleInheritance
    does Perl6::Metamodel::ArrayType
{
    # Any collisions to resolve.
    has @!collisions;

    # The (parametric) role(s) that this concrete one was directly derived
    # from.
    has @!roles;

    # Full flat list of done roles.
    has @!role_typecheck_list;

    # Are we composed yet?
    has $!composed;

    my $archetypes := Perl6::Metamodel::Archetypes.new( :nominal(1), :composable(1) );
    method archetypes() {
        $archetypes
    }

    method new(*%named) {
        nqp::findmethod(NQPMu, 'BUILDALL')(nqp::create(self), |%named)
    }

    my class Collision {
        has $!name;
        has @!roles;
        has $!private;
        has $!multi;
        method name() { $!name }
        method roles() { @!roles }
        method private() { $!private }
        method multi() { $!multi }
    }

    method new_type(:@roles, :$name = '<anon>', :$ver, :$auth, :$repr) {
        my $metarole := self.new(:roles(@roles));
        my $obj := nqp::settypehll(nqp::newtype($metarole, 'Uninstantiable'), 'perl6');
        $metarole.set_name($obj, $name);
        $metarole.set_ver($obj, $ver) if $ver;
        $metarole.set_auth($obj, $auth) if $auth;
        $obj;
    }

    method add_collision($obj, $colliding_name, @role_names, :$private = 0, :$multi) {
        @!collisions[+@!collisions] := Collision.new(
            :name($colliding_name), :roles(@role_names), :$private, :$multi
        );
    }

    method compose($obj) {
        RoleToRoleApplier.apply($obj, self.roles_to_compose($obj));
        for self.roles_to_compose($obj) {
            @!role_typecheck_list[+@!role_typecheck_list] := $_;
            for $_.HOW.role_typecheck_list($_) {
                @!role_typecheck_list[+@!role_typecheck_list] := $_;
            }
        }
        for @!roles {
            @!role_typecheck_list[+@!role_typecheck_list] := $_;
            for $_.HOW.role_typecheck_list($_) {
                @!role_typecheck_list[+@!role_typecheck_list] := $_;
            }
        }
        self.publish_type_cache($obj);
        $!composed := 1;
        $obj
    }

    method is_composed($obj) {
        $!composed ?? 1 !! 0
    }

    method collisions($obj) {
        @!collisions
    }

    method roles($obj, :$transitive = 1) {
        if $transitive {
            my @trans;
            for @!roles {
                @trans.push($_);
                for $_.HOW.roles($_) {
                    @trans.push($_);
                }
            }
        }
        else {
            @!roles
        }
    }

    method add_to_role_typecheck_list($obj, $type) {
        @!role_typecheck_list[+@!role_typecheck_list] := $type;
    }

    method role_typecheck_list($obj) {
        @!role_typecheck_list
    }

    method type_check($obj, $checkee) {
        my $decont := nqp::decont($checkee);
        if $decont =:= $obj.WHAT {
            return 1;
        }
        for @!role_typecheck_list {
            if nqp::decont($_) =:= $decont {
                return 1;
            }
        }
        0
    }

    method publish_type_cache($obj) {
        my @types := [$obj.WHAT];
        for @!role_typecheck_list { @types.push($_) }
        nqp::settypecache($obj, @types)
    }

    method mro($obj) {
        [$obj]
    }
}
#line 1 SETTING::src/Perl6/Metamodel/CurriedRoleHOW.nqp
# Sometimes, we see references to roles that provide parameters but
# do not fully resolve them. For example, in:
#
#   class C does R[T] { }
#
# We need to represent R[T], but we cannot yet fully specialize the
# role because we don't have the first parameter to hand. We may also
# run into the issue where we have things like:
#
#   sub foo(R[T] $x) { ... }
#   if $x ~~ R[T] { ... }
#
# Where we clearly want to talk about a partial parameterization of a
# role and actually want to do so in a way distinct from a particular
# instantiation of it. This meta-object represents those "partial types"
# as both a way to curry on your way to a full specialization, but also
# as a way to do type-checking or punning.
class Perl6::Metamodel::CurriedRoleHOW
    does Perl6::Metamodel::RolePunning
    does Perl6::Metamodel::TypePretense
    does Perl6::Metamodel::Naming
{
    has $!curried_role;
    has @!pos_args;
    has %!named_args;

    my $archetypes_g := Perl6::Metamodel::Archetypes.new( :composable(1), :inheritalizable(1), :parametric(1), :generic(1) );
    my $archetypes_ng := Perl6::Metamodel::Archetypes.new( :nominal(1), :composable(1), :inheritalizable(1), :parametric(1) );
    method archetypes() {
        if nqp::isconcrete(self) {
            for @!pos_args {
                if $_.HOW.archetypes.generic {
                    return $archetypes_g;
                }
            }
            for %!named_args {
                if $_.value.HOW.archetypes.generic {
                    return $archetypes_g;
                }
            }
        }
        $archetypes_ng
    }

    method new(*%named) {
        nqp::findmethod(NQPMu, 'BUILDALL')(nqp::create(self), |%named)
    }

    method new_type($curried_role, *@pos_args, *%named_args) {
        # construct a name
        my $name := $curried_role.HOW.name($curried_role);
        if @pos_args {
            my @pieces := nqp::list_s();
            for @pos_args {
                nqp::push_s(@pieces, $_.HOW.name($_));
            }
            $name := $name ~ "[" ~ nqp::join(",", @pieces) ~ "]";
        }

        my $meta := self.new(:curried_role($curried_role), :pos_args(@pos_args),
            :named_args(%named_args), :name($name));
        my $type := nqp::settypehll(nqp::newtype($meta, 'Uninstantiable'), 'perl6');
        nqp::settypecheckmode($type, 2)
    }

    method instantiate_generic($obj, $type_env) {
        my @new_pos;
        my %new_named;
        for @!pos_args {
            @new_pos.push($_.HOW.archetypes.generic ??
                $_.HOW.instantiate_generic($_, $type_env) !!
                $_);
        }
        for %!named_args {
            %new_named{$_.key} := $_.value.HOW.archetypes.generic ??
                $_.value.HOW.instantiate_generic($_.value, $type_env) !!
                $_.value;
        }
        self.new_type($!curried_role, |@new_pos, |%new_named)
    }

    method specialize($obj, $first_arg) {
        $!curried_role.HOW.specialize($!curried_role, $first_arg,
            |@!pos_args, |%!named_args);
    }

    method curried_role($obj) {
        $!curried_role
    }

    method role_arguments($obj) {
        @!pos_args
    }

    method roles($obj, :$transitive = 1) {
        $!curried_role.HOW.roles($obj, :$transitive)
    }

    method role_typecheck_list($obj) {
        $!curried_role.HOW.role_typecheck_list($obj)
    }

    method type_check($obj, $checkee) {
        $!curried_role.HOW.type_check($!curried_role, $checkee)
    }

    method accepts_type($obj, $checkee) {
        # First, we locate candidate curryings to check against. If
        # the checkee is itself a curried role, it also goes in. Note
        # that we only want those that have the same parametric role
        # as us.
        my @cands;
        my $crdc := nqp::decont($!curried_role);
        if nqp::istype($checkee.HOW, self.WHAT) {
            if nqp::decont($checkee.HOW.curried_role($checkee)) =:= $crdc {
                @cands.push($checkee);
            }
        }
        if nqp::can($checkee.HOW, 'role_typecheck_list') {
            for $checkee.HOW.role_typecheck_list($checkee) {
                if nqp::istype($_.HOW, self.WHAT) && !$_.HOW.archetypes.generic {
                    if nqp::decont($_.HOW.curried_role($_)) =:= $crdc {
                        @cands.push($_);
                    }
                }
            }
        }

        # Provided we have some candidates, check the arguments.
        my $num_args := +@!pos_args;
        if @cands {
            for @cands {
                my @try_args := $_.HOW.role_arguments($_);
                if +@try_args == $num_args {
                    my $i := 0;
                    my $ok := 1;
                    while $i < +$num_args {
                        if !@!pos_args[$i].ACCEPTS(@try_args[$i]) {
                            $ok := 0;
                            $i := $num_args;
                        }
                        $i := $i + 1;
                    }
                    if $ok {
                        return 1;
                    }
                }
            }
        }

        0;
    }

    method shortname($curried_role) {
        $curried_role.HOW.name($curried_role);
    }

}

#line 1 SETTING::src/Perl6/Metamodel/ParametricRoleHOW.nqp
my $concrete := Perl6::Metamodel::ConcreteRoleHOW;
my $currier := Perl6::Metamodel::CurriedRoleHOW;
class Perl6::Metamodel::ParametricRoleHOW
    does Perl6::Metamodel::Naming
    does Perl6::Metamodel::Documenting
    does Perl6::Metamodel::Versioning
    does Perl6::Metamodel::MethodContainer
    does Perl6::Metamodel::PrivateMethodContainer
    does Perl6::Metamodel::MultiMethodContainer
    does Perl6::Metamodel::AttributeContainer
    does Perl6::Metamodel::RoleContainer
    does Perl6::Metamodel::MultipleInheritance
    does Perl6::Metamodel::Stashing
    does Perl6::Metamodel::TypePretense
    does Perl6::Metamodel::RolePunning
    does Perl6::Metamodel::ArrayType
{
    has $!composed;
    has $!body_block;
    has $!in_group;
    has $!group;
    has $!signatured;
    has @!role_typecheck_list;
    has $!specialize_lock;

    my $archetypes := Perl6::Metamodel::Archetypes.new( :nominal(1), :composable(1), :inheritalizable(1), :parametric(1) );
    method archetypes() {
        $archetypes
    }

    method new(*%named) {
        nqp::findmethod(NQPMu, 'BUILDALL')(nqp::create(self), |%named)
    }

    method new_type(:$name, :$ver, :$auth, :$repr, :$signatured, *%extra) {
        my $metarole := self.new(:signatured($signatured), :specialize_lock(NQPLock.new));
        my $type := nqp::settypehll(nqp::newtype($metarole, 'Uninstantiable'), 'perl6');
        $metarole.set_name($type, $name // "<anon|{nqp::objectid($metarole)}>");
        $metarole.set_ver($type, $ver) if $ver;
        $metarole.set_auth($type, $auth) if $auth;
        $metarole.set_pun_repr($type, $repr) if $repr;
        if nqp::existskey(%extra, 'group') {
            $metarole.set_group($type, %extra<group>);
        }
        self.add_stash($type);
    }

    method parameterize($obj, *@pos_args, *%named_args) {
        $currier.new_type($obj, |@pos_args, |%named_args)
    }

    method set_body_block($obj, $block) {
        $!body_block := $block
    }

    method body_block($obj) {
        $!body_block
    }

    method signatured($obj) {
        $!signatured
    }

    method set_group($obj, $group) {
        $!group := $group;
        $!in_group := 1;
    }

    method group($obj) {
        $!in_group ?? $!group !! $obj
    }

    method compose($obj, :$compiler_services) {
        my @rtl;
        if $!in_group {
            @rtl.push($!group);
        }
        for self.roles_to_compose($obj) {
            @rtl.push($_);
            for $_.HOW.role_typecheck_list($_) {
                @rtl.push($_);
            }
        }
        @!role_typecheck_list := @rtl;
        $!composed := 1;
        $obj
    }

    method is_composed($obj) {
        $!composed
    }

    method roles($obj, :$transitive = 1) {
        if $transitive {
            my @result;
            for self.roles_to_compose($obj) {
                @result.push($_);
                for $_.HOW.roles($_, :transitive(1)) {
                    @result.push($_)
                }
            }
            @result
        }
        else {
            self.roles_to_compose($obj)
        }
    }

    method role_typecheck_list($obj) {
        @!role_typecheck_list
    }

    method type_check($obj, $checkee) {
        my $decont := nqp::decont($checkee);
        if $decont =:= $obj.WHAT {
            return 1;
        }
        if $!in_group && $decont =:= $!group {
            return 1;
        }
        for self.pretending_to_be() {
            if $decont =:= nqp::decont($_) {
                return 1;
            }
        }
        for self.roles_to_compose($obj) {
            if nqp::istype($checkee, $_) {
                return 1;
            }
        }
        0
    }

    method specialize($obj, *@pos_args, *%named_args) {
        # We only allow one specialization of a role to take place at a time,
        # since the body block captures the methods into its lexical scope,
        # but we don't do the appropriate cloning until a bit later. These
        # must happen before another specialize happens and re-captures the
        # things we are composing.
        $!specialize_lock.protect({
            # Run the body block to get the type environment (we know
            # the role in this case).
            my $type_env;
            my $error;
            try {
                my @result := $!body_block(|@pos_args, |%named_args);
                $type_env := @result[1];
                CATCH {
                    $error := $!
                }
            }
            if $error {
                nqp::die("Could not instantiate role '" ~ self.name($obj)
                         ~ "':\n" ~ nqp::getpayload($error))
            }

            # Use it to build concrete role.
            self.specialize_with($obj, $type_env, @pos_args)
        })
    }

    method specialize_with($obj, $type_env, @pos_args) {
        # Create a concrete role.
        my $conc := $concrete.new_type(:roles([$obj]), :name(self.name($obj)));

        # Go through attributes, reifying as needed and adding to
        # the concrete role.
        for self.attributes($obj, :local(1)) {
            $conc.HOW.add_attribute($conc,
                $_.is_generic ?? $_.instantiate_generic($type_env) !! $_);
        }

        # Go through methods and instantiate them; we always do this
        # unconditionally, since we need the clone anyway.
        for self.method_table($obj) {
            $conc.HOW.add_method($conc, $_.key, $_.value.instantiate_generic($type_env))
        }
        for self.submethod_table($obj) {
            $conc.HOW.add_method($conc, $_.key, $_.value.instantiate_generic($type_env))
        }
        for self.private_method_table($obj) {
            $conc.HOW.add_private_method($conc, $_.key, $_.value.instantiate_generic($type_env));
        }
        for self.multi_methods_to_incorporate($obj) {
            $conc.HOW.add_multi_method($conc, $_.name, $_.code.instantiate_generic($type_env))
        }

        # Roles done by this role need fully specializing also; all
        # they'll be missing is the target class (e.g. our first arg).
        for self.roles_to_compose($obj) {
            my $r := $_;
            if $_.HOW.archetypes.generic {
                $r := $r.HOW.instantiate_generic($r, $type_env);
                $conc.HOW.add_to_role_typecheck_list($conc, $r);
            }
            $conc.HOW.add_role($conc, $r.HOW.specialize($r, @pos_args[0]));
        }

        # Pass along any parents that have been added, resolving them in
        # the case they're generic (role Foo[::T] is T { })
        for self.parents($obj, :local(1)) {
            my $p := $_;
            if $_.HOW.archetypes.generic {
                $p := $p.HOW.instantiate_generic($p, $type_env);
            }
            $conc.HOW.add_parent($conc, $p);
        }

        # Resolve any array type being passed along (only really used in the
        # punning case, since roles are the way we get generic types).
        if self.is_array_type($obj) {
            my $at := self.array_type($obj);
            if $at.HOW.archetypes.generic {
                $at := $at.HOW.instantiate_generic($at, $type_env);
            }
            $conc.HOW.set_array_type($conc, $at);
        }

        $conc.HOW.compose($conc);
        return $conc;
    }

    method mro($obj) {
        [$obj]
    }
}
#line 1 SETTING::src/Perl6/Metamodel/ParametricRoleGroupHOW.nqp
# This represents a group of parametric roles. For example, given
# we have the declarations:
#
#   role Foo[] { } # (which is same as role Foo { })
#   role Foo[::T] { }
#   role Foo[::T1, ::T2] { }
#
# Each of them results in a type object that has a HOW of type
# Perl6::Metamodel::ParametricRoleHOW. In here, we keep the whole
# group of those, and know how to specialize to a certain parameter
# list by multi-dispatching over the set of candidates to pick
# a particular candidate.
class Perl6::Metamodel::ParametricRoleGroupHOW
    does Perl6::Metamodel::Naming
    does Perl6::Metamodel::Documenting
    does Perl6::Metamodel::Stashing
    does Perl6::Metamodel::TypePretense
    does Perl6::Metamodel::RolePunning
    does Perl6::Metamodel::BoolificationProtocol
{
    has @!candidates;
    has $!selector;
    has @!role_typecheck_list;

    my $archetypes := Perl6::Metamodel::Archetypes.new( :nominal(1), :composable(1), :inheritalizable(1), :parametric(1) );
    method archetypes() {
        $archetypes
    }

    method new(*%named) {
        nqp::findmethod(NQPMu, 'BUILDALL')(nqp::create(self), |%named)
    }

    my $selector_creator;
    method set_selector_creator($sc) {
        $selector_creator := $sc;
    }

    method new_type(:$name!, :$repr) {
        # Build and configure the type's basic details.
        my $meta := self.new(:selector($selector_creator()));
        my $type_obj := nqp::settypehll(nqp::newtype($meta, 'Uninstantiable'), 'perl6');
        $meta.set_name($type_obj, $name);
        $meta.set_pun_repr($meta, $repr) if $repr;
        $meta.set_boolification_mode($type_obj, 5);
        $meta.publish_boolification_spec($type_obj);
        self.add_stash($type_obj);

        # We use 6model parametrics to make this a parametric type on the
        # arguments we curry with. This means we'll make the curries unique.
        nqp::setparameterizer($type_obj, sub ($type, @packed) {
            $type.HOW.'!produce_parameterization'($type, @packed);
        });

        $type_obj
    }

    # We only take positional args into account for the parametric key. If
    # there are no nameds, we push this class in place of them so as to make
    # an otherwise equal key always the same, and named args make it always
    # unequal.
    my class NO_NAMEDS { }

    method parameterize($obj, *@args, *%named_args) {
        my int $i := 0;
        my int $n := nqp::elems(@args);
        while $i < $n {
            @args[$i] := nqp::decont(@args[$i]);
            $i++;
        }
        nqp::push(@args, %named_args || NO_NAMEDS);
        nqp::parameterizetype($obj, @args);
    }

    method !produce_parameterization($obj, @packed) {
        my @args := nqp::clone(@packed);
        my $maybe_nameds := nqp::pop(@args);
        my $curried;
        if $maybe_nameds {
            my %nameds := $maybe_nameds;
            $curried := $currier.new_type($obj, |@args, |%nameds);
        }
        else {
            $curried := $currier.new_type($obj, |@args);
        }
        $curried.HOW.set_pun_repr($curried, self.pun_repr($obj));
        $curried
    }

    method add_possibility($obj, $possible) {
        @!candidates[+@!candidates] := $possible;
        $!selector.add_dispatchee($possible.HOW.body_block($possible));
        self.update_role_typecheck_list($obj);
    }

    method specialize($obj, *@pos_args, *%named_args) {
        # Use multi-dispatcher to pick the body block of the best role.
        my $error;
        my $selected_body;
        try {
            sub try_select(*@pos, *%named) {
                $!selector.find_best_dispatchee(nqp::usecapture(), 0)
            }
            $selected_body := try_select(|@pos_args, |%named_args);
            CATCH { $error := $! }
        }
        if $error {
            my %ex := nqp::gethllsym('perl6', 'P6EX');
            if nqp::existskey(%ex, 'X::Role::Parametric::NoSuchCandidate') {
                %ex{'X::Role::Parametric::NoSuchCandidate'}($obj);
            }
            nqp::die("Could not find an appropriate parametric role variant for '" ~
                self.name($obj) ~ "' using the arguments supplied.\n" ~
                $error);
        }

        # Locate the role that has that body block.
        my $selected := NQPMu;
        for @!candidates {
            if $_.HOW.body_block($_) =:= $selected_body {
                $selected := $_;
                last;
            }
        }
        if $selected =:= NQPMu {
            nqp::die("Internal error: could not resolve body block to role candidate");
        }

        # Having picked the appropriate one, specialize it.
        $selected.HOW.specialize($selected, |@pos_args, |%named_args);
    }

    method update_role_typecheck_list($obj) {
        for @!candidates {
            if !$_.HOW.signatured($_) {
                @!role_typecheck_list := $_.HOW.role_typecheck_list($_);
            }
        }
    }

    method role_typecheck_list($obj) {
        @!role_typecheck_list
    }

    method type_check($obj, $checkee) {
        my $decont := nqp::decont($checkee);
        if $decont =:= $obj.WHAT {
            return 1;
        }
        for self.pretending_to_be() {
            if $decont =:= nqp::decont($_) {
                return 1;
            }
        }
        for @!role_typecheck_list {
            if $decont =:= nqp::decont($_) {
                return 1;
            }
        }
        0;
    }

    method candidates($obj) { nqp::clone(@!candidates) }

    method lookup($obj, $name) {
        my $c := self.'!get_default_candidate'($obj);
        $c.HOW.lookup($c, $name);
    }

    method methods($obj, *@pos, *%name) {
        my $c := self.'!get_default_candidate'($obj);
        $c.HOW.methods($c, |@pos, |%name);
    }

    method attributes($obj, *@pos, *%name) {
        my $c := self.'!get_default_candidate'($obj);
        $c.HOW.attributes($c, |@pos, |%name);
    }

    method roles($obj, *%named) {
        my $c := self.'!get_default_candidate'($obj);
        $c.HOW.roles($c, |%named)
    }

    method ver($obj) {
        my $c := self.'!get_default_candidate'($obj);
        $c.HOW.ver($c)
    }

    method auth($obj) {
        my $c := self.'!get_default_candidate'($obj);
        $c.HOW.auth($c)
    }

    method !get_default_candidate($obj) {
        @!candidates[0]
    }
}
#line 1 SETTING::src/Perl6/Metamodel/RoleToClassApplier.nqp
my class RoleToClassApplier {
    sub has_method($target, $name, $local) {
        if $local {
            my %mt := $target.HOW.method_table($target);
            return 1 if nqp::existskey(%mt, $name);
            %mt := $target.HOW.submethod_table($target);
            return nqp::existskey(%mt, $name);
        }
        else {
            for $target.HOW.mro($target) {
                my %mt := $_.HOW.method_table($_);
                if nqp::existskey(%mt, $name) {
                    return 1;
                }
                %mt := $_.HOW.submethod_table($_);
                if nqp::existskey(%mt, $name) {
                    return 1;
                }
            }
            return 0;
        }
    }

    sub has_private_method($target, $name) {
        my %pmt := $target.HOW.private_method_table($target);
        return nqp::existskey(%pmt, $name)
    }

    sub has_attribute($target, $name) {
        my @attributes := $target.HOW.attributes($target, :local(1));
        for @attributes {
            if $_.name eq $name { return 1; }
        }
        return 0;
    }
    sub has_public_attribute($target, $name) {
        my @attributes := $target.HOW.attributes($target, :local(1));
        for @attributes {
            return 1 if nqp::eqat($_.name, $name, 2) && $_.has_accessor;
        }
        return 0;
    }

    method apply($target, @roles) {
        # If we have many things to compose, then get them into a single helper
        # role first.
        my $to_compose;
        my $to_compose_meta;
        if +@roles == 1 {
            $to_compose := @roles[0];
            $to_compose_meta := $to_compose.HOW;
        }
        else {
            $to_compose := $concrete.new_type();
            $to_compose_meta := $to_compose.HOW;
            for @roles {
                $to_compose_meta.add_role($to_compose, $_);
            }
            $to_compose := $to_compose_meta.compose($to_compose);
        }

        # Collisions?
        my @collisions := $to_compose_meta.collisions($to_compose);
        for @collisions {
            if $_.private {
                unless has_private_method($target, $_.name) {
                    nqp::die("Private method '" ~ $_.name ~
                        "' must be resolved by class " ~
                        $target.HOW.name($target) ~
                        " because it exists in multiple roles (" ~
                        nqp::join(", ", $_.roles) ~ ")");
                }
            }
            elsif nqp::isconcrete($_.multi) {
                my $match := 0;
                for $target.HOW.multi_methods_to_incorporate($target) -> $maybe {
                    if $_.name eq $maybe.name &&
                            Perl6::Metamodel::Configuration.compare_multi_sigs($_.multi, $maybe.code) {
                        $match := 1;
                        last;
                    }
                }
                unless $match {
                    nqp::die("Multi method '" ~ $_.name ~ "' with signature " ~
                        $_.multi.signature.perl ~ " must be resolved by class " ~
                        $target.HOW.name($target) ~
                        " because it exists in multiple roles (" ~
                        nqp::join(", ", $_.roles) ~ ")");
                }
            }
            else {
                unless has_method($target, $_.name, 1) {
                    nqp::die("Method '" ~ $_.name ~
                        "' must be resolved by class " ~
                        $target.HOW.name($target) ~
                        " because it exists in multiple roles (" ~
                        nqp::join(", ", $_.roles) ~ ")");
                }
            }
        }

        # Compose in any methods.
        sub compose_method_table(%methods) {
            for %methods {
                my $name := $_.key;
                my $yada := 0;
                try { $yada := $_.value.yada }
                if $yada {
                    unless has_method($target, $name, 0)
                            || has_public_attribute($target, $name) {
                        my @needed;
                        for @roles {
                            for $_.HOW.method_table($_) -> $m {
                                if $m.key eq $name {
                                    nqp::push(@needed, $_.HOW.name($_));
                                }
                            }
                        }
                        nqp::die("Method '$name' must be implemented by " ~
                                 $target.HOW.name($target) ~
                                 " because it is required by roles: " ~
                                 nqp::join(", ", @needed) ~ ".");
                    }
                }
                elsif !has_method($target, $name, 1) {
                    $target.HOW.add_method($target, $name, $_.value);
                }
            }
        }
        compose_method_table($to_compose_meta.method_table($to_compose));
        compose_method_table($to_compose_meta.submethod_table($to_compose))
            if nqp::can($to_compose_meta, 'submethod_table');
        if nqp::can($to_compose_meta, 'private_method_table') {
            for $to_compose_meta.private_method_table($to_compose) {
                unless has_private_method($target, $_.key) {
                    $target.HOW.add_private_method($target, $_.key, $_.value);
                }
            }
        }

        # Compose in any multi-methods, looking for any requirements and
        # ensuring they are met.
        if nqp::can($to_compose_meta, 'multi_methods_to_incorporate') {
            my @multis := $to_compose_meta.multi_methods_to_incorporate($to_compose);
            my @required;
            for @multis -> $add {
                my $yada := 0;
                try { $yada := $add.code.yada }
                if $yada {
                    nqp::push(@required, $add);
                }
                else {
                    my $already := 0;
                    for $target.HOW.multi_methods_to_incorporate($target) -> $existing {
                        if $existing.name eq $add.name {
                            if Perl6::Metamodel::Configuration.compare_multi_sigs($existing.code, $add.code) {
                                $already := 1;
                                last;
                            }
                        }
                    }
                    unless $already {
                        $target.HOW.add_multi_method($target, $add.name, $add.code);
                    }
                }
                for @required -> $req {
                    my $satisfaction := 0;
                    for $target.HOW.multi_methods_to_incorporate($target) -> $existing {
                        if $existing.name eq $req.name {
                            if Perl6::Metamodel::Configuration.compare_multi_sigs($existing.code, $req.code) {
                                $satisfaction := 1;
                                last;
                            }
                        }
                    }
                    unless $satisfaction {
                        my $name := $req.name;
                        my $sig := $req.code.signature.perl;
                        nqp::die("Multi method '$name' with signature $sig must be implemented by " ~
                            $target.HOW.name($target) ~
                            " because it is required by a role");
                    }
                }
            }
        }

        # Compose in any role attributes.
        my @attributes := $to_compose_meta.attributes($to_compose, :local(1));
        for @attributes {
            if has_attribute($target, $_.name) {
                nqp::die("Attribute '" ~ $_.name ~ "' already exists in the class '" ~
                    $target.HOW.name($target) ~ "', but a role also wishes to compose it");
            }
            $target.HOW.add_attribute($target, $_);
        }

        # Compose in any parents.
        if nqp::can($to_compose_meta, 'parents') {
            my @parents := $to_compose_meta.parents($to_compose, :local(1));
            for @parents {
                $target.HOW.add_parent($target, $_);
            }
        }

        # Copy any array_type.
        if nqp::can($target.HOW, 'is_array_type') && !$target.HOW.is_array_type($target) {
            if nqp::can($to_compose_meta, 'is_array_type') {
                if $to_compose_meta.is_array_type($to_compose) {
                    $target.HOW.set_array_type($target, $to_compose_meta.array_type($to_compose));
                }
            }
        }

        1;
    }
}
#line 1 SETTING::src/Perl6/Metamodel/ClassHOW.nqp
class Perl6::Metamodel::ClassHOW
    does Perl6::Metamodel::Naming
    does Perl6::Metamodel::Documenting
    does Perl6::Metamodel::Versioning
    does Perl6::Metamodel::Stashing
    does Perl6::Metamodel::AttributeContainer
    does Perl6::Metamodel::MethodContainer
    does Perl6::Metamodel::PrivateMethodContainer
    does Perl6::Metamodel::MultiMethodContainer
    does Perl6::Metamodel::MetaMethodContainer
    does Perl6::Metamodel::RoleContainer
    does Perl6::Metamodel::MultipleInheritance
    does Perl6::Metamodel::DefaultParent
    does Perl6::Metamodel::C3MRO
    does Perl6::Metamodel::MROBasedMethodDispatch
    does Perl6::Metamodel::MROBasedTypeChecking
    does Perl6::Metamodel::Trusting
    does Perl6::Metamodel::BUILDPLAN
    does Perl6::Metamodel::Mixins
    does Perl6::Metamodel::ArrayType
    does Perl6::Metamodel::BoolificationProtocol
    does Perl6::Metamodel::REPRComposeProtocol
    does Perl6::Metamodel::InvocationProtocol
    does Perl6::Metamodel::Finalization
{
    has @!roles;
    has @!role_typecheck_list;
    has @!concretizations;
    has @!fallbacks;
    has $!composed;

    my $archetypes := Perl6::Metamodel::Archetypes.new(
        :nominal(1), :inheritable(1), :augmentable(1) );
    method archetypes() {
        $archetypes
    }

    method new(*%named) {
        nqp::findmethod(NQPMu, 'BUILDALL')(nqp::create(self), |%named)
    }

    method new_type(:$name, :$repr = 'P6opaque', :$ver, :$auth) {
        my $metaclass := self.new();
        my $obj := nqp::settypehll(nqp::newtype($metaclass, $repr), 'perl6');
        $metaclass.set_name($obj, $name // "<anon|{nqp::objectid($metaclass)}>");
        self.add_stash($obj);
        $metaclass.set_ver($obj, $ver) if $ver;
        $metaclass.set_auth($obj, $auth) if $auth;
        $metaclass.setup_mixin_cache($obj);
        nqp::setboolspec($obj, 5, nqp::null());
        $obj
    }

    # Adds a new fallback for method dispatch. Expects the specified
    # condition to have been met (passes it the object and method name),
    # and if it is calls $calculator with the object and method name to
    # calculate an invokable object.
    method add_fallback($obj, $condition, $calculator) {
        # Adding a fallback means any method cache is no longer authoritative.
        nqp::setmethcacheauth($obj, 0);

        # Add it.
        my %desc;
        %desc<cond> := $condition;
        %desc<calc> := $calculator;
        @!fallbacks[+@!fallbacks] := %desc;
    }

    method compose($obj, :$compiler_services) {
        # Instantiate all of the roles we have (need to do this since
        # all roles are generic on ::?CLASS) and pass them to the
        # composer.
        my @roles_to_compose := self.roles_to_compose($obj);
        if @roles_to_compose {
            my @ins_roles;
            while @roles_to_compose {
                my $r := @roles_to_compose.pop();
                @!roles[+@!roles] := $r;
                @!role_typecheck_list[+@!role_typecheck_list] := $r;
                my $ins := $r.HOW.specialize($r, $obj);
                @ins_roles.push($ins);
                nqp::push(@!concretizations, [$r, $ins]);
            }
            self.compute_mro($obj); # to the best of our knowledge, because the role applier wants it.
            RoleToClassApplier.apply($obj, @ins_roles);

            # Add them to the typecheck list, and pull in their
            # own type check lists also.
            for @ins_roles {
                @!role_typecheck_list[+@!role_typecheck_list] := $_;
                for $_.HOW.role_typecheck_list($_) {
                    @!role_typecheck_list[+@!role_typecheck_list] := $_;
                }
            }
        }

        # Some things we only do if we weren't already composed once, like
        # building the MRO.
        my $was_composed := $!composed;
        unless $!composed {
            if self.parents($obj, :local(1)) == 0 && self.has_default_parent_type && self.name($obj) ne 'Mu' {
                self.add_parent($obj, self.get_default_parent_type);
            }
            self.compute_mro($obj);
            $!composed := 1;
        }

        # Incorporate any new multi candidates (needs MRO built).
        self.incorporate_multi_candidates($obj);

        # Set up finalization as needed.
        self.setup_finalization($obj);

        # Compose attributes.
        self.compose_attributes($obj, :$compiler_services);

        # See if we have a Bool method other than the one in the top type.
        # If not, all it does is check if we have the type object.
        unless self.get_boolification_mode($obj) != 0 {
            my $i := 0;
            my @mro := self.mro($obj);
            while $i < +@mro {
                my $ptype := @mro[$i];
                last if nqp::existskey($ptype.HOW.method_table($ptype), 'Bool');
                last if nqp::can($ptype.HOW, 'submethod_table') &&
                    nqp::existskey($ptype.HOW.submethod_table($ptype), 'Bool');
                $i := $i + 1;
            }
            if $i + 1 == +@mro {
                self.set_boolification_mode($obj, 5)
            }
        }

        # If there's a FALLBACK method, register something to forward calls to it.
        my $FALLBACK := self.find_method($obj, 'FALLBACK', :no_fallback);
        if !nqp::isnull($FALLBACK) && nqp::defined($FALLBACK) {
            self.add_fallback($obj,
                sub ($obj, str $name) {
                    $name ne 'sink' && $name ne 'CALL-ME'
                },
                sub ($obj, str $name) {
                    -> $inv, *@pos, *%named { $FALLBACK($inv, $name, |@pos, |%named) }
                });
        }

        # This isn't an augment.
        unless $was_composed {

            # Create BUILDPLAN.
            self.create_BUILDPLAN($obj);

            # If the BUILDPLAN is not empty, we should attempt to auto-
            # generate a BUILDALL method.  If the BUILDPLAN is empty, then
            # the BUILDALL of the parent is already good enough.  We can
            # only auto-generate a BUILDALL method if we have compiler
            # services.  If we don't, then BUILDALL will fall back to the
            # one in Mu, which will iterate over the BUILDALLPLAN.
            if self.BUILDPLAN($obj) && nqp::isconcrete($compiler_services) {

                # Class does not appear to have a BUILDALL yet
                unless nqp::existskey($obj.HOW.submethod_table($obj),'BUILDALL')
                  || nqp::existskey($obj.HOW.method_table($obj),'BUILDALL') {
                    my $builder := nqp::findmethod(
                      $compiler_services,'generate_buildplan_executor');
                    my $method :=
                      $builder($compiler_services,$obj,self.BUILDALLPLAN($obj));

                    # We have a generated BUILDALL submethod, so install!
                    unless $method =:= NQPMu {
                        $method.set_name('BUILDALL');
                        self.add_method($obj,'BUILDALL',$method);
                    }
                }
            }

            # Compose the representation
            self.compose_repr($obj);
        }

        # Publish type and method caches.
        self.publish_type_cache($obj);
        self.publish_method_cache($obj);
        self.publish_boolification_spec($obj);

        # Compose the meta-methods.
        self.compose_meta_methods($obj);

        # Compose invocation protocol.
        self.compose_invocation($obj);

        $obj
    }

    method roles($obj, :$local, :$transitive = 1) {
        my @result;
        for @!roles {
            @result.push($_);
            if $transitive {
                for $_.HOW.roles($_, :transitive(1)) {
                    @result.push($_);
                }
            }
        }
        unless $local {
            my $first := 1;
            for self.mro($obj) {
                if $first {
                    $first := 0;
                    next;
                }
                for $_.HOW.roles($_, :$transitive, :local(1)) {
                    @result.push($_);
                }
            }
        }
        @result
    }

    method role_typecheck_list($obj) {
        @!role_typecheck_list
    }

    method concretization($obj, $ptype) {
        for @!concretizations {
            if nqp::decont($_[0]) =:= nqp::decont($ptype) {
                return $_[1];
            }
        }
        nqp::die("No concretization found for " ~ $ptype.HOW.name($ptype));
    }

    method is_composed($obj) {
        $!composed
    }

    # Stuff for junctiony dispatch fallback.
    my $junction_type;
    my $junction_autothreader;
    method setup_junction_fallback($type, $autothreader) {
        nqp::setmethcacheauth($type, 0);
        $junction_type := $type;
        $junction_autothreader := $autothreader;
    }

    # Handles the various dispatch fallback cases we have.
    method find_method_fallback($obj, $name) {
        # If the object is a junction, need to do a junction dispatch.
        if $obj.WHAT =:= $junction_type && $junction_autothreader {
            my $p6name := nqp::hllizefor($name, 'perl6');
            return -> *@pos_args, *%named_args {
                $junction_autothreader($p6name, |@pos_args, |%named_args)
            };
        }

        # Consider other fallbacks, if we have any.
        for @!fallbacks {
            if ($_<cond>)($obj, $name) {
                return ($_<calc>)($obj, $name);
            }
        }

        # Otherwise, didn't find anything.
        nqp::null()
    }

    # Does the type have any fallbacks?
    method has_fallbacks($obj) {
        return nqp::istype($obj, $junction_type) || +@!fallbacks;
    }
}
#line 1 SETTING::src/Perl6/Metamodel/GrammarHOW.nqp
class Perl6::Metamodel::GrammarHOW
    is Perl6::Metamodel::ClassHOW
    does Perl6::Metamodel::DefaultParent
{
}
#line 1 SETTING::src/Perl6/Metamodel/NativeHOW.nqp
class Perl6::Metamodel::NativeHOW
    does Perl6::Metamodel::Naming
    does Perl6::Metamodel::Documenting
    does Perl6::Metamodel::Versioning
    does Perl6::Metamodel::Stashing
    does Perl6::Metamodel::MultipleInheritance
    does Perl6::Metamodel::C3MRO
    does Perl6::Metamodel::MROBasedMethodDispatch
    does Perl6::Metamodel::MROBasedTypeChecking
{
    has $!nativesize;
    has int $!unsigned;
    has $!composed;

    my $archetypes := Perl6::Metamodel::Archetypes.new( :nominal(1) );
    method archetypes() {
        $archetypes
    }

    method new(*%named) {
        nqp::findmethod(NQPMu, 'BUILDALL')(nqp::create(self), |%named)
    }

    method new_type(:$name = '<anon>', :$repr = 'P6opaque', :$ver, :$auth) {
        my $metaclass := self.new();
        my $obj := nqp::settypehll(nqp::newtype($metaclass, $repr), 'perl6');
        $metaclass.set_name($obj, $name);
        $metaclass.set_ver($obj, $ver) if $ver;
        $metaclass.set_auth($obj, $auth) if $auth;
        self.add_stash($obj);
    }

    method compose($obj, :$compiler_services) {
        self.compute_mro($obj);
        self.publish_method_cache($obj);
        self.publish_type_cache($obj);
        if !$!composed && ($!nativesize || $!unsigned) {
            my $info := nqp::hash();
            $info<integer> := nqp::hash();
            $info<integer><unsigned> := 1 if $!unsigned;
            $info<float> := nqp::hash();
            if nqp::objprimspec($!nativesize) {
                $info<integer><bits> := $!nativesize;
                $info<float><bits>   := $!nativesize;
            }
            else {
                if $!nativesize {
                    $info<integer><bits> := nqp::unbox_i($!nativesize);
                    $info<float><bits>   := nqp::unbox_i($!nativesize);
                }
            }
            nqp::composetype($obj, $info);
        }
        $!composed := 1;
    }

    method is_composed($obj) {
        $!composed
    }

    method set_ctype($obj, $ctype) {
        if $ctype eq 'char' {
            $!nativesize := nqp::const::C_TYPE_CHAR;
        }
        elsif $ctype eq 'short' {
            $!nativesize := nqp::const::C_TYPE_SHORT;
        }
        elsif $ctype eq 'int' {
            $!nativesize := nqp::const::C_TYPE_INT;
        }
        elsif $ctype eq 'long' {
            $!nativesize := nqp::const::C_TYPE_LONG;
        }
        elsif $ctype eq 'longlong' {
            $!nativesize := nqp::const::C_TYPE_LONGLONG;
        }
        elsif $ctype eq 'float' {
            $!nativesize := nqp::const::C_TYPE_FLOAT;
        }
        elsif $ctype eq 'double' {
            $!nativesize := nqp::const::C_TYPE_DOUBLE;
        }
        elsif $ctype eq 'longdouble' {
            $!nativesize := nqp::const::C_TYPE_LONGDOUBLE;
        }
        elsif $ctype eq 'bool' {
            $!nativesize := nqp::const::C_TYPE_BOOL;
        }
        elsif $ctype eq 'size_t' {
            $!nativesize := nqp::const::C_TYPE_SIZE_T;
        }
        elsif $ctype eq 'atomic' {
            $!nativesize := nqp::const::C_TYPE_ATOMIC_INT;
        }
        else {
            nqp::die("Unhandled C type '$ctype'")
        }
    }

    method set_nativesize($obj, $nativesize) {
        $!nativesize := $nativesize;
    }

    method nativesize($obj) {
        $!nativesize
    }

    method set_unsigned($obj, $unsigned) {
        $!unsigned := $unsigned ?? 1 !! 0
    }

    method unsigned($obj) {
        $!unsigned
    }

    method method_table($obj) {
        nqp::hash('new',
          nqp::getstaticcode(sub (*@_,*%_) {
              @_[1] // nqp::die('Cannot instantiate a native type');
              nqp::getlexcaller('&DEPRECATED')(
                  '(my ' ~ @_[0].HOW.name(@_[0]) ~ ' $ = ' ~ @_[1].perl() ~ ')',
                  '2017.09.403',
                  '2018.01',
              );
              @_[1];
          }))
    }
    method submethod_table($obj) { nqp::hash() }
}
#line 1 SETTING::src/Perl6/Metamodel/NativeRefHOW.nqp
class Perl6::Metamodel::NativeRefHOW
    does Perl6::Metamodel::Naming
    does Perl6::Metamodel::Documenting
    does Perl6::Metamodel::Versioning
    does Perl6::Metamodel::Stashing
    does Perl6::Metamodel::MultipleInheritance
    does Perl6::Metamodel::C3MRO
    does Perl6::Metamodel::MROBasedMethodDispatch
    does Perl6::Metamodel::MROBasedTypeChecking
{
    has $!type;
    has $!refkind;
    has $!composed;
    has $!repr_composed;

    my $archetypes := Perl6::Metamodel::Archetypes.new( :nominal(1), :inheritable(1) );
    method archetypes() {
        $archetypes
    }

    method new(*%named) {
        nqp::findmethod(NQPMu, 'BUILDALL')(nqp::create(self), |%named)
    }

    method new_type(:$name = '<anon>', :$ver, :$auth) {
        my $metaclass := self.new();
        my $obj := nqp::settypehll(nqp::newtype($metaclass, 'NativeRef'), 'perl6');
        $metaclass.set_name($obj, $name);
        $metaclass.set_ver($obj, $ver) if $ver;
        $metaclass.set_auth($obj, $auth) if $auth;
        self.add_stash($obj);
    }

    method compose($obj, :$compiler_services) {
        self.compose_repr($obj);
        self.compute_mro($obj);
        self.publish_method_cache($obj);
        self.publish_type_cache($obj);
        $!composed := 1;
        $obj
    }

    method compose_repr($obj) {
        if !$!repr_composed {
            my $info := nqp::hash();
            $info<nativeref> := nqp::hash();
            $info<nativeref><type> := nqp::decont($!type);
            $info<nativeref><refkind> := $!refkind // 'unknown';
            nqp::composetype(nqp::decont($obj), $info);
            $!repr_composed := 1;
        }
    }

    method is_composed($obj) {
        $!composed
    }

    method set_native_type($obj, $type) {
        $!type := $type;
    }

    method native_type($obj) {
        $!type
    }

    method set_ref_kind($obj, $refkind) {
        $!refkind := $refkind;
    }

    method ref_kind($obj) {
        $!refkind
    }

    method method_table($obj) { nqp::hash() }
    method submethod_table($obj) { nqp::hash() }
}
#line 1 SETTING::src/Perl6/Metamodel/SubsetHOW.nqp
class Perl6::Metamodel::SubsetHOW
    does Perl6::Metamodel::Naming
    does Perl6::Metamodel::Documenting
    does Perl6::Metamodel::Stashing
{
    # The subset type or nominal type that we refine.
    has $!refinee;

    # The block implementing the refinement.
    has $!refinement;

    my $archetypes := Perl6::Metamodel::Archetypes.new( :nominalizable(1) );
    method archetypes() {
        $archetypes
    }

    method new(*%named) {
        nqp::findmethod(NQPMu, 'BUILDALL')(nqp::create(self), |%named)
    }

    method BUILD(:$refinee, :$refinement) {
        $!refinee := $refinee;
        $!refinement := $refinement;
    }

    method new_type(:$name = '<anon>', :$refinee!, :$refinement!) {
        my $metasubset := self.new(:refinee($refinee), :refinement($refinement));
        my $type := nqp::settypehll(nqp::newtype($metasubset, 'Uninstantiable'), 'perl6');
        $metasubset.set_name($type, $name);
        nqp::settypecheckmode($type, 2);
        self.add_stash($type)
    }

    method set_of($obj, $refinee) {
        my $archetypes := $!refinee.HOW.archetypes;
        unless $archetypes.nominal || $archetypes.nominalizable {
            nqp::die("The 'of' type of a subset must either be a valid nominal " ~
                "type or a type that can provide one");
        }
        $!refinee := nqp::decont($refinee);
        if nqp::objprimspec($!refinee) {
            my %ex := nqp::gethllsym('perl6', 'P6EX');
            if nqp::existskey(%ex, 'X::NYI') {
                %ex{'X::NYI'}('Subsets of native types');
            }
            else {
                nqp::die("Subsets of native types NYI");
            }
        }
    }

    method refinee($obj) {
        $!refinee
    }

    method refinement($obj) {
        $!refinement
    }

    method isa($obj, $type) {
        $!refinee.isa($type)
            || nqp::p6bool(nqp::istrue($type.HOW =:= self))
    }

    method nominalize($obj) {
        $!refinee.HOW.archetypes.nominal ??
            $!refinee !!
            $!refinee.HOW.nominalize($!refinee)
    }

    # Should have the same methods of the (eventually nominal) type
    # that we refine. (For the performance win, work out a way to
    # steal its method cache.)
    method find_method($obj, $name) {
        $!refinee.HOW.find_method($!refinee, $name)
    }

    # Do check when we're on LHS of smartmatch (e.g. Even ~~ Int).
    method type_check($obj, $checkee) {
        nqp::p6bool(nqp::istrue($checkee.HOW =:= self) ||
            nqp::istype($!refinee, $checkee))
    }

    # Here we check the value itself (when on RHS on smartmatch).
    method accepts_type($obj, $checkee) {
        nqp::p6bool(
            nqp::istype($checkee, $!refinee) &&
            nqp::istrue($!refinement.ACCEPTS($checkee)))
    }
}
#line 1 SETTING::src/Perl6/Metamodel/EnumHOW.nqp
# This is the meta-object for an enumeration (declared with enum).
# It keeps hold of the enumeration values in an Map, which is
# created at composition time. It supports having roles composed in,
# one or two of which presumably provide the core enum-ish methods.
class Perl6::Metamodel::EnumHOW
    does Perl6::Metamodel::Naming
    does Perl6::Metamodel::Documenting
    does Perl6::Metamodel::Stashing
    does Perl6::Metamodel::AttributeContainer
    does Perl6::Metamodel::MethodContainer
    does Perl6::Metamodel::MultiMethodContainer
    does Perl6::Metamodel::RoleContainer
    does Perl6::Metamodel::BaseType
    does Perl6::Metamodel::MROBasedMethodDispatch
    does Perl6::Metamodel::MROBasedTypeChecking
    does Perl6::Metamodel::BUILDPLAN
    does Perl6::Metamodel::BoolificationProtocol
    does Perl6::Metamodel::REPRComposeProtocol
    does Perl6::Metamodel::InvocationProtocol
    does Perl6::Metamodel::Mixins
{
    # Hash representing enumeration keys to values.
    has %!values;

    # Reverse mapping hash.
    has %!value_to_enum;

    # List of enum values (actual enum objects).
    has @!enum_value_list;

    # Roles that we do.
    has @!role_typecheck_list;

    # Role'd version of the enum.
    has $!role;
    has int $!roled;

    # Are we composed yet?
    has $!composed;

    # Exportation callback for enum symbols, if any.
    has $!export_callback;

    my $archetypes := Perl6::Metamodel::Archetypes.new( :nominal(1), :composalizable(1),
                                                        :augmentable(1) );
    method archetypes() {
        $archetypes
    }

    method new(*%named) {
        nqp::findmethod(NQPMu, 'BUILDALL')(nqp::create(self), |%named)
    }

    method new_type(:$name!, :$base_type?, :$repr = 'P6opaque') {
        my $meta := self.new();
        my $obj  := nqp::settypehll(nqp::newtype($meta, $repr), 'perl6');
        $meta.set_name($obj, $name);
        $meta.set_base_type($meta, $base_type) unless $base_type =:= NQPMu;
        $meta.setup_mixin_cache($obj);
        self.add_stash($obj);
    }

    # We only have add_parent to support mixins, which expect this method.
    method add_parent($obj, $parent) {
        self.set_base_type($obj, $parent);
    }

    method add_enum_value($obj, $value) {
        %!values{nqp::unbox_s($value.key)} := $value.value;
        @!enum_value_list[+@!enum_value_list] := $value;
    }

    method set_export_callback($obj, $callback) {
        $!export_callback := $callback
    }

    method enum_values($obj) {
        %!values
    }

    method elems($obj) {
        nqp::elems(%!values)
    }

    method enum_from_value($obj, $value) {
        unless %!value_to_enum {
            for @!enum_value_list {
                %!value_to_enum{$_.value} := $_;
            }
        }
        nqp::existskey(%!value_to_enum, $value)
            ?? %!value_to_enum{$value}
            !! $obj.WHAT;
    }

    method enum_value_list($obj) {
        @!enum_value_list
    }

    method compose($obj, :$compiler_services) {
        # Instantiate all of the roles we have (need to do this since
        # all roles are generic on ::?CLASS) and pass them to the
        # composer.
        my @roles_to_compose := self.roles_to_compose($obj);
        if @roles_to_compose {
            my @ins_roles;
            while @roles_to_compose {
                my $r := @roles_to_compose.pop();
                @!role_typecheck_list[+@!role_typecheck_list] := $r;
                @ins_roles.push($r.HOW.specialize($r, $obj))
            }
            RoleToClassApplier.apply($obj, @ins_roles);

            # Add them to the typecheck list, and pull in their
            # own type check lists also.
            for @ins_roles {
                @!role_typecheck_list[+@!role_typecheck_list] := $_;
                for $_.HOW.role_typecheck_list($_) {
                    @!role_typecheck_list[+@!role_typecheck_list] := $_;
                }
            }
        }

        # Incorporate any new multi candidates (needs MRO built).
        self.incorporate_multi_candidates($obj);

        # Compose attributes.
        for self.attributes($obj, :local) {
            $_.compose($obj);
        }

        # Publish type and method caches.
        self.publish_type_cache($obj);
        self.publish_method_cache($obj);

        # Publish boolification spec.
        self.publish_boolification_spec($obj);

        # Create BUILDPLAN.
        self.create_BUILDPLAN($obj);

        # Compose the representation.
        unless $!composed {
            self.compose_repr($obj);
            $!composed := 1;
        }

        # Compose invocation protocol.
        self.compose_invocation($obj);

        $obj
    }

    # Called by the compiler when all enum values have been added, to trigger
    # any needed actions.
    method compose_values($obj) {
        if $!export_callback {
            $!export_callback();
            $!export_callback := Mu;
        }
    }

    my $composalizer;
    method set_composalizer($c) { $composalizer := $c }
    method composalize($obj) {
        unless $!roled {
            $!role := $composalizer($obj, self.name($obj), %!values);
            $!roled := 1;
        }
        $!role
    }

    method is_composed($obj) {
        $!composed
    }

    method role_typecheck_list($obj) {
        @!role_typecheck_list
    }
}
#line 1 SETTING::src/Perl6/Metamodel/CoercionHOW.nqp
# Coercion types, of the form TargetType(ConstraintType), are implemented with
# 6model parametrics. We create a single BEGIN-time "root" for the coercion
# type family, and the target and constraint types are stored as parameters.
# This means we get cross-compilation-unit interning "for free", as well as
# avoiding a meta-object instance per coercion type created.
class Perl6::Metamodel::CoercionHOW
    does Perl6::Metamodel::MethodDelegation
    does Perl6::Metamodel::TypePretense
{
    my $archetypes := Perl6::Metamodel::Archetypes.new(:coercive);
    method archetypes() {
        $archetypes
    }

    method new_type($target, $constraint) {
        my $root := nqp::parameterizetype((Perl6::Metamodel::CoercionHOW.WHO)<root>,
            [$target, $constraint]);
        nqp::setdebugtypename($root, self.name($root));
    }

    method name($coercion_type) {
        if nqp::isnull(nqp::typeparameterized($coercion_type)) {
            '?(?)'
        }
        else {
            my $target := nqp::typeparameterat($coercion_type, 0);
            my $constraint := nqp::typeparameterat($coercion_type, 1);
            $target.HOW.name($target) ~ '(' ~ $constraint.HOW.name($constraint) ~ ')'
        }
    }

    method shortname($coercion_type) {
        if nqp::isnull(nqp::typeparameterized($coercion_type)) {
            '?(?)'
        }
        else {
            my $target := nqp::typeparameterat($coercion_type, 0);
            my $constraint := nqp::typeparameterat($coercion_type, 1);
            $target.HOW.shortname($target) ~ '(' ~ $constraint.HOW.shortname($constraint) ~ ')'
        }
    }

    sub check_instantiated($coercion_type) {
        nqp::die('Cannot perform this operation on an uninstantiated coercion type')
            if nqp::isnull(nqp::typeparameterized($coercion_type));
    }

    method target_type($coercion_type) {
        check_instantiated($coercion_type);
        nqp::typeparameterat($coercion_type, 0)
    }

    method constraint_type($coercion_type) {
        check_instantiated($coercion_type);
        nqp::typeparameterat($coercion_type, 1)
    }
}
BEGIN {
    my $root := nqp::newtype(Perl6::Metamodel::CoercionHOW, 'Uninstantiable');
    nqp::settypehll($root, 'perl6');
    nqp::setparameterizer($root, sub ($type, $params) {
        # Re-use same HOW.
        nqp::settypehll(nqp::newtype($type.HOW, 'Uninstantiable'), 'perl6');
    });
    (Perl6::Metamodel::CoercionHOW.WHO)<root> := $root;
}
#line 1 SETTING::src/Perl6/Metamodel/DefiniteHOW.nqp
# Coercion types, of the form TargetType(ConstraintType), are implemented with
# 6model parametrics. We create a single BEGIN-time "root" for the coercion
# type family, and the target and constraint types are stored as parameters.
# This means we get cross-compilation-unit interning "for free", as well as
# avoiding a meta-object instance per coercion type created.
class Perl6::Metamodel::DefiniteHOW
    #~ does Perl6::Metamodel::Naming
    does Perl6::Metamodel::Documenting

    #~ does Perl6::Metamodel::MethodDelegation
    #~ does Perl6::Metamodel::TypePretense

    #~ does Perl6::Metamodel::Stashing
    #~ does Perl6::Metamodel::AttributeContainer
    #~ does Perl6::Metamodel::MethodContainer
    #~ does Perl6::Metamodel::MultiMethodContainer
    #~ does Perl6::Metamodel::RoleContainer
    #~ does Perl6::Metamodel::BaseType
    #~ does Perl6::Metamodel::MROBasedMethodDispatch
    #~ does Perl6::Metamodel::MROBasedTypeChecking
    #~ does Perl6::Metamodel::BUILDPLAN
    #~ does Perl6::Metamodel::BoolificationProtocol
    #~ does Perl6::Metamodel::REPRComposeProtocol
    #~ does Perl6::Metamodel::InvocationProtocol
{
    my $archetypes := Perl6::Metamodel::Archetypes.new(:definite, :nominalizable(1));
    method archetypes() {
        $archetypes
    }

    #~ has @!mro;

    my class Definite { }
    my class NotDefinite { }

    method new_type(:$base_type!, :$definite!) {
        my $root := nqp::parameterizetype((Perl6::Metamodel::DefiniteHOW.WHO)<root>,
            [$base_type, $definite ?? Definite !! NotDefinite]);
        nqp::setdebugtypename($root, self.name($root));
    }

    method name($definite_type) {
        if nqp::isnull(nqp::typeparameterized($definite_type)) {
            '?:?'
        }
        else {
            my $base_type := nqp::typeparameterat($definite_type, 0);
            my $definite  := nqp::typeparameterat($definite_type, 1);
            $base_type.HOW.name($base_type) ~ ':' ~ (nqp::eqaddr($definite, Definite) ?? 'D' !! 'U')
        }
    }

    method shortname($definite_type) {
        if nqp::isnull(nqp::typeparameterized($definite_type)) {
            '?:?'
        }
        else {
            my $base_type := nqp::typeparameterat($definite_type, 0);
            my $definite  := nqp::typeparameterat($definite_type, 1);
            $base_type.HOW.shortname($base_type) ~ ':' ~ (nqp::eqaddr($definite, Definite) ?? 'D' !! 'U')
        }
    }

    sub check_instantiated($definite_type) {
        nqp::die('Cannot perform this operation on an uninstantiated definite type')
            if nqp::isnull(nqp::typeparameterized($definite_type));
    }

    method base_type($definite_type) {
        check_instantiated($definite_type);
        nqp::typeparameterat($definite_type, 0)
    }

    method definite($definite_type) {
        check_instantiated($definite_type);
        nqp::eqaddr(nqp::typeparameterat($definite_type, 1), Definite) ?? 1 !! 0
    }

    #~ # Our MRO is just that of base type.
    #~ method mro($obj) {
        #~ unless @!mro {
            #~ @!mro[0] := $obj;
            #~ for $!base_type.HOW.mro($!base_type) {
                #~ @!mro.push($_);
            #~ }
        #~ }
        #~ @!mro
    #~ }

    #~ method parents($obj, :$local, :$excl, :$all) {
        #~ my @parents := [$!base_type];
        #~ unless $local {
            #~ for $!base_type.HOW.parents($!base_type, :excl($excl), :all($all)) {
                #~ @parents.push($_);
            #~ }
        #~ }
        #~ @parents
    #~ }

    method nominalize($obj) {
        my $base_type := $obj.HOW.base_type($obj);
        $base_type.HOW.archetypes.nominal ??
            $base_type !!
            $base_type.HOW.nominalize($base_type)
    }

    #~ # Should have the same methods of the base type that we refine.
    #~ # (For the performance win, work out a way to steal its method cache.)
    method find_method($definite_type, $name) {
        my $base_type := self.base_type($definite_type);
        $base_type.HOW.find_method($base_type, $name)
    }

    # Do check when we're on LHS of smartmatch (e.g. Even ~~ Int).
    method type_check($definite_type, $checkee) {
        my $base_type := self.base_type($definite_type);
        nqp::p6bool(nqp::istype($base_type, $checkee))
    }

    # Here we check the value itself (when on RHS on smartmatch).
    method accepts_type($definite_type, $checkee) {
        my $base_type := self.base_type($definite_type);
        my $definite  := self.definite($definite_type);
        nqp::p6bool(
            nqp::istype($checkee, $base_type) &&
            nqp::isconcrete($checkee) == $definite
        )
    }
}

BEGIN {
    my $root := nqp::newtype(Perl6::Metamodel::DefiniteHOW, 'Uninstantiable');
    nqp::settypehll($root, 'perl6');

    nqp::setparameterizer($root, sub ($type, $params) {
        # Re-use same HOW.
        my $thing := nqp::settypehll(nqp::newtype($type.HOW, 'Uninstantiable'), 'perl6');
        nqp::settypecheckmode($thing, 2)
    });
    (Perl6::Metamodel::DefiniteHOW.WHO)<root> := $root;
}
#line 1 SETTING::src/Perl6/Metamodel/ContainerDescriptor.nqp
class Perl6::Metamodel::ContainerDescriptor {
    has     $!of;
    has int $!rw;
    has str $!name;
    has     $!default;
    has int $!dynamic;

    method BUILD(:$of, :$rw, :$name, :$default, :$dynamic) {
        $!of := $of;
        $!rw := $rw;
        $!name := $name;
        $!default := $default;
        $!dynamic := $dynamic;
    }

    method of() { $!of }
    method rw() { $!rw }
    method name() { $!name }
    method default() { $!default }
    method dynamic() { $!dynamic }

    method set_of($of) { $!of := $of; self }
    method set_rw($rw) { $!rw := $rw; self }
    method set_default($default) { $!default := $default; self }
    method set_dynamic($dynamic) { $!dynamic := $dynamic; self }

    method is_generic() {
        $!of.HOW.archetypes.generic
    }

    method instantiate_generic($type_environment) {
        my $ins_of := $!of.HOW.instantiate_generic($!of, $type_environment);
        my $ins := nqp::clone(self);
        nqp::bindattr($ins, $?CLASS, '$!of', $ins_of);
        $ins
    }
}
#line 1 SETTING::src/Perl6/Metamodel/Dispatchers.nqp
class Perl6::Metamodel::BaseDispatcher {
    has @!candidates;
    has $!idx;

    method candidates() { @!candidates }

    method exhausted() { $!idx >= +@!candidates }

    method last()      { @!candidates := [] }

    method call_with_args(*@pos, *%named) {
        my $call := @!candidates[$!idx];
        $!idx := $!idx + 1;
        if self.has_invocant {
            my $inv := self.invocant;
            nqp::setdispatcherfor(self, $call);
            $call($inv, |@pos, |%named);
        }
        else {
            nqp::setdispatcherfor(self, $call);
            $call(|@pos, |%named);
        }
    }

    method call_with_capture($capture) {
        my $call := @!candidates[$!idx];
        $!idx := $!idx + 1;
        nqp::setdispatcherfor(self, $call);
        nqp::invokewithcapture(nqp::decont($call), $capture)
    }

    method shift_callee() {
        my $callee := @!candidates[$!idx];
        $!idx := $!idx + 1;
        nqp::decont($callee)
    }
}

class Perl6::Metamodel::MethodDispatcher is Perl6::Metamodel::BaseDispatcher {
    has $!obj;

    method new(:@candidates, :$idx, :$obj) {
        my $disp := nqp::create(self);
        nqp::bindattr($disp, Perl6::Metamodel::BaseDispatcher, '@!candidates', @candidates);
        nqp::bindattr($disp, Perl6::Metamodel::BaseDispatcher, '$!idx', $idx);
        nqp::bindattr($disp, Perl6::Metamodel::MethodDispatcher, '$!obj', $obj);
        $disp
    }

    method vivify_for($sub, $lexpad, $args) {
        my $obj      := $lexpad<self>;
        my $name     := $sub.name;
        my @mro      := nqp::can($obj.HOW, 'mro_unhidden')
            ?? $obj.HOW.mro_unhidden($obj)
            !! $obj.HOW.mro($obj);
        my @methods;
        for @mro {
            my %mt := $_.HOW.method_table($_);
            if nqp::existskey(%mt, $name) {
                @methods.push(%mt{$name});
            }
        }
        self.new(:candidates(@methods), :obj($obj), :idx(1))
    }

    method has_invocant() { 1 }
    method invocant()     { $!obj }
}

class Perl6::Metamodel::MultiDispatcher is Perl6::Metamodel::BaseDispatcher {
    has $!has_invocant;
    has $!invocant;

    method new(:@candidates, :$idx, :$invocant, :$has_invocant) {
        my $disp := nqp::create(self);
        nqp::bindattr($disp, Perl6::Metamodel::BaseDispatcher, '@!candidates', @candidates);
        nqp::bindattr($disp, Perl6::Metamodel::BaseDispatcher, '$!idx', $idx);
        nqp::bindattr($disp, Perl6::Metamodel::MultiDispatcher, '$!invocant', $invocant);
        nqp::bindattr($disp, Perl6::Metamodel::MultiDispatcher, '$!has_invocant', $has_invocant);
        $disp
    }

    method vivify_for($sub, $lexpad, $args) {
        my $disp         := $sub.dispatcher();
        my $has_invocant := nqp::existskey($lexpad, 'self');
        my $invocant     := $has_invocant && $lexpad<self>;
        my @cands        := $disp.find_best_dispatchee($args, 1);
        self.new(:candidates(@cands), :idx(1), :invocant($invocant),
            :has_invocant($has_invocant))
    }

    method has_invocant() { $!has_invocant }
    method invocant() { $!invocant }
}

class Perl6::Metamodel::WrapDispatcher is Perl6::Metamodel::BaseDispatcher {
    method new(:@candidates, :$idx, :$invocant, :$has_invocant) {
        my $disp := nqp::create(self);
        nqp::bindattr($disp, Perl6::Metamodel::BaseDispatcher, '@!candidates', @candidates);
        nqp::bindattr($disp, Perl6::Metamodel::BaseDispatcher, '$!idx', 1);
        $disp
    }

    method has_invocant() { 0 }

    method add($wrapper) {
        self.candidates.unshift($wrapper)
    }

    method remove($wrapper) {
        my @cands := self.candidates;
        my $i := 0;
        while $i < +@cands {
            if nqp::decont(@cands[$i]) =:= nqp::decont($wrapper) {
                nqp::splice(@cands, [], $i, 1);
                return 1;
            }
            $i := $i + 1;
        }
        return 0;
    }

    method enter(*@pos, *%named) {
        my $fresh := nqp::clone(self);
        my $first := self.candidates[0];
        nqp::setdispatcherfor($fresh, $first);
        $first(|@pos, |%named)
    }
}

# vim: set ft=perl6 nomodifiable :
